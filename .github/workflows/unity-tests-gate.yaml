name: Unity Tests Gate

on:
  pull_request_target:
    branches: [main]
    types: [opened, reopened, synchronize, ready_for_review]
    paths:
      - "Packages/com.playroomkit.sdk/**/*.cs"
      - "Packages/com.playroomkit.sdk/**/*.asmdef"
      - "Packages/com.playroomkit.sdk/**/*.asmref"
      - "Packages/com.playroomkit.sdk/**/*.unity"
      - "Packages/com.playroomkit.sdk/package.json"

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

concurrency:
  group: unity-tests-gate-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  mark-pending:
    runs-on: ubuntu-latest
    steps:
      - name: Mark Unity tests as pending
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = pr.head.sha;

            const labelPending = "unity-test: pending";
            const labelPassed = "unity-test: passed";
            const labelFailed = "unity-test: failed";
            const commentTag = "<!-- unity-tests-gate -->";
            const checkName = "EditMode Test Results";
            const body = [
              commentTag,
              "### Unity EditMode Tests",
              "Not run automatically for PRs.",
              "Trigger manually (members/collaborators):",
              "`/run-unity-tests`",
            ].join("\n");

            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: sha,
              check_name: checkName,
              per_page: 1,
            });

            const payload = {
              owner,
              repo,
              status: "queued",
              output: {
                title: "EditMode Test Results - Pending",
                summary: "Manual Unity tests required.",
              },
            };

            if (checkRuns.total_count > 0) {
              await github.rest.checks.update({
                ...payload,
                check_run_id: checkRuns.check_runs[0].id,
              });
            } else {
              await github.rest.checks.create({
                ...payload,
                name: checkName,
                head_sha: sha,
              });
            }

            for (const label of [labelPassed, labelFailed]) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: pr.number,
                  name: label,
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
              }
            }

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.number,
              labels: [labelPending],
            });

            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: pr.number,
              per_page: 100,
            });

            const existing = comments.find((comment) =>
              comment.body && comment.body.includes(commentTag)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body,
              });
            }
