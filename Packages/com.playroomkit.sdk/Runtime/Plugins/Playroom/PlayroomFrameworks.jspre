(function(factory) {
  typeof define === "function" && define.amd ? define(factory) : factory();
})(function() {
  "use strict";
  function getDefaultExportFromCjs$1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var react = { exports: {} };
  var react_production = {};
  /**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReact_production;
  function requireReact_production() {
    if (hasRequiredReact_production) return react_production;
    hasRequiredReact_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, assign = Object.assign, emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop() {
    }
    var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== refProp ? refProp : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape2(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index2) {
      return "object" === typeof element && null !== element && null != element.key ? escape2("" + element.key) : index2.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    react_production.Activity = REACT_ACTIVITY_TYPE;
    react_production.Children = Children;
    react_production.Component = Component;
    react_production.Fragment = REACT_FRAGMENT_TYPE;
    react_production.Profiler = REACT_PROFILER_TYPE;
    react_production.PureComponent = PureComponent;
    react_production.StrictMode = REACT_STRICT_MODE_TYPE;
    react_production.Suspense = REACT_SUSPENSE_TYPE;
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    react_production.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }
    };
    react_production.cache = function(fn2) {
      return function() {
        return fn2.apply(null, arguments);
      };
    };
    react_production.cacheSignal = function() {
      return null;
    };
    react_production.cloneElement = function(element, config2, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key;
      if (null != config2)
        for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
          !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    react_production.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    react_production.createElement = function(type, config2, children) {
      var propName, props = {}, key = null;
      if (null != config2)
        for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
          hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config2[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, props);
    };
    react_production.createRef = function() {
      return { current: null };
    };
    react_production.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    react_production.isValidElement = isValidElement;
    react_production.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    react_production.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    react_production.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    react_production.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    react_production.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    react_production.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    react_production.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    react_production.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    react_production.useDebugValue = function() {
    };
    react_production.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    react_production.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    react_production.useEffectEvent = function(callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    react_production.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    react_production.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    react_production.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    react_production.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    react_production.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    react_production.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    react_production.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    react_production.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    react_production.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    react_production.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    react_production.version = "19.2.4";
    return react_production;
  }
  {
    react.exports = requireReact_production();
  }
  var reactExports = react.exports;
  const U = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
  var reactDom = { exports: {} };
  var reactDom_production = {};
  /**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactDom_production;
  function requireReactDom_production() {
    if (hasRequiredReactDom_production) return reactDom_production;
    hasRequiredReactDom_production = 1;
    var React = reactExports;
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop() {
    }
    var Internals = {
      d: {
        f: noop,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as2, input) {
      if ("font" === as2) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    reactDom_production.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key);
    };
    reactDom_production.flushSync = function(fn2) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn2) return fn2();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    reactDom_production.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    reactDom_production.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_production.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as2 ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as2 && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    reactDom_production.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    reactDom_production.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin);
        Internals.d.L(href, as2, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    reactDom_production.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    reactDom_production.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    reactDom_production.unstable_batchedUpdates = function(fn2, a) {
      return fn2(a);
    };
    reactDom_production.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    reactDom_production.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    reactDom_production.version = "19.2.4";
    return reactDom_production;
  }
  function checkDCE$1() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE$1();
    reactDom.exports = requireReactDom_production();
  }
  var reactDomExports = reactDom.exports;
  const yr = /* @__PURE__ */ getDefaultExportFromCjs$1(reactDomExports);
  var client = { exports: {} };
  var reactDomClient_production = {};
  var scheduler = { exports: {} };
  var scheduler_production = {};
  /**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredScheduler_production;
  function requireScheduler_production() {
    if (hasRequiredScheduler_production) return scheduler_production;
    hasRequiredScheduler_production = 1;
    (function(exports$1) {
      function push(heap, node) {
        var index2 = heap.length;
        heap.push(node);
        a: for (; 0 < index2; ) {
          var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
            var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      exports$1.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports$1.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports$1.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports$1.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports$1.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostTimeout(callback, ms2) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports$1.unstable_now());
        }, ms2);
      }
      exports$1.unstable_IdlePriority = 5;
      exports$1.unstable_ImmediatePriority = 1;
      exports$1.unstable_LowPriority = 4;
      exports$1.unstable_NormalPriority = 3;
      exports$1.unstable_Profiling = null;
      exports$1.unstable_UserBlockingPriority = 2;
      exports$1.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports$1.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports$1.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports$1.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports$1.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports$1.unstable_shouldYield = shouldYieldToHost;
      exports$1.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    })(scheduler_production);
    return scheduler_production;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production();
    }
    return scheduler.exports;
  }
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactDomClient_production;
  function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production) return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    var Scheduler = requireScheduler(), React = reactExports, ReactDOM = reactDomExports;
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function isValidContainer(node) {
      return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b.return) a = parentA, b = parentB;
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    var isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, valueStack = [], index2 = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor) {
      0 > index2 || (cursor.current = valueStack[index2], valueStack[index2] = null, index2--);
    }
    function push(cursor, value) {
      index2++;
      valueStack[index2] = cursor.current;
      cursor.current = value;
    }
    var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
          break;
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    var prefix, suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn2, construct) {
      if (!fn2 || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$1) {
                    control = x$1;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$2) {
                  control = x$2;
                }
                (Fake = fn2()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn2.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn2.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn2 ? fn2.displayName || fn2.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do
          info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root2.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
      root2 = root2.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root2, renderLanes2) {
      return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root2, updateLane) {
      root2.pendingLanes |= updateLane;
      268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
    }
    function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root2.pendingLanes;
      root2.pendingLanes = remainingLanes;
      root2.suspendedLanes = 0;
      root2.pingedLanes = 0;
      root2.warmLanes = 0;
      root2.expiredLanes &= remainingLanes;
      root2.entangledLanes &= remainingLanes;
      root2.errorRecoveryDisabledLanes &= remainingLanes;
      root2.shellSuspendCounter = 0;
      var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
      root2.pendingLanes |= spawnedLane;
      root2.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root2.entangledLanes |= spawnedLane;
      root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root2, entangledLanes) {
      var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
      for (root2 = root2.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
        lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root2, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn2) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn2();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
            for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root2) {
      var resources = root2[internalRootNodeResourcesKey];
      resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node.removeAttribute(name);
                return;
              }
          }
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField
      );
      if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get = descriptor.get, set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      if (!node._valueTracker) {
        var valueField = isCheckable(node) ? "checked" : "value";
        node._valueTracker = trackValueOnNode(
          node,
          valueField,
          "" + node[valueField]
        );
      }
    }
    function updateValueIfChanged(node) {
      if (!node) return false;
      var tracker = node._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), true) : false;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch2) {
          return "\\" + ch2.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
          track(element);
          return;
        }
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      track(element);
    }
    function setDefaultValue(node, type, value) {
      "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = true;
        for (propValue = 0; propValue < node.length; propValue++)
          i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = true;
            setDefaultSelected && (node[i].defaultSelected = true);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
      track(element);
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node = node.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
        for (var styleName$16 in styles)
          styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function noop$1() {
    }
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null, restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn2, a, b) {
      if (isInsideEventHandler) return fn2(a, b);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn2(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn2 = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn2))
            for (a = 0; a < fn2.length; a++) restoreStateOfTarget(fn2[a]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        var options = {};
        Object.defineProperty(options, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var root = null, startText = null, fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {
        },
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null, activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM) {
      var JSCompiler_inline_result$jscomp$286;
      if (canUseDOM) {
        var isSupported$jscomp$inline_427 = "oninput" in document;
        if (!isSupported$jscomp$inline_427) {
          var element$jscomp$inline_428 = document.createElement("div");
          element$jscomp$inline_428.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
        }
        JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
      } else JSCompiler_inline_result$jscomp$286 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is2(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is2;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root2, offset) {
      var node = getLeafNode(root2);
      root2 = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root2 + node.textContent.length;
          if (root2 <= offset && nodeEnd >= offset)
            return { node, offset: offset - root2 };
          root2 = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 65011712;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
      else if ("string" === typeof type)
        fiberTag = isHostHoistableType(
          type,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_TYPE:
            return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_LIST_TYPE:
            return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiberImplClass(18, null, null, 0);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    var CapturedStacks = /* @__PURE__ */ new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index3) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index3 += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(
        formatProdErrorMessage(
          418,
          1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        queuedErrors
      ), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes2;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now();
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
    } };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function trackUsedThenable(thenableState2, thenable, index3) {
      index3 = thenableState2[index3];
      void 0 === index3 ? thenableState2.push(thenable) : index3 !== thenable && (thenable.then(noop$1, noop$1), thenable = index3);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType2) {
      try {
        var init = lazyType2._init;
        return init(lazyType2._payload);
      } catch (x) {
        if (null !== x && "object" === typeof x && "function" === typeof x.then)
          throw suspendedThenable = x, SuspenseException;
        throw x;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error(formatProdErrorMessage(483));
    }
    var thenableState$1 = null, thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index3 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index3);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root2, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone2 = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
            return node;
        } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return false;
      return true;
    }
    function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index3 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index3);
      index3 = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null === index3 || null === index3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
        subscribe
      ]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action, payload = node.payload, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
        } catch (error$66) {
          onActionError(actionQueue, node, error$66);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node, error);
        }
      ) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
        9,
        { destroy: void 0 },
        actionStateActionEffect.bind(null, actionQueue, action),
        null
      ));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      ));
    }
    function mountEffect(create, deps) {
      mountEffectImpl(8390656, 8, create, deps);
    }
    function updateEffect(create, deps) {
      updateEffectImpl(2048, 8, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
    function updateInsertionEffect(create, deps) {
      return updateEffectImpl(4, 2, create, deps);
    }
    function updateLayoutEffect(create, deps) {
      return updateEffectImpl(4, 4, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function updateImperativeHandle(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountDebugValue() {
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {
          }, status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    }
    function noop() {
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action ? noop : function() {
          requestFormReset$1(formFiber);
          return action(formData);
        }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane()
      );
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$69 = enqueueUpdate(provider, fiber, lane);
            null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
            provider = { cache: createCache() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMount = {
      readContext,
      use,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      },
      useLayoutEffect: function(create, deps) {
        return mountEffectImpl(4194308, 4, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        mountEffectImpl(4, 2, create, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      },
      useRef: function(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      },
      useState: function(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      },
      useTransition: function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
          subscribe
        ]);
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        return getServerSnapshot;
      },
      useId: function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "_";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
        return hook.memoizedState = identifierPrefix;
      },
      useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: function(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      },
      useMemoCache,
      useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      },
      useEffectEvent: function(callback) {
        var hook = mountWorkInProgressHook(), ref = { impl: callback };
        hook.memoizedState = ref;
        return function() {
          if (0 !== (executionContext & 2))
            throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
    }, HooksDispatcherOnUpdate = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function() {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
    var HooksDispatcherOnRerender = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function() {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnRerender.useEffectEvent = updateEvent;
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var propName$73 in Component)
          void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root2, errorInfo) {
      try {
        var onUncaughtError = root2.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function() {
          throw e$74;
        });
      }
    }
    function logCaughtError(root2, boundary, errorInfo) {
      try {
        var onCaughtError = root2.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$75) {
        setTimeout(function() {
          throw e$75;
        });
      }
    }
    function createRootErrorUpdate(root2, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root2, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root2, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root2.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root2,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component,
        propsWithoutRef,
        ref,
        renderLanes2
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null === current) {
        var type = Component.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component,
        nextProps,
        renderLanes2
      );
    }
    function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
      null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress2.flags & 128)) {
          prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextProps = workInProgress2.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            prevState,
            renderLanes2,
            nextProps
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2,
            nextProps
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current, workInProgress2) {
      null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress2.mode
      );
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current;
    }
    function updateActivityComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
      workInProgress2.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var dehydrated = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          else if (null !== workInProgress2.memoizedState)
            workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else throw Error(formatProdErrorMessage(558));
        else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
            throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      current = createWorkInProgress(current.child, {
        mode: nextProps.mode,
        children: nextProps.children
      });
      current.ref = workInProgress2.ref;
      workInProgress2.child = current;
      current.return = workInProgress2;
      return current;
    }
    function markRef(current, workInProgress2) {
      var ref = workInProgress2.ref;
      if (null === ref)
        null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(
        current,
        workInProgress2,
        Component,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextPrimaryChildren },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            showFallback
          ), nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
          JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
          digest,
          nextPrimaryChildren
        ) : (nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      nextProps = nextProps.children;
      var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
      shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
      push(suspenseStackCursor, suspenseContext);
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      nextProps = isHydrating ? treeForkCount : 0;
      if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress2.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress2) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress2)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode,
            nextProps
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode,
            nextProps
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress2,
            false,
            null,
            null,
            void 0,
            nextProps
          );
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 31:
          if (null !== workInProgress2.memoizedState)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          var state$102 = workInProgress2.memoizedState;
          if (null !== state$102) {
            if (null !== state$102.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state$102 || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state$102)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state$102) break;
          else return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            var props = workInProgress2.pendingProps;
            current = resolveLazy(workInProgress2.elementType);
            workInProgress2.type = current;
            if ("function" === typeof current)
              shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              ));
            else {
              if (void 0 !== current && null !== current) {
                var $$typeof = current.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if ($$typeof === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(current) || current;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
            props,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            props,
            $$typeof,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            props = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            $$typeof = prevState.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, props, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            props = nextState.cache;
            pushProvider(workInProgress2, CacheContext, props);
            props !== prevState.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            props = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: props,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else if (props !== $$typeof) {
                $$typeof = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError($$typeof);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else {
                current = workInProgress2.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  props,
                  renderLanes2
                );
                for (workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (props === $$typeof) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(current, workInProgress2, props, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if ($$typeof = props = nextHydratableInstance)
              props = canHydrateInstance(
                props,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
            $$typeof || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          $$typeof = workInProgress2.type;
          prevState = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          props = prevState.children;
          shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = $$typeof);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, props, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            props,
            renderLanes2
          ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
        case 9:
          return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if (type = 0 !== (workInProgress2.mode & 32)) type = false;
      if (type) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
          if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
        if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$106 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
      else
        for (child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
          null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            null,
            newProps,
            renderLanes2
          ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            current,
            newProps,
            renderLanes2
          ));
          return null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2);
            else {
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (nextResource) {
                case 1:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case 2:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/2000/svg",
                        type
                      );
                      break;
                    case "math":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        type
                      );
                      break;
                    case "script":
                      nextResource = ownerDocument.createElement("div");
                      nextResource.innerHTML = "<script><\/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild
                      );
                      break;
                    case "select":
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                        is: newProps.is
                      }) : ownerDocument.createElement("select");
                      newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                  }
              }
              nextResource[internalInstanceKey] = workInProgress2;
              nextResource[internalPropsKey] = newProps;
              a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                  nextResource.appendChild(ownerDocument.stateNode);
                else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                  ownerDocument.child.return = ownerDocument;
                  ownerDocument = ownerDocument.child;
                  continue;
                }
                if (ownerDocument === workInProgress2) break a;
                for (; null === ownerDocument.sibling; ) {
                  if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                    break a;
                  ownerDocument = ownerDocument.return;
                }
                ownerDocument.sibling.return = ownerDocument.return;
                ownerDocument = ownerDocument.sibling;
              }
              workInProgress2.stateNode = nextResource;
              a: switch (setInitialProperties(nextResource, type, newProps), type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = true;
                  break a;
                default:
                  newProps = false;
              }
              newProps && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            workInProgress2.type,
            null === current ? null : current.memoizedProps,
            workInProgress2.pendingProps,
            renderLanes2
          );
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type = hydrationParentFiber;
              if (null !== type)
                switch (type.tag) {
                  case 27:
                  case 5:
                    newProps = type.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2, true);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress2);
            if (null !== renderLanes2) {
              if (null === current) {
                if (!newProps) throw Error(formatProdErrorMessage(318));
                current = workInProgress2.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current) throw Error(formatProdErrorMessage(557));
                current[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              current = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
            if (!current) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if (0 !== (workInProgress2.flags & 128))
              throw Error(formatProdErrorMessage(558));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type) throw Error(formatProdErrorMessage(318));
                type = workInProgress2.memoizedState;
                type = null !== type ? type.dehydrated : null;
                if (!type) throw Error(formatProdErrorMessage(317));
                type[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          newProps = workInProgress2.memoizedState;
          if (null === newProps) return bubbleProperties(workInProgress2), null;
          type = 0 !== (workInProgress2.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type) cutOffTailIfNeeded(newProps, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current = nextResource.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current = findFirstSuspended(nextResource), null !== current) {
                if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (null !== newProps.tail)
            return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
              suspenseStackCursor,
              type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
            ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (null !== workInProgress2.memoizedState) {
            popSuspenseHandler(workInProgress2);
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 31:
          null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              if (void 0 !== destroy) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$140) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$140);
          }
        else ref.current = null;
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
      try {
        for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
          singleton.removeAttributeNode(attributes[0]);
        setInitialProperties(singleton, type, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
    function commitBeforeMutationEffects(root2, firstChild) {
      root2 = root2.containerInfo;
      eventsEnabled = _enabled;
      root2 = getActiveElementDeep(root2);
      if (hasSelectionCapabilities(root2)) {
        if ("selectionStart" in root2)
          var JSCompiler_temp = {
            start: root2.selectionStart,
            end: root2.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
              b: for (; ; ) {
                for (var next; ; ) {
                  node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                  node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (; ; ) {
                  if (node === root2) break b;
                  parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                  parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
          root2.return = firstChild, nextEffect = root2;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root2 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                  for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                    anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root2 & 1024) && null !== focusNode) {
                  root2 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset
                    );
                    root2 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root2;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root2 & 1024)) {
                  if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root2);
                  else if (1 === JSCompiler_temp)
                    switch (root2.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root2);
                        break;
                      default:
                        root2.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root2 = firstChild.sibling;
            if (null !== root2) {
              root2.return = firstChild.return;
              nextEffect = root2;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$139) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$139
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
            null,
            finishedWork
          ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null, hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
            9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
            deletedFiber.stateNode
          ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root2 = childToDelete.alternate;
          null !== root2 && (root2.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root2) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root2.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root2.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
              if (5 === root2.tag || 26 === root2.tag) {
                if (null === current) {
                  wasHidden = current = root2;
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot)
                      maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                    else {
                      i = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                      i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root2.tag) {
                if (null === current) {
                  wasHidden = root2;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root2.tag) {
                if (null === current) {
                  wasHidden = root2;
                  try {
                    var instance = wasHidden.stateNode;
                    hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                root2.child.return = root2;
                root2 = root2.child;
                continue;
              }
              if (root2 === finishedWork) break a;
              for (; null === root2.sibling; ) {
                if (null === root2.return || root2.return === finishedWork) break a;
                current === root2 && (current = null);
                root2 = root2.return;
              }
              current === root2 && (current = null);
              root2.sibling.return = root2.return;
              root2 = root2.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$141 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
              var before$142 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
              break;
            case 3:
            case 4:
              var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$144,
                parent$143
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root2, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root2,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id2,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 31:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id2 = finishedWork.alternate;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256) || false
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState
          ), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            suspendedState,
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i = deletions.stateNode;
            i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache = fiber.memoizedState.cachePool.pool;
              null != cache && cache.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache = fiber.child;
        if (null !== cache) cache.return = fiber, nextEffect = cache;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache = nextEffect;
            var sibling = cache.sibling, returnFiber = cache.return;
            detachFiberAfterEffects(cache);
            if (cache === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      }
    }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
    function requestUpdateLane() {
      return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root2, fiber, lane) {
      if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
        prepareFreshStack(root2, 0), markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root2, lane);
      if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
        root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root2);
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root2 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root2,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                    workInProgressRootRecoverableErrors,
                    renderWasConcurrent
                  ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              pendingEffectsLanes = lanes;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  "Throttled",
                  -0,
                  0
                ),
                exitStatus
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root2.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
        suspendedCommitReason = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$1
        };
        accumulateSuspenseyCommitOnFiber(
          finishedWork,
          lanes,
          suspendedCommitReason
        );
        var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
        timeoutOffset = waitForCommitToBeReady(
          suspendedCommitReason,
          timeoutOffset
        );
        if (null !== timeoutOffset) {
          pendingEffectsLanes = lanes;
          root2.cancelPendingCommit = timeoutOffset(
            commitRoot.bind(
              null,
              root2,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedCommitReason,
              null,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root2,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root2.suspendedLanes |= suspendedLanes;
      root2.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root2.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root2, lanes) {
      var timeoutHandle = root2.timeoutHandle;
      -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root2.cancelPendingCommit;
      null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root2;
      workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root2.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
          lanes |= root2[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root2, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      ));
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root2, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$165) {
          handleThrow(root2, thrownValue$165);
        }
      while (1);
      lanes && root2.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root2,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root2);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$167) {
          handleThrow(root2, thrownValue$167);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = unitOfWork;
      var current = next.alternate;
      switch (next.tag) {
        case 15:
        case 0:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type.render,
            next.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next);
        default:
          unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root2,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root2 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root2 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root2);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next) {
          workInProgress = next;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        next = unitOfWork.return;
        null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root2.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root2,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root2;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects();
          return null;
        })) : (root2.callbackNode = null, root2.callbackPriority = 0);
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root2, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root2);
            var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
              priorFocusedElem.ownerDocument.documentElement,
              priorFocusedElem
            )) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                    end,
                    priorFocusedElem.value.length
                  );
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      start$jscomp$0
                    ), endMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      end$jscomp$0
                    );
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem; selection = selection.parentNode; )
                1 === selection.nodeType && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root2.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
        var remainingLanes = root2.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128)
            );
          } catch (err) {
          }
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
              var recoverableError = recoverableErrors[i];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack
              });
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root2);
        remainingLanes = root2.pendingLanes;
        0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0);
      }
    }
    function releaseRootPooledCache(root2, remainingLanes) {
      0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
          }
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root2, wakeable, lanes) {
      var pingCache = root2.pingCache;
      if (null === pingCache) {
        pingCache = root2.pingCache = new PossiblyWeakMap();
        var threadIDs = /* @__PURE__ */ new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      var pingCache = root2.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      root2.warmLanes &= ~pingedLanes;
      workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root2);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root2) {
      root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$170 = firstScheduledRoot; null !== root$170; ) {
            if (0 !== syncTransitionLanes) {
              var pendingLanes = root$170.pendingLanes;
              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
              else {
                var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
              }
              0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            } else
              JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                root$170,
                root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
              ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            root$170 = root$170.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
        var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
        if (0 === nextLanes)
          root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
        else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root2 = next;
      }
      0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
      for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
        var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root2,
        root2 === currentTime ? suspendedLanes : 0,
        null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
      );
      pingedLanes = root2.callbackNode;
      if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root2.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root2.callbackPriority = currentTime;
        root2.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root2.callbackPriority = 2;
      root2.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return root2.callbackNode = null, root2.callbackPriority = 0, null;
      var originalCallbackNode = root2.callbackNode;
      if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root2,
        root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root2, now());
      return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
    }
    function performSyncWorkOnRoot(root2, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root2, lanes, true);
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        ) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    action,
                    formData
                  ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
      var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1579,
        "on" + capitalizedEvent$jscomp$inline_1580
      );
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                      lastHostComponent++;
                    _instance = 0;
                    for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                      _instance++;
                    for (; 0 < lastHostComponent - _instance; )
                      reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                    for (; 0 < _instance - lastHostComponent; )
                      instance = inCapturePhase(instance), _instance--;
                    for (; lastHostComponent--; ) {
                      if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common2; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common2) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({ event, listeners });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
            key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$184 = props[hasSrc];
              if (null != propValue$184)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$184;
                    break;
                  case "type":
                    propValue = propValue$184;
                    break;
                  case "checked":
                    checked = propValue$184;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$184;
                    break;
                  case "value":
                    propKey = propValue$184;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$184;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$184)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$184, props, null);
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$184 in props)
              props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$201 in nextProps) {
            var propKey = nextProps[propKey$201];
            lastProp = lastProps[propKey$201];
            if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
              switch (propKey$201) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$201,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$201 = null;
          for (type in lastProps)
            if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) || setProp(
                    domElement,
                    tag,
                    type,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$201 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$201 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
              switch (value) {
                case "value":
                  propKey$201 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type && setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, propKey$201, propKey);
          return;
        case "option":
          for (var propKey$217 in lastProps)
            if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
              switch (propKey$217) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$217,
                    null,
                    nextProps,
                    propKey$201
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$222 in lastProps)
            propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
          for (checked in nextProps)
            if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$201)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$227 in lastProps)
              propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
            for (defaultChecked in nextProps)
              propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$232 in lastProps)
        propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
      for (lastProp in nextProps)
        propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
          var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
          if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1; i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration) break;
              var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
            }
            --i;
            bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
            count++;
            if (10 < count) break;
          }
        }
        if (0 < count) return bits / count / 1e6;
      }
      return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
    }
    var eventsEnabled = null, selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (0 === parentNamespace)
        switch (type) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node = hydrationInstance, depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node || "/&" === node) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
            depth++;
          else if ("html" === node)
            releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
          else if ("head" === node) {
            node = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node);
            for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
        node = nextNode;
      } while (node);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node.nextSibling;
        1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node)
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
        node = nextNode;
      } while (node);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return "$?" === instance.data || "$~" === instance.data;
    }
    function isSuspenseInstanceFallback(instance) {
      return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$~" === instance.data) instance._reactRetry = callback;
      else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
        callback();
      else {
        var listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType || "/&" === nodeType) return null;
        }
      }
      return node;
    }
    var previousHydratableOnEnteringScopedSingleton = null;
    function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data = hydrationInstance.data;
          if ("/$" === data || "/&" === data) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" !== data && "/&" !== data || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error(formatProdErrorMessage(452));
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error(formatProdErrorMessage(453));
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error(formatProdErrorMessage(454));
          return type;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as2, options2) {
      previousDispatcher.L(href, as2, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as2) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as2) + '"]';
        "image" === as2 ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as2) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign(
          {
            rel: "preload",
            href: "image" === as2 && options2 && options2.imageSrcSet ? void 0 : href,
            as: as2
          },
          options2
        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as2 && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as2 && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as2 = ownerDocument.createElement("link"), setInitialProperties(as2, "link", href), markNodeAsHoistable(as2), ownerDocument.head.appendChild(as2)));
      }
    }
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as2 = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as2) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
        switch (as2) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as2) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as2 = ownerDocument.createElement("link");
          setInitialProperties(as2, "link", href);
          markNodeAsHoistable(as2);
          ownerDocument.head.appendChild(as2);
        }
      }
    }
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key)
          ))
            state.loading = 5;
          else {
            href = assign(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state.loading |= 1;
            });
            link.addEventListener("error", function() {
              state.loading |= 2;
            });
            state.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state
          };
          styles.set(key, resource);
        }
      }
    }
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var styles$243 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$244 = styles$243.get(type);
            resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type)
            )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
              JSCompiler_inline_result,
              type,
              pendingProps,
              resource$244.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$244;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type));
      }
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
        return state.loading |= 1;
      }), key.addEventListener("error", function() {
        return state.loading |= 2;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$249 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$249)
              return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$249);
            var linkInstance = instance$249;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$249, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$249, props.precedence, hoistableRoot);
            return resource.instance = instance$249;
          case "script":
            instance$249 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$249)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$249))
              instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root2) {
      for (var nodes = root2.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = /* @__PURE__ */ new Map();
        var caches = tagCaches = /* @__PURE__ */ new Map();
        caches.set(ownerDocument, cache);
      } else
        caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type = props.disabled, "string" === typeof props.precedence && null == type;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    function suspendResource(state, hoistableRoot, resource, props) {
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    var estimatedBytesWithinLimit = 0;
    function waitForCommitToBeReady(state, timeoutOffset) {
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count || 0 < state.imgCount ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function() {
            state.waitingForImages = false;
            if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          },
          (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
        );
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root2, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root2);
        if (precedences) var last = precedences.get(null);
        else {
          precedences = /* @__PURE__ */ new Map();
          precedencesByRoot.set(root2, precedences);
          for (var nodes = root2.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
              precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(null, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(null, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane();
        lane = getBumpedLaneForHydrationByLane(lane);
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root2 = fiber;
                      root2.pendingLanes |= 2;
                      for (root2.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root2.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                    }
                  }
                  break;
                case 31:
                case 13:
                  root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i = 0; i < formReplayingQueue.length; i += 3) {
            var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
        attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept && "react-transition" === event.info && event.intercept({
          handler: function() {
            return new Promise(function(resolve) {
              return pendingResolve = resolve;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
            state: currentEntry.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if ("object" === typeof navigation) {
        var isCancelled = false, pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function() {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
          navigation.removeEventListener("navigateerror", handleNavigateComplete);
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root2 = this._internalRoot;
      if (null === root2) throw Error(formatProdErrorMessage(409));
      var current = root2.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root2, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root2 = this._internalRoot;
      if (null !== root2) {
        this._internalRoot = null;
        var container = root2.containerInfo;
        updateContainerImpl(root2.current, 2, null, root2, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
    if ("19.2.4" !== isomorphicReactPackageVersion$jscomp$inline_1840)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1840,
          "19.2.4"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2347 = {
      bundleType: 0,
      version: "19.2.4",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.2.4"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2348.inject(
            internals$jscomp$inline_2347
          ), injectedHook = hook$jscomp$inline_2348;
        } catch (err) {
        }
    }
    reactDomClient_production.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    reactDomClient_production.version = "19.2.4";
    return reactDomClient_production;
  }
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    client.exports = requireReactDomClient_production();
  }
  var clientExports = client.exports;
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production = {};
  /**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production;
  function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config2, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config2.key && (key = "" + config2.key);
      if ("key" in config2) {
        maybeKey = {};
        for (var propName in config2)
          "key" !== propName && (maybeKey[propName] = config2[propName]);
      } else maybeKey = config2;
      config2 = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config2 ? config2 : null,
        props: maybeKey
      };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    return reactJsxRuntime_production;
  }
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  const ny = /* @__PURE__ */ getDefaultExportFromCjs$1(jsxRuntimeExports);
  var define_process_env_default = { NODE_ENV: "production" };
  var Gm = Object.defineProperty;
  var Zm = (t10, e, r) => e in t10 ? Gm(t10, e, { enumerable: true, configurable: true, writable: true, value: r }) : t10[e] = r;
  var ge = (t10, e, r) => (Zm(t10, typeof e != "symbol" ? e + "" : e, r), r);
  const u0 = {
    SyncIntervalTime: 3e3
  };
  var Jo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
  function f0(t10) {
    if (t10.__esModule)
      return t10;
    var e = t10.default;
    if (typeof e == "function") {
      var r = function n() {
        if (this instanceof n) {
          var i = [null];
          i.push.apply(i, arguments);
          var o = Function.bind.apply(e, i);
          return new o();
        }
        return e.apply(this, arguments);
      };
      r.prototype = e.prototype;
    } else
      r = {};
    return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(t10).forEach(function(n) {
      var i = Object.getOwnPropertyDescriptor(t10, n);
      Object.defineProperty(r, n, i.get ? i : {
        enumerable: true,
        get: function() {
          return t10[n];
        }
      });
    }), r;
  }
  var ui = {}, iy = {
    get exports() {
      return ui;
    },
    set exports(t10) {
      ui = t10;
    }
  }, ii = typeof Reflect == "object" ? Reflect : null, Pf = ii && typeof ii.apply == "function" ? ii.apply : function(e, r, n) {
    return Function.prototype.apply.call(e, r, n);
  }, Es;
  ii && typeof ii.ownKeys == "function" ? Es = ii.ownKeys : Object.getOwnPropertySymbols ? Es = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : Es = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function oy(t10) {
    console && console.warn && console.warn(t10);
  }
  var d0 = Number.isNaN || function(e) {
    return e !== e;
  };
  function He() {
    He.init.call(this);
  }
  iy.exports = He;
  ui.once = cy;
  He.EventEmitter = He;
  He.prototype._events = void 0;
  He.prototype._eventsCount = 0;
  He.prototype._maxListeners = void 0;
  var Rf = 10;
  function xa(t10) {
    if (typeof t10 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t10);
  }
  Object.defineProperty(He, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return Rf;
    },
    set: function(t10) {
      if (typeof t10 != "number" || t10 < 0 || d0(t10))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t10 + ".");
      Rf = t10;
    }
  });
  He.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  He.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || d0(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function h0(t10) {
    return t10._maxListeners === void 0 ? He.defaultMaxListeners : t10._maxListeners;
  }
  He.prototype.getMaxListeners = function() {
    return h0(this);
  };
  He.prototype.emit = function(e) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r.push(arguments[n]);
    var i = e === "error", o = this._events;
    if (o !== void 0)
      i = i && o.error === void 0;
    else if (!i)
      return false;
    if (i) {
      var s;
      if (r.length > 0 && (s = r[0]), s instanceof Error)
        throw s;
      var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw a.context = s, a;
    }
    var l = o[e];
    if (l === void 0)
      return false;
    if (typeof l == "function")
      Pf(l, this, r);
    else
      for (var c = l.length, u = b0(l, c), n = 0; n < c; ++n)
        Pf(u[n], this, r);
    return true;
  };
  function p0(t10, e, r, n) {
    var i, o, s;
    if (xa(r), o = t10._events, o === void 0 ? (o = t10._events = /* @__PURE__ */ Object.create(null), t10._eventsCount = 0) : (o.newListener !== void 0 && (t10.emit(
      "newListener",
      e,
      r.listener ? r.listener : r
    ), o = t10._events), s = o[e]), s === void 0)
      s = o[e] = r, ++t10._eventsCount;
    else if (typeof s == "function" ? s = o[e] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), i = h0(t10), i > 0 && s.length > i && !s.warned) {
      s.warned = true;
      var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a.name = "MaxListenersExceededWarning", a.emitter = t10, a.type = e, a.count = s.length, oy(a);
    }
    return t10;
  }
  He.prototype.addListener = function(e, r) {
    return p0(this, e, r, false);
  };
  He.prototype.on = He.prototype.addListener;
  He.prototype.prependListener = function(e, r) {
    return p0(this, e, r, true);
  };
  function sy() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function g0(t10, e, r) {
    var n = { fired: false, wrapFn: void 0, target: t10, type: e, listener: r }, i = sy.bind(n);
    return i.listener = r, n.wrapFn = i, i;
  }
  He.prototype.once = function(e, r) {
    return xa(r), this.on(e, g0(this, e, r)), this;
  };
  He.prototype.prependOnceListener = function(e, r) {
    return xa(r), this.prependListener(e, g0(this, e, r)), this;
  };
  He.prototype.removeListener = function(e, r) {
    var n, i, o, s, a;
    if (xa(r), i = this._events, i === void 0)
      return this;
    if (n = i[e], n === void 0)
      return this;
    if (n === r || n.listener === r)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
    else if (typeof n != "function") {
      for (o = -1, s = n.length - 1; s >= 0; s--)
        if (n[s] === r || n[s].listener === r) {
          a = n[s].listener, o = s;
          break;
        }
      if (o < 0)
        return this;
      o === 0 ? n.shift() : ay(n, o), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r);
    }
    return this;
  };
  He.prototype.off = He.prototype.removeListener;
  He.prototype.removeAllListeners = function(e) {
    var r, n, i;
    if (n = this._events, n === void 0)
      return this;
    if (n.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
    if (arguments.length === 0) {
      var o = Object.keys(n), s;
      for (i = 0; i < o.length; ++i)
        s = o[i], s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (r = n[e], typeof r == "function")
      this.removeListener(e, r);
    else if (r !== void 0)
      for (i = r.length - 1; i >= 0; i--)
        this.removeListener(e, r[i]);
    return this;
  };
  function m0(t10, e, r) {
    var n = t10._events;
    if (n === void 0)
      return [];
    var i = n[e];
    return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ly(i) : b0(i, i.length);
  }
  He.prototype.listeners = function(e) {
    return m0(this, e, true);
  };
  He.prototype.rawListeners = function(e) {
    return m0(this, e, false);
  };
  He.listenerCount = function(t10, e) {
    return typeof t10.listenerCount == "function" ? t10.listenerCount(e) : y0.call(t10, e);
  };
  He.prototype.listenerCount = y0;
  function y0(t10) {
    var e = this._events;
    if (e !== void 0) {
      var r = e[t10];
      if (typeof r == "function")
        return 1;
      if (r !== void 0)
        return r.length;
    }
    return 0;
  }
  He.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Es(this._events) : [];
  };
  function b0(t10, e) {
    for (var r = new Array(e), n = 0; n < e; ++n)
      r[n] = t10[n];
    return r;
  }
  function ay(t10, e) {
    for (; e + 1 < t10.length; e++)
      t10[e] = t10[e + 1];
    t10.pop();
  }
  function ly(t10) {
    for (var e = new Array(t10.length), r = 0; r < e.length; ++r)
      e[r] = t10[r].listener || t10[r];
    return e;
  }
  function cy(t10, e) {
    return new Promise(function(r, n) {
      function i(s) {
        t10.removeListener(e, o), n(s);
      }
      function o() {
        typeof t10.removeListener == "function" && t10.removeListener("error", i), r([].slice.call(arguments));
      }
      v0(t10, e, o, { once: true }), e !== "error" && uy(t10, i, { once: true });
    });
  }
  function uy(t10, e, r) {
    typeof t10.on == "function" && v0(t10, "error", e, r);
  }
  function v0(t10, e, r, n) {
    if (typeof t10.on == "function")
      n.once ? t10.once(e, r) : t10.on(e, r);
    else if (typeof t10.addEventListener == "function")
      t10.addEventListener(e, function i(o) {
        n.once && t10.removeEventListener(e, i), r(o);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t10);
  }
  class ru extends ui.EventEmitter {
    constructor() {
      super(), this.temporaryListeners = [];
    }
    on(e, r, n) {
      return super.on(e, r), n && this.temporaryListeners.push([e, r]), () => {
        this.off(e, r);
      };
    }
    removeTemporaryListeners() {
      console.log(
        "removeTemporaryListeners CALLED",
        this,
        this.temporaryListeners
      ), this.temporaryListeners.forEach(([e, r]) => {
        this.removeListener(e, r);
      }), this.temporaryListeners = [];
    }
  }
  var Vs = {}, fy = {
    get exports() {
      return Vs;
    },
    set exports(t10) {
      Vs = t10;
    }
  }, ll, Df;
  function dy() {
    if (Df)
      return ll;
    Df = 1;
    var t10 = 1e3, e = t10 * 60, r = e * 60, n = r * 24, i = n * 7, o = n * 365.25;
    ll = function(u, f) {
      f = f || {};
      var d = typeof u;
      if (d === "string" && u.length > 0)
        return s(u);
      if (d === "number" && isFinite(u))
        return f.long ? l(u) : a(u);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
      );
    };
    function s(u) {
      if (u = String(u), !(u.length > 100)) {
        var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          u
        );
        if (f) {
          var d = parseFloat(f[1]), h = (f[2] || "ms").toLowerCase();
          switch (h) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return d * o;
            case "weeks":
            case "week":
            case "w":
              return d * i;
            case "days":
            case "day":
            case "d":
              return d * n;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return d * r;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return d * e;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return d * t10;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return d;
            default:
              return;
          }
        }
      }
    }
    function a(u) {
      var f = Math.abs(u);
      return f >= n ? Math.round(u / n) + "d" : f >= r ? Math.round(u / r) + "h" : f >= e ? Math.round(u / e) + "m" : f >= t10 ? Math.round(u / t10) + "s" : u + "ms";
    }
    function l(u) {
      var f = Math.abs(u);
      return f >= n ? c(u, f, n, "day") : f >= r ? c(u, f, r, "hour") : f >= e ? c(u, f, e, "minute") : f >= t10 ? c(u, f, t10, "second") : u + " ms";
    }
    function c(u, f, d, h) {
      var g = f >= d * 1.5;
      return Math.round(u / d) + " " + h + (g ? "s" : "");
    }
    return ll;
  }
  function hy(t10) {
    r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = i, r.enabled = s, r.humanize = dy(), r.destroy = c, Object.keys(t10).forEach((u) => {
      r[u] = t10[u];
    }), r.names = [], r.skips = [], r.formatters = {};
    function e(u) {
      let f = 0;
      for (let d = 0; d < u.length; d++)
        f = (f << 5) - f + u.charCodeAt(d), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    r.selectColor = e;
    function r(u) {
      let f, d = null, h, g;
      function p(...y) {
        if (!p.enabled)
          return;
        const b = p, x = Number(/* @__PURE__ */ new Date()), S = x - (f || x);
        b.diff = S, b.prev = f, b.curr = x, f = x, y[0] = r.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
        let C = 0;
        y[0] = y[0].replace(/%([a-zA-Z%])/g, (L, F) => {
          if (L === "%%")
            return "%";
          C++;
          const V = r.formatters[F];
          if (typeof V == "function") {
            const W = y[C];
            L = V.call(b, W), y.splice(C, 1), C--;
          }
          return L;
        }), r.formatArgs.call(b, y), (b.log || r.log).apply(b, y);
      }
      return p.namespace = u, p.useColors = r.useColors(), p.color = r.selectColor(u), p.extend = n, p.destroy = r.destroy, Object.defineProperty(p, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => d !== null ? d : (h !== r.namespaces && (h = r.namespaces, g = r.enabled(u)), g),
        set: (y) => {
          d = y;
        }
      }), typeof r.init == "function" && r.init(p), p;
    }
    function n(u, f) {
      const d = r(this.namespace + (typeof f > "u" ? ":" : f) + u);
      return d.log = this.log, d;
    }
    function i(u) {
      r.save(u), r.namespaces = u, r.names = [], r.skips = [];
      let f;
      const d = (typeof u == "string" ? u : "").split(/[\s,]+/), h = d.length;
      for (f = 0; f < h; f++)
        d[f] && (u = d[f].replace(/\*/g, ".*?"), u[0] === "-" ? r.skips.push(new RegExp("^" + u.slice(1) + "$")) : r.names.push(new RegExp("^" + u + "$")));
    }
    function o() {
      const u = [
        ...r.names.map(a),
        ...r.skips.map(a).map((f) => "-" + f)
      ].join(",");
      return r.enable(""), u;
    }
    function s(u) {
      if (u[u.length - 1] === "*")
        return true;
      let f, d;
      for (f = 0, d = r.skips.length; f < d; f++)
        if (r.skips[f].test(u))
          return false;
      for (f = 0, d = r.names.length; f < d; f++)
        if (r.names[f].test(u))
          return true;
      return false;
    }
    function a(u) {
      return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return r.enable(r.load()), r;
  }
  var py = hy;
  (function(t10, e) {
    e.formatArgs = n, e.save = i, e.load = o, e.useColors = r, e.storage = s(), e.destroy = /* @__PURE__ */ (() => {
      let l = false;
      return () => {
        l || (l = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(l) {
      if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t10.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      l.splice(1, 0, c, "color: inherit");
      let u = 0, f = 0;
      l[0].replace(/%[a-zA-Z%]/g, (d) => {
        d !== "%%" && (u++, d === "%c" && (f = u));
      }), l.splice(f, 0, c);
    }
    e.log = console.debug || console.log || (() => {
    });
    function i(l) {
      try {
        l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
      } catch {
      }
    }
    function o() {
      let l;
      try {
        l = e.storage.getItem("debug");
      } catch {
      }
      return !l && typeof process < "u" && "env" in process && (l = define_process_env_default.DEBUG), l;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    t10.exports = py(e);
    const { formatters: a } = t10.exports;
    a.j = function(l) {
      try {
        return JSON.stringify(l);
      } catch (c) {
        return "[UnexpectedJSONParseError]: " + c.message;
      }
    };
  })(fy, Vs);
  var gy = function() {
    if (typeof globalThis > "u")
      return null;
    var e = {
      RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
      RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
      RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
    };
    return e.RTCPeerConnection ? e : null;
  }, dc = {}, Mf = {
    get exports() {
      return dc;
    },
    set exports(t10) {
      dc = t10;
    }
  }, ho = {}, my = {
    get exports() {
      return ho;
    },
    set exports(t10) {
      ho = t10;
    }
  }, Mo = {}, No = {};
  No.byteLength = vy;
  No.toByteArray = wy;
  No.fromByteArray = Sy;
  var pr = [], Kt = [], yy = typeof Uint8Array < "u" ? Uint8Array : Array, cl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var qn = 0, by = cl.length; qn < by; ++qn)
    pr[qn] = cl[qn], Kt[cl.charCodeAt(qn)] = qn;
  Kt["-".charCodeAt(0)] = 62;
  Kt["_".charCodeAt(0)] = 63;
  function A0(t10) {
    var e = t10.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t10.indexOf("=");
    r === -1 && (r = e);
    var n = r === e ? 0 : 4 - r % 4;
    return [r, n];
  }
  function vy(t10) {
    var e = A0(t10), r = e[0], n = e[1];
    return (r + n) * 3 / 4 - n;
  }
  function Ay(t10, e, r) {
    return (e + r) * 3 / 4 - r;
  }
  function wy(t10) {
    var e, r = A0(t10), n = r[0], i = r[1], o = new yy(Ay(t10, n, i)), s = 0, a = i > 0 ? n - 4 : n, l;
    for (l = 0; l < a; l += 4)
      e = Kt[t10.charCodeAt(l)] << 18 | Kt[t10.charCodeAt(l + 1)] << 12 | Kt[t10.charCodeAt(l + 2)] << 6 | Kt[t10.charCodeAt(l + 3)], o[s++] = e >> 16 & 255, o[s++] = e >> 8 & 255, o[s++] = e & 255;
    return i === 2 && (e = Kt[t10.charCodeAt(l)] << 2 | Kt[t10.charCodeAt(l + 1)] >> 4, o[s++] = e & 255), i === 1 && (e = Kt[t10.charCodeAt(l)] << 10 | Kt[t10.charCodeAt(l + 1)] << 4 | Kt[t10.charCodeAt(l + 2)] >> 2, o[s++] = e >> 8 & 255, o[s++] = e & 255), o;
  }
  function xy(t10) {
    return pr[t10 >> 18 & 63] + pr[t10 >> 12 & 63] + pr[t10 >> 6 & 63] + pr[t10 & 63];
  }
  function _y(t10, e, r) {
    for (var n, i = [], o = e; o < r; o += 3)
      n = (t10[o] << 16 & 16711680) + (t10[o + 1] << 8 & 65280) + (t10[o + 2] & 255), i.push(xy(n));
    return i.join("");
  }
  function Sy(t10) {
    for (var e, r = t10.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)
      i.push(_y(t10, s, s + o > a ? a : s + o));
    return n === 1 ? (e = t10[r - 1], i.push(
      pr[e >> 2] + pr[e << 4 & 63] + "=="
    )) : n === 2 && (e = (t10[r - 2] << 8) + t10[r - 1], i.push(
      pr[e >> 10] + pr[e >> 4 & 63] + pr[e << 2 & 63] + "="
    )), i.join("");
  }
  var _a = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  _a.read = function(t10, e, r, n, i) {
    var o, s, a = i * 8 - n - 1, l = (1 << a) - 1, c = l >> 1, u = -7, f = r ? i - 1 : 0, d = r ? -1 : 1, h = t10[e + f];
    for (f += d, o = h & (1 << -u) - 1, h >>= -u, u += a; u > 0; o = o * 256 + t10[e + f], f += d, u -= 8)
      ;
    for (s = o & (1 << -u) - 1, o >>= -u, u += n; u > 0; s = s * 256 + t10[e + f], f += d, u -= 8)
      ;
    if (o === 0)
      o = 1 - c;
    else {
      if (o === l)
        return s ? NaN : (h ? -1 : 1) * (1 / 0);
      s = s + Math.pow(2, n), o = o - c;
    }
    return (h ? -1 : 1) * s * Math.pow(2, o - n);
  };
  _a.write = function(t10, e, r, n, i, o) {
    var s, a, l, c = o * 8 - i - 1, u = (1 << c) - 1, f = u >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = n ? 0 : o - 1, g = n ? 1 : -1, p = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = u) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), s + f >= 1 ? e += d / l : e += d * Math.pow(2, 1 - f), e * l >= 2 && (s++, l /= 2), s + f >= u ? (a = 0, s = u) : s + f >= 1 ? (a = (e * l - 1) * Math.pow(2, i), s = s + f) : (a = e * Math.pow(2, f - 1) * Math.pow(2, i), s = 0)); i >= 8; t10[r + h] = a & 255, h += g, a /= 256, i -= 8)
      ;
    for (s = s << i | a, c += i; c > 0; t10[r + h] = s & 255, h += g, s /= 256, c -= 8)
      ;
    t10[r + h - g] |= p * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(t10) {
    var e = No, r = _a, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t10.Buffer = a, t10.SlowBuffer = x, t10.INSPECT_MAX_BYTES = 50;
    var i = 2147483647;
    t10.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function o() {
      try {
        var I = new Uint8Array(1), v = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(v, Uint8Array.prototype), Object.setPrototypeOf(I, v), I.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(a.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.byteOffset;
      }
    });
    function s(I) {
      if (I > i)
        throw new RangeError('The value "' + I + '" is invalid for option "size"');
      var v = new Uint8Array(I);
      return Object.setPrototypeOf(v, a.prototype), v;
    }
    function a(I, v, w) {
      if (typeof I == "number") {
        if (typeof v == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return f(I);
      }
      return l(I, v, w);
    }
    a.poolSize = 8192;
    function l(I, v, w) {
      if (typeof I == "string")
        return d(I, v);
      if (ArrayBuffer.isView(I))
        return g(I);
      if (I == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof I
        );
      if (ee(I, ArrayBuffer) || I && ee(I.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ee(I, SharedArrayBuffer) || I && ee(I.buffer, SharedArrayBuffer)))
        return p(I, v, w);
      if (typeof I == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var D = I.valueOf && I.valueOf();
      if (D != null && D !== I)
        return a.from(D, v, w);
      var Q = y(I);
      if (Q)
        return Q;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof I[Symbol.toPrimitive] == "function")
        return a.from(
          I[Symbol.toPrimitive]("string"),
          v,
          w
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof I
      );
    }
    a.from = function(I, v, w) {
      return l(I, v, w);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function c(I) {
      if (typeof I != "number")
        throw new TypeError('"size" argument must be of type number');
      if (I < 0)
        throw new RangeError('The value "' + I + '" is invalid for option "size"');
    }
    function u(I, v, w) {
      return c(I), I <= 0 ? s(I) : v !== void 0 ? typeof w == "string" ? s(I).fill(v, w) : s(I).fill(v) : s(I);
    }
    a.alloc = function(I, v, w) {
      return u(I, v, w);
    };
    function f(I) {
      return c(I), s(I < 0 ? 0 : b(I) | 0);
    }
    a.allocUnsafe = function(I) {
      return f(I);
    }, a.allocUnsafeSlow = function(I) {
      return f(I);
    };
    function d(I, v) {
      if ((typeof v != "string" || v === "") && (v = "utf8"), !a.isEncoding(v))
        throw new TypeError("Unknown encoding: " + v);
      var w = S(I, v) | 0, D = s(w), Q = D.write(I, v);
      return Q !== w && (D = D.slice(0, Q)), D;
    }
    function h(I) {
      for (var v = I.length < 0 ? 0 : b(I.length) | 0, w = s(v), D = 0; D < v; D += 1)
        w[D] = I[D] & 255;
      return w;
    }
    function g(I) {
      if (ee(I, Uint8Array)) {
        var v = new Uint8Array(I);
        return p(v.buffer, v.byteOffset, v.byteLength);
      }
      return h(I);
    }
    function p(I, v, w) {
      if (v < 0 || I.byteLength < v)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (I.byteLength < v + (w || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var D;
      return v === void 0 && w === void 0 ? D = new Uint8Array(I) : w === void 0 ? D = new Uint8Array(I, v) : D = new Uint8Array(I, v, w), Object.setPrototypeOf(D, a.prototype), D;
    }
    function y(I) {
      if (a.isBuffer(I)) {
        var v = b(I.length) | 0, w = s(v);
        return w.length === 0 || I.copy(w, 0, 0, v), w;
      }
      if (I.length !== void 0)
        return typeof I.length != "number" || re(I.length) ? s(0) : h(I);
      if (I.type === "Buffer" && Array.isArray(I.data))
        return h(I.data);
    }
    function b(I) {
      if (I >= i)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return I | 0;
    }
    function x(I) {
      return +I != I && (I = 0), a.alloc(+I);
    }
    a.isBuffer = function(v) {
      return v != null && v._isBuffer === true && v !== a.prototype;
    }, a.compare = function(v, w) {
      if (ee(v, Uint8Array) && (v = a.from(v, v.offset, v.byteLength)), ee(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)), !a.isBuffer(v) || !a.isBuffer(w))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (v === w)
        return 0;
      for (var D = v.length, Q = w.length, ae = 0, fe = Math.min(D, Q); ae < fe; ++ae)
        if (v[ae] !== w[ae]) {
          D = v[ae], Q = w[ae];
          break;
        }
      return D < Q ? -1 : Q < D ? 1 : 0;
    }, a.isEncoding = function(v) {
      switch (String(v).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, a.concat = function(v, w) {
      if (!Array.isArray(v))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (v.length === 0)
        return a.alloc(0);
      var D;
      if (w === void 0)
        for (w = 0, D = 0; D < v.length; ++D)
          w += v[D].length;
      var Q = a.allocUnsafe(w), ae = 0;
      for (D = 0; D < v.length; ++D) {
        var fe = v[D];
        if (ee(fe, Uint8Array))
          ae + fe.length > Q.length ? a.from(fe).copy(Q, ae) : Uint8Array.prototype.set.call(
            Q,
            fe,
            ae
          );
        else if (a.isBuffer(fe))
          fe.copy(Q, ae);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        ae += fe.length;
      }
      return Q;
    };
    function S(I, v) {
      if (a.isBuffer(I))
        return I.length;
      if (ArrayBuffer.isView(I) || ee(I, ArrayBuffer))
        return I.byteLength;
      if (typeof I != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof I
        );
      var w = I.length, D = arguments.length > 2 && arguments[2] === true;
      if (!D && w === 0)
        return 0;
      for (var Q = false; ; )
        switch (v) {
          case "ascii":
          case "latin1":
          case "binary":
            return w;
          case "utf8":
          case "utf-8":
            return Z(I).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return w * 2;
          case "hex":
            return w >>> 1;
          case "base64":
            return R(I).length;
          default:
            if (Q)
              return D ? -1 : Z(I).length;
            v = ("" + v).toLowerCase(), Q = true;
        }
    }
    a.byteLength = S;
    function C(I, v, w) {
      var D = false;
      if ((v === void 0 || v < 0) && (v = 0), v > this.length || ((w === void 0 || w > this.length) && (w = this.length), w <= 0) || (w >>>= 0, v >>>= 0, w <= v))
        return "";
      for (I || (I = "utf8"); ; )
        switch (I) {
          case "hex":
            return Y(this, v, w);
          case "utf8":
          case "utf-8":
            return z10(this, v, w);
          case "ascii":
            return q(this, v, w);
          case "latin1":
          case "binary":
            return te(this, v, w);
          case "base64":
            return P10(this, v, w);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return K(this, v, w);
          default:
            if (D)
              throw new TypeError("Unknown encoding: " + I);
            I = (I + "").toLowerCase(), D = true;
        }
    }
    a.prototype._isBuffer = true;
    function _(I, v, w) {
      var D = I[v];
      I[v] = I[w], I[w] = D;
    }
    a.prototype.swap16 = function() {
      var v = this.length;
      if (v % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var w = 0; w < v; w += 2)
        _(this, w, w + 1);
      return this;
    }, a.prototype.swap32 = function() {
      var v = this.length;
      if (v % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var w = 0; w < v; w += 4)
        _(this, w, w + 3), _(this, w + 1, w + 2);
      return this;
    }, a.prototype.swap64 = function() {
      var v = this.length;
      if (v % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var w = 0; w < v; w += 8)
        _(this, w, w + 7), _(this, w + 1, w + 6), _(this, w + 2, w + 5), _(this, w + 3, w + 4);
      return this;
    }, a.prototype.toString = function() {
      var v = this.length;
      return v === 0 ? "" : arguments.length === 0 ? z10(this, 0, v) : C.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(v) {
      if (!a.isBuffer(v))
        throw new TypeError("Argument must be a Buffer");
      return this === v ? true : a.compare(this, v) === 0;
    }, a.prototype.inspect = function() {
      var v = "", w = t10.INSPECT_MAX_BYTES;
      return v = this.toString("hex", 0, w).replace(/(.{2})/g, "$1 ").trim(), this.length > w && (v += " ... "), "<Buffer " + v + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(v, w, D, Q, ae) {
      if (ee(v, Uint8Array) && (v = a.from(v, v.offset, v.byteLength)), !a.isBuffer(v))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof v
        );
      if (w === void 0 && (w = 0), D === void 0 && (D = v ? v.length : 0), Q === void 0 && (Q = 0), ae === void 0 && (ae = this.length), w < 0 || D > v.length || Q < 0 || ae > this.length)
        throw new RangeError("out of range index");
      if (Q >= ae && w >= D)
        return 0;
      if (Q >= ae)
        return -1;
      if (w >= D)
        return 1;
      if (w >>>= 0, D >>>= 0, Q >>>= 0, ae >>>= 0, this === v)
        return 0;
      for (var fe = ae - Q, Ae = D - w, ve = Math.min(fe, Ae), be = this.slice(Q, ae), Pe = v.slice(w, D), E = 0; E < ve; ++E)
        if (be[E] !== Pe[E]) {
          fe = be[E], Ae = Pe[E];
          break;
        }
      return fe < Ae ? -1 : Ae < fe ? 1 : 0;
    };
    function L(I, v, w, D, Q) {
      if (I.length === 0)
        return -1;
      if (typeof w == "string" ? (D = w, w = 0) : w > 2147483647 ? w = 2147483647 : w < -2147483648 && (w = -2147483648), w = +w, re(w) && (w = Q ? 0 : I.length - 1), w < 0 && (w = I.length + w), w >= I.length) {
        if (Q)
          return -1;
        w = I.length - 1;
      } else if (w < 0)
        if (Q)
          w = 0;
        else
          return -1;
      if (typeof v == "string" && (v = a.from(v, D)), a.isBuffer(v))
        return v.length === 0 ? -1 : F(I, v, w, D, Q);
      if (typeof v == "number")
        return v = v & 255, typeof Uint8Array.prototype.indexOf == "function" ? Q ? Uint8Array.prototype.indexOf.call(I, v, w) : Uint8Array.prototype.lastIndexOf.call(I, v, w) : F(I, [v], w, D, Q);
      throw new TypeError("val must be string, number or Buffer");
    }
    function F(I, v, w, D, Q) {
      var ae = 1, fe = I.length, Ae = v.length;
      if (D !== void 0 && (D = String(D).toLowerCase(), D === "ucs2" || D === "ucs-2" || D === "utf16le" || D === "utf-16le")) {
        if (I.length < 2 || v.length < 2)
          return -1;
        ae = 2, fe /= 2, Ae /= 2, w /= 2;
      }
      function ve(A, M) {
        return ae === 1 ? A[M] : A.readUInt16BE(M * ae);
      }
      var be;
      if (Q) {
        var Pe = -1;
        for (be = w; be < fe; be++)
          if (ve(I, be) === ve(v, Pe === -1 ? 0 : be - Pe)) {
            if (Pe === -1 && (Pe = be), be - Pe + 1 === Ae)
              return Pe * ae;
          } else
            Pe !== -1 && (be -= be - Pe), Pe = -1;
      } else
        for (w + Ae > fe && (w = fe - Ae), be = w; be >= 0; be--) {
          for (var E = true, m = 0; m < Ae; m++)
            if (ve(I, be + m) !== ve(v, m)) {
              E = false;
              break;
            }
          if (E)
            return be;
        }
      return -1;
    }
    a.prototype.includes = function(v, w, D) {
      return this.indexOf(v, w, D) !== -1;
    }, a.prototype.indexOf = function(v, w, D) {
      return L(this, v, w, D, true);
    }, a.prototype.lastIndexOf = function(v, w, D) {
      return L(this, v, w, D, false);
    };
    function V(I, v, w, D) {
      w = Number(w) || 0;
      var Q = I.length - w;
      D ? (D = Number(D), D > Q && (D = Q)) : D = Q;
      var ae = v.length;
      D > ae / 2 && (D = ae / 2);
      for (var fe = 0; fe < D; ++fe) {
        var Ae = parseInt(v.substr(fe * 2, 2), 16);
        if (re(Ae))
          return fe;
        I[w + fe] = Ae;
      }
      return fe;
    }
    function W(I, v, w, D) {
      return k(Z(v, I.length - w), I, w, D);
    }
    function X(I, v, w, D) {
      return k(oe(v), I, w, D);
    }
    function G(I, v, w, D) {
      return k(R(v), I, w, D);
    }
    function ie(I, v, w, D) {
      return k(ue(v, I.length - w), I, w, D);
    }
    a.prototype.write = function(v, w, D, Q) {
      if (w === void 0)
        Q = "utf8", D = this.length, w = 0;
      else if (D === void 0 && typeof w == "string")
        Q = w, D = this.length, w = 0;
      else if (isFinite(w))
        w = w >>> 0, isFinite(D) ? (D = D >>> 0, Q === void 0 && (Q = "utf8")) : (Q = D, D = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var ae = this.length - w;
      if ((D === void 0 || D > ae) && (D = ae), v.length > 0 && (D < 0 || w < 0) || w > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      Q || (Q = "utf8");
      for (var fe = false; ; )
        switch (Q) {
          case "hex":
            return V(this, v, w, D);
          case "utf8":
          case "utf-8":
            return W(this, v, w, D);
          case "ascii":
          case "latin1":
          case "binary":
            return X(this, v, w, D);
          case "base64":
            return G(this, v, w, D);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ie(this, v, w, D);
          default:
            if (fe)
              throw new TypeError("Unknown encoding: " + Q);
            Q = ("" + Q).toLowerCase(), fe = true;
        }
    }, a.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function P10(I, v, w) {
      return v === 0 && w === I.length ? e.fromByteArray(I) : e.fromByteArray(I.slice(v, w));
    }
    function z10(I, v, w) {
      w = Math.min(I.length, w);
      for (var D = [], Q = v; Q < w; ) {
        var ae = I[Q], fe = null, Ae = ae > 239 ? 4 : ae > 223 ? 3 : ae > 191 ? 2 : 1;
        if (Q + Ae <= w) {
          var ve, be, Pe, E;
          switch (Ae) {
            case 1:
              ae < 128 && (fe = ae);
              break;
            case 2:
              ve = I[Q + 1], (ve & 192) === 128 && (E = (ae & 31) << 6 | ve & 63, E > 127 && (fe = E));
              break;
            case 3:
              ve = I[Q + 1], be = I[Q + 2], (ve & 192) === 128 && (be & 192) === 128 && (E = (ae & 15) << 12 | (ve & 63) << 6 | be & 63, E > 2047 && (E < 55296 || E > 57343) && (fe = E));
              break;
            case 4:
              ve = I[Q + 1], be = I[Q + 2], Pe = I[Q + 3], (ve & 192) === 128 && (be & 192) === 128 && (Pe & 192) === 128 && (E = (ae & 15) << 18 | (ve & 63) << 12 | (be & 63) << 6 | Pe & 63, E > 65535 && E < 1114112 && (fe = E));
          }
        }
        fe === null ? (fe = 65533, Ae = 1) : fe > 65535 && (fe -= 65536, D.push(fe >>> 10 & 1023 | 55296), fe = 56320 | fe & 1023), D.push(fe), Q += Ae;
      }
      return O(D);
    }
    var B = 4096;
    function O(I) {
      var v = I.length;
      if (v <= B)
        return String.fromCharCode.apply(String, I);
      for (var w = "", D = 0; D < v; )
        w += String.fromCharCode.apply(
          String,
          I.slice(D, D += B)
        );
      return w;
    }
    function q(I, v, w) {
      var D = "";
      w = Math.min(I.length, w);
      for (var Q = v; Q < w; ++Q)
        D += String.fromCharCode(I[Q] & 127);
      return D;
    }
    function te(I, v, w) {
      var D = "";
      w = Math.min(I.length, w);
      for (var Q = v; Q < w; ++Q)
        D += String.fromCharCode(I[Q]);
      return D;
    }
    function Y(I, v, w) {
      var D = I.length;
      (!v || v < 0) && (v = 0), (!w || w < 0 || w > D) && (w = D);
      for (var Q = "", ae = v; ae < w; ++ae)
        Q += ye[I[ae]];
      return Q;
    }
    function K(I, v, w) {
      for (var D = I.slice(v, w), Q = "", ae = 0; ae < D.length - 1; ae += 2)
        Q += String.fromCharCode(D[ae] + D[ae + 1] * 256);
      return Q;
    }
    a.prototype.slice = function(v, w) {
      var D = this.length;
      v = ~~v, w = w === void 0 ? D : ~~w, v < 0 ? (v += D, v < 0 && (v = 0)) : v > D && (v = D), w < 0 ? (w += D, w < 0 && (w = 0)) : w > D && (w = D), w < v && (w = v);
      var Q = this.subarray(v, w);
      return Object.setPrototypeOf(Q, a.prototype), Q;
    };
    function $(I, v, w) {
      if (I % 1 !== 0 || I < 0)
        throw new RangeError("offset is not uint");
      if (I + v > w)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var Q = this[v], ae = 1, fe = 0; ++fe < w && (ae *= 256); )
        Q += this[v + fe] * ae;
      return Q;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var Q = this[v + --w], ae = 1; w > 0 && (ae *= 256); )
        Q += this[v + --w] * ae;
      return Q;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(v, w) {
      return v = v >>> 0, w || $(v, 1, this.length), this[v];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(v, w) {
      return v = v >>> 0, w || $(v, 2, this.length), this[v] | this[v + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(v, w) {
      return v = v >>> 0, w || $(v, 2, this.length), this[v] << 8 | this[v + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), (this[v] | this[v + 1] << 8 | this[v + 2] << 16) + this[v + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), this[v] * 16777216 + (this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3]);
    }, a.prototype.readIntLE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var Q = this[v], ae = 1, fe = 0; ++fe < w && (ae *= 256); )
        Q += this[v + fe] * ae;
      return ae *= 128, Q >= ae && (Q -= Math.pow(2, 8 * w)), Q;
    }, a.prototype.readIntBE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var Q = w, ae = 1, fe = this[v + --Q]; Q > 0 && (ae *= 256); )
        fe += this[v + --Q] * ae;
      return ae *= 128, fe >= ae && (fe -= Math.pow(2, 8 * w)), fe;
    }, a.prototype.readInt8 = function(v, w) {
      return v = v >>> 0, w || $(v, 1, this.length), this[v] & 128 ? (255 - this[v] + 1) * -1 : this[v];
    }, a.prototype.readInt16LE = function(v, w) {
      v = v >>> 0, w || $(v, 2, this.length);
      var D = this[v] | this[v + 1] << 8;
      return D & 32768 ? D | 4294901760 : D;
    }, a.prototype.readInt16BE = function(v, w) {
      v = v >>> 0, w || $(v, 2, this.length);
      var D = this[v + 1] | this[v] << 8;
      return D & 32768 ? D | 4294901760 : D;
    }, a.prototype.readInt32LE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), this[v] | this[v + 1] << 8 | this[v + 2] << 16 | this[v + 3] << 24;
    }, a.prototype.readInt32BE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), this[v] << 24 | this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3];
    }, a.prototype.readFloatLE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), r.read(this, v, true, 23, 4);
    }, a.prototype.readFloatBE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), r.read(this, v, false, 23, 4);
    }, a.prototype.readDoubleLE = function(v, w) {
      return v = v >>> 0, w || $(v, 8, this.length), r.read(this, v, true, 52, 8);
    }, a.prototype.readDoubleBE = function(v, w) {
      return v = v >>> 0, w || $(v, 8, this.length), r.read(this, v, false, 52, 8);
    };
    function se(I, v, w, D, Q, ae) {
      if (!a.isBuffer(I))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (v > Q || v < ae)
        throw new RangeError('"value" argument is out of bounds');
      if (w + D > I.length)
        throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(v, w, D, Q) {
      if (v = +v, w = w >>> 0, D = D >>> 0, !Q) {
        var ae = Math.pow(2, 8 * D) - 1;
        se(this, v, w, D, ae, 0);
      }
      var fe = 1, Ae = 0;
      for (this[w] = v & 255; ++Ae < D && (fe *= 256); )
        this[w + Ae] = v / fe & 255;
      return w + D;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(v, w, D, Q) {
      if (v = +v, w = w >>> 0, D = D >>> 0, !Q) {
        var ae = Math.pow(2, 8 * D) - 1;
        se(this, v, w, D, ae, 0);
      }
      var fe = D - 1, Ae = 1;
      for (this[w + fe] = v & 255; --fe >= 0 && (Ae *= 256); )
        this[w + fe] = v / Ae & 255;
      return w + D;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 1, 255, 0), this[w] = v & 255, w + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 65535, 0), this[w] = v & 255, this[w + 1] = v >>> 8, w + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 65535, 0), this[w] = v >>> 8, this[w + 1] = v & 255, w + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 4294967295, 0), this[w + 3] = v >>> 24, this[w + 2] = v >>> 16, this[w + 1] = v >>> 8, this[w] = v & 255, w + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 4294967295, 0), this[w] = v >>> 24, this[w + 1] = v >>> 16, this[w + 2] = v >>> 8, this[w + 3] = v & 255, w + 4;
    }, a.prototype.writeIntLE = function(v, w, D, Q) {
      if (v = +v, w = w >>> 0, !Q) {
        var ae = Math.pow(2, 8 * D - 1);
        se(this, v, w, D, ae - 1, -ae);
      }
      var fe = 0, Ae = 1, ve = 0;
      for (this[w] = v & 255; ++fe < D && (Ae *= 256); )
        v < 0 && ve === 0 && this[w + fe - 1] !== 0 && (ve = 1), this[w + fe] = (v / Ae >> 0) - ve & 255;
      return w + D;
    }, a.prototype.writeIntBE = function(v, w, D, Q) {
      if (v = +v, w = w >>> 0, !Q) {
        var ae = Math.pow(2, 8 * D - 1);
        se(this, v, w, D, ae - 1, -ae);
      }
      var fe = D - 1, Ae = 1, ve = 0;
      for (this[w + fe] = v & 255; --fe >= 0 && (Ae *= 256); )
        v < 0 && ve === 0 && this[w + fe + 1] !== 0 && (ve = 1), this[w + fe] = (v / Ae >> 0) - ve & 255;
      return w + D;
    }, a.prototype.writeInt8 = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 1, 127, -128), v < 0 && (v = 255 + v + 1), this[w] = v & 255, w + 1;
    }, a.prototype.writeInt16LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 32767, -32768), this[w] = v & 255, this[w + 1] = v >>> 8, w + 2;
    }, a.prototype.writeInt16BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 32767, -32768), this[w] = v >>> 8, this[w + 1] = v & 255, w + 2;
    }, a.prototype.writeInt32LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 2147483647, -2147483648), this[w] = v & 255, this[w + 1] = v >>> 8, this[w + 2] = v >>> 16, this[w + 3] = v >>> 24, w + 4;
    }, a.prototype.writeInt32BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 2147483647, -2147483648), v < 0 && (v = 4294967295 + v + 1), this[w] = v >>> 24, this[w + 1] = v >>> 16, this[w + 2] = v >>> 8, this[w + 3] = v & 255, w + 4;
    };
    function he(I, v, w, D, Q, ae) {
      if (w + D > I.length)
        throw new RangeError("Index out of range");
      if (w < 0)
        throw new RangeError("Index out of range");
    }
    function de(I, v, w, D, Q) {
      return v = +v, w = w >>> 0, Q || he(I, v, w, 4), r.write(I, v, w, D, 23, 4), w + 4;
    }
    a.prototype.writeFloatLE = function(v, w, D) {
      return de(this, v, w, true, D);
    }, a.prototype.writeFloatBE = function(v, w, D) {
      return de(this, v, w, false, D);
    };
    function pe(I, v, w, D, Q) {
      return v = +v, w = w >>> 0, Q || he(I, v, w, 8), r.write(I, v, w, D, 52, 8), w + 8;
    }
    a.prototype.writeDoubleLE = function(v, w, D) {
      return pe(this, v, w, true, D);
    }, a.prototype.writeDoubleBE = function(v, w, D) {
      return pe(this, v, w, false, D);
    }, a.prototype.copy = function(v, w, D, Q) {
      if (!a.isBuffer(v))
        throw new TypeError("argument should be a Buffer");
      if (D || (D = 0), !Q && Q !== 0 && (Q = this.length), w >= v.length && (w = v.length), w || (w = 0), Q > 0 && Q < D && (Q = D), Q === D || v.length === 0 || this.length === 0)
        return 0;
      if (w < 0)
        throw new RangeError("targetStart out of bounds");
      if (D < 0 || D >= this.length)
        throw new RangeError("Index out of range");
      if (Q < 0)
        throw new RangeError("sourceEnd out of bounds");
      Q > this.length && (Q = this.length), v.length - w < Q - D && (Q = v.length - w + D);
      var ae = Q - D;
      return this === v && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(w, D, Q) : Uint8Array.prototype.set.call(
        v,
        this.subarray(D, Q),
        w
      ), ae;
    }, a.prototype.fill = function(v, w, D, Q) {
      if (typeof v == "string") {
        if (typeof w == "string" ? (Q = w, w = 0, D = this.length) : typeof D == "string" && (Q = D, D = this.length), Q !== void 0 && typeof Q != "string")
          throw new TypeError("encoding must be a string");
        if (typeof Q == "string" && !a.isEncoding(Q))
          throw new TypeError("Unknown encoding: " + Q);
        if (v.length === 1) {
          var ae = v.charCodeAt(0);
          (Q === "utf8" && ae < 128 || Q === "latin1") && (v = ae);
        }
      } else
        typeof v == "number" ? v = v & 255 : typeof v == "boolean" && (v = Number(v));
      if (w < 0 || this.length < w || this.length < D)
        throw new RangeError("Out of range index");
      if (D <= w)
        return this;
      w = w >>> 0, D = D === void 0 ? this.length : D >>> 0, v || (v = 0);
      var fe;
      if (typeof v == "number")
        for (fe = w; fe < D; ++fe)
          this[fe] = v;
      else {
        var Ae = a.isBuffer(v) ? v : a.from(v, Q), ve = Ae.length;
        if (ve === 0)
          throw new TypeError('The value "' + v + '" is invalid for argument "value"');
        for (fe = 0; fe < D - w; ++fe)
          this[fe + w] = Ae[fe % ve];
      }
      return this;
    };
    var j = /[^+/0-9A-Za-z-_]/g;
    function H(I) {
      if (I = I.split("=")[0], I = I.trim().replace(j, ""), I.length < 2)
        return "";
      for (; I.length % 4 !== 0; )
        I = I + "=";
      return I;
    }
    function Z(I, v) {
      v = v || 1 / 0;
      for (var w, D = I.length, Q = null, ae = [], fe = 0; fe < D; ++fe) {
        if (w = I.charCodeAt(fe), w > 55295 && w < 57344) {
          if (!Q) {
            if (w > 56319) {
              (v -= 3) > -1 && ae.push(239, 191, 189);
              continue;
            } else if (fe + 1 === D) {
              (v -= 3) > -1 && ae.push(239, 191, 189);
              continue;
            }
            Q = w;
            continue;
          }
          if (w < 56320) {
            (v -= 3) > -1 && ae.push(239, 191, 189), Q = w;
            continue;
          }
          w = (Q - 55296 << 10 | w - 56320) + 65536;
        } else
          Q && (v -= 3) > -1 && ae.push(239, 191, 189);
        if (Q = null, w < 128) {
          if ((v -= 1) < 0)
            break;
          ae.push(w);
        } else if (w < 2048) {
          if ((v -= 2) < 0)
            break;
          ae.push(
            w >> 6 | 192,
            w & 63 | 128
          );
        } else if (w < 65536) {
          if ((v -= 3) < 0)
            break;
          ae.push(
            w >> 12 | 224,
            w >> 6 & 63 | 128,
            w & 63 | 128
          );
        } else if (w < 1114112) {
          if ((v -= 4) < 0)
            break;
          ae.push(
            w >> 18 | 240,
            w >> 12 & 63 | 128,
            w >> 6 & 63 | 128,
            w & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return ae;
    }
    function oe(I) {
      for (var v = [], w = 0; w < I.length; ++w)
        v.push(I.charCodeAt(w) & 255);
      return v;
    }
    function ue(I, v) {
      for (var w, D, Q, ae = [], fe = 0; fe < I.length && !((v -= 2) < 0); ++fe)
        w = I.charCodeAt(fe), D = w >> 8, Q = w % 256, ae.push(Q), ae.push(D);
      return ae;
    }
    function R(I) {
      return e.toByteArray(H(I));
    }
    function k(I, v, w, D) {
      for (var Q = 0; Q < D && !(Q + w >= v.length || Q >= I.length); ++Q)
        v[Q + w] = I[Q];
      return Q;
    }
    function ee(I, v) {
      return I instanceof v || I != null && I.constructor != null && I.constructor.name != null && I.constructor.name === v.name;
    }
    function re(I) {
      return I !== I;
    }
    var ye = function() {
      for (var I = "0123456789abcdef", v = new Array(256), w = 0; w < 16; ++w)
        for (var D = w * 16, Q = 0; Q < 16; ++Q)
          v[D + Q] = I[w] + I[Q];
      return v;
    }();
  })(Mo);
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  (function(t10, e) {
    var r = Mo, n = r.Buffer;
    function i(s, a) {
      for (var l in s)
        a[l] = s[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t10.exports = r : (i(r, e), e.Buffer = o);
    function o(s, a, l) {
      return n(s, a, l);
    }
    o.prototype = Object.create(n.prototype), i(n, o), o.from = function(s, a, l) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, a, l);
    }, o.alloc = function(s, a, l) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var c = n(s);
      return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
    }, o.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }, o.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  })(my, ho);
  var ul = 65536, Ey = 4294967295;
  function ky() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Cy = ho.Buffer, qs = globalThis.crypto || globalThis.msCrypto;
  qs && qs.getRandomValues ? Mf.exports = Ty : Mf.exports = ky;
  function Ty(t10, e) {
    if (t10 > Ey)
      throw new RangeError("requested too many random bytes");
    var r = Cy.allocUnsafe(t10);
    if (t10 > 0)
      if (t10 > ul)
        for (var n = 0; n < t10; n += ul)
          qs.getRandomValues(r.slice(n, n + ul));
      else
        qs.getRandomValues(r);
    return typeof e == "function" ? process.nextTick(function() {
      e(null, r);
    }) : r;
  }
  var Hs = {}, Iy = {
    get exports() {
      return Hs;
    },
    set exports(t10) {
      Hs = t10;
    }
  }, w0 = ui.EventEmitter;
  const Oy = {}, Py = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Oy
  }, Symbol.toStringTag, { value: "Module" })), x0 = /* @__PURE__ */ f0(Py);
  var fl, Nf;
  function Ry() {
    if (Nf)
      return fl;
    Nf = 1;
    function t10(d, h) {
      var g = Object.keys(d);
      if (Object.getOwnPropertySymbols) {
        var p = Object.getOwnPropertySymbols(d);
        h && (p = p.filter(function(y) {
          return Object.getOwnPropertyDescriptor(d, y).enumerable;
        })), g.push.apply(g, p);
      }
      return g;
    }
    function e(d) {
      for (var h = 1; h < arguments.length; h++) {
        var g = arguments[h] != null ? arguments[h] : {};
        h % 2 ? t10(Object(g), true).forEach(function(p) {
          r(d, p, g[p]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(g)) : t10(Object(g)).forEach(function(p) {
          Object.defineProperty(d, p, Object.getOwnPropertyDescriptor(g, p));
        });
      }
      return d;
    }
    function r(d, h, g) {
      return h in d ? Object.defineProperty(d, h, { value: g, enumerable: true, configurable: true, writable: true }) : d[h] = g, d;
    }
    function n(d, h) {
      if (!(d instanceof h))
        throw new TypeError("Cannot call a class as a function");
    }
    function i(d, h) {
      for (var g = 0; g < h.length; g++) {
        var p = h[g];
        p.enumerable = p.enumerable || false, p.configurable = true, "value" in p && (p.writable = true), Object.defineProperty(d, p.key, p);
      }
    }
    function o(d, h, g) {
      return h && i(d.prototype, h), d;
    }
    var s = Mo, a = s.Buffer, l = x0, c = l.inspect, u = c && c.custom || "inspect";
    function f(d, h, g) {
      a.prototype.copy.call(d, h, g);
    }
    return fl = /* @__PURE__ */ function() {
      function d() {
        n(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return o(d, [{
        key: "push",
        value: function(g) {
          var p = {
            data: g,
            next: null
          };
          this.length > 0 ? this.tail.next = p : this.head = p, this.tail = p, ++this.length;
        }
      }, {
        key: "unshift",
        value: function(g) {
          var p = {
            data: g,
            next: this.head
          };
          this.length === 0 && (this.tail = p), this.head = p, ++this.length;
        }
      }, {
        key: "shift",
        value: function() {
          if (this.length !== 0) {
            var g = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, g;
          }
        }
      }, {
        key: "clear",
        value: function() {
          this.head = this.tail = null, this.length = 0;
        }
      }, {
        key: "join",
        value: function(g) {
          if (this.length === 0)
            return "";
          for (var p = this.head, y = "" + p.data; p = p.next; )
            y += g + p.data;
          return y;
        }
      }, {
        key: "concat",
        value: function(g) {
          if (this.length === 0)
            return a.alloc(0);
          for (var p = a.allocUnsafe(g >>> 0), y = this.head, b = 0; y; )
            f(y.data, p, b), b += y.data.length, y = y.next;
          return p;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function(g, p) {
          var y;
          return g < this.head.data.length ? (y = this.head.data.slice(0, g), this.head.data = this.head.data.slice(g)) : g === this.head.data.length ? y = this.shift() : y = p ? this._getString(g) : this._getBuffer(g), y;
        }
      }, {
        key: "first",
        value: function() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function(g) {
          var p = this.head, y = 1, b = p.data;
          for (g -= b.length; p = p.next; ) {
            var x = p.data, S = g > x.length ? x.length : g;
            if (S === x.length ? b += x : b += x.slice(0, g), g -= S, g === 0) {
              S === x.length ? (++y, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = x.slice(S));
              break;
            }
            ++y;
          }
          return this.length -= y, b;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function(g) {
          var p = a.allocUnsafe(g), y = this.head, b = 1;
          for (y.data.copy(p), g -= y.data.length; y = y.next; ) {
            var x = y.data, S = g > x.length ? x.length : g;
            if (x.copy(p, p.length - g, 0, S), g -= S, g === 0) {
              S === x.length ? (++b, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = x.slice(S));
              break;
            }
            ++b;
          }
          return this.length -= b, p;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: u,
        value: function(g, p) {
          return c(this, e({}, p, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]), d;
    }(), fl;
  }
  function Dy(t10, e) {
    var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
    return n || i ? (e ? e(t10) : t10 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(hc, this, t10)) : process.nextTick(hc, this, t10)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t10 || null, function(o) {
      !e && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(ks, r) : (r._writableState.errorEmitted = true, process.nextTick(Lf, r, o)) : process.nextTick(Lf, r, o) : e ? (process.nextTick(ks, r), e(o)) : process.nextTick(ks, r);
    }), this);
  }
  function Lf(t10, e) {
    hc(t10, e), ks(t10);
  }
  function ks(t10) {
    t10._writableState && !t10._writableState.emitClose || t10._readableState && !t10._readableState.emitClose || t10.emit("close");
  }
  function My() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function hc(t10, e) {
    t10.emit("error", e);
  }
  function Ny(t10, e) {
    var r = t10._readableState, n = t10._writableState;
    r && r.autoDestroy || n && n.autoDestroy ? t10.destroy(e) : t10.emit("error", e);
  }
  var _0 = {
    destroy: Dy,
    undestroy: My,
    errorOrDestroy: Ny
  }, zn = {};
  function Ly(t10, e) {
    t10.prototype = Object.create(e.prototype), t10.prototype.constructor = t10, t10.__proto__ = e;
  }
  var S0 = {};
  function Zt(t10, e, r) {
    r || (r = Error);
    function n(o, s, a) {
      return typeof e == "string" ? e : e(o, s, a);
    }
    var i = /* @__PURE__ */ function(o) {
      Ly(s, o);
      function s(a, l, c) {
        return o.call(this, n(a, l, c)) || this;
      }
      return s;
    }(r);
    i.prototype.name = r.name, i.prototype.code = t10, S0[t10] = i;
  }
  function Bf(t10, e) {
    if (Array.isArray(t10)) {
      var r = t10.length;
      return t10 = t10.map(function(n) {
        return String(n);
      }), r > 2 ? "one of ".concat(e, " ").concat(t10.slice(0, r - 1).join(", "), ", or ") + t10[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t10[0], " or ").concat(t10[1]) : "of ".concat(e, " ").concat(t10[0]);
    } else
      return "of ".concat(e, " ").concat(String(t10));
  }
  function By(t10, e, r) {
    return t10.substr(0, e.length) === e;
  }
  function Fy(t10, e, r) {
    return (r === void 0 || r > t10.length) && (r = t10.length), t10.substring(r - e.length, r) === e;
  }
  function jy(t10, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t10.length ? false : t10.indexOf(e, r) !== -1;
  }
  Zt("ERR_INVALID_OPT_VALUE", function(t10, e) {
    return 'The value "' + e + '" is invalid for option "' + t10 + '"';
  }, TypeError);
  Zt("ERR_INVALID_ARG_TYPE", function(t10, e, r) {
    var n;
    typeof e == "string" && By(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
    var i;
    if (Fy(t10, " argument"))
      i = "The ".concat(t10, " ").concat(n, " ").concat(Bf(e, "type"));
    else {
      var o = jy(t10, ".") ? "property" : "argument";
      i = 'The "'.concat(t10, '" ').concat(o, " ").concat(n, " ").concat(Bf(e, "type"));
    }
    return i += ". Received type ".concat(typeof r), i;
  }, TypeError);
  Zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  Zt("ERR_METHOD_NOT_IMPLEMENTED", function(t10) {
    return "The " + t10 + " method is not implemented";
  });
  Zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  Zt("ERR_STREAM_DESTROYED", function(t10) {
    return "Cannot call " + t10 + " after a stream was destroyed";
  });
  Zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  Zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  Zt("ERR_STREAM_WRITE_AFTER_END", "write after end");
  Zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  Zt("ERR_UNKNOWN_ENCODING", function(t10) {
    return "Unknown encoding: " + t10;
  }, TypeError);
  Zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  zn.codes = S0;
  var Wy = zn.codes.ERR_INVALID_OPT_VALUE;
  function Uy(t10, e, r) {
    return t10.highWaterMark != null ? t10.highWaterMark : e ? t10[r] : null;
  }
  function zy(t10, e, r, n) {
    var i = Uy(e, n, r);
    if (i != null) {
      if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
        var o = n ? r : "highWaterMark";
        throw new Wy(o, i);
      }
      return Math.floor(i);
    }
    return t10.objectMode ? 16 : 16 * 1024;
  }
  var E0 = {
    getHighWaterMark: zy
  }, Rn = {}, Ff = {
    get exports() {
      return Rn;
    },
    set exports(t10) {
      Rn = t10;
    }
  };
  typeof Object.create == "function" ? Ff.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
      constructor: {
        value: e,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : Ff.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  };
  var Vy = qy;
  function qy(t10, e) {
    if (dl("noDeprecation"))
      return t10;
    var r = false;
    function n() {
      if (!r) {
        if (dl("throwDeprecation"))
          throw new Error(e);
        dl("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t10.apply(this, arguments);
    }
    return n;
  }
  function dl(t10) {
    try {
      if (!globalThis.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = globalThis.localStorage[t10];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
  var hl, jf;
  function k0() {
    if (jf)
      return hl;
    jf = 1, hl = V;
    function t10(j) {
      var H = this;
      this.next = null, this.entry = null, this.finish = function() {
        pe(H, j);
      };
    }
    var e;
    V.WritableState = L;
    var r = {
      deprecate: Vy
    }, n = w0, i = Mo.Buffer, o = globalThis.Uint8Array || function() {
    };
    function s(j) {
      return i.from(j);
    }
    function a(j) {
      return i.isBuffer(j) || j instanceof o;
    }
    var l = _0, c = E0, u = c.getHighWaterMark, f = zn.codes, d = f.ERR_INVALID_ARG_TYPE, h = f.ERR_METHOD_NOT_IMPLEMENTED, g = f.ERR_MULTIPLE_CALLBACK, p = f.ERR_STREAM_CANNOT_PIPE, y = f.ERR_STREAM_DESTROYED, b = f.ERR_STREAM_NULL_VALUES, x = f.ERR_STREAM_WRITE_AFTER_END, S = f.ERR_UNKNOWN_ENCODING, C = l.errorOrDestroy;
    Rn(V, n);
    function _() {
    }
    function L(j, H, Z) {
      e = e || fi(), j = j || {}, typeof Z != "boolean" && (Z = H instanceof e), this.objectMode = !!j.objectMode, Z && (this.objectMode = this.objectMode || !!j.writableObjectMode), this.highWaterMark = u(this, j, "writableHighWaterMark", Z), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var oe = j.decodeStrings === false;
      this.decodeStrings = !oe, this.defaultEncoding = j.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(ue) {
        O(H, ue);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = j.emitClose !== false, this.autoDestroy = !!j.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t10(this);
    }
    L.prototype.getBuffer = function() {
      for (var H = this.bufferedRequest, Z = []; H; )
        Z.push(H), H = H.next;
      return Z;
    }, function() {
      try {
        Object.defineProperty(L.prototype, "buffer", {
          get: r.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch {
      }
    }();
    var F;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (F = Function.prototype[Symbol.hasInstance], Object.defineProperty(V, Symbol.hasInstance, {
      value: function(H) {
        return F.call(this, H) ? true : this !== V ? false : H && H._writableState instanceof L;
      }
    })) : F = function(H) {
      return H instanceof this;
    };
    function V(j) {
      e = e || fi();
      var H = this instanceof e;
      if (!H && !F.call(V, this))
        return new V(j);
      this._writableState = new L(j, this, H), this.writable = true, j && (typeof j.write == "function" && (this._write = j.write), typeof j.writev == "function" && (this._writev = j.writev), typeof j.destroy == "function" && (this._destroy = j.destroy), typeof j.final == "function" && (this._final = j.final)), n.call(this);
    }
    V.prototype.pipe = function() {
      C(this, new p());
    };
    function W(j, H) {
      var Z = new x();
      C(j, Z), process.nextTick(H, Z);
    }
    function X(j, H, Z, oe) {
      var ue;
      return Z === null ? ue = new b() : typeof Z != "string" && !H.objectMode && (ue = new d("chunk", ["string", "Buffer"], Z)), ue ? (C(j, ue), process.nextTick(oe, ue), false) : true;
    }
    V.prototype.write = function(j, H, Z) {
      var oe = this._writableState, ue = false, R = !oe.objectMode && a(j);
      return R && !i.isBuffer(j) && (j = s(j)), typeof H == "function" && (Z = H, H = null), R ? H = "buffer" : H || (H = oe.defaultEncoding), typeof Z != "function" && (Z = _), oe.ending ? W(this, Z) : (R || X(this, oe, j, Z)) && (oe.pendingcb++, ue = ie(this, oe, R, j, H, Z)), ue;
    }, V.prototype.cork = function() {
      this._writableState.corked++;
    }, V.prototype.uncork = function() {
      var j = this._writableState;
      j.corked && (j.corked--, !j.writing && !j.corked && !j.bufferProcessing && j.bufferedRequest && Y(this, j));
    }, V.prototype.setDefaultEncoding = function(H) {
      if (typeof H == "string" && (H = H.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((H + "").toLowerCase()) > -1))
        throw new S(H);
      return this._writableState.defaultEncoding = H, this;
    }, Object.defineProperty(V.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function G(j, H, Z) {
      return !j.objectMode && j.decodeStrings !== false && typeof H == "string" && (H = i.from(H, Z)), H;
    }
    Object.defineProperty(V.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function ie(j, H, Z, oe, ue, R) {
      if (!Z) {
        var k = G(H, oe, ue);
        oe !== k && (Z = true, ue = "buffer", oe = k);
      }
      var ee = H.objectMode ? 1 : oe.length;
      H.length += ee;
      var re = H.length < H.highWaterMark;
      if (re || (H.needDrain = true), H.writing || H.corked) {
        var ye = H.lastBufferedRequest;
        H.lastBufferedRequest = {
          chunk: oe,
          encoding: ue,
          isBuf: Z,
          callback: R,
          next: null
        }, ye ? ye.next = H.lastBufferedRequest : H.bufferedRequest = H.lastBufferedRequest, H.bufferedRequestCount += 1;
      } else
        P10(j, H, false, ee, oe, ue, R);
      return re;
    }
    function P10(j, H, Z, oe, ue, R, k) {
      H.writelen = oe, H.writecb = k, H.writing = true, H.sync = true, H.destroyed ? H.onwrite(new y("write")) : Z ? j._writev(ue, H.onwrite) : j._write(ue, R, H.onwrite), H.sync = false;
    }
    function z10(j, H, Z, oe, ue) {
      --H.pendingcb, Z ? (process.nextTick(ue, oe), process.nextTick(he, j, H), j._writableState.errorEmitted = true, C(j, oe)) : (ue(oe), j._writableState.errorEmitted = true, C(j, oe), he(j, H));
    }
    function B(j) {
      j.writing = false, j.writecb = null, j.length -= j.writelen, j.writelen = 0;
    }
    function O(j, H) {
      var Z = j._writableState, oe = Z.sync, ue = Z.writecb;
      if (typeof ue != "function")
        throw new g();
      if (B(Z), H)
        z10(j, Z, oe, H, ue);
      else {
        var R = K(Z) || j.destroyed;
        !R && !Z.corked && !Z.bufferProcessing && Z.bufferedRequest && Y(j, Z), oe ? process.nextTick(q, j, Z, R, ue) : q(j, Z, R, ue);
      }
    }
    function q(j, H, Z, oe) {
      Z || te(j, H), H.pendingcb--, oe(), he(j, H);
    }
    function te(j, H) {
      H.length === 0 && H.needDrain && (H.needDrain = false, j.emit("drain"));
    }
    function Y(j, H) {
      H.bufferProcessing = true;
      var Z = H.bufferedRequest;
      if (j._writev && Z && Z.next) {
        var oe = H.bufferedRequestCount, ue = new Array(oe), R = H.corkedRequestsFree;
        R.entry = Z;
        for (var k = 0, ee = true; Z; )
          ue[k] = Z, Z.isBuf || (ee = false), Z = Z.next, k += 1;
        ue.allBuffers = ee, P10(j, H, true, H.length, ue, "", R.finish), H.pendingcb++, H.lastBufferedRequest = null, R.next ? (H.corkedRequestsFree = R.next, R.next = null) : H.corkedRequestsFree = new t10(H), H.bufferedRequestCount = 0;
      } else {
        for (; Z; ) {
          var re = Z.chunk, ye = Z.encoding, I = Z.callback, v = H.objectMode ? 1 : re.length;
          if (P10(j, H, false, v, re, ye, I), Z = Z.next, H.bufferedRequestCount--, H.writing)
            break;
        }
        Z === null && (H.lastBufferedRequest = null);
      }
      H.bufferedRequest = Z, H.bufferProcessing = false;
    }
    V.prototype._write = function(j, H, Z) {
      Z(new h("_write()"));
    }, V.prototype._writev = null, V.prototype.end = function(j, H, Z) {
      var oe = this._writableState;
      return typeof j == "function" ? (Z = j, j = null, H = null) : typeof H == "function" && (Z = H, H = null), j != null && this.write(j, H), oe.corked && (oe.corked = 1, this.uncork()), oe.ending || de(this, oe, Z), this;
    }, Object.defineProperty(V.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.length;
      }
    });
    function K(j) {
      return j.ending && j.length === 0 && j.bufferedRequest === null && !j.finished && !j.writing;
    }
    function $(j, H) {
      j._final(function(Z) {
        H.pendingcb--, Z && C(j, Z), H.prefinished = true, j.emit("prefinish"), he(j, H);
      });
    }
    function se(j, H) {
      !H.prefinished && !H.finalCalled && (typeof j._final == "function" && !H.destroyed ? (H.pendingcb++, H.finalCalled = true, process.nextTick($, j, H)) : (H.prefinished = true, j.emit("prefinish")));
    }
    function he(j, H) {
      var Z = K(H);
      if (Z && (se(j, H), H.pendingcb === 0 && (H.finished = true, j.emit("finish"), H.autoDestroy))) {
        var oe = j._readableState;
        (!oe || oe.autoDestroy && oe.endEmitted) && j.destroy();
      }
      return Z;
    }
    function de(j, H, Z) {
      H.ending = true, he(j, H), Z && (H.finished ? process.nextTick(Z) : j.once("finish", Z)), H.ended = true, j.writable = false;
    }
    function pe(j, H, Z) {
      var oe = j.entry;
      for (j.entry = null; oe; ) {
        var ue = oe.callback;
        H.pendingcb--, ue(Z), oe = oe.next;
      }
      H.corkedRequestsFree.next = j;
    }
    return Object.defineProperty(V.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState === void 0 ? false : this._writableState.destroyed;
      },
      set: function(H) {
        this._writableState && (this._writableState.destroyed = H);
      }
    }), V.prototype.destroy = l.destroy, V.prototype._undestroy = l.undestroy, V.prototype._destroy = function(j, H) {
      H(j);
    }, hl;
  }
  var pl, Wf;
  function fi() {
    if (Wf)
      return pl;
    Wf = 1;
    var t10 = Object.keys || function(c) {
      var u = [];
      for (var f in c)
        u.push(f);
      return u;
    };
    pl = s;
    var e = T0(), r = k0();
    Rn(s, e);
    for (var n = t10(r.prototype), i = 0; i < n.length; i++) {
      var o = n[i];
      s.prototype[o] || (s.prototype[o] = r.prototype[o]);
    }
    function s(c) {
      if (!(this instanceof s))
        return new s(c);
      e.call(this, c), r.call(this, c), this.allowHalfOpen = true, c && (c.readable === false && (this.readable = false), c.writable === false && (this.writable = false), c.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", a)));
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    }), Object.defineProperty(s.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    }), Object.defineProperty(s.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.length;
      }
    });
    function a() {
      this._writableState.ended || process.nextTick(l, this);
    }
    function l(c) {
      c.end();
    }
    return Object.defineProperty(s.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(u) {
        this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = u, this._writableState.destroyed = u);
      }
    }), pl;
  }
  var gl = {}, Uf;
  function zf() {
    if (Uf)
      return gl;
    Uf = 1;
    var t10 = ho.Buffer, e = t10.isEncoding || function(b) {
      switch (b = "" + b, b && b.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function r(b) {
      if (!b)
        return "utf8";
      for (var x; ; )
        switch (b) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return b;
          default:
            if (x)
              return;
            b = ("" + b).toLowerCase(), x = true;
        }
    }
    function n(b) {
      var x = r(b);
      if (typeof x != "string" && (t10.isEncoding === e || !e(b)))
        throw new Error("Unknown encoding: " + b);
      return x || b;
    }
    gl.StringDecoder = i;
    function i(b) {
      this.encoding = n(b);
      var x;
      switch (this.encoding) {
        case "utf16le":
          this.text = f, this.end = d, x = 4;
          break;
        case "utf8":
          this.fillLast = l, x = 4;
          break;
        case "base64":
          this.text = h, this.end = g, x = 3;
          break;
        default:
          this.write = p, this.end = y;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t10.allocUnsafe(x);
    }
    i.prototype.write = function(b) {
      if (b.length === 0)
        return "";
      var x, S;
      if (this.lastNeed) {
        if (x = this.fillLast(b), x === void 0)
          return "";
        S = this.lastNeed, this.lastNeed = 0;
      } else
        S = 0;
      return S < b.length ? x ? x + this.text(b, S) : this.text(b, S) : x || "";
    }, i.prototype.end = u, i.prototype.text = c, i.prototype.fillLast = function(b) {
      if (this.lastNeed <= b.length)
        return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
    };
    function o(b) {
      return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
    }
    function s(b, x, S) {
      var C = x.length - 1;
      if (C < S)
        return 0;
      var _ = o(x[C]);
      return _ >= 0 ? (_ > 0 && (b.lastNeed = _ - 1), _) : --C < S || _ === -2 ? 0 : (_ = o(x[C]), _ >= 0 ? (_ > 0 && (b.lastNeed = _ - 2), _) : --C < S || _ === -2 ? 0 : (_ = o(x[C]), _ >= 0 ? (_ > 0 && (_ === 2 ? _ = 0 : b.lastNeed = _ - 3), _) : 0));
    }
    function a(b, x, S) {
      if ((x[0] & 192) !== 128)
        return b.lastNeed = 0, "";
      if (b.lastNeed > 1 && x.length > 1) {
        if ((x[1] & 192) !== 128)
          return b.lastNeed = 1, "";
        if (b.lastNeed > 2 && x.length > 2 && (x[2] & 192) !== 128)
          return b.lastNeed = 2, "";
      }
    }
    function l(b) {
      var x = this.lastTotal - this.lastNeed, S = a(this, b);
      if (S !== void 0)
        return S;
      if (this.lastNeed <= b.length)
        return b.copy(this.lastChar, x, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      b.copy(this.lastChar, x, 0, b.length), this.lastNeed -= b.length;
    }
    function c(b, x) {
      var S = s(this, b, x);
      if (!this.lastNeed)
        return b.toString("utf8", x);
      this.lastTotal = S;
      var C = b.length - (S - this.lastNeed);
      return b.copy(this.lastChar, 0, C), b.toString("utf8", x, C);
    }
    function u(b) {
      var x = b && b.length ? this.write(b) : "";
      return this.lastNeed ? x + "" : x;
    }
    function f(b, x) {
      if ((b.length - x) % 2 === 0) {
        var S = b.toString("utf16le", x);
        if (S) {
          var C = S.charCodeAt(S.length - 1);
          if (C >= 55296 && C <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], S.slice(0, -1);
        }
        return S;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", x, b.length - 1);
    }
    function d(b) {
      var x = b && b.length ? this.write(b) : "";
      if (this.lastNeed) {
        var S = this.lastTotal - this.lastNeed;
        return x + this.lastChar.toString("utf16le", 0, S);
      }
      return x;
    }
    function h(b, x) {
      var S = (b.length - x) % 3;
      return S === 0 ? b.toString("base64", x) : (this.lastNeed = 3 - S, this.lastTotal = 3, S === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", x, b.length - S));
    }
    function g(b) {
      var x = b && b.length ? this.write(b) : "";
      return this.lastNeed ? x + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : x;
    }
    function p(b) {
      return b.toString(this.encoding);
    }
    function y(b) {
      return b && b.length ? this.write(b) : "";
    }
    return gl;
  }
  var Vf = zn.codes.ERR_STREAM_PREMATURE_CLOSE;
  function Hy(t10) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
          n[i] = arguments[i];
        t10.apply(this, n);
      }
    };
  }
  function Ky() {
  }
  function Yy(t10) {
    return t10.setHeader && typeof t10.abort == "function";
  }
  function C0(t10, e, r) {
    if (typeof e == "function")
      return C0(t10, null, e);
    e || (e = {}), r = Hy(r || Ky);
    var n = e.readable || e.readable !== false && t10.readable, i = e.writable || e.writable !== false && t10.writable, o = function() {
      t10.writable || a();
    }, s = t10._writableState && t10._writableState.finished, a = function() {
      i = false, s = true, n || r.call(t10);
    }, l = t10._readableState && t10._readableState.endEmitted, c = function() {
      n = false, l = true, i || r.call(t10);
    }, u = function(g) {
      r.call(t10, g);
    }, f = function() {
      var g;
      if (n && !l)
        return (!t10._readableState || !t10._readableState.ended) && (g = new Vf()), r.call(t10, g);
      if (i && !s)
        return (!t10._writableState || !t10._writableState.ended) && (g = new Vf()), r.call(t10, g);
    }, d = function() {
      t10.req.on("finish", a);
    };
    return Yy(t10) ? (t10.on("complete", a), t10.on("abort", f), t10.req ? d() : t10.on("request", d)) : i && !t10._writableState && (t10.on("end", o), t10.on("close", o)), t10.on("end", c), t10.on("finish", a), e.error !== false && t10.on("error", u), t10.on("close", f), function() {
      t10.removeListener("complete", a), t10.removeListener("abort", f), t10.removeListener("request", d), t10.req && t10.req.removeListener("finish", a), t10.removeListener("end", o), t10.removeListener("close", o), t10.removeListener("finish", a), t10.removeListener("end", c), t10.removeListener("error", u), t10.removeListener("close", f);
    };
  }
  var nu = C0, ml, qf;
  function Xy() {
    if (qf)
      return ml;
    qf = 1;
    var t10;
    function e(b, x, S) {
      return x in b ? Object.defineProperty(b, x, { value: S, enumerable: true, configurable: true, writable: true }) : b[x] = S, b;
    }
    var r = nu, n = Symbol("lastResolve"), i = Symbol("lastReject"), o = Symbol("error"), s = Symbol("ended"), a = Symbol("lastPromise"), l = Symbol("handlePromise"), c = Symbol("stream");
    function u(b, x) {
      return {
        value: b,
        done: x
      };
    }
    function f(b) {
      var x = b[n];
      if (x !== null) {
        var S = b[c].read();
        S !== null && (b[a] = null, b[n] = null, b[i] = null, x(u(S, false)));
      }
    }
    function d(b) {
      process.nextTick(f, b);
    }
    function h(b, x) {
      return function(S, C) {
        b.then(function() {
          if (x[s]) {
            S(u(void 0, true));
            return;
          }
          x[l](S, C);
        }, C);
      };
    }
    var g = Object.getPrototypeOf(function() {
    }), p = Object.setPrototypeOf((t10 = {
      get stream() {
        return this[c];
      },
      next: function() {
        var x = this, S = this[o];
        if (S !== null)
          return Promise.reject(S);
        if (this[s])
          return Promise.resolve(u(void 0, true));
        if (this[c].destroyed)
          return new Promise(function(F, V) {
            process.nextTick(function() {
              x[o] ? V(x[o]) : F(u(void 0, true));
            });
          });
        var C = this[a], _;
        if (C)
          _ = new Promise(h(C, this));
        else {
          var L = this[c].read();
          if (L !== null)
            return Promise.resolve(u(L, false));
          _ = new Promise(this[l]);
        }
        return this[a] = _, _;
      }
    }, e(t10, Symbol.asyncIterator, function() {
      return this;
    }), e(t10, "return", function() {
      var x = this;
      return new Promise(function(S, C) {
        x[c].destroy(null, function(_) {
          if (_) {
            C(_);
            return;
          }
          S(u(void 0, true));
        });
      });
    }), t10), g), y = function(x) {
      var S, C = Object.create(p, (S = {}, e(S, c, {
        value: x,
        writable: true
      }), e(S, n, {
        value: null,
        writable: true
      }), e(S, i, {
        value: null,
        writable: true
      }), e(S, o, {
        value: null,
        writable: true
      }), e(S, s, {
        value: x._readableState.endEmitted,
        writable: true
      }), e(S, l, {
        value: function(L, F) {
          var V = C[c].read();
          V ? (C[a] = null, C[n] = null, C[i] = null, L(u(V, false))) : (C[n] = L, C[i] = F);
        },
        writable: true
      }), S));
      return C[a] = null, r(x, function(_) {
        if (_ && _.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var L = C[i];
          L !== null && (C[a] = null, C[n] = null, C[i] = null, L(_)), C[o] = _;
          return;
        }
        var F = C[n];
        F !== null && (C[a] = null, C[n] = null, C[i] = null, F(u(void 0, true))), C[s] = true;
      }), x.on("readable", d.bind(null, C)), C;
    };
    return ml = y, ml;
  }
  var yl, Hf;
  function Jy() {
    return Hf || (Hf = 1, yl = function() {
      throw new Error("Readable.from is not available in the browser");
    }), yl;
  }
  var bl, Kf;
  function T0() {
    if (Kf)
      return bl;
    Kf = 1, bl = W;
    var t10;
    W.ReadableState = V, ui.EventEmitter;
    var e = function(k, ee) {
      return k.listeners(ee).length;
    }, r = w0, n = Mo.Buffer, i = globalThis.Uint8Array || function() {
    };
    function o(R) {
      return n.from(R);
    }
    function s(R) {
      return n.isBuffer(R) || R instanceof i;
    }
    var a = x0, l;
    a && a.debuglog ? l = a.debuglog("stream") : l = function() {
    };
    var c = Ry(), u = _0, f = E0, d = f.getHighWaterMark, h = zn.codes, g = h.ERR_INVALID_ARG_TYPE, p = h.ERR_STREAM_PUSH_AFTER_EOF, y = h.ERR_METHOD_NOT_IMPLEMENTED, b = h.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, x, S, C;
    Rn(W, r);
    var _ = u.errorOrDestroy, L = ["error", "close", "destroy", "pause", "resume"];
    function F(R, k, ee) {
      if (typeof R.prependListener == "function")
        return R.prependListener(k, ee);
      !R._events || !R._events[k] ? R.on(k, ee) : Array.isArray(R._events[k]) ? R._events[k].unshift(ee) : R._events[k] = [ee, R._events[k]];
    }
    function V(R, k, ee) {
      t10 = t10 || fi(), R = R || {}, typeof ee != "boolean" && (ee = k instanceof t10), this.objectMode = !!R.objectMode, ee && (this.objectMode = this.objectMode || !!R.readableObjectMode), this.highWaterMark = d(this, R, "readableHighWaterMark", ee), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = R.emitClose !== false, this.autoDestroy = !!R.autoDestroy, this.destroyed = false, this.defaultEncoding = R.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, R.encoding && (x || (x = zf().StringDecoder), this.decoder = new x(R.encoding), this.encoding = R.encoding);
    }
    function W(R) {
      if (t10 = t10 || fi(), !(this instanceof W))
        return new W(R);
      var k = this instanceof t10;
      this._readableState = new V(R, this, k), this.readable = true, R && (typeof R.read == "function" && (this._read = R.read), typeof R.destroy == "function" && (this._destroy = R.destroy)), r.call(this);
    }
    Object.defineProperty(W.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState === void 0 ? false : this._readableState.destroyed;
      },
      set: function(k) {
        this._readableState && (this._readableState.destroyed = k);
      }
    }), W.prototype.destroy = u.destroy, W.prototype._undestroy = u.undestroy, W.prototype._destroy = function(R, k) {
      k(R);
    }, W.prototype.push = function(R, k) {
      var ee = this._readableState, re;
      return ee.objectMode ? re = true : typeof R == "string" && (k = k || ee.defaultEncoding, k !== ee.encoding && (R = n.from(R, k), k = ""), re = true), X(this, R, k, false, re);
    }, W.prototype.unshift = function(R) {
      return X(this, R, null, true, false);
    };
    function X(R, k, ee, re, ye) {
      l("readableAddChunk", k);
      var I = R._readableState;
      if (k === null)
        I.reading = false, O(R, I);
      else {
        var v;
        if (ye || (v = ie(I, k)), v)
          _(R, v);
        else if (I.objectMode || k && k.length > 0)
          if (typeof k != "string" && !I.objectMode && Object.getPrototypeOf(k) !== n.prototype && (k = o(k)), re)
            I.endEmitted ? _(R, new b()) : G(R, I, k, true);
          else if (I.ended)
            _(R, new p());
          else {
            if (I.destroyed)
              return false;
            I.reading = false, I.decoder && !ee ? (k = I.decoder.write(k), I.objectMode || k.length !== 0 ? G(R, I, k, false) : Y(R, I)) : G(R, I, k, false);
          }
        else
          re || (I.reading = false, Y(R, I));
      }
      return !I.ended && (I.length < I.highWaterMark || I.length === 0);
    }
    function G(R, k, ee, re) {
      k.flowing && k.length === 0 && !k.sync ? (k.awaitDrain = 0, R.emit("data", ee)) : (k.length += k.objectMode ? 1 : ee.length, re ? k.buffer.unshift(ee) : k.buffer.push(ee), k.needReadable && q(R)), Y(R, k);
    }
    function ie(R, k) {
      var ee;
      return !s(k) && typeof k != "string" && k !== void 0 && !R.objectMode && (ee = new g("chunk", ["string", "Buffer", "Uint8Array"], k)), ee;
    }
    W.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    }, W.prototype.setEncoding = function(R) {
      x || (x = zf().StringDecoder);
      var k = new x(R);
      this._readableState.decoder = k, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var ee = this._readableState.buffer.head, re = ""; ee !== null; )
        re += k.write(ee.data), ee = ee.next;
      return this._readableState.buffer.clear(), re !== "" && this._readableState.buffer.push(re), this._readableState.length = re.length, this;
    };
    var P10 = 1073741824;
    function z10(R) {
      return R >= P10 ? R = P10 : (R--, R |= R >>> 1, R |= R >>> 2, R |= R >>> 4, R |= R >>> 8, R |= R >>> 16, R++), R;
    }
    function B(R, k) {
      return R <= 0 || k.length === 0 && k.ended ? 0 : k.objectMode ? 1 : R !== R ? k.flowing && k.length ? k.buffer.head.data.length : k.length : (R > k.highWaterMark && (k.highWaterMark = z10(R)), R <= k.length ? R : k.ended ? k.length : (k.needReadable = true, 0));
    }
    W.prototype.read = function(R) {
      l("read", R), R = parseInt(R, 10);
      var k = this._readableState, ee = R;
      if (R !== 0 && (k.emittedReadable = false), R === 0 && k.needReadable && ((k.highWaterMark !== 0 ? k.length >= k.highWaterMark : k.length > 0) || k.ended))
        return l("read: emitReadable", k.length, k.ended), k.length === 0 && k.ended ? Z(this) : q(this), null;
      if (R = B(R, k), R === 0 && k.ended)
        return k.length === 0 && Z(this), null;
      var re = k.needReadable;
      l("need readable", re), (k.length === 0 || k.length - R < k.highWaterMark) && (re = true, l("length less than watermark", re)), k.ended || k.reading ? (re = false, l("reading or ended", re)) : re && (l("do read"), k.reading = true, k.sync = true, k.length === 0 && (k.needReadable = true), this._read(k.highWaterMark), k.sync = false, k.reading || (R = B(ee, k)));
      var ye;
      return R > 0 ? ye = H(R, k) : ye = null, ye === null ? (k.needReadable = k.length <= k.highWaterMark, R = 0) : (k.length -= R, k.awaitDrain = 0), k.length === 0 && (k.ended || (k.needReadable = true), ee !== R && k.ended && Z(this)), ye !== null && this.emit("data", ye), ye;
    };
    function O(R, k) {
      if (l("onEofChunk"), !k.ended) {
        if (k.decoder) {
          var ee = k.decoder.end();
          ee && ee.length && (k.buffer.push(ee), k.length += k.objectMode ? 1 : ee.length);
        }
        k.ended = true, k.sync ? q(R) : (k.needReadable = false, k.emittedReadable || (k.emittedReadable = true, te(R)));
      }
    }
    function q(R) {
      var k = R._readableState;
      l("emitReadable", k.needReadable, k.emittedReadable), k.needReadable = false, k.emittedReadable || (l("emitReadable", k.flowing), k.emittedReadable = true, process.nextTick(te, R));
    }
    function te(R) {
      var k = R._readableState;
      l("emitReadable_", k.destroyed, k.length, k.ended), !k.destroyed && (k.length || k.ended) && (R.emit("readable"), k.emittedReadable = false), k.needReadable = !k.flowing && !k.ended && k.length <= k.highWaterMark, j(R);
    }
    function Y(R, k) {
      k.readingMore || (k.readingMore = true, process.nextTick(K, R, k));
    }
    function K(R, k) {
      for (; !k.reading && !k.ended && (k.length < k.highWaterMark || k.flowing && k.length === 0); ) {
        var ee = k.length;
        if (l("maybeReadMore read 0"), R.read(0), ee === k.length)
          break;
      }
      k.readingMore = false;
    }
    W.prototype._read = function(R) {
      _(this, new y("_read()"));
    }, W.prototype.pipe = function(R, k) {
      var ee = this, re = this._readableState;
      switch (re.pipesCount) {
        case 0:
          re.pipes = R;
          break;
        case 1:
          re.pipes = [re.pipes, R];
          break;
        default:
          re.pipes.push(R);
          break;
      }
      re.pipesCount += 1, l("pipe count=%d opts=%j", re.pipesCount, k);
      var ye = (!k || k.end !== false) && R !== process.stdout && R !== process.stderr, I = ye ? w : Pe;
      re.endEmitted ? process.nextTick(I) : ee.once("end", I), R.on("unpipe", v);
      function v(E, m) {
        l("onunpipe"), E === ee && m && m.hasUnpiped === false && (m.hasUnpiped = true, ae());
      }
      function w() {
        l("onend"), R.end();
      }
      var D = $(ee);
      R.on("drain", D);
      var Q = false;
      function ae() {
        l("cleanup"), R.removeListener("close", ve), R.removeListener("finish", be), R.removeListener("drain", D), R.removeListener("error", Ae), R.removeListener("unpipe", v), ee.removeListener("end", w), ee.removeListener("end", Pe), ee.removeListener("data", fe), Q = true, re.awaitDrain && (!R._writableState || R._writableState.needDrain) && D();
      }
      ee.on("data", fe);
      function fe(E) {
        l("ondata");
        var m = R.write(E);
        l("dest.write", m), m === false && ((re.pipesCount === 1 && re.pipes === R || re.pipesCount > 1 && ue(re.pipes, R) !== -1) && !Q && (l("false write response, pause", re.awaitDrain), re.awaitDrain++), ee.pause());
      }
      function Ae(E) {
        l("onerror", E), Pe(), R.removeListener("error", Ae), e(R, "error") === 0 && _(R, E);
      }
      F(R, "error", Ae);
      function ve() {
        R.removeListener("finish", be), Pe();
      }
      R.once("close", ve);
      function be() {
        l("onfinish"), R.removeListener("close", ve), Pe();
      }
      R.once("finish", be);
      function Pe() {
        l("unpipe"), ee.unpipe(R);
      }
      return R.emit("pipe", ee), re.flowing || (l("pipe resume"), ee.resume()), R;
    };
    function $(R) {
      return function() {
        var ee = R._readableState;
        l("pipeOnDrain", ee.awaitDrain), ee.awaitDrain && ee.awaitDrain--, ee.awaitDrain === 0 && e(R, "data") && (ee.flowing = true, j(R));
      };
    }
    W.prototype.unpipe = function(R) {
      var k = this._readableState, ee = {
        hasUnpiped: false
      };
      if (k.pipesCount === 0)
        return this;
      if (k.pipesCount === 1)
        return R && R !== k.pipes ? this : (R || (R = k.pipes), k.pipes = null, k.pipesCount = 0, k.flowing = false, R && R.emit("unpipe", this, ee), this);
      if (!R) {
        var re = k.pipes, ye = k.pipesCount;
        k.pipes = null, k.pipesCount = 0, k.flowing = false;
        for (var I = 0; I < ye; I++)
          re[I].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var v = ue(k.pipes, R);
      return v === -1 ? this : (k.pipes.splice(v, 1), k.pipesCount -= 1, k.pipesCount === 1 && (k.pipes = k.pipes[0]), R.emit("unpipe", this, ee), this);
    }, W.prototype.on = function(R, k) {
      var ee = r.prototype.on.call(this, R, k), re = this._readableState;
      return R === "data" ? (re.readableListening = this.listenerCount("readable") > 0, re.flowing !== false && this.resume()) : R === "readable" && !re.endEmitted && !re.readableListening && (re.readableListening = re.needReadable = true, re.flowing = false, re.emittedReadable = false, l("on readable", re.length, re.reading), re.length ? q(this) : re.reading || process.nextTick(he, this)), ee;
    }, W.prototype.addListener = W.prototype.on, W.prototype.removeListener = function(R, k) {
      var ee = r.prototype.removeListener.call(this, R, k);
      return R === "readable" && process.nextTick(se, this), ee;
    }, W.prototype.removeAllListeners = function(R) {
      var k = r.prototype.removeAllListeners.apply(this, arguments);
      return (R === "readable" || R === void 0) && process.nextTick(se, this), k;
    };
    function se(R) {
      var k = R._readableState;
      k.readableListening = R.listenerCount("readable") > 0, k.resumeScheduled && !k.paused ? k.flowing = true : R.listenerCount("data") > 0 && R.resume();
    }
    function he(R) {
      l("readable nexttick read 0"), R.read(0);
    }
    W.prototype.resume = function() {
      var R = this._readableState;
      return R.flowing || (l("resume"), R.flowing = !R.readableListening, de(this, R)), R.paused = false, this;
    };
    function de(R, k) {
      k.resumeScheduled || (k.resumeScheduled = true, process.nextTick(pe, R, k));
    }
    function pe(R, k) {
      l("resume", k.reading), k.reading || R.read(0), k.resumeScheduled = false, R.emit("resume"), j(R), k.flowing && !k.reading && R.read(0);
    }
    W.prototype.pause = function() {
      return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (l("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function j(R) {
      var k = R._readableState;
      for (l("flow", k.flowing); k.flowing && R.read() !== null; )
        ;
    }
    W.prototype.wrap = function(R) {
      var k = this, ee = this._readableState, re = false;
      R.on("end", function() {
        if (l("wrapped end"), ee.decoder && !ee.ended) {
          var v = ee.decoder.end();
          v && v.length && k.push(v);
        }
        k.push(null);
      }), R.on("data", function(v) {
        if (l("wrapped data"), ee.decoder && (v = ee.decoder.write(v)), !(ee.objectMode && v == null) && !(!ee.objectMode && (!v || !v.length))) {
          var w = k.push(v);
          w || (re = true, R.pause());
        }
      });
      for (var ye in R)
        this[ye] === void 0 && typeof R[ye] == "function" && (this[ye] = /* @__PURE__ */ function(w) {
          return function() {
            return R[w].apply(R, arguments);
          };
        }(ye));
      for (var I = 0; I < L.length; I++)
        R.on(L[I], this.emit.bind(this, L[I]));
      return this._read = function(v) {
        l("wrapped _read", v), re && (re = false, R.resume());
      }, this;
    }, typeof Symbol == "function" && (W.prototype[Symbol.asyncIterator] = function() {
      return S === void 0 && (S = Xy()), S(this);
    }), Object.defineProperty(W.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    }), Object.defineProperty(W.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    }), Object.defineProperty(W.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(k) {
        this._readableState && (this._readableState.flowing = k);
      }
    }), W._fromList = H, Object.defineProperty(W.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.length;
      }
    });
    function H(R, k) {
      if (k.length === 0)
        return null;
      var ee;
      return k.objectMode ? ee = k.buffer.shift() : !R || R >= k.length ? (k.decoder ? ee = k.buffer.join("") : k.buffer.length === 1 ? ee = k.buffer.first() : ee = k.buffer.concat(k.length), k.buffer.clear()) : ee = k.buffer.consume(R, k.decoder), ee;
    }
    function Z(R) {
      var k = R._readableState;
      l("endReadable", k.endEmitted), k.endEmitted || (k.ended = true, process.nextTick(oe, k, R));
    }
    function oe(R, k) {
      if (l("endReadableNT", R.endEmitted, R.length), !R.endEmitted && R.length === 0 && (R.endEmitted = true, k.readable = false, k.emit("end"), R.autoDestroy)) {
        var ee = k._writableState;
        (!ee || ee.autoDestroy && ee.finished) && k.destroy();
      }
    }
    typeof Symbol == "function" && (W.from = function(R, k) {
      return C === void 0 && (C = Jy()), C(W, R, k);
    });
    function ue(R, k) {
      for (var ee = 0, re = R.length; ee < re; ee++)
        if (R[ee] === k)
          return ee;
      return -1;
    }
    return bl;
  }
  var I0 = Br, Sa = zn.codes, Qy = Sa.ERR_METHOD_NOT_IMPLEMENTED, Gy = Sa.ERR_MULTIPLE_CALLBACK, Zy = Sa.ERR_TRANSFORM_ALREADY_TRANSFORMING, $y = Sa.ERR_TRANSFORM_WITH_LENGTH_0, Ea = fi();
  Rn(Br, Ea);
  function eb(t10, e) {
    var r = this._transformState;
    r.transforming = false;
    var n = r.writecb;
    if (n === null)
      return this.emit("error", new Gy());
    r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t10);
    var i = this._readableState;
    i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
  function Br(t10) {
    if (!(this instanceof Br))
      return new Br(t10);
    Ea.call(this, t10), this._transformState = {
      afterTransform: eb.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = true, this._readableState.sync = false, t10 && (typeof t10.transform == "function" && (this._transform = t10.transform), typeof t10.flush == "function" && (this._flush = t10.flush)), this.on("prefinish", tb);
  }
  function tb() {
    var t10 = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Yf(t10, e, r);
    }) : Yf(this, null, null);
  }
  Br.prototype.push = function(t10, e) {
    return this._transformState.needTransform = false, Ea.prototype.push.call(this, t10, e);
  };
  Br.prototype._transform = function(t10, e, r) {
    r(new Qy("_transform()"));
  };
  Br.prototype._write = function(t10, e, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = t10, n.writeencoding = e, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
  };
  Br.prototype._read = function(t10) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  Br.prototype._destroy = function(t10, e) {
    Ea.prototype._destroy.call(this, t10, function(r) {
      e(r);
    });
  };
  function Yf(t10, e, r) {
    if (e)
      return t10.emit("error", e);
    if (r != null && t10.push(r), t10._writableState.length)
      throw new $y();
    if (t10._transformState.transforming)
      throw new Zy();
    return t10.push(null);
  }
  var rb = po, O0 = I0;
  Rn(po, O0);
  function po(t10) {
    if (!(this instanceof po))
      return new po(t10);
    O0.call(this, t10);
  }
  po.prototype._transform = function(t10, e, r) {
    r(null, t10);
  };
  var vl;
  function nb(t10) {
    var e = false;
    return function() {
      e || (e = true, t10.apply(void 0, arguments));
    };
  }
  var P0 = zn.codes, ib = P0.ERR_MISSING_ARGS, ob = P0.ERR_STREAM_DESTROYED;
  function Xf(t10) {
    if (t10)
      throw t10;
  }
  function sb(t10) {
    return t10.setHeader && typeof t10.abort == "function";
  }
  function ab(t10, e, r, n) {
    n = nb(n);
    var i = false;
    t10.on("close", function() {
      i = true;
    }), vl === void 0 && (vl = nu), vl(t10, {
      readable: e,
      writable: r
    }, function(s) {
      if (s)
        return n(s);
      i = true, n();
    });
    var o = false;
    return function(s) {
      if (!i && !o) {
        if (o = true, sb(t10))
          return t10.abort();
        if (typeof t10.destroy == "function")
          return t10.destroy();
        n(s || new ob("pipe"));
      }
    };
  }
  function Jf(t10) {
    t10();
  }
  function lb(t10, e) {
    return t10.pipe(e);
  }
  function cb(t10) {
    return !t10.length || typeof t10[t10.length - 1] != "function" ? Xf : t10.pop();
  }
  function ub() {
    for (var t10 = arguments.length, e = new Array(t10), r = 0; r < t10; r++)
      e[r] = arguments[r];
    var n = cb(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new ib("streams");
    var i, o = e.map(function(s, a) {
      var l = a < e.length - 1, c = a > 0;
      return ab(s, l, c, function(u) {
        i || (i = u), u && o.forEach(Jf), !l && (o.forEach(Jf), n(i));
      });
    });
    return e.reduce(lb);
  }
  var fb = ub;
  (function(t10, e) {
    e = t10.exports = T0(), e.Stream = e, e.Readable = e, e.Writable = k0(), e.Duplex = fi(), e.Transform = I0, e.PassThrough = rb, e.finished = nu, e.pipeline = fb;
  })(Iy, Hs);
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  let Qf;
  var db = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : globalThis) : (t10) => (Qf || (Qf = Promise.resolve())).then(t10).catch((e) => setTimeout(() => {
    throw e;
  }, 0));
  function Gf(t10, e) {
    for (const r in e)
      Object.defineProperty(t10, r, {
        value: e[r],
        enumerable: true,
        configurable: true
      });
    return t10;
  }
  function hb(t10, e, r) {
    if (!t10 || typeof t10 == "string")
      throw new TypeError("Please pass an Error to err-code");
    r || (r = {}), typeof e == "object" && (r = e, e = ""), e && (r.code = e);
    try {
      return Gf(t10, r);
    } catch {
      r.message = t10.message, r.stack = t10.stack;
      const i = function() {
      };
      return i.prototype = Object.create(Object.getPrototypeOf(t10)), Gf(new i(), r);
    }
  }
  var pb = hb, R0 = {};
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(t10) {
    const e = No, r = _a, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t10.Buffer = a, t10.SlowBuffer = x, t10.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t10.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function o() {
      try {
        const E = new Uint8Array(1), m = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(m, Uint8Array.prototype), Object.setPrototypeOf(E, m), E.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(a.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.byteOffset;
      }
    });
    function s(E) {
      if (E > i)
        throw new RangeError('The value "' + E + '" is invalid for option "size"');
      const m = new Uint8Array(E);
      return Object.setPrototypeOf(m, a.prototype), m;
    }
    function a(E, m, A) {
      if (typeof E == "number") {
        if (typeof m == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return f(E);
      }
      return l(E, m, A);
    }
    a.poolSize = 8192;
    function l(E, m, A) {
      if (typeof E == "string")
        return d(E, m);
      if (ArrayBuffer.isView(E))
        return g(E);
      if (E == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
        );
      if (fe(E, ArrayBuffer) || E && fe(E.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (fe(E, SharedArrayBuffer) || E && fe(E.buffer, SharedArrayBuffer)))
        return p(E, m, A);
      if (typeof E == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const M = E.valueOf && E.valueOf();
      if (M != null && M !== E)
        return a.from(M, m, A);
      const J = y(E);
      if (J)
        return J;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof E[Symbol.toPrimitive] == "function")
        return a.from(E[Symbol.toPrimitive]("string"), m, A);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
      );
    }
    a.from = function(E, m, A) {
      return l(E, m, A);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function c(E) {
      if (typeof E != "number")
        throw new TypeError('"size" argument must be of type number');
      if (E < 0)
        throw new RangeError('The value "' + E + '" is invalid for option "size"');
    }
    function u(E, m, A) {
      return c(E), E <= 0 ? s(E) : m !== void 0 ? typeof A == "string" ? s(E).fill(m, A) : s(E).fill(m) : s(E);
    }
    a.alloc = function(E, m, A) {
      return u(E, m, A);
    };
    function f(E) {
      return c(E), s(E < 0 ? 0 : b(E) | 0);
    }
    a.allocUnsafe = function(E) {
      return f(E);
    }, a.allocUnsafeSlow = function(E) {
      return f(E);
    };
    function d(E, m) {
      if ((typeof m != "string" || m === "") && (m = "utf8"), !a.isEncoding(m))
        throw new TypeError("Unknown encoding: " + m);
      const A = S(E, m) | 0;
      let M = s(A);
      const J = M.write(E, m);
      return J !== A && (M = M.slice(0, J)), M;
    }
    function h(E) {
      const m = E.length < 0 ? 0 : b(E.length) | 0, A = s(m);
      for (let M = 0; M < m; M += 1)
        A[M] = E[M] & 255;
      return A;
    }
    function g(E) {
      if (fe(E, Uint8Array)) {
        const m = new Uint8Array(E);
        return p(m.buffer, m.byteOffset, m.byteLength);
      }
      return h(E);
    }
    function p(E, m, A) {
      if (m < 0 || E.byteLength < m)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (E.byteLength < m + (A || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let M;
      return m === void 0 && A === void 0 ? M = new Uint8Array(E) : A === void 0 ? M = new Uint8Array(E, m) : M = new Uint8Array(E, m, A), Object.setPrototypeOf(M, a.prototype), M;
    }
    function y(E) {
      if (a.isBuffer(E)) {
        const m = b(E.length) | 0, A = s(m);
        return A.length === 0 || E.copy(A, 0, 0, m), A;
      }
      if (E.length !== void 0)
        return typeof E.length != "number" || Ae(E.length) ? s(0) : h(E);
      if (E.type === "Buffer" && Array.isArray(E.data))
        return h(E.data);
    }
    function b(E) {
      if (E >= i)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return E | 0;
    }
    function x(E) {
      return +E != E && (E = 0), a.alloc(+E);
    }
    a.isBuffer = function(m) {
      return m != null && m._isBuffer === true && m !== a.prototype;
    }, a.compare = function(m, A) {
      if (fe(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)), fe(A, Uint8Array) && (A = a.from(A, A.offset, A.byteLength)), !a.isBuffer(m) || !a.isBuffer(A))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (m === A)
        return 0;
      let M = m.length, J = A.length;
      for (let ne = 0, le = Math.min(M, J); ne < le; ++ne)
        if (m[ne] !== A[ne]) {
          M = m[ne], J = A[ne];
          break;
        }
      return M < J ? -1 : J < M ? 1 : 0;
    }, a.isEncoding = function(m) {
      switch (String(m).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, a.concat = function(m, A) {
      if (!Array.isArray(m))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (m.length === 0)
        return a.alloc(0);
      let M;
      if (A === void 0)
        for (A = 0, M = 0; M < m.length; ++M)
          A += m[M].length;
      const J = a.allocUnsafe(A);
      let ne = 0;
      for (M = 0; M < m.length; ++M) {
        let le = m[M];
        if (fe(le, Uint8Array))
          ne + le.length > J.length ? (a.isBuffer(le) || (le = a.from(le)), le.copy(J, ne)) : Uint8Array.prototype.set.call(
            J,
            le,
            ne
          );
        else if (a.isBuffer(le))
          le.copy(J, ne);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        ne += le.length;
      }
      return J;
    };
    function S(E, m) {
      if (a.isBuffer(E))
        return E.length;
      if (ArrayBuffer.isView(E) || fe(E, ArrayBuffer))
        return E.byteLength;
      if (typeof E != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof E
        );
      const A = E.length, M = arguments.length > 2 && arguments[2] === true;
      if (!M && A === 0)
        return 0;
      let J = false;
      for (; ; )
        switch (m) {
          case "ascii":
          case "latin1":
          case "binary":
            return A;
          case "utf8":
          case "utf-8":
            return v(E).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return A * 2;
          case "hex":
            return A >>> 1;
          case "base64":
            return Q(E).length;
          default:
            if (J)
              return M ? -1 : v(E).length;
            m = ("" + m).toLowerCase(), J = true;
        }
    }
    a.byteLength = S;
    function C(E, m, A) {
      let M = false;
      if ((m === void 0 || m < 0) && (m = 0), m > this.length || ((A === void 0 || A > this.length) && (A = this.length), A <= 0) || (A >>>= 0, m >>>= 0, A <= m))
        return "";
      for (E || (E = "utf8"); ; )
        switch (E) {
          case "hex":
            return Y(this, m, A);
          case "utf8":
          case "utf-8":
            return z10(this, m, A);
          case "ascii":
            return q(this, m, A);
          case "latin1":
          case "binary":
            return te(this, m, A);
          case "base64":
            return P10(this, m, A);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return K(this, m, A);
          default:
            if (M)
              throw new TypeError("Unknown encoding: " + E);
            E = (E + "").toLowerCase(), M = true;
        }
    }
    a.prototype._isBuffer = true;
    function _(E, m, A) {
      const M = E[m];
      E[m] = E[A], E[A] = M;
    }
    a.prototype.swap16 = function() {
      const m = this.length;
      if (m % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let A = 0; A < m; A += 2)
        _(this, A, A + 1);
      return this;
    }, a.prototype.swap32 = function() {
      const m = this.length;
      if (m % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let A = 0; A < m; A += 4)
        _(this, A, A + 3), _(this, A + 1, A + 2);
      return this;
    }, a.prototype.swap64 = function() {
      const m = this.length;
      if (m % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let A = 0; A < m; A += 8)
        _(this, A, A + 7), _(this, A + 1, A + 6), _(this, A + 2, A + 5), _(this, A + 3, A + 4);
      return this;
    }, a.prototype.toString = function() {
      const m = this.length;
      return m === 0 ? "" : arguments.length === 0 ? z10(this, 0, m) : C.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(m) {
      if (!a.isBuffer(m))
        throw new TypeError("Argument must be a Buffer");
      return this === m ? true : a.compare(this, m) === 0;
    }, a.prototype.inspect = function() {
      let m = "";
      const A = t10.INSPECT_MAX_BYTES;
      return m = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (m += " ... "), "<Buffer " + m + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(m, A, M, J, ne) {
      if (fe(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)), !a.isBuffer(m))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m
        );
      if (A === void 0 && (A = 0), M === void 0 && (M = m ? m.length : 0), J === void 0 && (J = 0), ne === void 0 && (ne = this.length), A < 0 || M > m.length || J < 0 || ne > this.length)
        throw new RangeError("out of range index");
      if (J >= ne && A >= M)
        return 0;
      if (J >= ne)
        return -1;
      if (A >= M)
        return 1;
      if (A >>>= 0, M >>>= 0, J >>>= 0, ne >>>= 0, this === m)
        return 0;
      let le = ne - J, _e = M - A;
      const Xe = Math.min(le, _e), Ke = this.slice(J, ne), Qe = m.slice(A, M);
      for (let ze = 0; ze < Xe; ++ze)
        if (Ke[ze] !== Qe[ze]) {
          le = Ke[ze], _e = Qe[ze];
          break;
        }
      return le < _e ? -1 : _e < le ? 1 : 0;
    };
    function L(E, m, A, M, J) {
      if (E.length === 0)
        return -1;
      if (typeof A == "string" ? (M = A, A = 0) : A > 2147483647 ? A = 2147483647 : A < -2147483648 && (A = -2147483648), A = +A, Ae(A) && (A = J ? 0 : E.length - 1), A < 0 && (A = E.length + A), A >= E.length) {
        if (J)
          return -1;
        A = E.length - 1;
      } else if (A < 0)
        if (J)
          A = 0;
        else
          return -1;
      if (typeof m == "string" && (m = a.from(m, M)), a.isBuffer(m))
        return m.length === 0 ? -1 : F(E, m, A, M, J);
      if (typeof m == "number")
        return m = m & 255, typeof Uint8Array.prototype.indexOf == "function" ? J ? Uint8Array.prototype.indexOf.call(E, m, A) : Uint8Array.prototype.lastIndexOf.call(E, m, A) : F(E, [m], A, M, J);
      throw new TypeError("val must be string, number or Buffer");
    }
    function F(E, m, A, M, J) {
      let ne = 1, le = E.length, _e = m.length;
      if (M !== void 0 && (M = String(M).toLowerCase(), M === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
        if (E.length < 2 || m.length < 2)
          return -1;
        ne = 2, le /= 2, _e /= 2, A /= 2;
      }
      function Xe(Qe, ze) {
        return ne === 1 ? Qe[ze] : Qe.readUInt16BE(ze * ne);
      }
      let Ke;
      if (J) {
        let Qe = -1;
        for (Ke = A; Ke < le; Ke++)
          if (Xe(E, Ke) === Xe(m, Qe === -1 ? 0 : Ke - Qe)) {
            if (Qe === -1 && (Qe = Ke), Ke - Qe + 1 === _e)
              return Qe * ne;
          } else
            Qe !== -1 && (Ke -= Ke - Qe), Qe = -1;
      } else
        for (A + _e > le && (A = le - _e), Ke = A; Ke >= 0; Ke--) {
          let Qe = true;
          for (let ze = 0; ze < _e; ze++)
            if (Xe(E, Ke + ze) !== Xe(m, ze)) {
              Qe = false;
              break;
            }
          if (Qe)
            return Ke;
        }
      return -1;
    }
    a.prototype.includes = function(m, A, M) {
      return this.indexOf(m, A, M) !== -1;
    }, a.prototype.indexOf = function(m, A, M) {
      return L(this, m, A, M, true);
    }, a.prototype.lastIndexOf = function(m, A, M) {
      return L(this, m, A, M, false);
    };
    function V(E, m, A, M) {
      A = Number(A) || 0;
      const J = E.length - A;
      M ? (M = Number(M), M > J && (M = J)) : M = J;
      const ne = m.length;
      M > ne / 2 && (M = ne / 2);
      let le;
      for (le = 0; le < M; ++le) {
        const _e = parseInt(m.substr(le * 2, 2), 16);
        if (Ae(_e))
          return le;
        E[A + le] = _e;
      }
      return le;
    }
    function W(E, m, A, M) {
      return ae(v(m, E.length - A), E, A, M);
    }
    function X(E, m, A, M) {
      return ae(w(m), E, A, M);
    }
    function G(E, m, A, M) {
      return ae(Q(m), E, A, M);
    }
    function ie(E, m, A, M) {
      return ae(D(m, E.length - A), E, A, M);
    }
    a.prototype.write = function(m, A, M, J) {
      if (A === void 0)
        J = "utf8", M = this.length, A = 0;
      else if (M === void 0 && typeof A == "string")
        J = A, M = this.length, A = 0;
      else if (isFinite(A))
        A = A >>> 0, isFinite(M) ? (M = M >>> 0, J === void 0 && (J = "utf8")) : (J = M, M = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const ne = this.length - A;
      if ((M === void 0 || M > ne) && (M = ne), m.length > 0 && (M < 0 || A < 0) || A > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      J || (J = "utf8");
      let le = false;
      for (; ; )
        switch (J) {
          case "hex":
            return V(this, m, A, M);
          case "utf8":
          case "utf-8":
            return W(this, m, A, M);
          case "ascii":
          case "latin1":
          case "binary":
            return X(this, m, A, M);
          case "base64":
            return G(this, m, A, M);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ie(this, m, A, M);
          default:
            if (le)
              throw new TypeError("Unknown encoding: " + J);
            J = ("" + J).toLowerCase(), le = true;
        }
    }, a.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function P10(E, m, A) {
      return m === 0 && A === E.length ? e.fromByteArray(E) : e.fromByteArray(E.slice(m, A));
    }
    function z10(E, m, A) {
      A = Math.min(E.length, A);
      const M = [];
      let J = m;
      for (; J < A; ) {
        const ne = E[J];
        let le = null, _e = ne > 239 ? 4 : ne > 223 ? 3 : ne > 191 ? 2 : 1;
        if (J + _e <= A) {
          let Xe, Ke, Qe, ze;
          switch (_e) {
            case 1:
              ne < 128 && (le = ne);
              break;
            case 2:
              Xe = E[J + 1], (Xe & 192) === 128 && (ze = (ne & 31) << 6 | Xe & 63, ze > 127 && (le = ze));
              break;
            case 3:
              Xe = E[J + 1], Ke = E[J + 2], (Xe & 192) === 128 && (Ke & 192) === 128 && (ze = (ne & 15) << 12 | (Xe & 63) << 6 | Ke & 63, ze > 2047 && (ze < 55296 || ze > 57343) && (le = ze));
              break;
            case 4:
              Xe = E[J + 1], Ke = E[J + 2], Qe = E[J + 3], (Xe & 192) === 128 && (Ke & 192) === 128 && (Qe & 192) === 128 && (ze = (ne & 15) << 18 | (Xe & 63) << 12 | (Ke & 63) << 6 | Qe & 63, ze > 65535 && ze < 1114112 && (le = ze));
          }
        }
        le === null ? (le = 65533, _e = 1) : le > 65535 && (le -= 65536, M.push(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), M.push(le), J += _e;
      }
      return O(M);
    }
    const B = 4096;
    function O(E) {
      const m = E.length;
      if (m <= B)
        return String.fromCharCode.apply(String, E);
      let A = "", M = 0;
      for (; M < m; )
        A += String.fromCharCode.apply(
          String,
          E.slice(M, M += B)
        );
      return A;
    }
    function q(E, m, A) {
      let M = "";
      A = Math.min(E.length, A);
      for (let J = m; J < A; ++J)
        M += String.fromCharCode(E[J] & 127);
      return M;
    }
    function te(E, m, A) {
      let M = "";
      A = Math.min(E.length, A);
      for (let J = m; J < A; ++J)
        M += String.fromCharCode(E[J]);
      return M;
    }
    function Y(E, m, A) {
      const M = E.length;
      (!m || m < 0) && (m = 0), (!A || A < 0 || A > M) && (A = M);
      let J = "";
      for (let ne = m; ne < A; ++ne)
        J += ve[E[ne]];
      return J;
    }
    function K(E, m, A) {
      const M = E.slice(m, A);
      let J = "";
      for (let ne = 0; ne < M.length - 1; ne += 2)
        J += String.fromCharCode(M[ne] + M[ne + 1] * 256);
      return J;
    }
    a.prototype.slice = function(m, A) {
      const M = this.length;
      m = ~~m, A = A === void 0 ? M : ~~A, m < 0 ? (m += M, m < 0 && (m = 0)) : m > M && (m = M), A < 0 ? (A += M, A < 0 && (A = 0)) : A > M && (A = M), A < m && (A = m);
      const J = this.subarray(m, A);
      return Object.setPrototypeOf(J, a.prototype), J;
    };
    function $(E, m, A) {
      if (E % 1 !== 0 || E < 0)
        throw new RangeError("offset is not uint");
      if (E + m > A)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let J = this[m], ne = 1, le = 0;
      for (; ++le < A && (ne *= 256); )
        J += this[m + le] * ne;
      return J;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let J = this[m + --A], ne = 1;
      for (; A > 0 && (ne *= 256); )
        J += this[m + --A] * ne;
      return J;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(m, A) {
      return m = m >>> 0, A || $(m, 1, this.length), this[m];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(m, A) {
      return m = m >>> 0, A || $(m, 2, this.length), this[m] | this[m + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(m, A) {
      return m = m >>> 0, A || $(m, 2, this.length), this[m] << 8 | this[m + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + this[m + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), this[m] * 16777216 + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);
    }, a.prototype.readBigUInt64LE = be(function(m) {
      m = m >>> 0, ee(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && re(m, this.length - 8);
      const J = A + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24, ne = this[++m] + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + M * 2 ** 24;
      return BigInt(J) + (BigInt(ne) << BigInt(32));
    }), a.prototype.readBigUInt64BE = be(function(m) {
      m = m >>> 0, ee(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && re(m, this.length - 8);
      const J = A * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m], ne = this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + M;
      return (BigInt(J) << BigInt(32)) + BigInt(ne);
    }), a.prototype.readIntLE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let J = this[m], ne = 1, le = 0;
      for (; ++le < A && (ne *= 256); )
        J += this[m + le] * ne;
      return ne *= 128, J >= ne && (J -= Math.pow(2, 8 * A)), J;
    }, a.prototype.readIntBE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let J = A, ne = 1, le = this[m + --J];
      for (; J > 0 && (ne *= 256); )
        le += this[m + --J] * ne;
      return ne *= 128, le >= ne && (le -= Math.pow(2, 8 * A)), le;
    }, a.prototype.readInt8 = function(m, A) {
      return m = m >>> 0, A || $(m, 1, this.length), this[m] & 128 ? (255 - this[m] + 1) * -1 : this[m];
    }, a.prototype.readInt16LE = function(m, A) {
      m = m >>> 0, A || $(m, 2, this.length);
      const M = this[m] | this[m + 1] << 8;
      return M & 32768 ? M | 4294901760 : M;
    }, a.prototype.readInt16BE = function(m, A) {
      m = m >>> 0, A || $(m, 2, this.length);
      const M = this[m + 1] | this[m] << 8;
      return M & 32768 ? M | 4294901760 : M;
    }, a.prototype.readInt32LE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;
    }, a.prototype.readInt32BE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];
    }, a.prototype.readBigInt64LE = be(function(m) {
      m = m >>> 0, ee(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && re(m, this.length - 8);
      const J = this[m + 4] + this[m + 5] * 2 ** 8 + this[m + 6] * 2 ** 16 + (M << 24);
      return (BigInt(J) << BigInt(32)) + BigInt(A + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24);
    }), a.prototype.readBigInt64BE = be(function(m) {
      m = m >>> 0, ee(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && re(m, this.length - 8);
      const J = (A << 24) + // Overflow
      this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m];
      return (BigInt(J) << BigInt(32)) + BigInt(this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + M);
    }), a.prototype.readFloatLE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), r.read(this, m, true, 23, 4);
    }, a.prototype.readFloatBE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), r.read(this, m, false, 23, 4);
    }, a.prototype.readDoubleLE = function(m, A) {
      return m = m >>> 0, A || $(m, 8, this.length), r.read(this, m, true, 52, 8);
    }, a.prototype.readDoubleBE = function(m, A) {
      return m = m >>> 0, A || $(m, 8, this.length), r.read(this, m, false, 52, 8);
    };
    function se(E, m, A, M, J, ne) {
      if (!a.isBuffer(E))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (m > J || m < ne)
        throw new RangeError('"value" argument is out of bounds');
      if (A + M > E.length)
        throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(m, A, M, J) {
      if (m = +m, A = A >>> 0, M = M >>> 0, !J) {
        const _e = Math.pow(2, 8 * M) - 1;
        se(this, m, A, M, _e, 0);
      }
      let ne = 1, le = 0;
      for (this[A] = m & 255; ++le < M && (ne *= 256); )
        this[A + le] = m / ne & 255;
      return A + M;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(m, A, M, J) {
      if (m = +m, A = A >>> 0, M = M >>> 0, !J) {
        const _e = Math.pow(2, 8 * M) - 1;
        se(this, m, A, M, _e, 0);
      }
      let ne = M - 1, le = 1;
      for (this[A + ne] = m & 255; --ne >= 0 && (le *= 256); )
        this[A + ne] = m / le & 255;
      return A + M;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 1, 255, 0), this[A] = m & 255, A + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 65535, 0), this[A] = m & 255, this[A + 1] = m >>> 8, A + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 65535, 0), this[A] = m >>> 8, this[A + 1] = m & 255, A + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 4294967295, 0), this[A + 3] = m >>> 24, this[A + 2] = m >>> 16, this[A + 1] = m >>> 8, this[A] = m & 255, A + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 4294967295, 0), this[A] = m >>> 24, this[A + 1] = m >>> 16, this[A + 2] = m >>> 8, this[A + 3] = m & 255, A + 4;
    };
    function he(E, m, A, M, J) {
      k(m, M, J, E, A, 7);
      let ne = Number(m & BigInt(4294967295));
      E[A++] = ne, ne = ne >> 8, E[A++] = ne, ne = ne >> 8, E[A++] = ne, ne = ne >> 8, E[A++] = ne;
      let le = Number(m >> BigInt(32) & BigInt(4294967295));
      return E[A++] = le, le = le >> 8, E[A++] = le, le = le >> 8, E[A++] = le, le = le >> 8, E[A++] = le, A;
    }
    function de(E, m, A, M, J) {
      k(m, M, J, E, A, 7);
      let ne = Number(m & BigInt(4294967295));
      E[A + 7] = ne, ne = ne >> 8, E[A + 6] = ne, ne = ne >> 8, E[A + 5] = ne, ne = ne >> 8, E[A + 4] = ne;
      let le = Number(m >> BigInt(32) & BigInt(4294967295));
      return E[A + 3] = le, le = le >> 8, E[A + 2] = le, le = le >> 8, E[A + 1] = le, le = le >> 8, E[A] = le, A + 8;
    }
    a.prototype.writeBigUInt64LE = be(function(m, A = 0) {
      return he(this, m, A, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = be(function(m, A = 0) {
      return de(this, m, A, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(m, A, M, J) {
      if (m = +m, A = A >>> 0, !J) {
        const Xe = Math.pow(2, 8 * M - 1);
        se(this, m, A, M, Xe - 1, -Xe);
      }
      let ne = 0, le = 1, _e = 0;
      for (this[A] = m & 255; ++ne < M && (le *= 256); )
        m < 0 && _e === 0 && this[A + ne - 1] !== 0 && (_e = 1), this[A + ne] = (m / le >> 0) - _e & 255;
      return A + M;
    }, a.prototype.writeIntBE = function(m, A, M, J) {
      if (m = +m, A = A >>> 0, !J) {
        const Xe = Math.pow(2, 8 * M - 1);
        se(this, m, A, M, Xe - 1, -Xe);
      }
      let ne = M - 1, le = 1, _e = 0;
      for (this[A + ne] = m & 255; --ne >= 0 && (le *= 256); )
        m < 0 && _e === 0 && this[A + ne + 1] !== 0 && (_e = 1), this[A + ne] = (m / le >> 0) - _e & 255;
      return A + M;
    }, a.prototype.writeInt8 = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 1, 127, -128), m < 0 && (m = 255 + m + 1), this[A] = m & 255, A + 1;
    }, a.prototype.writeInt16LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 32767, -32768), this[A] = m & 255, this[A + 1] = m >>> 8, A + 2;
    }, a.prototype.writeInt16BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 32767, -32768), this[A] = m >>> 8, this[A + 1] = m & 255, A + 2;
    }, a.prototype.writeInt32LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 2147483647, -2147483648), this[A] = m & 255, this[A + 1] = m >>> 8, this[A + 2] = m >>> 16, this[A + 3] = m >>> 24, A + 4;
    }, a.prototype.writeInt32BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), this[A] = m >>> 24, this[A + 1] = m >>> 16, this[A + 2] = m >>> 8, this[A + 3] = m & 255, A + 4;
    }, a.prototype.writeBigInt64LE = be(function(m, A = 0) {
      return he(this, m, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = be(function(m, A = 0) {
      return de(this, m, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function pe(E, m, A, M, J, ne) {
      if (A + M > E.length)
        throw new RangeError("Index out of range");
      if (A < 0)
        throw new RangeError("Index out of range");
    }
    function j(E, m, A, M, J) {
      return m = +m, A = A >>> 0, J || pe(E, m, A, 4), r.write(E, m, A, M, 23, 4), A + 4;
    }
    a.prototype.writeFloatLE = function(m, A, M) {
      return j(this, m, A, true, M);
    }, a.prototype.writeFloatBE = function(m, A, M) {
      return j(this, m, A, false, M);
    };
    function H(E, m, A, M, J) {
      return m = +m, A = A >>> 0, J || pe(E, m, A, 8), r.write(E, m, A, M, 52, 8), A + 8;
    }
    a.prototype.writeDoubleLE = function(m, A, M) {
      return H(this, m, A, true, M);
    }, a.prototype.writeDoubleBE = function(m, A, M) {
      return H(this, m, A, false, M);
    }, a.prototype.copy = function(m, A, M, J) {
      if (!a.isBuffer(m))
        throw new TypeError("argument should be a Buffer");
      if (M || (M = 0), !J && J !== 0 && (J = this.length), A >= m.length && (A = m.length), A || (A = 0), J > 0 && J < M && (J = M), J === M || m.length === 0 || this.length === 0)
        return 0;
      if (A < 0)
        throw new RangeError("targetStart out of bounds");
      if (M < 0 || M >= this.length)
        throw new RangeError("Index out of range");
      if (J < 0)
        throw new RangeError("sourceEnd out of bounds");
      J > this.length && (J = this.length), m.length - A < J - M && (J = m.length - A + M);
      const ne = J - M;
      return this === m && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(A, M, J) : Uint8Array.prototype.set.call(
        m,
        this.subarray(M, J),
        A
      ), ne;
    }, a.prototype.fill = function(m, A, M, J) {
      if (typeof m == "string") {
        if (typeof A == "string" ? (J = A, A = 0, M = this.length) : typeof M == "string" && (J = M, M = this.length), J !== void 0 && typeof J != "string")
          throw new TypeError("encoding must be a string");
        if (typeof J == "string" && !a.isEncoding(J))
          throw new TypeError("Unknown encoding: " + J);
        if (m.length === 1) {
          const le = m.charCodeAt(0);
          (J === "utf8" && le < 128 || J === "latin1") && (m = le);
        }
      } else
        typeof m == "number" ? m = m & 255 : typeof m == "boolean" && (m = Number(m));
      if (A < 0 || this.length < A || this.length < M)
        throw new RangeError("Out of range index");
      if (M <= A)
        return this;
      A = A >>> 0, M = M === void 0 ? this.length : M >>> 0, m || (m = 0);
      let ne;
      if (typeof m == "number")
        for (ne = A; ne < M; ++ne)
          this[ne] = m;
      else {
        const le = a.isBuffer(m) ? m : a.from(m, J), _e = le.length;
        if (_e === 0)
          throw new TypeError('The value "' + m + '" is invalid for argument "value"');
        for (ne = 0; ne < M - A; ++ne)
          this[ne + A] = le[ne % _e];
      }
      return this;
    };
    const Z = {};
    function oe(E, m, A) {
      Z[E] = class extends A {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: m.apply(this, arguments),
            writable: true,
            configurable: true
          }), this.name = `${this.name} [${E}]`, this.stack, delete this.name;
        }
        get code() {
          return E;
        }
        set code(J) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: J,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${E}]: ${this.message}`;
        }
      };
    }
    oe(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(E) {
        return E ? `${E} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), oe(
      "ERR_INVALID_ARG_TYPE",
      function(E, m) {
        return `The "${E}" argument must be of type number. Received type ${typeof m}`;
      },
      TypeError
    ), oe(
      "ERR_OUT_OF_RANGE",
      function(E, m, A) {
        let M = `The value of "${E}" is out of range.`, J = A;
        return Number.isInteger(A) && Math.abs(A) > 2 ** 32 ? J = ue(String(A)) : typeof A == "bigint" && (J = String(A), (A > BigInt(2) ** BigInt(32) || A < -(BigInt(2) ** BigInt(32))) && (J = ue(J)), J += "n"), M += ` It must be ${m}. Received ${J}`, M;
      },
      RangeError
    );
    function ue(E) {
      let m = "", A = E.length;
      const M = E[0] === "-" ? 1 : 0;
      for (; A >= M + 4; A -= 3)
        m = `_${E.slice(A - 3, A)}${m}`;
      return `${E.slice(0, A)}${m}`;
    }
    function R(E, m, A) {
      ee(m, "offset"), (E[m] === void 0 || E[m + A] === void 0) && re(m, E.length - (A + 1));
    }
    function k(E, m, A, M, J, ne) {
      if (E > A || E < m) {
        const le = typeof m == "bigint" ? "n" : "";
        let _e;
        throw m === 0 || m === BigInt(0) ? _e = `>= 0${le} and < 2${le} ** ${(ne + 1) * 8}${le}` : _e = `>= -(2${le} ** ${(ne + 1) * 8 - 1}${le}) and < 2 ** ${(ne + 1) * 8 - 1}${le}`, new Z.ERR_OUT_OF_RANGE("value", _e, E);
      }
      R(M, J, ne);
    }
    function ee(E, m) {
      if (typeof E != "number")
        throw new Z.ERR_INVALID_ARG_TYPE(m, "number", E);
    }
    function re(E, m, A) {
      throw Math.floor(E) !== E ? (ee(E, A), new Z.ERR_OUT_OF_RANGE("offset", "an integer", E)) : m < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${m}`,
        E
      );
    }
    const ye = /[^+/0-9A-Za-z-_]/g;
    function I(E) {
      if (E = E.split("=")[0], E = E.trim().replace(ye, ""), E.length < 2)
        return "";
      for (; E.length % 4 !== 0; )
        E = E + "=";
      return E;
    }
    function v(E, m) {
      m = m || 1 / 0;
      let A;
      const M = E.length;
      let J = null;
      const ne = [];
      for (let le = 0; le < M; ++le) {
        if (A = E.charCodeAt(le), A > 55295 && A < 57344) {
          if (!J) {
            if (A > 56319) {
              (m -= 3) > -1 && ne.push(239, 191, 189);
              continue;
            } else if (le + 1 === M) {
              (m -= 3) > -1 && ne.push(239, 191, 189);
              continue;
            }
            J = A;
            continue;
          }
          if (A < 56320) {
            (m -= 3) > -1 && ne.push(239, 191, 189), J = A;
            continue;
          }
          A = (J - 55296 << 10 | A - 56320) + 65536;
        } else
          J && (m -= 3) > -1 && ne.push(239, 191, 189);
        if (J = null, A < 128) {
          if ((m -= 1) < 0)
            break;
          ne.push(A);
        } else if (A < 2048) {
          if ((m -= 2) < 0)
            break;
          ne.push(
            A >> 6 | 192,
            A & 63 | 128
          );
        } else if (A < 65536) {
          if ((m -= 3) < 0)
            break;
          ne.push(
            A >> 12 | 224,
            A >> 6 & 63 | 128,
            A & 63 | 128
          );
        } else if (A < 1114112) {
          if ((m -= 4) < 0)
            break;
          ne.push(
            A >> 18 | 240,
            A >> 12 & 63 | 128,
            A >> 6 & 63 | 128,
            A & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return ne;
    }
    function w(E) {
      const m = [];
      for (let A = 0; A < E.length; ++A)
        m.push(E.charCodeAt(A) & 255);
      return m;
    }
    function D(E, m) {
      let A, M, J;
      const ne = [];
      for (let le = 0; le < E.length && !((m -= 2) < 0); ++le)
        A = E.charCodeAt(le), M = A >> 8, J = A % 256, ne.push(J), ne.push(M);
      return ne;
    }
    function Q(E) {
      return e.toByteArray(I(E));
    }
    function ae(E, m, A, M) {
      let J;
      for (J = 0; J < M && !(J + A >= m.length || J >= E.length); ++J)
        m[J + A] = E[J];
      return J;
    }
    function fe(E, m) {
      return E instanceof m || E != null && E.constructor != null && E.constructor.name != null && E.constructor.name === m.name;
    }
    function Ae(E) {
      return E !== E;
    }
    const ve = function() {
      const E = "0123456789abcdef", m = new Array(256);
      for (let A = 0; A < 16; ++A) {
        const M = A * 16;
        for (let J = 0; J < 16; ++J)
          m[M + J] = E[A] + E[J];
      }
      return m;
    }();
    function be(E) {
      return typeof BigInt > "u" ? Pe : E;
    }
    function Pe() {
      throw new Error("BigInt not supported");
    }
  })(R0);
  /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  const gb = Vs("simple-peer"), D0 = gy, Zf = dc, mb = Hs, Al = db, Oe = pb, { Buffer: yb } = R0, wl = 64 * 1024, bb = 5 * 1e3, vb = 5 * 1e3;
  function $f(t10) {
    return t10.replace(/a=ice-options:trickle\s\n/g, "");
  }
  function Ab(t10) {
    console.warn(t10);
  }
  class Dn extends mb.Duplex {
    constructor(e) {
      if (e = Object.assign({
        allowHalfOpen: false
      }, e), super(e), this._id = Zf(4).toString("hex").slice(0, 7), this._debug("new peer %o", e), this.channelName = e.initiator ? e.channelName || Zf(20).toString("hex") : null, this.initiator = e.initiator || false, this.channelConfig = e.channelConfig || Dn.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, Dn.config, e.config), this.offerOptions = e.offerOptions || {}, this.answerOptions = e.answerOptions || {}, this.sdpTransform = e.sdpTransform || ((r) => r), this.streams = e.streams || (e.stream ? [e.stream] : []), this.trickle = e.trickle !== void 0 ? e.trickle : true, this.allowHalfTrickle = e.allowHalfTrickle !== void 0 ? e.allowHalfTrickle : false, this.iceCompleteTimeout = e.iceCompleteTimeout || bb, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e.wrtc && typeof e.wrtc == "object" ? e.wrtc : D0(), !this._wrtc)
        throw Oe(typeof window > "u" ? new Error("No WebRTC support: Specify `opts.wrtc` option in this environment") : new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
      this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
      try {
        this._pc = new this._wrtc.RTCPeerConnection(this.config);
      } catch (r) {
        this.destroy(Oe(r, "ERR_PC_CONSTRUCTOR"));
        return;
      }
      this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == "number", this._pc.oniceconnectionstatechange = () => {
        this._onIceStateChange();
      }, this._pc.onicegatheringstatechange = () => {
        this._onIceStateChange();
      }, this._pc.onconnectionstatechange = () => {
        this._onConnectionStateChange();
      }, this._pc.onsignalingstatechange = () => {
        this._onSignalingStateChange();
      }, this._pc.onicecandidate = (r) => {
        this._onIceCandidate(r);
      }, typeof this._pc.peerIdentity == "object" && this._pc.peerIdentity.catch((r) => {
        this.destroy(Oe(r, "ERR_PC_PEER_IDENTITY"));
      }), this.initiator || this.channelNegotiated ? this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      }) : this._pc.ondatachannel = (r) => {
        this._setupData(r);
      }, this.streams && this.streams.forEach((r) => {
        this.addStream(r);
      }), this._pc.ontrack = (r) => {
        this._onTrack(r);
      }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
        this._onFinish();
      }, this.once("finish", this._onFinishBound);
    }
    get bufferSize() {
      return this._channel && this._channel.bufferedAmount || 0;
    }
    // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    get connected() {
      return this._connected && this._channel.readyState === "open";
    }
    address() {
      return { port: this.localPort, family: this.localFamily, address: this.localAddress };
    }
    signal(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Oe(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
        if (typeof e == "string")
          try {
            e = JSON.parse(e);
          } catch {
            e = {};
          }
        this._debug("signal()"), e.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e.transceiverRequest.kind, e.transceiverRequest.init)), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e)).then(() => {
          this.destroyed || (this._pendingCandidates.forEach((r) => {
            this._addIceCandidate(r);
          }), this._pendingCandidates = [], this._pc.remoteDescription.type === "offer" && this._createAnswer());
        }).catch((r) => {
          this.destroy(Oe(r, "ERR_SET_REMOTE_DESCRIPTION"));
        }), !e.sdp && !e.candidate && !e.renegotiate && !e.transceiverRequest && this.destroy(Oe(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
      }
    }
    _addIceCandidate(e) {
      const r = new this._wrtc.RTCIceCandidate(e);
      this._pc.addIceCandidate(r).catch((n) => {
        !r.address || r.address.endsWith(".local") ? Ab("Ignoring unsupported ICE candidate.") : this.destroy(Oe(n, "ERR_ADD_ICE_CANDIDATE"));
      });
    }
    /**
     * Send text/binary data to the remote peer.
     * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
     */
    send(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Oe(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
        this._channel.send(e);
      }
    }
    /**
     * Add a Transceiver to the connection.
     * @param {String} kind
     * @param {Object} init
     */
    addTransceiver(e, r) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Oe(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
        if (this._debug("addTransceiver()"), this.initiator)
          try {
            this._pc.addTransceiver(e, r), this._needsNegotiation();
          } catch (n) {
            this.destroy(Oe(n, "ERR_ADD_TRANSCEIVER"));
          }
        else
          this.emit("signal", {
            // request initiator to renegotiate
            type: "transceiverRequest",
            transceiverRequest: { kind: e, init: r }
          });
      }
    }
    /**
     * Add a MediaStream to the connection.
     * @param {MediaStream} stream
     */
    addStream(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Oe(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addStream()"), e.getTracks().forEach((r) => {
          this.addTrack(r, e);
        });
      }
    }
    /**
     * Add a MediaStreamTrack to the connection.
     * @param {MediaStreamTrack} track
     * @param {MediaStream} stream
     */
    addTrack(e, r) {
      if (this.destroying)
        return;
      if (this.destroyed)
        throw Oe(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
      this._debug("addTrack()");
      const n = this._senderMap.get(e) || /* @__PURE__ */ new Map();
      let i = n.get(r);
      if (!i)
        i = this._pc.addTrack(e, r), n.set(r, i), this._senderMap.set(e, n), this._needsNegotiation();
      else
        throw i.removed ? Oe(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED") : Oe(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
    }
    /**
     * Replace a MediaStreamTrack by another in the connection.
     * @param {MediaStreamTrack} oldTrack
     * @param {MediaStreamTrack} newTrack
     * @param {MediaStream} stream
     */
    replaceTrack(e, r, n) {
      if (this.destroying)
        return;
      if (this.destroyed)
        throw Oe(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
      this._debug("replaceTrack()");
      const i = this._senderMap.get(e), o = i ? i.get(n) : null;
      if (!o)
        throw Oe(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
      r && this._senderMap.set(r, i), o.replaceTrack != null ? o.replaceTrack(r) : this.destroy(Oe(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
    }
    /**
     * Remove a MediaStreamTrack from the connection.
     * @param {MediaStreamTrack} track
     * @param {MediaStream} stream
     */
    removeTrack(e, r) {
      if (this.destroying)
        return;
      if (this.destroyed)
        throw Oe(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
      this._debug("removeSender()");
      const n = this._senderMap.get(e), i = n ? n.get(r) : null;
      if (!i)
        throw Oe(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
      try {
        i.removed = true, this._pc.removeTrack(i);
      } catch (o) {
        o.name === "NS_ERROR_UNEXPECTED" ? this._sendersAwaitingStable.push(i) : this.destroy(Oe(o, "ERR_REMOVE_TRACK"));
      }
      this._needsNegotiation();
    }
    /**
     * Remove a MediaStream from the connection.
     * @param {MediaStream} stream
     */
    removeStream(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Oe(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSenders()"), e.getTracks().forEach((r) => {
          this.removeTrack(r, e);
        });
      }
    }
    _needsNegotiation() {
      this._debug("_needsNegotiation"), !this._batchedNegotiation && (this._batchedNegotiation = true, Al(() => {
        this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
      }));
    }
    negotiate() {
      if (!this.destroying) {
        if (this.destroyed)
          throw Oe(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
        this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
          this._createOffer();
        }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", {
          // request initiator to renegotiate
          type: "renegotiate",
          renegotiate: true
        })), this._isNegotiating = true;
      }
    }
    // TODO: Delete this method once readable-stream is updated to contain a default
    // implementation of destroy() that automatically calls _destroy()
    // See: https://github.com/nodejs/readable-stream/issues/283
    destroy(e) {
      this._destroy(e, () => {
      });
    }
    _destroy(e, r) {
      this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e && (e.message || e)), Al(() => {
        if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e && (e.message || e)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
          try {
            this._channel.close();
          } catch {
          }
          this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
        }
        if (this._pc) {
          try {
            this._pc.close();
          } catch {
          }
          this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
        }
        this._pc = null, this._channel = null, e && this.emit("error", e), this.emit("close"), r();
      }));
    }
    _setupData(e) {
      if (!e.channel)
        return this.destroy(Oe(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
      this._channel = e.channel, this._channel.binaryType = "arraybuffer", typeof this._channel.bufferedAmountLowThreshold == "number" && (this._channel.bufferedAmountLowThreshold = wl), this.channelName = this._channel.label, this._channel.onmessage = (n) => {
        this._onChannelMessage(n);
      }, this._channel.onbufferedamountlow = () => {
        this._onChannelBufferedAmountLow();
      }, this._channel.onopen = () => {
        this._onChannelOpen();
      }, this._channel.onclose = () => {
        this._onChannelClose();
      }, this._channel.onerror = (n) => {
        const i = n.error instanceof Error ? n.error : new Error(`Datachannel error: ${n.message} ${n.filename}:${n.lineno}:${n.colno}`);
        this.destroy(Oe(i, "ERR_DATA_CHANNEL"));
      };
      let r = false;
      this._closingInterval = setInterval(() => {
        this._channel && this._channel.readyState === "closing" ? (r && this._onChannelClose(), r = true) : r = false;
      }, vb);
    }
    _read() {
    }
    _write(e, r, n) {
      if (this.destroyed)
        return n(Oe(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
      if (this._connected) {
        try {
          this.send(e);
        } catch (i) {
          return this.destroy(Oe(i, "ERR_DATA_CHANNEL"));
        }
        this._channel.bufferedAmount > wl ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n) : n(null);
      } else
        this._debug("write before connect"), this._chunk = e, this._cb = n;
    }
    // When stream finishes writing, close socket. Half open connections are not
    // supported.
    _onFinish() {
      if (this.destroyed)
        return;
      const e = () => {
        setTimeout(() => this.destroy(), 1e3);
      };
      this._connected ? e() : this.once("connect", e);
    }
    _startIceCompleteTimeout() {
      this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
        this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
      }, this.iceCompleteTimeout));
    }
    _createOffer() {
      this.destroyed || this._pc.createOffer(this.offerOptions).then((e) => {
        if (this.destroyed)
          return;
        !this.trickle && !this.allowHalfTrickle && (e.sdp = $f(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
        const r = () => {
          if (this.destroyed)
            return;
          const o = this._pc.localDescription || e;
          this._debug("signal"), this.emit("signal", {
            type: o.type,
            sdp: o.sdp
          });
        }, n = () => {
          this._debug("createOffer success"), !this.destroyed && (this.trickle || this._iceComplete ? r() : this.once("_iceComplete", r));
        }, i = (o) => {
          this.destroy(Oe(o, "ERR_SET_LOCAL_DESCRIPTION"));
        };
        this._pc.setLocalDescription(e).then(n).catch(i);
      }).catch((e) => {
        this.destroy(Oe(e, "ERR_CREATE_OFFER"));
      });
    }
    _requestMissingTransceivers() {
      this._pc.getTransceivers && this._pc.getTransceivers().forEach((e) => {
        !e.mid && e.sender.track && !e.requested && (e.requested = true, this.addTransceiver(e.sender.track.kind));
      });
    }
    _createAnswer() {
      this.destroyed || this._pc.createAnswer(this.answerOptions).then((e) => {
        if (this.destroyed)
          return;
        !this.trickle && !this.allowHalfTrickle && (e.sdp = $f(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
        const r = () => {
          if (this.destroyed)
            return;
          const o = this._pc.localDescription || e;
          this._debug("signal"), this.emit("signal", {
            type: o.type,
            sdp: o.sdp
          }), this.initiator || this._requestMissingTransceivers();
        }, n = () => {
          this.destroyed || (this.trickle || this._iceComplete ? r() : this.once("_iceComplete", r));
        }, i = (o) => {
          this.destroy(Oe(o, "ERR_SET_LOCAL_DESCRIPTION"));
        };
        this._pc.setLocalDescription(e).then(n).catch(i);
      }).catch((e) => {
        this.destroy(Oe(e, "ERR_CREATE_ANSWER"));
      });
    }
    _onConnectionStateChange() {
      this.destroyed || this._pc.connectionState === "failed" && this.destroy(Oe(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
    _onIceStateChange() {
      if (this.destroyed)
        return;
      const e = this._pc.iceConnectionState, r = this._pc.iceGatheringState;
      this._debug(
        "iceStateChange (connection: %s) (gathering: %s)",
        e,
        r
      ), this.emit("iceStateChange", e, r), (e === "connected" || e === "completed") && (this._pcReady = true, this._maybeReady()), e === "failed" && this.destroy(Oe(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), e === "closed" && this.destroy(Oe(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
    getStats(e) {
      const r = (n) => (Object.prototype.toString.call(n.values) === "[object Array]" && n.values.forEach((i) => {
        Object.assign(n, i);
      }), n);
      this._pc.getStats.length === 0 || this._isReactNativeWebrtc ? this._pc.getStats().then((n) => {
        const i = [];
        n.forEach((o) => {
          i.push(r(o));
        }), e(null, i);
      }, (n) => e(n)) : this._pc.getStats.length > 0 ? this._pc.getStats((n) => {
        if (this.destroyed)
          return;
        const i = [];
        n.result().forEach((o) => {
          const s = {};
          o.names().forEach((a) => {
            s[a] = o.stat(a);
          }), s.id = o.id, s.type = o.type, s.timestamp = o.timestamp, i.push(r(s));
        }), e(null, i);
      }, (n) => e(n)) : e(null, []);
    }
    _maybeReady() {
      if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
        return;
      this._connecting = true;
      const e = () => {
        this.destroyed || this.getStats((r, n) => {
          if (this.destroyed)
            return;
          r && (n = []);
          const i = {}, o = {}, s = {};
          let a = false;
          n.forEach((c) => {
            (c.type === "remotecandidate" || c.type === "remote-candidate") && (i[c.id] = c), (c.type === "localcandidate" || c.type === "local-candidate") && (o[c.id] = c), (c.type === "candidatepair" || c.type === "candidate-pair") && (s[c.id] = c);
          });
          const l = (c) => {
            a = true;
            let u = o[c.localCandidateId];
            u && (u.ip || u.address) ? (this.localAddress = u.ip || u.address, this.localPort = Number(u.port)) : u && u.ipAddress ? (this.localAddress = u.ipAddress, this.localPort = Number(u.portNumber)) : typeof c.googLocalAddress == "string" && (u = c.googLocalAddress.split(":"), this.localAddress = u[0], this.localPort = Number(u[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
            let f = i[c.remoteCandidateId];
            f && (f.ip || f.address) ? (this.remoteAddress = f.ip || f.address, this.remotePort = Number(f.port)) : f && f.ipAddress ? (this.remoteAddress = f.ipAddress, this.remotePort = Number(f.portNumber)) : typeof c.googRemoteAddress == "string" && (f = c.googRemoteAddress.split(":"), this.remoteAddress = f[0], this.remotePort = Number(f[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug(
              "connect local: %s:%s remote: %s:%s",
              this.localAddress,
              this.localPort,
              this.remoteAddress,
              this.remotePort
            );
          };
          if (n.forEach((c) => {
            c.type === "transport" && c.selectedCandidatePairId && l(s[c.selectedCandidatePairId]), (c.type === "googCandidatePair" && c.googActiveConnection === "true" || (c.type === "candidatepair" || c.type === "candidate-pair") && c.selected) && l(c);
          }), !a && (!Object.keys(s).length || Object.keys(o).length)) {
            setTimeout(e, 100);
            return;
          } else
            this._connecting = false, this._connected = true;
          if (this._chunk) {
            try {
              this.send(this._chunk);
            } catch (u) {
              return this.destroy(Oe(u, "ERR_DATA_CHANNEL"));
            }
            this._chunk = null, this._debug('sent chunk from "write before connect"');
            const c = this._cb;
            this._cb = null, c(null);
          }
          typeof this._channel.bufferedAmountLowThreshold != "number" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
        });
      };
      e();
    }
    _onInterval() {
      !this._cb || !this._channel || this._channel.bufferedAmount > wl || this._onChannelBufferedAmountLow();
    }
    _onSignalingStateChange() {
      this.destroyed || (this._pc.signalingState === "stable" && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e) => {
        this._pc.removeTrack(e), this._queuedNegotiation = true;
      }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
    }
    _onIceCandidate(e) {
      this.destroyed || (e.candidate && this.trickle ? this.emit("signal", {
        type: "candidate",
        candidate: {
          candidate: e.candidate.candidate,
          sdpMLineIndex: e.candidate.sdpMLineIndex,
          sdpMid: e.candidate.sdpMid
        }
      }) : !e.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e.candidate && this._startIceCompleteTimeout());
    }
    _onChannelMessage(e) {
      if (this.destroyed)
        return;
      let r = e.data;
      r instanceof ArrayBuffer && (r = yb.from(r)), this.push(r);
    }
    _onChannelBufferedAmountLow() {
      if (this.destroyed || !this._cb)
        return;
      this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
      const e = this._cb;
      this._cb = null, e(null);
    }
    _onChannelOpen() {
      this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
    }
    _onChannelClose() {
      this.destroyed || (this._debug("on channel close"), this.destroy());
    }
    _onTrack(e) {
      this.destroyed || e.streams.forEach((r) => {
        this._debug("on track"), this.emit("track", e.track, r), this._remoteTracks.push({
          track: e.track,
          stream: r
        }), !this._remoteStreams.some((n) => n.id === r.id) && (this._remoteStreams.push(r), Al(() => {
          this._debug("on stream"), this.emit("stream", r);
        }));
      });
    }
    _debug() {
      const e = [].slice.call(arguments);
      e[0] = "[" + this._id + "] " + e[0], gb.apply(null, e);
    }
  }
  Dn.WEBRTC_SUPPORT = !!D0();
  Dn.config = {
    iceServers: [
      {
        urls: [
          "stun:stun.l.google.com:19302",
          "stun:globalThis.stun.twilio.com:3478"
        ]
      }
    ],
    sdpSemantics: "unified-plan"
  };
  Dn.channelConfig = {};
  var ed = Dn;
  function Se() {
    localStorage.getItem("debug") === "true" && console.log(...arguments);
  }
  typeof window < "u" && (window.process = {
    ...window.process,
    nextTick: function(t10, e, r, n) {
      setTimeout(() => {
        t10(e, r, n);
      }, 0);
    }
  }, window.process.env = window.process.env || {});
  function wb(t10) {
    t10 = t10.replace(/#/g, "");
    var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    t10 = t10.replace(e, function(n, i, o, s) {
      return i + i + o + o + s + s;
    });
    var r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t10);
    return r ? {
      r: parseInt(r[1], 16),
      g: parseInt(r[2], 16),
      b: parseInt(r[3], 16),
      hexString: `#${t10}`,
      hex: parseInt(r[1], 16) << 16 | parseInt(r[2], 16) << 8 | parseInt(r[3], 16)
    } : null;
  }
  class xb extends ru {
    constructor({
      websocketSend: e,
      id: r,
      myId: n,
      isRenderServer: i,
      isRenderServerOrHostIfNotCasting: o,
      playerIsSpectator: s,
      playerIsProxy: a,
      broadcastUnreliable: l,
      setPlayerState: c,
      getBootDate: u,
      avatarList: f,
      kickPlayer: d,
      leavePlayer: h,
      state: g = {},
      defaultPlayerState: p = {}
    }) {
      super(), this.websocketSend = e, this.broadcastUnreliable = l, this.setPlayerState = c, this.myId = n, this._kickPlayerTrigger = d, this._leavePlayerTrigger = h, this.id = r, this.avatarList = f, this.syncIntervalTime = u0.SyncIntervalTime, this.isRenderServer = i, this.isRenderServerOrHostIfNotCasting = o, this.playerIsSpectator = s, this.playerIsProxy = a, this.state = g, this.defaultPlayerState = p, this.iUpdatedStateAt = {}, this.playerIsProxy && (this.state.__proxyBy = n), this.getBootDate = u, this.stateKeyUpdateOrder = {}, this.inputState = {}, this.peer = null, this.webrtcConnected = false, this.webrtcRetryCount = 0, this.controllerLegacy = false, this.heartbeatInterval = 0, this.retryWebRtcTimeout = 0, this.isDestroyed = false, this.timeDiffFromServer = 0, this.bot = void 0, this.on("input_broadcast", (y) => {
        !o() && !s && this.send({ pinput: y });
      });
    }
    send(e, r, n) {
      if (this.webrtcConnected && !r && !this.playerIsProxy)
        try {
          Se(
            "sending unreliable",
            e,
            r,
            "webrtcConnected",
            this.webrtcConnected
          ), this.peer.send(JSON.stringify(e));
        } catch (i) {
          Se(i);
        }
      else
        !r && this.isRenderServerOrHostIfNotCasting() && !n ? this.broadcastUnreliable(e) : this.playerIsProxy || (this.isRenderServerOrHostIfNotCasting() && (e.for = this.id), Se(
          "sending reliable",
          e,
          r,
          "webrtcConnected",
          this.webrtcConnected
        ), this.websocketSend(JSON.stringify(e)));
    }
    startWebrtc() {
      if (this.retryWebRtcTimeout && (clearTimeout(this.retryWebRtcTimeout), this.retryWebRtcTimeout = 0), this.peer && this.peer.destroy(), !this.isRenderServerOrHostIfNotCasting() && this.myId === this.id) {
        Se("webrtc::connecting", "not render server, isMyId");
        try {
          this.peer = new ed({ initiator: true, objectMode: true });
        } catch (e) {
          Se(this._idToHuman(), "::webrtc:", "connection error", e), this.webrtcConnected = false;
          return;
        }
        this.peer.on("signal", (e) => {
          Se("got signal", e), this.send({ signal: e }, true);
        }), this.peer.on("connect", () => {
          this.webrtcConnected = true, this.webrtcRetryCount = 0, this.emit("webrtc_connected"), clearTimeout(this.retryWebRtcTimeout);
        }), this.peer.on("data", (e) => {
          e = JSON.parse(e), Se("webrtc::host says:", e), e.ping ? (this.timeDiffFromServer = e.ping - Date.now(), this.send({ pong: e.ping })) : e.pstate ? this.setPlayerState(e) : e.gstate && this.emit("global_state_unreliable", e.gstate);
        }), this.peer.on("stream", (e) => {
          this.emit("stream", e);
        }), this.peer.on("close", () => {
          Se(this._idToHuman(), "::webrtc:", "connection closed"), this.webrtcConnected = false, this.retryWebRtcTimeout = setTimeout(() => {
            !this.isDestroyed && this.webrtcRetryCount < 5 && (this.startWebrtc(), this.webrtcRetryCount++);
          }, 3e3);
        }), this.peer.on("error", (e) => {
          Se(this._idToHuman(), "::webrtc:", "connection error", e), this.webrtcConnected = false;
        });
      } else if (this.isRenderServerOrHostIfNotCasting() && this.myId !== this.id) {
        Se("webrtc::connecting", "is render server, notMyId"), clearInterval(this.heartbeatInterval), this.heartbeatInterval = setInterval(() => {
          this.send({
            ping: Date.now()
          });
        }, 5e3);
        try {
          this.peer = new ed({ objectMode: true });
        } catch (e) {
          Se(this._idToHuman(), "::webrtc:", "connection error", e), this.webrtcConnected = false;
          return;
        }
        this.peer.on("signal", (e) => {
          Se("got signal", e), this.send({ for: this.id, signal: e }, true);
        }), this.peer.on("connect", () => {
          Se("connected to player via webrtc"), this.webrtcConnected = true, this.send({ ping: Date.now() }), this.emit("webrtc_connected");
        }), this.peer.on("data", (e) => {
          Se(this._idToHuman(), "::webrtc:", e), e = JSON.parse(e), e.pinput ? this.handleInput(e.pinput) : e.pstate ? this.setState(e.d[0], e.d[1]) : e.pong && this.handlePingResponse(e);
        }), this.peer.on("close", () => {
          this.webrtcConnected = false, Se(this._idToHuman(), "::webrtc:", "connection closed");
        }), this.peer.on("error", (e) => {
          this.webrtcConnected = false, Se(this._idToHuman(), "::webrtc:", "connection error", e);
        });
      }
    }
    _idToHuman() {
      return `${this.playerIsSpectator ? "spectator" : "player"}(${this.id})`;
    }
    signal(e) {
      this.peer.destroyed && this.isRenderServerOrHostIfNotCasting() && this.startWebrtc();
      try {
        Se("signaling", e), this.peer.signal(e);
      } catch (r) {
        Se(r);
      }
    }
    handlePingResponse(e) {
      var r = Date.now() - e.pong;
      this.emit("ping", r);
    }
    // used for local players
    attachControllerLegacy(e) {
      this.detachControllerLegacy(), this.controllerLegacy = e, this.controllerLegacy.on("keydown", this.handleKeyDown.bind(this)), this.controllerLegacy.on("keyup", this.handleKeyUp.bind(this)), this.controllerLegacy.on("dpad", this.handleDpad.bind(this)), this.controllerLegacy.on("gyro", this.handleGyro.bind(this));
    }
    detachControllerLegacy() {
      if (this.controllerLegacy) {
        const e = this.controllerLegacy;
        return this.controllerLegacy.off("keydown", this.handleKeyDown), this.controllerLegacy.off("keyup", this.handleKeyUp), this.controllerLegacy.off("dpad", this.handleDpad), this.controllerLegacy.off("gyro", this.handleGyro), delete this.controllerLegacy, e;
      }
    }
    onKeyPress(e, r) {
      this.on("keypress", (n) => {
        n.key === e && r(n);
      });
    }
    onKeyUp(e, r) {
      this.on("keyup", (n) => {
        n.key === e && r(n);
      });
    }
    onKeyDown(e, r) {
      this.on("keydown", (n) => {
        n.key === e && r(n);
      });
    }
    onQuit(e) {
      return this.on("quit", e);
    }
    handleKeyDown(e) {
      this.handleInput({ keydown: e });
    }
    handleKeyUp(e) {
      this.handleInput({ keyup: e });
    }
    handleDpad(e) {
      this.handleInput({ dpad: e });
    }
    handleGyro(e) {
      this.handleInput({ gyro: e });
    }
    // handle the input, pass it to subscribers (usually the game logic which will use this to move players in engine)
    handleInput(e, r) {
      let n = false;
      Object.keys(e).forEach((i) => {
        const o = e[i];
        i === "keydown" && !this.inputState[o] && (this.inputState[o] = true, this.emit("keydown", { key: o }), this.emit("keypress", { key: o }), n = true), i === "keyup" && this.inputState[o] && (delete this.inputState[o], this.emit("keyup", { key: o }), n = true), i === "dpad" && (this.inputState.dpad = e.dpad, n = true), i === "gyro" && (this.inputState.gyro = e.gyro, n = true);
      }), n && (Se("inputEmit", e), this.emit("input", e), r || this.emit("input_broadcast", e));
    }
    isKeyDown(e) {
      return this.inputState[e];
    }
    on(e, r, n) {
      return e === "profile" && r(this.state.profile), e === "webrtc_connected" && this.webrtcConnected && r(), super.on(e, r, n);
    }
    getState(e) {
      return e ? typeof this.state[e] == "object" ? JSON.parse(JSON.stringify(this.state[e])) : this.state[e] : this.state;
    }
    // public method to change state object (used by host only or to change my own state). This is then synced with all clients.
    setState(e, r, n) {
      JSON.stringify(this.state[e]) !== JSON.stringify(r) && (this.setLocalState(e, r), this.iUpdatedStateAt[e] = Date.now(), this.isRenderServerOrHostIfNotCasting() && !n ? this.broadcastUnreliable({
        pstate: this.id,
        d: [e, r],
        o: Date.now() - this.getBootDate()
      }) : this.send(
        {
          pstate: this.id,
          d: [e, r],
          o: Date.now() - this.getBootDate() - this.timeDiffFromServer
        },
        n
      ));
    }
    setFullDefaultLocalState(e) {
      Object.keys(e).forEach((r) => {
        this.setDefaultLocalState(r, e[r]);
      });
    }
    // get default player state
    getDefaultState(e) {
      return e ? typeof this.defaultPlayerState[e] == "object" ? JSON.parse(JSON.stringify(this.defaultPlayerState[e])) : this.defaultPlayerState[e] : this.defaultPlayerState;
    }
    /**
     * store default player states. This will come in handy when we reset the player states,
     * we will replace the states with these default states.
     */
    setDefaultState(e, r) {
      const n = typeof r == "object" ? JSON.parse(JSON.stringify(r)) : r;
      this.setDefaultLocalState(e, n) && this.send(
        {
          default_pstate: this.id,
          d: [e, n],
          o: Date.now() - this.getBootDate() - this.timeDiffFromServer
        },
        true
      );
    }
    setDefaultLocalState(e, r) {
      if (JSON.stringify(this.defaultPlayerState[e]) !== JSON.stringify(r))
        return this.defaultPlayerState[e] = r, true;
    }
    getProfile() {
      let e = this.getState("profile") || { color: "#ffffff", name: "" };
      return e && e.color && (e = { ...e, color: wb(e.color) }), this.avatarList && this.avatarList.length > 0 && (e.avatarIndex = this.avatarList.indexOf(e.photo)), e.avatarIndex === void 0 && (e.avatarIndex = -1), e;
    }
    setRoundState(e, r, n) {
      this.setState(`round.${e}`, r, n);
    }
    getRoundState(e) {
      if (e)
        return this.getState(`round.${e}`);
      {
        let r = {};
        return Object.keys(this.getState()).forEach((n) => {
          n.startsWith("round.") && (r[n.substring(6)] = this.getState(n));
        }), r;
      }
    }
    resetRoundState() {
      Object.keys(this.getState()).forEach((e) => {
        e.startsWith("round.") && this.setState(e, void 0);
      });
    }
    setFullLocalState(e, r) {
      Object.keys(e).forEach((n) => {
        (!this.iUpdatedStateAt[n] || this.iUpdatedStateAt[n] + this.syncIntervalTime < Date.now()) && this.setLocalState(n, e[n], r);
      }), Object.keys(this.state).forEach((n) => {
        var i;
        (!this.iUpdatedStateAt[n] || this.iUpdatedStateAt[n] + this.syncIntervalTime < Date.now()) && e[n] === void 0 && (Se("set default states for the playerState", this.state[n]), this.setLocalState(n, (i = this.defaultPlayerState) == null ? void 0 : i[n], r));
      });
    }
    // just change local state without broadcasting
    // updateOrder: since we have two channels the state can come from,
    // we keep order in mind and only update if it's latest from host
    setLocalState(e, r, n) {
      if (n && this.stateKeyUpdateOrder[e] && this.stateKeyUpdateOrder[e] > n)
        return;
      this.stateKeyUpdateOrder[e] = n || 0;
      const i = JSON.stringify(r);
      var o = false;
      JSON.stringify(this.state[e]) !== i && (o = true);
      const s = typeof r == "object" ? JSON.parse(i) : r;
      return this.state[e] = s, o && (this.emit("state", e, s), e === "profile" && this.emit("profile", s)), o;
    }
    kick() {
      return new Promise((e, r) => {
        if (!this.isRenderServerOrHostIfNotCasting()) {
          r("Only the host can kick a player.");
          return;
        }
        this._kickPlayerTrigger(this.id, e);
      });
    }
    leaveRoom() {
      return new Promise((e, r) => {
        if (this.id !== this.myId) {
          r("Players can only remove themselves from the room.");
          return;
        }
        this._leavePlayerTrigger(this.id, e);
      });
    }
    disconnect(e) {
      Se("[PlayerState] disconnecting with eventCode:", e), this.detachControllerLegacy(), clearInterval(this.heartbeatInterval), this.isDestroyed = true, this.peer && this.peer.destroy(), this.emit("quit", this);
    }
    isBot() {
      return this.state.__bot;
    }
    isProxyPlayer() {
      return this.state.__proxyBy;
    }
  }
  typeof window < "u" && (window.__TEMPSTORAGE__ = {});
  function _b(t10, e) {
    var r;
    window._USETEMPSTORAGE ? window.__TEMPSTORAGE__[t10] = e : (r = window._PLAYROOM_CONFIG) != null && r.sessionStorage ? sessionStorage.setItem(t10, e) : localStorage.setItem(t10, e);
  }
  function Sb(t10) {
    var e;
    return window._USETEMPSTORAGE ? window.__TEMPSTORAGE__[t10] : (e = window._PLAYROOM_CONFIG) != null && e.sessionStorage ? sessionStorage.getItem(t10) : localStorage.getItem(t10);
  }
  const ct = {
    set: _b,
    get: Sb
  };
  let ka = (t10 = 21) => crypto.getRandomValues(new Uint8Array(t10)).reduce((e, r) => (r &= 63, r < 36 ? e += r.toString(36) : r < 62 ? e += (r - 26).toString(36).toUpperCase() : r > 62 ? e += "-" : e += "_", e), "");
  function M0() {
    const t10 = localStorage.getItem("permId") || ka(32);
    return localStorage.setItem("permId", t10), t10;
  }
  function Eb() {
    const t10 = ct.get("myId") || ka(12);
    return ct.set("myId", t10), t10;
  }
  function xl(t10) {
    return new Promise((e) => setTimeout(e, t10));
  }
  function kb(t10, e) {
    return new Promise((r, n) => {
      if (t10.getState(e) !== void 0)
        r();
      else {
        const i = t10.on(
          "state",
          (o, s) => {
            o === e && (i(), r());
          },
          true
        );
      }
    });
  }
  function wE(t10, e) {
    const r = we();
    return new Promise((n, i) => {
      const o = (l) => {
        e && e(l), n(l);
      };
      let s = r.getState(t10);
      s && o(s);
      const a = r.on("state", (l, c) => {
        c === t10 && l[c] && (a(), o(l[c]));
      });
    });
  }
  function xE(t10, e, r) {
    return new Promise((n) => {
      const i = (a) => {
        r && r(a), n(a);
      };
      let o = t10.getState(e);
      o && i(o);
      const s = t10.on("state", (a, l) => {
        a === e && l && (s(), i(l));
      });
    });
  }
  var N0 = {}, L0 = {};
  Object.defineProperty(L0, "__esModule", { value: true });
  var B0 = {};
  (function(t10) {
    Object.defineProperty(t10, "__esModule", { value: true }), t10.createArrayPatch = t10.createObjectPatch = t10.createPatch = void 0;
    const e = (s) => (s instanceof Object && typeof s.toJSON == "function" && (s = s.toJSON()), typeof s == "function" ? s = void 0 : typeof s == "number" && (s !== s || s === 1 / 0 || s === -1 / 0) && (s = null), s), r = (s, a) => (s = e(s), a = e(a), n(s, a));
    t10.createPatch = r;
    const n = (s, a) => {
      if (s === void 0 && (s = null), a === void 0 && (a = null), s === a)
        return "none";
      if (typeof s == "object" && s !== null && (typeof a == "object" && a !== null)) {
        const u = Array.isArray(s), f = Array.isArray(a);
        if (u && f)
          return (0, t10.createArrayPatch)(s, a);
        if (!u && !f)
          return (0, t10.createObjectPatch)(s, a);
      }
      return "reset";
    }, i = (s, a) => {
      const l = [], c = {}, u = {};
      let f = 0, d = 0, h = 0;
      for (const p in s) {
        const y = e(s[p]);
        if (y === void 0)
          continue;
        f += 1;
        const b = e(a[p]);
        if (b === void 0) {
          l.push(p);
          continue;
        }
        const x = n(y, b);
        x === "reset" ? (c[p] = b, d += 1) : x !== "none" && (u[p] = x, h += 1);
      }
      if (f && l.length + d === f)
        return "reset";
      for (const p in a) {
        const y = e(a[p]);
        if (y === void 0)
          continue;
        if (f === 0)
          return "reset";
        e(s[p]) === void 0 && (c[p] = y, d += 1);
      }
      const g = { t: "o" };
      return l.length && (g.r = l), d && (g.s = c), h && (g.p = u), !g.r && !g.s && !g.p ? "none" : g;
    };
    t10.createObjectPatch = i;
    const o = (s, a) => {
      const l = s.length, c = a.length;
      let u, f, d, h, g;
      for (h = 0; h < l && h < c; h += 1) {
        const q = e(s[h]), te = e(a[h]);
        if (g = n(q, te), g !== "none")
          break;
      }
      if (h === l)
        return h === c ? "none" : { t: "a", s: [[
          l,
          0,
          ...a.slice(h, c).map(e)
        ]] };
      if (h === c)
        return { t: "a", s: [[h, l - h]] };
      let p = l - 1, y = c - 1, b;
      for (; p >= h && y >= h && (u = e(s[p]), f = e(a[y]), b = n(u, f), b === "none"); )
        p -= 1, y -= 1;
      if (p < h)
        return { t: "a", s: [[
          h,
          0,
          ...a.slice(h, y + 1).map(e)
        ]] };
      if (y < h)
        return { t: "a", s: [[h, p - h + 1]] };
      const x = p - h + 1, S = y - h + 1, C = x * S, _ = x + 1, L = new Array(C);
      L[0] = g, L[C - 1] = b;
      let F, V, W, X, G, ie;
      F = { 1: 0 };
      e:
        for (V = 0; V < C; V++)
          for (F = Object.create(F), W = -V; W <= V; W += 2) {
            for (W === -V || W !== V && F[W - 1] < F[W + 1] ? X = F[W + 1] : X = F[W - 1] + 1, G = X - W, d = G * x + X; d < C && X < x && G < S && (ie = L[d], ie || (u = e(s[h + X]), f = e(a[h + G]), ie = L[d] = n(u, f)), ie !== "reset"); )
              X++, G++, d += _;
            if (F[W] = X, X >= x && G >= S)
              break e;
          }
      let P10 = false;
      const z10 = {}, B = [];
      if (V === C) {
        if (h === 0 && x === l)
          return "reset";
        B.push([h, x, ...a.slice(h, y + 1)]);
      } else {
        W = x - S;
        let q = [NaN, NaN];
        for (; V-- >= 0; ) {
          const te = F[W - 1] === void 0 || F[W + 1] !== void 0 && F[W - 1] < F[W + 1];
          W = te ? W + 1 : W - 1, X = F[W], G = X - W;
          const Y = h + X;
          for (te ? (G !== -1 && (q[0] === Y ? (f = e(a[h + G]), q.splice(2, 0, f)) : B.push(q = [Y, 0, a[h + G]])), G++) : (G !== -1 && (q[0] === Y + 1 ? (q[0] -= 1, q[1] += 1) : B.push(q = [Y, 1])), X++), d = G * x + X; d < C && X < x && G < S && (ie = L[d], ie !== "reset"); )
            ie !== "none" && (z10[h + X] = ie, P10 = true), X++, G++, d += _;
          F = Object.getPrototypeOf(F);
        }
      }
      const O = { t: "a" };
      return P10 && (O.p = z10), B.length && (O.s = B), O;
    };
    t10.createArrayPatch = o;
  })(B0);
  var $r = {};
  Object.defineProperty($r, "__esModule", { value: true });
  $r.applyArrayPatch = $r.applyObjectPatch = $r.applyPatch = void 0;
  function F0(t10 = false) {
    const e = (i, o) => {
      if (o.t === "o")
        return r(i, o);
      if (o.t === "a")
        return n(i, o);
      throw Error("Invalid patch");
    }, r = (i, o) => {
      let s = t10 ? i : Object.assign({}, i);
      const a = o.r;
      if (a)
        for (const u of a)
          delete s[u];
      const l = o.s;
      if (l)
        for (const u in l)
          s[u] = l[u];
      const c = o.p;
      if (c)
        for (const u in c)
          s[u] = e(s[u], c[u]);
      return s;
    }, n = (i, o) => {
      const s = t10 ? i : [...i], a = o.p;
      if (a)
        for (const c in a)
          s[c] = e(s[c], a[c]);
      const l = o.s;
      if (l)
        for (let c of l)
          s.splice(...c);
      return s;
    };
    return { applyPatch: e, applyObjectPatch: r, applyArrayPatch: n };
  }
  const iu = F0(), ou = F0(true);
  $r.applyPatch = Object.assign(iu.applyPatch, {
    /**
     * Variant that modifies the target value in-place.
     */
    inPlace: ou.applyPatch
  });
  $r.applyObjectPatch = Object.assign(iu.applyObjectPatch, {
    /**
     * Variant that modifies the target object in-place.
     */
    inPlace: ou.applyObjectPatch
  });
  $r.applyArrayPatch = Object.assign(iu.applyArrayPatch, {
    /**
     * Variant that modifies the target array in-place.
     */
    inPlace: ou.applyArrayPatch
  });
  (function(t10) {
    var e = Jo && Jo.__createBinding || (Object.create ? function(n, i, o, s) {
      s === void 0 && (s = o);
      var a = Object.getOwnPropertyDescriptor(i, o);
      (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
        return i[o];
      } }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
      s === void 0 && (s = o), n[s] = i[o];
    }), r = Jo && Jo.__exportStar || function(n, i) {
      for (var o in n)
        o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && e(i, n, o);
    };
    Object.defineProperty(t10, "__esModule", { value: true }), r(L0, t10), r(B0, t10), r($r, t10);
  })(N0);
  var en = {
    DEBUG: false,
    LIB_VERSION: "2.45.0"
  }, St;
  if (typeof window > "u") {
    var td = {
      hostname: ""
    };
    St = {
      navigator: { userAgent: "" },
      document: {
        location: td,
        referrer: ""
      },
      screen: { width: 0, height: 0 },
      location: td
    };
  } else
    St = window;
  var Ca = Array.prototype, Cb = Function.prototype, j0 = Object.prototype, Hr = Ca.slice, Lo = j0.toString, Ta = j0.hasOwnProperty, lt = St.console, Ir = St.navigator, Ye = St.document, Pi = St.opera, Ks = St.screen, er = Ir.userAgent, _l = Cb.bind, rd = Ca.forEach, nd = Ca.indexOf, id = Ca.map, Tb = Array.isArray, pc = {}, T = {
    trim: function(t10) {
      return t10.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
  }, qe = {
    /** @type {function(...*)} */
    log: function() {
      if (en.DEBUG && !T.isUndefined(lt) && lt)
        try {
          lt.log.apply(lt, arguments);
        } catch {
          T.each(arguments, function(e) {
            lt.log(e);
          });
        }
    },
    /** @type {function(...*)} */
    warn: function() {
      if (en.DEBUG && !T.isUndefined(lt) && lt) {
        var t10 = ["Mixpanel warning:"].concat(T.toArray(arguments));
        try {
          lt.warn.apply(lt, t10);
        } catch {
          T.each(t10, function(r) {
            lt.warn(r);
          });
        }
      }
    },
    /** @type {function(...*)} */
    error: function() {
      if (en.DEBUG && !T.isUndefined(lt) && lt) {
        var t10 = ["Mixpanel error:"].concat(T.toArray(arguments));
        try {
          lt.error.apply(lt, t10);
        } catch {
          T.each(t10, function(r) {
            lt.error(r);
          });
        }
      }
    },
    /** @type {function(...*)} */
    critical: function() {
      if (!T.isUndefined(lt) && lt) {
        var t10 = ["Mixpanel error:"].concat(T.toArray(arguments));
        try {
          lt.error.apply(lt, t10);
        } catch {
          T.each(t10, function(r) {
            lt.error(r);
          });
        }
      }
    }
  }, Sl = function(t10, e) {
    return function() {
      return arguments[0] = "[" + e + "] " + arguments[0], t10.apply(qe, arguments);
    };
  }, su = function(t10) {
    return {
      log: Sl(qe.log, t10),
      error: Sl(qe.error, t10),
      critical: Sl(qe.critical, t10)
    };
  };
  T.bind = function(t10, e) {
    var r, n;
    if (_l && t10.bind === _l)
      return _l.apply(t10, Hr.call(arguments, 1));
    if (!T.isFunction(t10))
      throw new TypeError();
    return r = Hr.call(arguments, 2), n = function() {
      if (!(this instanceof n))
        return t10.apply(e, r.concat(Hr.call(arguments)));
      var i = {};
      i.prototype = t10.prototype;
      var o = new i();
      i.prototype = null;
      var s = t10.apply(o, r.concat(Hr.call(arguments)));
      return Object(s) === s ? s : o;
    }, n;
  };
  T.each = function(t10, e, r) {
    if (t10 != null) {
      if (rd && t10.forEach === rd)
        t10.forEach(e, r);
      else if (t10.length === +t10.length) {
        for (var n = 0, i = t10.length; n < i; n++)
          if (n in t10 && e.call(r, t10[n], n, t10) === pc)
            return;
      } else
        for (var o in t10)
          if (Ta.call(t10, o) && e.call(r, t10[o], o, t10) === pc)
            return;
    }
  };
  T.extend = function(t10) {
    return T.each(Hr.call(arguments, 1), function(e) {
      for (var r in e)
        e[r] !== void 0 && (t10[r] = e[r]);
    }), t10;
  };
  T.isArray = Tb || function(t10) {
    return Lo.call(t10) === "[object Array]";
  };
  T.isFunction = function(t10) {
    try {
      return /^\s*\bfunction\b/.test(t10);
    } catch {
      return false;
    }
  };
  T.isArguments = function(t10) {
    return !!(t10 && Ta.call(t10, "callee"));
  };
  T.toArray = function(t10) {
    return t10 ? t10.toArray ? t10.toArray() : T.isArray(t10) || T.isArguments(t10) ? Hr.call(t10) : T.values(t10) : [];
  };
  T.map = function(t10, e, r) {
    if (id && t10.map === id)
      return t10.map(e, r);
    var n = [];
    return T.each(t10, function(i) {
      n.push(e.call(r, i));
    }), n;
  };
  T.keys = function(t10) {
    var e = [];
    return t10 === null || T.each(t10, function(r, n) {
      e[e.length] = n;
    }), e;
  };
  T.values = function(t10) {
    var e = [];
    return t10 === null || T.each(t10, function(r) {
      e[e.length] = r;
    }), e;
  };
  T.include = function(t10, e) {
    var r = false;
    return t10 === null ? r : nd && t10.indexOf === nd ? t10.indexOf(e) != -1 : (T.each(t10, function(n) {
      if (r || (r = n === e))
        return pc;
    }), r);
  };
  T.includes = function(t10, e) {
    return t10.indexOf(e) !== -1;
  };
  T.inherit = function(t10, e) {
    return t10.prototype = new e(), t10.prototype.constructor = t10, t10.superclass = e.prototype, t10;
  };
  T.isObject = function(t10) {
    return t10 === Object(t10) && !T.isArray(t10);
  };
  T.isEmptyObject = function(t10) {
    if (T.isObject(t10)) {
      for (var e in t10)
        if (Ta.call(t10, e))
          return false;
      return true;
    }
    return false;
  };
  T.isUndefined = function(t10) {
    return t10 === void 0;
  };
  T.isString = function(t10) {
    return Lo.call(t10) == "[object String]";
  };
  T.isDate = function(t10) {
    return Lo.call(t10) == "[object Date]";
  };
  T.isNumber = function(t10) {
    return Lo.call(t10) == "[object Number]";
  };
  T.isElement = function(t10) {
    return !!(t10 && t10.nodeType === 1);
  };
  T.encodeDates = function(t10) {
    return T.each(t10, function(e, r) {
      T.isDate(e) ? t10[r] = T.formatDate(e) : T.isObject(e) && (t10[r] = T.encodeDates(e));
    }), t10;
  };
  T.timestamp = function() {
    return Date.now = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    }, Date.now();
  };
  T.formatDate = function(t10) {
    function e(r) {
      return r < 10 ? "0" + r : r;
    }
    return t10.getUTCFullYear() + "-" + e(t10.getUTCMonth() + 1) + "-" + e(t10.getUTCDate()) + "T" + e(t10.getUTCHours()) + ":" + e(t10.getUTCMinutes()) + ":" + e(t10.getUTCSeconds());
  };
  T.strip_empty_properties = function(t10) {
    var e = {};
    return T.each(t10, function(r, n) {
      T.isString(r) && r.length > 0 && (e[n] = r);
    }), e;
  };
  T.truncate = function(t10, e) {
    var r;
    return typeof t10 == "string" ? r = t10.slice(0, e) : T.isArray(t10) ? (r = [], T.each(t10, function(n) {
      r.push(T.truncate(n, e));
    })) : T.isObject(t10) ? (r = {}, T.each(t10, function(n, i) {
      r[i] = T.truncate(n, e);
    })) : r = t10, r;
  };
  T.JSONEncode = /* @__PURE__ */ function() {
    return function(t10) {
      var e = t10, r = function(i) {
        var o = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, s = {
          // table of character substitutions
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        };
        return o.lastIndex = 0, o.test(i) ? '"' + i.replace(o, function(a) {
          var l = s[a];
          return typeof l == "string" ? l : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + i + '"';
      }, n = function(i, o) {
        var s = "", a = "    ", l = 0, c = "", u = "", f = 0, d = s, h = [], g = o[i];
        switch (g && typeof g == "object" && typeof g.toJSON == "function" && (g = g.toJSON(i)), typeof g) {
          case "string":
            return r(g);
          case "number":
            return isFinite(g) ? String(g) : "null";
          case "boolean":
          case "null":
            return String(g);
          case "object":
            if (!g)
              return "null";
            if (s += a, h = [], Lo.apply(g) === "[object Array]") {
              for (f = g.length, l = 0; l < f; l += 1)
                h[l] = n(l, g) || "null";
              return u = h.length === 0 ? "[]" : s ? `[
` + s + h.join(`,
` + s) + `
` + d + "]" : "[" + h.join(",") + "]", s = d, u;
            }
            for (c in g)
              Ta.call(g, c) && (u = n(c, g), u && h.push(r(c) + (s ? ": " : ":") + u));
            return u = h.length === 0 ? "{}" : s ? "{" + h.join(",") + d + "}" : "{" + h.join(",") + "}", s = d, u;
        }
      };
      return n("", {
        "": e
      });
    };
  }();
  T.JSONDecode = function() {
    var t10, e, r = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: `
`,
      r: "\r",
      t: "	"
    }, n, i = function(h) {
      var g = new SyntaxError(h);
      throw g.at = t10, g.text = n, g;
    }, o = function(h) {
      return h && h !== e && i("Expected '" + h + "' instead of '" + e + "'"), e = n.charAt(t10), t10 += 1, e;
    }, s = function() {
      var h, g = "";
      for (e === "-" && (g = "-", o("-")); e >= "0" && e <= "9"; )
        g += e, o();
      if (e === ".")
        for (g += "."; o() && e >= "0" && e <= "9"; )
          g += e;
      if (e === "e" || e === "E")
        for (g += e, o(), (e === "-" || e === "+") && (g += e, o()); e >= "0" && e <= "9"; )
          g += e, o();
      if (h = +g, !isFinite(h))
        i("Bad number");
      else
        return h;
    }, a = function() {
      var h, g, p = "", y;
      if (e === '"')
        for (; o(); ) {
          if (e === '"')
            return o(), p;
          if (e === "\\")
            if (o(), e === "u") {
              for (y = 0, g = 0; g < 4 && (h = parseInt(o(), 16), !!isFinite(h)); g += 1)
                y = y * 16 + h;
              p += String.fromCharCode(y);
            } else if (typeof r[e] == "string")
              p += r[e];
            else
              break;
          else
            p += e;
        }
      i("Bad string");
    }, l = function() {
      for (; e && e <= " "; )
        o();
    }, c = function() {
      switch (e) {
        case "t":
          return o("t"), o("r"), o("u"), o("e"), true;
        case "f":
          return o("f"), o("a"), o("l"), o("s"), o("e"), false;
        case "n":
          return o("n"), o("u"), o("l"), o("l"), null;
      }
      i('Unexpected "' + e + '"');
    }, u, f = function() {
      var h = [];
      if (e === "[") {
        if (o("["), l(), e === "]")
          return o("]"), h;
        for (; e; ) {
          if (h.push(u()), l(), e === "]")
            return o("]"), h;
          o(","), l();
        }
      }
      i("Bad array");
    }, d = function() {
      var h, g = {};
      if (e === "{") {
        if (o("{"), l(), e === "}")
          return o("}"), g;
        for (; e; ) {
          if (h = a(), l(), o(":"), Object.hasOwnProperty.call(g, h) && i('Duplicate key "' + h + '"'), g[h] = u(), l(), e === "}")
            return o("}"), g;
          o(","), l();
        }
      }
      i("Bad object");
    };
    return u = function() {
      switch (l(), e) {
        case "{":
          return d();
        case "[":
          return f();
        case '"':
          return a();
        case "-":
          return s();
        default:
          return e >= "0" && e <= "9" ? s() : c();
      }
    }, function(h) {
      var g;
      return n = h, t10 = 0, e = " ", g = u(), l(), e && i("Syntax error"), g;
    };
  }();
  T.base64Encode = function(t10) {
    var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", r, n, i, o, s, a, l, c, u = 0, f = 0, d = "", h = [];
    if (!t10)
      return t10;
    t10 = T.utf8Encode(t10);
    do
      r = t10.charCodeAt(u++), n = t10.charCodeAt(u++), i = t10.charCodeAt(u++), c = r << 16 | n << 8 | i, o = c >> 18 & 63, s = c >> 12 & 63, a = c >> 6 & 63, l = c & 63, h[f++] = e.charAt(o) + e.charAt(s) + e.charAt(a) + e.charAt(l);
    while (u < t10.length);
    switch (d = h.join(""), t10.length % 3) {
      case 1:
        d = d.slice(0, -2) + "==";
        break;
      case 2:
        d = d.slice(0, -1) + "=";
        break;
    }
    return d;
  };
  T.utf8Encode = function(t10) {
    t10 = (t10 + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`);
    var e = "", r, n, i = 0, o;
    for (r = n = 0, i = t10.length, o = 0; o < i; o++) {
      var s = t10.charCodeAt(o), a = null;
      s < 128 ? n++ : s > 127 && s < 2048 ? a = String.fromCharCode(s >> 6 | 192, s & 63 | 128) : a = String.fromCharCode(s >> 12 | 224, s >> 6 & 63 | 128, s & 63 | 128), a !== null && (n > r && (e += t10.substring(r, n)), e += a, r = n = o + 1);
    }
    return n > r && (e += t10.substring(r, t10.length)), e;
  };
  T.UUID = /* @__PURE__ */ function() {
    var t10 = function() {
      for (var n = 1 * /* @__PURE__ */ new Date(), i = 0; n == 1 * /* @__PURE__ */ new Date(); )
        i++;
      return n.toString(16) + i.toString(16);
    }, e = function() {
      return Math.random().toString(16).replace(".", "");
    }, r = function() {
      var n = er, i, o, s = [], a = 0;
      function l(c, u) {
        var f, d = 0;
        for (f = 0; f < u.length; f++)
          d |= s[f] << f * 8;
        return c ^ d;
      }
      for (i = 0; i < n.length; i++)
        o = n.charCodeAt(i), s.unshift(o & 255), s.length >= 4 && (a = l(a, s), s = []);
      return s.length > 0 && (a = l(a, s)), a.toString(16);
    };
    return function() {
      var n = (Ks.height * Ks.width).toString(16);
      return t10() + "-" + e() + "-" + r() + "-" + n + "-" + t10();
    };
  }();
  var od = [
    "ahrefsbot",
    "baiduspider",
    "bingbot",
    "bingpreview",
    "facebookexternal",
    "petalbot",
    "pinterest",
    "screaming frog",
    "yahoo! slurp",
    "yandexbot",
    // a whole bunch of goog-specific crawlers
    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers
    "adsbot-google",
    "apis-google",
    "duplexweb-google",
    "feedfetcher-google",
    "google favicon",
    "google web preview",
    "google-read-aloud",
    "googlebot",
    "googleweblight",
    "mediapartners-google",
    "storebot-google"
  ];
  T.isBlockedUA = function(t10) {
    var e;
    for (t10 = t10.toLowerCase(), e = 0; e < od.length; e++)
      if (t10.indexOf(od[e]) !== -1)
        return true;
    return false;
  };
  T.HTTPBuildQuery = function(t10, e) {
    var r, n, i = [];
    return T.isUndefined(e) && (e = "&"), T.each(t10, function(o, s) {
      r = encodeURIComponent(o.toString()), n = encodeURIComponent(s), i[i.length] = n + "=" + r;
    }), i.join(e);
  };
  T.getQueryParam = function(t10, e) {
    e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
    var r = "[\\?&]" + e + "=([^&#]*)", n = new RegExp(r), i = n.exec(t10);
    if (i === null || i && typeof i[1] != "string" && i[1].length)
      return "";
    var o = i[1];
    try {
      o = decodeURIComponent(o);
    } catch {
      qe.error("Skipping decoding for malformed query param: " + o);
    }
    return o.replace(/\+/g, " ");
  };
  T.cookie = {
    get: function(t10) {
      for (var e = t10 + "=", r = Ye.cookie.split(";"), n = 0; n < r.length; n++) {
        for (var i = r[n]; i.charAt(0) == " "; )
          i = i.substring(1, i.length);
        if (i.indexOf(e) === 0)
          return decodeURIComponent(i.substring(e.length, i.length));
      }
      return null;
    },
    parse: function(t10) {
      var e;
      try {
        e = T.JSONDecode(T.cookie.get(t10)) || {};
      } catch {
      }
      return e;
    },
    set_seconds: function(t10, e, r, n, i, o, s) {
      var a = "", l = "", c = "";
      if (s)
        a = "; domain=" + s;
      else if (n) {
        var u = sd(Ye.location.hostname);
        a = u ? "; domain=." + u : "";
      }
      if (r) {
        var f = /* @__PURE__ */ new Date();
        f.setTime(f.getTime() + r * 1e3), l = "; expires=" + f.toGMTString();
      }
      o && (i = true, c = "; SameSite=None"), i && (c += "; secure"), Ye.cookie = t10 + "=" + encodeURIComponent(e) + l + "; path=/" + a + c;
    },
    set: function(t10, e, r, n, i, o, s) {
      var a = "", l = "", c = "";
      if (s)
        a = "; domain=" + s;
      else if (n) {
        var u = sd(Ye.location.hostname);
        a = u ? "; domain=." + u : "";
      }
      if (r) {
        var f = /* @__PURE__ */ new Date();
        f.setTime(f.getTime() + r * 24 * 60 * 60 * 1e3), l = "; expires=" + f.toGMTString();
      }
      o && (i = true, c = "; SameSite=None"), i && (c += "; secure");
      var d = t10 + "=" + encodeURIComponent(e) + l + "; path=/" + a + c;
      return Ye.cookie = d, d;
    },
    remove: function(t10, e, r) {
      T.cookie.set(t10, "", -1, e, false, false, r);
    }
  };
  var El = null, Ys = function(t10, e) {
    if (El !== null && !e)
      return El;
    var r = true;
    try {
      t10 = t10 || window.localStorage;
      var n = "__mplss_" + au(8), i = "xyz";
      t10.setItem(n, i), t10.getItem(n) !== i && (r = false), t10.removeItem(n);
    } catch {
      r = false;
    }
    return El = r, r;
  };
  T.localStorage = {
    is_supported: function(t10) {
      var e = Ys(null, t10);
      return e || qe.error("localStorage unsupported; falling back to cookie store"), e;
    },
    error: function(t10) {
      qe.error("localStorage error: " + t10);
    },
    get: function(t10) {
      try {
        return window.localStorage.getItem(t10);
      } catch (e) {
        T.localStorage.error(e);
      }
      return null;
    },
    parse: function(t10) {
      try {
        return T.JSONDecode(T.localStorage.get(t10)) || {};
      } catch {
      }
      return null;
    },
    set: function(t10, e) {
      try {
        window.localStorage.setItem(t10, e);
      } catch (r) {
        T.localStorage.error(r);
      }
    },
    remove: function(t10) {
      try {
        window.localStorage.removeItem(t10);
      } catch (e) {
        T.localStorage.error(e);
      }
    }
  };
  T.register_event = function() {
    var t10 = function(n, i, o, s, a) {
      if (!n) {
        qe.error("No valid element provided to register_event");
        return;
      }
      if (n.addEventListener && !s)
        n.addEventListener(i, o, !!a);
      else {
        var l = "on" + i, c = n[l];
        n[l] = e(n, o, c);
      }
    };
    function e(n, i, o) {
      var s = function(a) {
        if (a = a || r(window.event), !!a) {
          var l = true, c, u;
          return T.isFunction(o) && (c = o(a)), u = i.call(n, a), (c === false || u === false) && (l = false), l;
        }
      };
      return s;
    }
    function r(n) {
      return n && (n.preventDefault = r.preventDefault, n.stopPropagation = r.stopPropagation), n;
    }
    return r.preventDefault = function() {
      this.returnValue = false;
    }, r.stopPropagation = function() {
      this.cancelBubble = true;
    }, t10;
  }();
  var Ib = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
  T.dom_query = /* @__PURE__ */ function() {
    function t10(i) {
      return i.all ? i.all : i.getElementsByTagName("*");
    }
    var e = /[\t\r\n]/g;
    function r(i, o) {
      var s = " " + o + " ";
      return (" " + i.className + " ").replace(e, " ").indexOf(s) >= 0;
    }
    function n(i) {
      if (!Ye.getElementsByTagName)
        return [];
      var o = i.split(" "), s, a, l, c, u, f, d, h, g, p, y = [Ye];
      for (f = 0; f < o.length; f++) {
        if (s = o[f].replace(/^\s+/, "").replace(/\s+$/, ""), s.indexOf("#") > -1) {
          a = s.split("#"), l = a[0];
          var b = a[1], x = Ye.getElementById(b);
          if (!x || l && x.nodeName.toLowerCase() != l)
            return [];
          y = [x];
          continue;
        }
        if (s.indexOf(".") > -1) {
          a = s.split("."), l = a[0];
          var S = a[1];
          for (l || (l = "*"), c = [], u = 0, d = 0; d < y.length; d++)
            for (l == "*" ? g = t10(y[d]) : g = y[d].getElementsByTagName(l), h = 0; h < g.length; h++)
              c[u++] = g[h];
          for (y = [], p = 0, d = 0; d < c.length; d++)
            c[d].className && T.isString(c[d].className) && // some SVG elements have classNames which are not strings
            r(c[d], S) && (y[p++] = c[d]);
          continue;
        }
        var C = s.match(Ib);
        if (C) {
          l = C[1];
          var _ = C[2], L = C[3], F = C[4];
          for (l || (l = "*"), c = [], u = 0, d = 0; d < y.length; d++)
            for (l == "*" ? g = t10(y[d]) : g = y[d].getElementsByTagName(l), h = 0; h < g.length; h++)
              c[u++] = g[h];
          y = [], p = 0;
          var V;
          switch (L) {
            case "=":
              V = function(W) {
                return W.getAttribute(_) == F;
              };
              break;
            case "~":
              V = function(W) {
                return W.getAttribute(_).match(new RegExp("\\b" + F + "\\b"));
              };
              break;
            case "|":
              V = function(W) {
                return W.getAttribute(_).match(new RegExp("^" + F + "-?"));
              };
              break;
            case "^":
              V = function(W) {
                return W.getAttribute(_).indexOf(F) === 0;
              };
              break;
            case "$":
              V = function(W) {
                return W.getAttribute(_).lastIndexOf(F) == W.getAttribute(_).length - F.length;
              };
              break;
            case "*":
              V = function(W) {
                return W.getAttribute(_).indexOf(F) > -1;
              };
              break;
            default:
              V = function(W) {
                return W.getAttribute(_);
              };
          }
          for (y = [], p = 0, d = 0; d < c.length; d++)
            V(c[d]) && (y[p++] = c[d]);
          continue;
        }
        for (l = s, c = [], u = 0, d = 0; d < y.length; d++)
          for (g = y[d].getElementsByTagName(l), h = 0; h < g.length; h++)
            c[u++] = g[h];
        y = c;
      }
      return y;
    }
    return function(i) {
      return T.isElement(i) ? [i] : T.isObject(i) && !T.isUndefined(i.length) ? i : n.call(this, i);
    };
  }();
  T.info = {
    campaignParams: function() {
      var t10 = "utm_source utm_medium utm_campaign utm_content utm_term".split(" "), e = "", r = {};
      return T.each(t10, function(n) {
        e = T.getQueryParam(Ye.URL, n), e.length && (r[n] = e);
      }), r;
    },
    searchEngine: function(t10) {
      return t10.search("https?://(.*)google.([^/?]*)") === 0 ? "google" : t10.search("https?://(.*)bing.com") === 0 ? "bing" : t10.search("https?://(.*)yahoo.com") === 0 ? "yahoo" : t10.search("https?://(.*)duckduckgo.com") === 0 ? "duckduckgo" : null;
    },
    searchInfo: function(t10) {
      var e = T.info.searchEngine(t10), r = e != "yahoo" ? "q" : "p", n = {};
      if (e !== null) {
        n.$search_engine = e;
        var i = T.getQueryParam(t10, r);
        i.length && (n.mp_keyword = i);
      }
      return n;
    },
    /**
     * This function detects which browser is running this script.
     * The order of the checks are important since many user agents
     * include key words used in later checks.
     */
    browser: function(t10, e, r) {
      return e = e || "", r || T.includes(t10, " OPR/") ? T.includes(t10, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(t10) ? "BlackBerry" : T.includes(t10, "IEMobile") || T.includes(t10, "WPDesktop") ? "Internet Explorer Mobile" : T.includes(t10, "SamsungBrowser/") ? "Samsung Internet" : T.includes(t10, "Edge") || T.includes(t10, "Edg/") ? "Microsoft Edge" : T.includes(t10, "FBIOS") ? "Facebook Mobile" : T.includes(t10, "Chrome") ? "Chrome" : T.includes(t10, "CriOS") ? "Chrome iOS" : T.includes(t10, "UCWEB") || T.includes(t10, "UCBrowser") ? "UC Browser" : T.includes(t10, "FxiOS") ? "Firefox iOS" : T.includes(e, "Apple") ? T.includes(t10, "Mobile") ? "Mobile Safari" : "Safari" : T.includes(t10, "Android") ? "Android Mobile" : T.includes(t10, "Konqueror") ? "Konqueror" : T.includes(t10, "Firefox") ? "Firefox" : T.includes(t10, "MSIE") || T.includes(t10, "Trident/") ? "Internet Explorer" : T.includes(t10, "Gecko") ? "Mozilla" : "";
    },
    /**
     * This function detects which browser version is running this script,
     * parsing major and minor version (e.g., 42.1). User agent strings from:
     * http://www.useragentstring.com/pages/useragentstring.php
     */
    browserVersion: function(t10, e, r) {
      var n = T.info.browser(t10, e, r), i = {
        "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
        "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
        Chrome: /Chrome\/(\d+(\.\d+)?)/,
        "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
        "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
        Safari: /Version\/(\d+(\.\d+)?)/,
        "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
        Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
        Firefox: /Firefox\/(\d+(\.\d+)?)/,
        "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
        Konqueror: /Konqueror:(\d+(\.\d+)?)/,
        BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
        "Android Mobile": /android\s(\d+(\.\d+)?)/,
        "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
        "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
        Mozilla: /rv:(\d+(\.\d+)?)/
      }, o = i[n];
      if (o === void 0)
        return null;
      var s = t10.match(o);
      return s ? parseFloat(s[s.length - 2]) : null;
    },
    os: function() {
      var t10 = er;
      return /Windows/i.test(t10) ? /Phone/.test(t10) || /WPDesktop/.test(t10) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t10) ? "iOS" : /Android/.test(t10) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t10) ? "BlackBerry" : /Mac/i.test(t10) ? "Mac OS X" : /Linux/.test(t10) ? "Linux" : /CrOS/.test(t10) ? "Chrome OS" : "";
    },
    device: function(t10) {
      return /Windows Phone/i.test(t10) || /WPDesktop/.test(t10) ? "Windows Phone" : /iPad/.test(t10) ? "iPad" : /iPod/.test(t10) ? "iPod Touch" : /iPhone/.test(t10) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(t10) ? "BlackBerry" : /Android/.test(t10) ? "Android" : "";
    },
    referringDomain: function(t10) {
      var e = t10.split("/");
      return e.length >= 3 ? e[2] : "";
    },
    properties: function() {
      return T.extend(T.strip_empty_properties({
        $os: T.info.os(),
        $browser: T.info.browser(er, Ir.vendor, Pi),
        $referrer: Ye.referrer,
        $referring_domain: T.info.referringDomain(Ye.referrer),
        $device: T.info.device(er)
      }), {
        $current_url: St.location.href,
        $browser_version: T.info.browserVersion(er, Ir.vendor, Pi),
        $screen_height: Ks.height,
        $screen_width: Ks.width,
        mp_lib: "web",
        $lib_version: en.LIB_VERSION,
        $insert_id: au(),
        time: T.timestamp() / 1e3
        // epoch time in seconds
      });
    },
    people_properties: function() {
      return T.extend(T.strip_empty_properties({
        $os: T.info.os(),
        $browser: T.info.browser(er, Ir.vendor, Pi)
      }), {
        $browser_version: T.info.browserVersion(er, Ir.vendor, Pi)
      });
    },
    pageviewInfo: function(t10) {
      return T.strip_empty_properties({
        mp_page: t10,
        mp_referrer: Ye.referrer,
        mp_browser: T.info.browser(er, Ir.vendor, Pi),
        mp_platform: T.info.os()
      });
    }
  };
  var au = function(t10) {
    var e = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
    return t10 ? e.substring(0, t10) : e;
  }, Ob = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i, Pb = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i, sd = function(t10) {
    var e = Pb, r = t10.split("."), n = r[r.length - 1];
    (n.length > 4 || n === "com" || n === "org") && (e = Ob);
    var i = t10.match(e);
    return i ? i[0] : "";
  }, Xs = null, Js = null;
  typeof JSON < "u" && (Xs = JSON.stringify, Js = JSON.parse);
  Xs = Xs || T.JSONEncode;
  Js = Js || T.JSONDecode;
  T.toArray = T.toArray;
  T.isObject = T.isObject;
  T.JSONEncode = T.JSONEncode;
  T.JSONDecode = T.JSONDecode;
  T.isBlockedUA = T.isBlockedUA;
  T.isEmptyObject = T.isEmptyObject;
  T.info = T.info;
  T.info.device = T.info.device;
  T.info.browser = T.info.browser;
  T.info.browserVersion = T.info.browserVersion;
  T.info.properties = T.info.properties;
  var Wr = function() {
  };
  Wr.prototype.create_properties = function() {
  };
  Wr.prototype.event_handler = function() {
  };
  Wr.prototype.after_track_handler = function() {
  };
  Wr.prototype.init = function(t10) {
    return this.mp = t10, this;
  };
  Wr.prototype.track = function(t10, e, r, n) {
    var i = this, o = T.dom_query(t10);
    if (o.length === 0) {
      qe.error("The DOM query (" + t10 + ") returned 0 elements");
      return;
    }
    return T.each(o, function(s) {
      T.register_event(s, this.override_event, function(a) {
        var l = {}, c = i.create_properties(r, this), u = i.mp.get_config("track_links_timeout");
        i.event_handler(a, this, l), window.setTimeout(i.track_callback(n, c, l, true), u), i.mp.track(e, c, i.track_callback(n, c, l));
      });
    }, this), true;
  };
  Wr.prototype.track_callback = function(t10, e, r, n) {
    n = n || false;
    var i = this;
    return function() {
      r.callback_fired || (r.callback_fired = true, !(t10 && t10(n, e) === false) && i.after_track_handler(e, r, n));
    };
  };
  Wr.prototype.create_properties = function(t10, e) {
    var r;
    return typeof t10 == "function" ? r = t10(e) : r = T.extend({}, t10), r;
  };
  var di = function() {
    this.override_event = "click";
  };
  T.inherit(di, Wr);
  di.prototype.create_properties = function(t10, e) {
    var r = di.superclass.create_properties.apply(this, arguments);
    return e.href && (r.url = e.href), r;
  };
  di.prototype.event_handler = function(t10, e, r) {
    r.new_tab = t10.which === 2 || t10.metaKey || t10.ctrlKey || e.target === "_blank", r.href = e.href, r.new_tab || t10.preventDefault();
  };
  di.prototype.after_track_handler = function(t10, e) {
    e.new_tab || setTimeout(function() {
      window.location = e.href;
    }, 0);
  };
  var Ia = function() {
    this.override_event = "submit";
  };
  T.inherit(Ia, Wr);
  Ia.prototype.event_handler = function(t10, e, r) {
    r.element = e, t10.preventDefault();
  };
  Ia.prototype.after_track_handler = function(t10, e) {
    setTimeout(function() {
      e.element.submit();
    }, 0);
  };
  var Rb = su("lock"), W0 = function(t10, e) {
    e = e || {}, this.storageKey = t10, this.storage = e.storage || window.localStorage, this.pollIntervalMS = e.pollIntervalMS || 100, this.timeoutMS = e.timeoutMS || 2e3;
  };
  W0.prototype.withLock = function(t10, e, r) {
    !r && typeof e != "function" && (r = e, e = null);
    var n = r || (/* @__PURE__ */ new Date()).getTime() + "|" + Math.random(), i = (/* @__PURE__ */ new Date()).getTime(), o = this.storageKey, s = this.pollIntervalMS, a = this.timeoutMS, l = this.storage, c = o + ":X", u = o + ":Y", f = o + ":Z", d = function(x) {
      e && e(x);
    }, h = function(x) {
      if ((/* @__PURE__ */ new Date()).getTime() - i > a) {
        Rb.error("Timeout waiting for mutex on " + o + "; clearing lock. [" + n + "]"), l.removeItem(f), l.removeItem(u), y();
        return;
      }
      setTimeout(function() {
        try {
          x();
        } catch (S) {
          d(S);
        }
      }, s * (Math.random() + 0.1));
    }, g = function(x, S) {
      x() ? S() : h(function() {
        g(x, S);
      });
    }, p = function() {
      var x = l.getItem(u);
      if (x && x !== n)
        return false;
      if (l.setItem(u, n), l.getItem(u) === n)
        return true;
      if (!Ys(l, true))
        throw new Error("localStorage support dropped while acquiring lock");
      return false;
    }, y = function() {
      l.setItem(c, n), g(p, function() {
        if (l.getItem(c) === n) {
          b();
          return;
        }
        h(function() {
          if (l.getItem(u) !== n) {
            y();
            return;
          }
          g(function() {
            return !l.getItem(f);
          }, b);
        });
      });
    }, b = function() {
      l.setItem(f, "1");
      try {
        t10();
      } finally {
        l.removeItem(f), l.getItem(u) === n && l.removeItem(u), l.getItem(c) === n && l.removeItem(c);
      }
    };
    try {
      if (Ys(l, true))
        y();
      else
        throw new Error("localStorage support check failed");
    } catch (x) {
      d(x);
    }
  };
  var ad = su("batch"), cn = function(t10, e) {
    e = e || {}, this.storageKey = t10, this.storage = e.storage || window.localStorage, this.reportError = e.errorReporter || T.bind(ad.error, ad), this.lock = new W0(t10, { storage: this.storage }), this.pid = e.pid || null, this.memQueue = [];
  };
  cn.prototype.enqueue = function(t10, e, r) {
    var n = {
      id: au(),
      flushAfter: (/* @__PURE__ */ new Date()).getTime() + e * 2,
      payload: t10
    };
    this.lock.withLock(T.bind(function() {
      var o;
      try {
        var s = this.readFromStorage();
        s.push(n), o = this.saveToStorage(s), o && this.memQueue.push(n);
      } catch {
        this.reportError("Error enqueueing item", t10), o = false;
      }
      r && r(o);
    }, this), T.bind(function(o) {
      this.reportError("Error acquiring storage lock", o), r && r(false);
    }, this), this.pid);
  };
  cn.prototype.fillBatch = function(t10) {
    var e = this.memQueue.slice(0, t10);
    if (e.length < t10) {
      var r = this.readFromStorage();
      if (r.length) {
        var n = {};
        T.each(e, function(s) {
          n[s.id] = true;
        });
        for (var i = 0; i < r.length; i++) {
          var o = r[i];
          if ((/* @__PURE__ */ new Date()).getTime() > o.flushAfter && !n[o.id] && (o.orphaned = true, e.push(o), e.length >= t10))
            break;
        }
      }
    }
    return e;
  };
  var ld = function(t10, e) {
    var r = [];
    return T.each(t10, function(n) {
      n.id && !e[n.id] && r.push(n);
    }), r;
  };
  cn.prototype.removeItemsByID = function(t10, e) {
    var r = {};
    T.each(t10, function(i) {
      r[i] = true;
    }), this.memQueue = ld(this.memQueue, r);
    var n = T.bind(function() {
      var i;
      try {
        var o = this.readFromStorage();
        if (o = ld(o, r), i = this.saveToStorage(o), i) {
          o = this.readFromStorage();
          for (var s = 0; s < o.length; s++) {
            var a = o[s];
            if (a.id && r[a.id])
              return this.reportError("Item not removed from storage"), false;
          }
        }
      } catch {
        this.reportError("Error removing items", t10), i = false;
      }
      return i;
    }, this);
    this.lock.withLock(function() {
      var o = n();
      e && e(o);
    }, T.bind(function(o) {
      var s = false;
      if (this.reportError("Error acquiring storage lock", o), !Ys(this.storage, true) && (s = n(), !s))
        try {
          this.storage.removeItem(this.storageKey);
        } catch (a) {
          this.reportError("Error clearing queue", a);
        }
      e && e(s);
    }, this), this.pid);
  };
  var cd = function(t10, e) {
    var r = [];
    return T.each(t10, function(n) {
      var i = n.id;
      if (i in e) {
        var o = e[i];
        o !== null && (n.payload = o, r.push(n));
      } else
        r.push(n);
    }), r;
  };
  cn.prototype.updatePayloads = function(t10, e) {
    this.memQueue = cd(this.memQueue, t10), this.lock.withLock(T.bind(function() {
      var n;
      try {
        var i = this.readFromStorage();
        i = cd(i, t10), n = this.saveToStorage(i);
      } catch {
        this.reportError("Error updating items", t10), n = false;
      }
      e && e(n);
    }, this), T.bind(function(n) {
      this.reportError("Error acquiring storage lock", n), e && e(false);
    }, this), this.pid);
  };
  cn.prototype.readFromStorage = function() {
    var t10;
    try {
      t10 = this.storage.getItem(this.storageKey), t10 && (t10 = Js(t10), T.isArray(t10) || (this.reportError("Invalid storage entry:", t10), t10 = null));
    } catch (e) {
      this.reportError("Error retrieving queue", e), t10 = null;
    }
    return t10 || [];
  };
  cn.prototype.saveToStorage = function(t10) {
    try {
      return this.storage.setItem(this.storageKey, Xs(t10)), true;
    } catch (e) {
      return this.reportError("Error saving queue", e), false;
    }
  };
  cn.prototype.clear = function() {
    this.memQueue = [], this.storage.removeItem(this.storageKey);
  };
  var Db = 10 * 60 * 1e3, ro = su("batch"), xr = function(t10, e) {
    this.errorReporter = e.errorReporter, this.queue = new cn(t10, {
      errorReporter: T.bind(this.reportError, this),
      storage: e.storage
    }), this.libConfig = e.libConfig, this.sendRequest = e.sendRequestFunc, this.beforeSendHook = e.beforeSendHook, this.stopAllBatching = e.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0;
  };
  xr.prototype.enqueue = function(t10, e) {
    this.queue.enqueue(t10, this.flushInterval, e);
  };
  xr.prototype.start = function() {
    this.stopped = false, this.consecutiveRemovalFailures = 0, this.flush();
  };
  xr.prototype.stop = function() {
    this.stopped = true, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null);
  };
  xr.prototype.clear = function() {
    this.queue.clear();
  };
  xr.prototype.resetBatchSize = function() {
    this.batchSize = this.libConfig.batch_size;
  };
  xr.prototype.resetFlush = function() {
    this.scheduleFlush(this.libConfig.batch_flush_interval_ms);
  };
  xr.prototype.scheduleFlush = function(t10) {
    this.flushInterval = t10, this.stopped || (this.timeoutID = setTimeout(T.bind(this.flush, this), this.flushInterval));
  };
  xr.prototype.flush = function(t10) {
    try {
      if (this.requestInProgress) {
        ro.log("Flush: Request already in progress");
        return;
      }
      t10 = t10 || {};
      var e = this.libConfig.batch_request_timeout_ms, r = (/* @__PURE__ */ new Date()).getTime(), n = this.batchSize, i = this.queue.fillBatch(n), o = [], s = {};
      if (T.each(i, function(c) {
        var u = c.payload;
        this.beforeSendHook && !c.orphaned && (u = this.beforeSendHook(u)), u && o.push(u), s[c.id] = u;
      }, this), o.length < 1) {
        this.resetFlush();
        return;
      }
      this.requestInProgress = true;
      var a = T.bind(function(c) {
        this.requestInProgress = false;
        try {
          var u = false;
          if (t10.unloading)
            this.queue.updatePayloads(s);
          else if (T.isObject(c) && c.error === "timeout" && (/* @__PURE__ */ new Date()).getTime() - r >= e)
            this.reportError("Network timeout; retrying"), this.flush();
          else if (T.isObject(c) && c.xhr_req && (c.xhr_req.status >= 500 || c.xhr_req.status === 429 || c.error === "timeout")) {
            var f = this.flushInterval * 2, d = c.xhr_req.responseHeaders;
            if (d) {
              var h = d["Retry-After"];
              h && (f = parseInt(h, 10) * 1e3 || f);
            }
            f = Math.min(Db, f), this.reportError("Error; retry in " + f + " ms"), this.scheduleFlush(f);
          } else if (T.isObject(c) && c.xhr_req && c.xhr_req.status === 413)
            if (i.length > 1) {
              var g = Math.max(1, Math.floor(n / 2));
              this.batchSize = Math.min(this.batchSize, g, i.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush();
            } else
              this.reportError("Single-event request too large; dropping", i), this.resetBatchSize(), u = true;
          else
            u = true;
          u && this.queue.removeItemsByID(
            T.map(i, function(p) {
              return p.id;
            }),
            T.bind(function(p) {
              p ? (this.consecutiveRemovalFailures = 0, this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush());
            }, this)
          );
        } catch (p) {
          this.reportError("Error handling API response", p), this.resetFlush();
        }
      }, this), l = {
        method: "POST",
        verbose: true,
        ignore_json_errors: true,
        // eslint-disable-line camelcase
        timeout_ms: e
        // eslint-disable-line camelcase
      };
      t10.unloading && (l.transport = "sendBeacon"), ro.log("MIXPANEL REQUEST:", o), this.sendRequest(o, l, a);
    } catch (c) {
      this.reportError("Error flushing request queue", c), this.resetFlush();
    }
  };
  xr.prototype.reportError = function(t10, e) {
    if (ro.error.apply(ro.error, arguments), this.errorReporter)
      try {
        e instanceof Error || (e = new Error(t10)), this.errorReporter(t10, e);
      } catch (r) {
        ro.error(r);
      }
  };
  var Mb = "__mp_opt_in_out_";
  function Nb(t10, e) {
    V0(true, t10, e);
  }
  function Lb(t10, e) {
    V0(false, t10, e);
  }
  function Bb(t10, e) {
    return z0(t10, e) === "1";
  }
  function U0(t10, e) {
    if (jb(e))
      return qe.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), true;
    var r = z0(t10, e) === "0";
    return r && qe.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), r;
  }
  function Bo(t10) {
    return uu(t10, function(e) {
      return this.get_config(e);
    });
  }
  function un(t10) {
    return uu(t10, function(e) {
      return this._get_config(e);
    });
  }
  function Si(t10) {
    return uu(t10, function(e) {
      return this._get_config(e);
    });
  }
  function Fb(t10, e) {
    e = e || {}, lu(e).remove(
      cu(t10, e),
      !!e.crossSubdomainCookie,
      e.cookieDomain
    );
  }
  function lu(t10) {
    return t10 = t10 || {}, t10.persistenceType === "localStorage" ? T.localStorage : T.cookie;
  }
  function cu(t10, e) {
    return e = e || {}, (e.persistencePrefix || Mb) + t10;
  }
  function z0(t10, e) {
    return lu(e).get(cu(t10, e));
  }
  function jb(t10) {
    if (t10 && t10.ignoreDnt)
      return false;
    var e = t10 && t10.window || St, r = e.navigator || {}, n = false;
    return T.each([
      r.doNotTrack,
      // standard
      r.msDoNotTrack,
      e.doNotTrack
    ], function(i) {
      T.includes([true, 1, "1", "yes"], i) && (n = true);
    }), n;
  }
  function V0(t10, e, r) {
    if (!T.isString(e) || !e.length) {
      qe.error("gdpr." + (t10 ? "optIn" : "optOut") + " called with an invalid token");
      return;
    }
    r = r || {}, lu(r).set(
      cu(e, r),
      t10 ? 1 : 0,
      T.isNumber(r.cookieExpiration) ? r.cookieExpiration : null,
      !!r.crossSubdomainCookie,
      !!r.secureCookie,
      !!r.crossSiteCookie,
      r.cookieDomain
    ), r.track && t10 && r.track(r.trackEventName || "$opt_in", r.trackProperties, {
      send_immediately: true
    });
  }
  function uu(t10, e) {
    return function() {
      var r = false;
      try {
        var n = e.call(this, "token"), i = e.call(this, "ignore_dnt"), o = e.call(this, "opt_out_tracking_persistence_type"), s = e.call(this, "opt_out_tracking_cookie_prefix"), a = e.call(this, "window");
        n && (r = U0(n, {
          ignoreDnt: i,
          persistenceType: o,
          persistencePrefix: s,
          window: a
        }));
      } catch (c) {
        qe.error("Unexpected error when checking tracking opt-out status: " + c);
      }
      if (!r)
        return t10.apply(this, arguments);
      var l = arguments[arguments.length - 1];
      typeof l == "function" && l(0);
    };
  }
  var nn = "$set", hi = "$set_once", rr = "$unset", Mn = "$add", Fr = "$append", Nn = "$union", on = "$remove", Wb = "$delete", q0 = {
    set_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[nn] = n, r;
    },
    unset_action: function(t10) {
      var e = {}, r = [];
      return T.isArray(t10) || (t10 = [t10]), T.each(t10, function(n) {
        this._is_reserved_property(n) || r.push(n);
      }, this), e[rr] = r, e;
    },
    set_once_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[hi] = n, r;
    },
    union_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = T.isArray(i) ? i : [i]);
      }, this) : n[t10] = T.isArray(e) ? e : [e], r[Nn] = n, r;
    },
    append_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[Fr] = n, r;
    },
    remove_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[on] = n, r;
    },
    delete_action: function() {
      var t10 = {};
      return t10[Wb] = "", t10;
    }
  }, et = function() {
  };
  T.extend(et.prototype, q0);
  et.prototype._init = function(t10, e, r) {
    this._mixpanel = t10, this._group_key = e, this._group_id = r;
  };
  et.prototype.set = Si(function(t10, e, r) {
    var n = this.set_action(t10, e);
    return T.isObject(t10) && (r = e), this._send_request(n, r);
  });
  et.prototype.set_once = Si(function(t10, e, r) {
    var n = this.set_once_action(t10, e);
    return T.isObject(t10) && (r = e), this._send_request(n, r);
  });
  et.prototype.unset = Si(function(t10, e) {
    var r = this.unset_action(t10);
    return this._send_request(r, e);
  });
  et.prototype.union = Si(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.union_action(t10, e);
    return this._send_request(n, r);
  });
  et.prototype.delete = Si(function(t10) {
    var e = this.delete_action();
    return this._send_request(e, t10);
  });
  et.prototype.remove = Si(function(t10, e, r) {
    var n = this.remove_action(t10, e);
    return this._send_request(n, r);
  });
  et.prototype._send_request = function(t10, e) {
    t10.$group_key = this._group_key, t10.$group_id = this._group_id, t10.$token = this._get_config("token");
    var r = T.encodeDates(t10);
    return this._mixpanel._track_or_batch({
      type: "groups",
      data: r,
      endpoint: this._get_config("api_host") + "/groups/",
      batcher: this._mixpanel.request_batchers.groups
    }, e);
  };
  et.prototype._is_reserved_property = function(t10) {
    return t10 === "$group_key" || t10 === "$group_id";
  };
  et.prototype._get_config = function(t10) {
    return this._mixpanel.get_config(t10);
  };
  et.prototype.toString = function() {
    return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id;
  };
  et.prototype.remove = et.prototype.remove;
  et.prototype.set = et.prototype.set;
  et.prototype.set_once = et.prototype.set_once;
  et.prototype.union = et.prototype.union;
  et.prototype.unset = et.prototype.unset;
  et.prototype.toString = et.prototype.toString;
  var Ee = function() {
  };
  T.extend(Ee.prototype, q0);
  Ee.prototype._init = function(t10) {
    this._mixpanel = t10;
  };
  Ee.prototype.set = un(function(t10, e, r) {
    var n = this.set_action(t10, e);
    return T.isObject(t10) && (r = e), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), n[nn] = T.extend(
      {},
      T.info.people_properties(),
      this._mixpanel.persistence.get_referrer_info(),
      n[nn]
    ), this._send_request(n, r);
  });
  Ee.prototype.set_once = un(function(t10, e, r) {
    var n = this.set_once_action(t10, e);
    return T.isObject(t10) && (r = e), this._send_request(n, r);
  });
  Ee.prototype.unset = un(function(t10, e) {
    var r = this.unset_action(t10);
    return this._send_request(r, e);
  });
  Ee.prototype.increment = un(function(t10, e, r) {
    var n = {}, i = {};
    return T.isObject(t10) ? (T.each(t10, function(o, s) {
      if (!this._is_reserved_property(s))
        if (isNaN(parseFloat(o))) {
          qe.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
          return;
        } else
          i[s] = o;
    }, this), r = e) : (T.isUndefined(e) && (e = 1), i[t10] = e), n[Mn] = i, this._send_request(n, r);
  });
  Ee.prototype.append = un(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.append_action(t10, e);
    return this._send_request(n, r);
  });
  Ee.prototype.remove = un(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.remove_action(t10, e);
    return this._send_request(n, r);
  });
  Ee.prototype.union = un(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.union_action(t10, e);
    return this._send_request(n, r);
  });
  Ee.prototype.track_charge = un(function(t10, e, r) {
    if (!T.isNumber(t10) && (t10 = parseFloat(t10), isNaN(t10))) {
      qe.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
      return;
    }
    return this.append("$transactions", T.extend({
      $amount: t10
    }, e), r);
  });
  Ee.prototype.clear_charges = function(t10) {
    return this.set("$transactions", [], t10);
  };
  Ee.prototype.delete_user = function() {
    if (!this._identify_called()) {
      qe.error("mixpanel.people.delete_user() requires you to call identify() first");
      return;
    }
    var t10 = { $delete: this._mixpanel.get_distinct_id() };
    return this._send_request(t10);
  };
  Ee.prototype.toString = function() {
    return this._mixpanel.toString() + ".people";
  };
  Ee.prototype._send_request = function(t10, e) {
    t10.$token = this._get_config("token"), t10.$distinct_id = this._mixpanel.get_distinct_id();
    var r = this._mixpanel.get_property("$device_id"), n = this._mixpanel.get_property("$user_id"), i = this._mixpanel.get_property("$had_persisted_distinct_id");
    r && (t10.$device_id = r), n && (t10.$user_id = n), i && (t10.$had_persisted_distinct_id = i);
    var o = T.encodeDates(t10);
    return this._identify_called() ? this._mixpanel._track_or_batch({
      type: "people",
      data: o,
      endpoint: this._get_config("api_host") + "/engage/",
      batcher: this._mixpanel.request_batchers.people
    }, e) : (this._enqueue(t10), T.isUndefined(e) || (this._get_config("verbose") ? e({ status: -1, error: null }) : e(-1)), T.truncate(o, 255));
  };
  Ee.prototype._get_config = function(t10) {
    return this._mixpanel.get_config(t10);
  };
  Ee.prototype._identify_called = function() {
    return this._mixpanel._flags.identify_called === true;
  };
  Ee.prototype._enqueue = function(t10) {
    nn in t10 ? this._mixpanel.persistence._add_to_people_queue(nn, t10) : hi in t10 ? this._mixpanel.persistence._add_to_people_queue(hi, t10) : rr in t10 ? this._mixpanel.persistence._add_to_people_queue(rr, t10) : Mn in t10 ? this._mixpanel.persistence._add_to_people_queue(Mn, t10) : Fr in t10 ? this._mixpanel.persistence._add_to_people_queue(Fr, t10) : on in t10 ? this._mixpanel.persistence._add_to_people_queue(on, t10) : Nn in t10 ? this._mixpanel.persistence._add_to_people_queue(Nn, t10) : qe.error("Invalid call to _enqueue():", t10);
  };
  Ee.prototype._flush_one_queue = function(t10, e, r, n) {
    var i = this, o = T.extend({}, this._mixpanel.persistence._get_queue(t10)), s = o;
    !T.isUndefined(o) && T.isObject(o) && !T.isEmptyObject(o) && (i._mixpanel.persistence._pop_from_people_queue(t10, o), n && (s = n(o)), e.call(i, s, function(a, l) {
      a === 0 && i._mixpanel.persistence._add_to_people_queue(t10, o), T.isUndefined(r) || r(a, l);
    }));
  };
  Ee.prototype._flush = function(t10, e, r, n, i, o, s) {
    var a = this, l = this._mixpanel.persistence._get_queue(Fr), c = this._mixpanel.persistence._get_queue(on);
    if (this._flush_one_queue(nn, this.set, t10), this._flush_one_queue(hi, this.set_once, n), this._flush_one_queue(rr, this.unset, o, function(y) {
      return T.keys(y);
    }), this._flush_one_queue(Mn, this.increment, e), this._flush_one_queue(Nn, this.union, i), !T.isUndefined(l) && T.isArray(l) && l.length) {
      for (var u, f = function(y, b) {
        y === 0 && a._mixpanel.persistence._add_to_people_queue(Fr, u), T.isUndefined(r) || r(y, b);
      }, d = l.length - 1; d >= 0; d--)
        u = l.pop(), T.isEmptyObject(u) || a.append(u, f);
      a._mixpanel.persistence.save();
    }
    if (!T.isUndefined(c) && T.isArray(c) && c.length) {
      for (var h, g = function(y, b) {
        y === 0 && a._mixpanel.persistence._add_to_people_queue(on, h), T.isUndefined(s) || s(y, b);
      }, p = c.length - 1; p >= 0; p--)
        h = c.pop(), T.isEmptyObject(h) || a.remove(h, g);
      a._mixpanel.persistence.save();
    }
  };
  Ee.prototype._is_reserved_property = function(t10) {
    return t10 === "$distinct_id" || t10 === "$token" || t10 === "$device_id" || t10 === "$user_id" || t10 === "$had_persisted_distinct_id";
  };
  Ee.prototype.set = Ee.prototype.set;
  Ee.prototype.set_once = Ee.prototype.set_once;
  Ee.prototype.unset = Ee.prototype.unset;
  Ee.prototype.increment = Ee.prototype.increment;
  Ee.prototype.append = Ee.prototype.append;
  Ee.prototype.remove = Ee.prototype.remove;
  Ee.prototype.union = Ee.prototype.union;
  Ee.prototype.track_charge = Ee.prototype.track_charge;
  Ee.prototype.clear_charges = Ee.prototype.clear_charges;
  Ee.prototype.delete_user = Ee.prototype.delete_user;
  Ee.prototype.toString = Ee.prototype.toString;
  var fu = "__mps", du = "__mpso", hu = "__mpus", pu = "__mpa", gu = "__mpap", mu = "__mpr", yu = "__mpu", H0 = "$people_distinct_id", Qs = "__alias", go = "__timers", Ub = [
    fu,
    du,
    hu,
    pu,
    gu,
    mu,
    yu,
    H0,
    Qs,
    go
  ], Te = function(t10) {
    this.props = {}, this.campaign_params_saved = false, t10.persistence_name ? this.name = "mp_" + t10.persistence_name : this.name = "mp_" + t10.token + "_mixpanel";
    var e = t10.persistence;
    e !== "cookie" && e !== "localStorage" && (qe.critical("Unknown persistence type " + e + "; falling back to cookie"), e = t10.persistence = "cookie"), e === "localStorage" && T.localStorage.is_supported() ? this.storage = T.localStorage : this.storage = T.cookie, this.load(), this.update_config(t10), this.upgrade(t10), this.save();
  };
  Te.prototype.properties = function() {
    var t10 = {};
    return T.each(this.props, function(e, r) {
      T.include(Ub, r) || (t10[r] = e);
    }), t10;
  };
  Te.prototype.load = function() {
    if (!this.disabled) {
      var t10 = this.storage.parse(this.name);
      t10 && (this.props = T.extend({}, t10));
    }
  };
  Te.prototype.upgrade = function(t10) {
    var e = t10.upgrade, r, n;
    e && (r = "mp_super_properties", typeof e == "string" && (r = e), n = this.storage.parse(r), this.storage.remove(r), this.storage.remove(r, true), n && (this.props = T.extend(
      this.props,
      n.all,
      n.events
    ))), !t10.cookie_name && t10.name !== "mixpanel" && (r = "mp_" + t10.token + "_" + t10.name, n = this.storage.parse(r), n && (this.storage.remove(r), this.storage.remove(r, true), this.register_once(n))), this.storage === T.localStorage && (n = T.cookie.parse(this.name), T.cookie.remove(this.name), T.cookie.remove(this.name, true), n && this.register_once(n));
  };
  Te.prototype.save = function() {
    this.disabled || this.storage.set(
      this.name,
      T.JSONEncode(this.props),
      this.expire_days,
      this.cross_subdomain,
      this.secure,
      this.cross_site,
      this.cookie_domain
    );
  };
  Te.prototype.remove = function() {
    this.storage.remove(this.name, false, this.cookie_domain), this.storage.remove(this.name, true, this.cookie_domain);
  };
  Te.prototype.clear = function() {
    this.remove(), this.props = {};
  };
  Te.prototype.register_once = function(t10, e, r) {
    return T.isObject(t10) ? (typeof e > "u" && (e = "None"), this.expire_days = typeof r > "u" ? this.default_expiry : r, T.each(t10, function(n, i) {
      (!this.props.hasOwnProperty(i) || this.props[i] === e) && (this.props[i] = n);
    }, this), this.save(), true) : false;
  };
  Te.prototype.register = function(t10, e) {
    return T.isObject(t10) ? (this.expire_days = typeof e > "u" ? this.default_expiry : e, T.extend(this.props, t10), this.save(), true) : false;
  };
  Te.prototype.unregister = function(t10) {
    t10 in this.props && (delete this.props[t10], this.save());
  };
  Te.prototype.update_campaign_params = function() {
    this.campaign_params_saved || (this.register_once(T.info.campaignParams()), this.campaign_params_saved = true);
  };
  Te.prototype.update_search_keyword = function(t10) {
    this.register(T.info.searchInfo(t10));
  };
  Te.prototype.update_referrer_info = function(t10) {
    this.register_once({
      $initial_referrer: t10 || "$direct",
      $initial_referring_domain: T.info.referringDomain(t10) || "$direct"
    }, "");
  };
  Te.prototype.get_referrer_info = function() {
    return T.strip_empty_properties({
      $initial_referrer: this.props.$initial_referrer,
      $initial_referring_domain: this.props.$initial_referring_domain
    });
  };
  Te.prototype.safe_merge = function(t10) {
    return T.each(this.props, function(e, r) {
      r in t10 || (t10[r] = e);
    }), t10;
  };
  Te.prototype.update_config = function(t10) {
    this.default_expiry = this.expire_days = t10.cookie_expiration, this.set_disabled(t10.disable_persistence), this.set_cookie_domain(t10.cookie_domain), this.set_cross_site(t10.cross_site_cookie), this.set_cross_subdomain(t10.cross_subdomain_cookie), this.set_secure(t10.secure_cookie);
  };
  Te.prototype.set_disabled = function(t10) {
    this.disabled = t10, this.disabled ? this.remove() : this.save();
  };
  Te.prototype.set_cookie_domain = function(t10) {
    t10 !== this.cookie_domain && (this.remove(), this.cookie_domain = t10, this.save());
  };
  Te.prototype.set_cross_site = function(t10) {
    t10 !== this.cross_site && (this.cross_site = t10, this.remove(), this.save());
  };
  Te.prototype.set_cross_subdomain = function(t10) {
    t10 !== this.cross_subdomain && (this.cross_subdomain = t10, this.remove(), this.save());
  };
  Te.prototype.get_cross_subdomain = function() {
    return this.cross_subdomain;
  };
  Te.prototype.set_secure = function(t10) {
    t10 !== this.secure && (this.secure = !!t10, this.remove(), this.save());
  };
  Te.prototype._add_to_people_queue = function(t10, e) {
    var r = this._get_queue_key(t10), n = e[t10], i = this._get_or_create_queue(nn), o = this._get_or_create_queue(hi), s = this._get_or_create_queue(rr), a = this._get_or_create_queue(Mn), l = this._get_or_create_queue(Nn), c = this._get_or_create_queue(on, []), u = this._get_or_create_queue(Fr, []);
    r === fu ? (T.extend(i, n), this._pop_from_people_queue(Mn, n), this._pop_from_people_queue(Nn, n), this._pop_from_people_queue(rr, n)) : r === du ? (T.each(n, function(f, d) {
      d in o || (o[d] = f);
    }), this._pop_from_people_queue(rr, n)) : r === hu ? T.each(n, function(f) {
      T.each([i, o, a, l], function(d) {
        f in d && delete d[f];
      }), T.each(u, function(d) {
        f in d && delete d[f];
      }), s[f] = true;
    }) : r === pu ? (T.each(n, function(f, d) {
      d in i ? i[d] += f : (d in a || (a[d] = 0), a[d] += f);
    }, this), this._pop_from_people_queue(rr, n)) : r === yu ? (T.each(n, function(f, d) {
      T.isArray(f) && (d in l || (l[d] = []), l[d] = l[d].concat(f));
    }), this._pop_from_people_queue(rr, n)) : r === mu ? (c.push(n), this._pop_from_people_queue(Fr, n)) : r === gu && (u.push(n), this._pop_from_people_queue(rr, n)), qe.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), qe.log(e), this.save();
  };
  Te.prototype._pop_from_people_queue = function(t10, e) {
    var r = this._get_queue(t10);
    T.isUndefined(r) || (T.each(e, function(n, i) {
      t10 === Fr || t10 === on ? T.each(r, function(o) {
        o[i] === n && delete o[i];
      }) : delete r[i];
    }, this), this.save());
  };
  Te.prototype._get_queue_key = function(t10) {
    if (t10 === nn)
      return fu;
    if (t10 === hi)
      return du;
    if (t10 === rr)
      return hu;
    if (t10 === Mn)
      return pu;
    if (t10 === Fr)
      return gu;
    if (t10 === on)
      return mu;
    if (t10 === Nn)
      return yu;
    qe.error("Invalid queue:", t10);
  };
  Te.prototype._get_queue = function(t10) {
    return this.props[this._get_queue_key(t10)];
  };
  Te.prototype._get_or_create_queue = function(t10, e) {
    var r = this._get_queue_key(t10);
    return e = T.isUndefined(e) ? {} : e, this.props[r] || (this.props[r] = e);
  };
  Te.prototype.set_event_timer = function(t10, e) {
    var r = this.props[go] || {};
    r[t10] = e, this.props[go] = r, this.save();
  };
  Te.prototype.remove_event_timer = function(t10) {
    var e = this.props[go] || {}, r = e[t10];
    return T.isUndefined(r) || (delete this.props[go][t10], this.save()), r;
  };
  var bu, wt, K0 = 0, zb = 1, Vb = function(t10) {
    return t10;
  }, mo = function() {
  }, Yt = "mixpanel", Y0 = "base64", qb = "json", oi = St.XMLHttpRequest && "withCredentials" in new XMLHttpRequest(), X0 = !oi && er.indexOf("MSIE") === -1 && er.indexOf("Mozilla") === -1, Gs = null;
  Ir.sendBeacon && (Gs = function() {
    return Ir.sendBeacon.apply(Ir, arguments);
  });
  var ud = {
    api_host: "https://api-js.mixpanel.com",
    api_method: "POST",
    api_transport: "XHR",
    api_payload_format: Y0,
    app_host: "https://mixpanel.com",
    cdn: "https://cdn.mxpnl.com",
    cross_site_cookie: false,
    cross_subdomain_cookie: true,
    error_reporter: mo,
    persistence: "cookie",
    persistence_name: "",
    cookie_domain: "",
    cookie_name: "",
    loaded: mo,
    store_google: true,
    save_referrer: true,
    test: false,
    verbose: false,
    img: false,
    debug: false,
    track_links_timeout: 300,
    cookie_expiration: 365,
    upgrade: false,
    disable_persistence: false,
    disable_cookie: false,
    secure_cookie: false,
    ip: true,
    opt_out_tracking_by_default: false,
    opt_out_persistence_by_default: false,
    opt_out_tracking_persistence_type: "localStorage",
    opt_out_tracking_cookie_prefix: null,
    property_blacklist: [],
    xhr_headers: {},
    // { header: value, header2: value }
    ignore_dnt: false,
    batch_requests: true,
    batch_size: 50,
    batch_flush_interval_ms: 5e3,
    batch_request_timeout_ms: 9e4,
    batch_autostart: true,
    hooks: {}
  }, J0 = false, ce = function() {
  }, gc = function(t10, e, r) {
    var n, i = r === Yt ? wt : wt[r];
    if (i && bu === K0)
      n = i;
    else {
      if (i && !T.isArray(i)) {
        qe.error("You have already initialized " + r);
        return;
      }
      n = new ce();
    }
    return n._cached_groups = {}, n._init(t10, e, r), n.people = new Ee(), n.people._init(n), en.DEBUG = en.DEBUG || n.get_config("debug"), !T.isUndefined(i) && T.isArray(i) && (n._execute_array.call(n.people, i.people), n._execute_array(i)), n;
  };
  ce.prototype.init = function(t10, e, r) {
    if (T.isUndefined(r)) {
      this.report_error("You must name your new library: init(token, config, name)");
      return;
    }
    if (r === Yt) {
      this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
      return;
    }
    var n = gc(t10, e, r);
    return wt[r] = n, n._loaded(), n;
  };
  ce.prototype._init = function(t10, e, r) {
    e = e || {}, this.__loaded = true, this.config = {};
    var n = {};
    if (!("api_payload_format" in e)) {
      var i = e.api_host || ud.api_host;
      i.match(/\.mixpanel\.com$/) && (n.api_payload_format = qb);
    }
    if (this.set_config(T.extend({}, ud, n, e, {
      name: r,
      token: t10,
      callback_fn: (r === Yt ? r : Yt + "." + r) + "._jsc"
    })), this._jsc = mo, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
      disable_all_events: false,
      identify_called: false
    }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) {
      if (!T.localStorage.is_supported(true) || !oi)
        this._batch_requests = false, qe.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
      else if (this.init_batchers(), Gs && St.addEventListener) {
        var o = T.bind(function() {
          this.request_batchers.events.stopped || this.request_batchers.events.flush({ unloading: true });
        }, this);
        St.addEventListener("pagehide", function(a) {
          a.persisted && o();
        }), St.addEventListener("visibilitychange", function() {
          Ye.visibilityState === "hidden" && o();
        });
      }
    }
    this.persistence = this.cookie = new Te(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
    var s = T.UUID();
    this.get_distinct_id() || this.register_once({
      distinct_id: s,
      $device_id: s
    }, "");
  };
  ce.prototype._loaded = function() {
    this.get_config("loaded")(this), this._set_default_superprops();
  };
  ce.prototype._set_default_superprops = function() {
    this.persistence.update_search_keyword(Ye.referrer), this.get_config("store_google") && this.persistence.update_campaign_params(), this.get_config("save_referrer") && this.persistence.update_referrer_info(Ye.referrer);
  };
  ce.prototype._dom_loaded = function() {
    T.each(this.__dom_loaded_queue, function(t10) {
      this._track_dom.apply(this, t10);
    }, this), this.has_opted_out_tracking() || T.each(this.__request_queue, function(t10) {
      this._send_request.apply(this, t10);
    }, this), delete this.__dom_loaded_queue, delete this.__request_queue;
  };
  ce.prototype._track_dom = function(t10, e) {
    if (this.get_config("img"))
      return this.report_error("You can't use DOM tracking functions with img = true."), false;
    if (!J0)
      return this.__dom_loaded_queue.push([t10, e]), false;
    var r = new t10().init(this);
    return r.track.apply(r, e);
  };
  ce.prototype._prepare_callback = function(t10, e) {
    if (T.isUndefined(t10))
      return null;
    if (oi) {
      var r = function(s) {
        t10(s, e);
      };
      return r;
    } else {
      var n = this._jsc, i = "" + Math.floor(Math.random() * 1e8), o = this.get_config("callback_fn") + "[" + i + "]";
      return n[i] = function(s) {
        delete n[i], t10(s, e);
      }, o;
    }
  };
  ce.prototype._send_request = function(t10, e, r, n) {
    var i = true;
    if (X0)
      return this.__request_queue.push(arguments), i;
    var o = {
      method: this.get_config("api_method"),
      transport: this.get_config("api_transport"),
      verbose: this.get_config("verbose")
    }, s = null;
    !n && (T.isFunction(r) || typeof r == "string") && (n = r, r = null), r = T.extend(o, r || {}), oi || (r.method = "GET");
    var a = r.method === "POST", l = Gs && a && r.transport.toLowerCase() === "sendbeacon", c = r.verbose;
    e.verbose && (c = true), this.get_config("test") && (e.test = 1), c && (e.verbose = 1), this.get_config("img") && (e.img = 1), oi || (n ? e.callback = n : (c || this.get_config("test")) && (e.callback = "(function(){})")), e.ip = this.get_config("ip") ? 1 : 0, e._ = (/* @__PURE__ */ new Date()).getTime().toString(), a && (s = "data=" + encodeURIComponent(e.data), delete e.data), t10 += "?" + T.HTTPBuildQuery(e);
    var u = this;
    if ("img" in e) {
      var f = Ye.createElement("img");
      f.src = t10, Ye.body.appendChild(f);
    } else if (l) {
      try {
        i = Gs(t10, s);
      } catch (b) {
        u.report_error(b), i = false;
      }
      try {
        n && n(i ? 1 : 0);
      } catch (b) {
        u.report_error(b);
      }
    } else if (oi)
      try {
        var d = new XMLHttpRequest();
        d.open(r.method, t10, true);
        var h = this.get_config("xhr_headers");
        if (a && (h["Content-Type"] = "application/x-www-form-urlencoded"), T.each(h, function(b, x) {
          d.setRequestHeader(x, b);
        }), r.timeout_ms && typeof d.timeout < "u") {
          d.timeout = r.timeout_ms;
          var g = (/* @__PURE__ */ new Date()).getTime();
        }
        d.withCredentials = true, d.onreadystatechange = function() {
          if (d.readyState === 4)
            if (d.status === 200) {
              if (n)
                if (c) {
                  var b;
                  try {
                    b = T.JSONDecode(d.responseText);
                  } catch (S) {
                    if (u.report_error(S), r.ignore_json_errors)
                      b = d.responseText;
                    else
                      return;
                  }
                  n(b);
                } else
                  n(Number(d.responseText));
            } else {
              var x;
              d.timeout && !d.status && (/* @__PURE__ */ new Date()).getTime() - g >= d.timeout ? x = "timeout" : x = "Bad HTTP status: " + d.status + " " + d.statusText, u.report_error(x), n && n(c ? { status: 0, error: x, xhr_req: d } : 0);
            }
        }, d.send(s);
      } catch (b) {
        u.report_error(b), i = false;
      }
    else {
      var p = Ye.createElement("script");
      p.type = "text/javascript", p.async = true, p.defer = true, p.src = t10;
      var y = Ye.getElementsByTagName("script")[0];
      y.parentNode.insertBefore(p, y);
    }
    return i;
  };
  ce.prototype._execute_array = function(t10) {
    var e, r = [], n = [], i = [];
    T.each(t10, function(s) {
      s && (e = s[0], T.isArray(e) ? i.push(s) : typeof s == "function" ? s.call(this) : T.isArray(s) && e === "alias" ? r.push(s) : T.isArray(s) && e.indexOf("track") !== -1 && typeof this[e] == "function" ? i.push(s) : n.push(s));
    }, this);
    var o = function(s, a) {
      T.each(s, function(l) {
        if (T.isArray(l[0])) {
          var c = a;
          T.each(l, function(u) {
            c = c[u[0]].apply(c, u.slice(1));
          });
        } else
          this[l[0]].apply(this, l.slice(1));
      }, a);
    };
    o(r, this), o(n, this), o(i, this);
  };
  ce.prototype.are_batchers_initialized = function() {
    return !!this.request_batchers.events;
  };
  ce.prototype.init_batchers = function() {
    var t10 = this.get_config("token");
    if (!this.are_batchers_initialized()) {
      var e = T.bind(function(r) {
        return new xr(
          "__mpq_" + t10 + r.queue_suffix,
          {
            libConfig: this.config,
            sendRequestFunc: T.bind(function(n, i, o) {
              this._send_request(
                this.get_config("api_host") + r.endpoint,
                this._encode_data_for_request(n),
                i,
                this._prepare_callback(o, n)
              );
            }, this),
            beforeSendHook: T.bind(function(n) {
              return this._run_hook("before_send_" + r.type, n);
            }, this),
            errorReporter: this.get_config("error_reporter"),
            stopAllBatchingFunc: T.bind(this.stop_batch_senders, this)
          }
        );
      }, this);
      this.request_batchers = {
        events: e({ type: "events", endpoint: "/track/", queue_suffix: "_ev" }),
        people: e({ type: "people", endpoint: "/engage/", queue_suffix: "_pp" }),
        groups: e({ type: "groups", endpoint: "/groups/", queue_suffix: "_gr" })
      };
    }
    this.get_config("batch_autostart") && this.start_batch_senders();
  };
  ce.prototype.start_batch_senders = function() {
    this.are_batchers_initialized() && (this._batch_requests = true, T.each(this.request_batchers, function(t10) {
      t10.start();
    }));
  };
  ce.prototype.stop_batch_senders = function() {
    this._batch_requests = false, T.each(this.request_batchers, function(t10) {
      t10.stop(), t10.clear();
    });
  };
  ce.prototype.push = function(t10) {
    this._execute_array([t10]);
  };
  ce.prototype.disable = function(t10) {
    typeof t10 > "u" ? this._flags.disable_all_events = true : this.__disabled_events = this.__disabled_events.concat(t10);
  };
  ce.prototype._encode_data_for_request = function(t10) {
    var e = T.JSONEncode(t10);
    return this.get_config("api_payload_format") === Y0 && (e = T.base64Encode(e)), { data: e };
  };
  ce.prototype._track_or_batch = function(t10, e) {
    var r = T.truncate(t10.data, 255), n = t10.endpoint, i = t10.batcher, o = t10.should_send_immediately, s = t10.send_request_options || {};
    e = e || mo;
    var a = true, l = T.bind(function() {
      return s.skip_hooks || (r = this._run_hook("before_send_" + t10.type, r)), r ? (qe.log("MIXPANEL REQUEST:"), qe.log(r), this._send_request(
        n,
        this._encode_data_for_request(r),
        s,
        this._prepare_callback(e, r)
      )) : null;
    }, this);
    return this._batch_requests && !o ? i.enqueue(r, function(c) {
      c ? e(1, r) : l();
    }) : a = l(), a && r;
  };
  ce.prototype.track = Bo(function(t10, e, r, n) {
    !n && typeof r == "function" && (n = r, r = null), r = r || {};
    var i = r.transport;
    i && (r.transport = i);
    var o = r.send_immediately;
    if (typeof n != "function" && (n = mo), T.isUndefined(t10)) {
      this.report_error("No event name provided to mixpanel.track");
      return;
    }
    if (this._event_is_disabled(t10)) {
      n(0);
      return;
    }
    e = e || {}, e.token = this.get_config("token");
    var s = this.persistence.remove_event_timer(t10);
    if (!T.isUndefined(s)) {
      var a = (/* @__PURE__ */ new Date()).getTime() - s;
      e.$duration = parseFloat((a / 1e3).toFixed(3));
    }
    this._set_default_superprops(), e = T.extend(
      {},
      T.info.properties(),
      this.persistence.properties(),
      this.unpersisted_superprops,
      e
    );
    var l = this.get_config("property_blacklist");
    T.isArray(l) ? T.each(l, function(f) {
      delete e[f];
    }) : this.report_error("Invalid value for property_blacklist config: " + l);
    var c = {
      event: t10,
      properties: e
    }, u = this._track_or_batch({
      type: "events",
      data: c,
      endpoint: this.get_config("api_host") + "/track/",
      batcher: this.request_batchers.events,
      should_send_immediately: o,
      send_request_options: r
    }, n);
    return u;
  });
  ce.prototype.set_group = Bo(function(t10, e, r) {
    T.isArray(e) || (e = [e]);
    var n = {};
    return n[t10] = e, this.register(n), this.people.set(t10, e, r);
  });
  ce.prototype.add_group = Bo(function(t10, e, r) {
    var n = this.get_property(t10);
    if (n === void 0) {
      var i = {};
      i[t10] = [e], this.register(i);
    } else
      n.indexOf(e) === -1 && (n.push(e), this.register(i));
    return this.people.union(t10, e, r);
  });
  ce.prototype.remove_group = Bo(function(t10, e, r) {
    var n = this.get_property(t10);
    if (n !== void 0) {
      var i = n.indexOf(e);
      i > -1 && (n.splice(i, 1), this.register({ group_key: n })), n.length === 0 && this.unregister(t10);
    }
    return this.people.remove(t10, e, r);
  });
  ce.prototype.track_with_groups = Bo(function(t10, e, r, n) {
    var i = T.extend({}, e || {});
    return T.each(r, function(o, s) {
      o != null && (i[s] = o);
    }), this.track(t10, i, n);
  });
  ce.prototype._create_map_key = function(t10, e) {
    return t10 + "_" + JSON.stringify(e);
  };
  ce.prototype._remove_group_from_cache = function(t10, e) {
    delete this._cached_groups[this._create_map_key(t10, e)];
  };
  ce.prototype.get_group = function(t10, e) {
    var r = this._create_map_key(t10, e), n = this._cached_groups[r];
    return (n === void 0 || n._group_key !== t10 || n._group_id !== e) && (n = new et(), n._init(this, t10, e), this._cached_groups[r] = n), n;
  };
  ce.prototype.track_pageview = function(t10) {
    T.isUndefined(t10) && (t10 = Ye.location.href), this.track("mp_page_view", T.info.pageviewInfo(t10));
  };
  ce.prototype.track_links = function() {
    return this._track_dom.call(this, di, arguments);
  };
  ce.prototype.track_forms = function() {
    return this._track_dom.call(this, Ia, arguments);
  };
  ce.prototype.time_event = function(t10) {
    if (T.isUndefined(t10)) {
      this.report_error("No event name provided to mixpanel.time_event");
      return;
    }
    this._event_is_disabled(t10) || this.persistence.set_event_timer(t10, (/* @__PURE__ */ new Date()).getTime());
  };
  var Hb = {
    persistent: true
  }, vu = function(t10) {
    var e;
    return T.isObject(t10) ? e = t10 : T.isUndefined(t10) ? e = {} : e = { days: t10 }, T.extend({}, Hb, e);
  };
  ce.prototype.register = function(t10, e) {
    var r = vu(e);
    r.persistent ? this.persistence.register(t10, r.days) : T.extend(this.unpersisted_superprops, t10);
  };
  ce.prototype.register_once = function(t10, e, r) {
    var n = vu(r);
    n.persistent ? this.persistence.register_once(t10, e, n.days) : (typeof e > "u" && (e = "None"), T.each(t10, function(i, o) {
      (!this.unpersisted_superprops.hasOwnProperty(o) || this.unpersisted_superprops[o] === e) && (this.unpersisted_superprops[o] = i);
    }, this));
  };
  ce.prototype.unregister = function(t10, e) {
    e = vu(e), e.persistent ? this.persistence.unregister(t10) : delete this.unpersisted_superprops[t10];
  };
  ce.prototype._register_single = function(t10, e) {
    var r = {};
    r[t10] = e, this.register(r);
  };
  ce.prototype.identify = function(t10, e, r, n, i, o, s, a) {
    var l = this.get_distinct_id();
    if (this.register({ $user_id: t10 }), !this.get_property("$device_id")) {
      var c = l;
      this.register_once({
        $had_persisted_distinct_id: true,
        $device_id: c
      }, "");
    }
    t10 !== l && t10 !== this.get_property(Qs) && (this.unregister(Qs), this.register({ distinct_id: t10 })), this._flags.identify_called = true, this.people._flush(e, r, n, i, o, s, a), t10 !== l && this.track("$identify", {
      distinct_id: t10,
      $anon_distinct_id: l
    }, { skip_hooks: true });
  };
  ce.prototype.reset = function() {
    this.persistence.clear(), this._flags.identify_called = false;
    var t10 = T.UUID();
    this.register_once({
      distinct_id: t10,
      $device_id: t10
    }, "");
  };
  ce.prototype.get_distinct_id = function() {
    return this.get_property("distinct_id");
  };
  ce.prototype.alias = function(t10, e) {
    if (t10 === this.get_property(H0))
      return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
    var r = this;
    return T.isUndefined(e) && (e = this.get_distinct_id()), t10 !== e ? (this._register_single(Qs, t10), this.track("$create_alias", {
      alias: t10,
      distinct_id: e
    }, {
      skip_hooks: true
    }, function() {
      r.identify(t10);
    })) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(t10), -1);
  };
  ce.prototype.name_tag = function(t10) {
    this._register_single("mp_name_tag", t10);
  };
  ce.prototype.set_config = function(t10) {
    if (T.isObject(t10)) {
      T.extend(this.config, t10);
      var e = t10.batch_size;
      e && T.each(this.request_batchers, function(r) {
        r.resetBatchSize();
      }), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), en.DEBUG = en.DEBUG || this.get_config("debug");
    }
  };
  ce.prototype.get_config = function(t10) {
    return this.config[t10];
  };
  ce.prototype._run_hook = function(t10) {
    var e = (this.config.hooks[t10] || Vb).apply(this, Hr.call(arguments, 1));
    return typeof e > "u" && (this.report_error(t10 + " hook did not return a value"), e = null), e;
  };
  ce.prototype.get_property = function(t10) {
    return this.persistence.props[t10];
  };
  ce.prototype.toString = function() {
    var t10 = this.get_config("name");
    return t10 !== Yt && (t10 = Yt + "." + t10), t10;
  };
  ce.prototype._event_is_disabled = function(t10) {
    return T.isBlockedUA(er) || this._flags.disable_all_events || T.include(this.__disabled_events, t10);
  };
  ce.prototype._gdpr_init = function() {
    var t10 = this.get_config("opt_out_tracking_persistence_type") === "localStorage";
    t10 && T.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({ persistence_type: "cookie" }) && this.opt_in_tracking({ enable_persistence: false }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({ persistence_type: "cookie" }) && this.opt_out_tracking({ clear_persistence: false }), this.clear_opt_in_out_tracking({
      persistence_type: "cookie",
      enable_persistence: false
    })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({ clear_persistence: true }) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || T.cookie.get("mp_optout")) && (T.cookie.remove("mp_optout"), this.opt_out_tracking({
      clear_persistence: this.get_config("opt_out_persistence_by_default")
    }));
  };
  ce.prototype._gdpr_update_persistence = function(t10) {
    var e;
    if (t10 && t10.clear_persistence)
      e = true;
    else if (t10 && t10.enable_persistence)
      e = false;
    else
      return;
    !this.get_config("disable_persistence") && this.persistence.disabled !== e && this.persistence.set_disabled(e), e && T.each(this.request_batchers, function(r) {
      r.clear();
    });
  };
  ce.prototype._gdpr_call_func = function(t10, e) {
    return e = T.extend({
      track: T.bind(this.track, this),
      persistence_type: this.get_config("opt_out_tracking_persistence_type"),
      cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
      cookie_expiration: this.get_config("cookie_expiration"),
      cross_site_cookie: this.get_config("cross_site_cookie"),
      cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
      cookie_domain: this.get_config("cookie_domain"),
      secure_cookie: this.get_config("secure_cookie"),
      ignore_dnt: this.get_config("ignore_dnt")
    }, e), T.localStorage.is_supported() || (e.persistence_type = "cookie"), t10(this.get_config("token"), {
      track: e.track,
      trackEventName: e.track_event_name,
      trackProperties: e.track_properties,
      persistenceType: e.persistence_type,
      persistencePrefix: e.cookie_prefix,
      cookieDomain: e.cookie_domain,
      cookieExpiration: e.cookie_expiration,
      crossSiteCookie: e.cross_site_cookie,
      crossSubdomainCookie: e.cross_subdomain_cookie,
      secureCookie: e.secure_cookie,
      ignoreDnt: e.ignore_dnt
    });
  };
  ce.prototype.opt_in_tracking = function(t10) {
    t10 = T.extend({
      enable_persistence: true
    }, t10), this._gdpr_call_func(Nb, t10), this._gdpr_update_persistence(t10);
  };
  ce.prototype.opt_out_tracking = function(t10) {
    t10 = T.extend({
      clear_persistence: true,
      delete_user: true
    }, t10), t10.delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(Lb, t10), this._gdpr_update_persistence(t10);
  };
  ce.prototype.has_opted_in_tracking = function(t10) {
    return this._gdpr_call_func(Bb, t10);
  };
  ce.prototype.has_opted_out_tracking = function(t10) {
    return this._gdpr_call_func(U0, t10);
  };
  ce.prototype.clear_opt_in_out_tracking = function(t10) {
    t10 = T.extend({
      enable_persistence: true
    }, t10), this._gdpr_call_func(Fb, t10), this._gdpr_update_persistence(t10);
  };
  ce.prototype.report_error = function(t10, e) {
    qe.error.apply(qe.error, arguments);
    try {
      !e && !(t10 instanceof Error) && (t10 = new Error(t10)), this.get_config("error_reporter")(t10, e);
    } catch (r) {
      qe.error(r);
    }
  };
  ce.prototype.init = ce.prototype.init;
  ce.prototype.reset = ce.prototype.reset;
  ce.prototype.disable = ce.prototype.disable;
  ce.prototype.time_event = ce.prototype.time_event;
  ce.prototype.track = ce.prototype.track;
  ce.prototype.track_links = ce.prototype.track_links;
  ce.prototype.track_forms = ce.prototype.track_forms;
  ce.prototype.track_pageview = ce.prototype.track_pageview;
  ce.prototype.register = ce.prototype.register;
  ce.prototype.register_once = ce.prototype.register_once;
  ce.prototype.unregister = ce.prototype.unregister;
  ce.prototype.identify = ce.prototype.identify;
  ce.prototype.alias = ce.prototype.alias;
  ce.prototype.name_tag = ce.prototype.name_tag;
  ce.prototype.set_config = ce.prototype.set_config;
  ce.prototype.get_config = ce.prototype.get_config;
  ce.prototype.get_property = ce.prototype.get_property;
  ce.prototype.get_distinct_id = ce.prototype.get_distinct_id;
  ce.prototype.toString = ce.prototype.toString;
  ce.prototype.opt_out_tracking = ce.prototype.opt_out_tracking;
  ce.prototype.opt_in_tracking = ce.prototype.opt_in_tracking;
  ce.prototype.has_opted_out_tracking = ce.prototype.has_opted_out_tracking;
  ce.prototype.has_opted_in_tracking = ce.prototype.has_opted_in_tracking;
  ce.prototype.clear_opt_in_out_tracking = ce.prototype.clear_opt_in_out_tracking;
  ce.prototype.get_group = ce.prototype.get_group;
  ce.prototype.set_group = ce.prototype.set_group;
  ce.prototype.add_group = ce.prototype.add_group;
  ce.prototype.remove_group = ce.prototype.remove_group;
  ce.prototype.track_with_groups = ce.prototype.track_with_groups;
  ce.prototype.start_batch_senders = ce.prototype.start_batch_senders;
  ce.prototype.stop_batch_senders = ce.prototype.stop_batch_senders;
  Te.prototype.properties = Te.prototype.properties;
  Te.prototype.update_search_keyword = Te.prototype.update_search_keyword;
  Te.prototype.update_referrer_info = Te.prototype.update_referrer_info;
  Te.prototype.get_cross_subdomain = Te.prototype.get_cross_subdomain;
  Te.prototype.clear = Te.prototype.clear;
  var ri = {}, Kb = function() {
    T.each(ri, function(t10, e) {
      e !== Yt && (wt[e] = t10);
    }), wt._ = T;
  }, Yb = function() {
    wt.init = function(t10, e, r) {
      if (r)
        return wt[r] || (wt[r] = ri[r] = gc(t10, e, r), wt[r]._loaded()), wt[r];
      var n = wt;
      ri[Yt] ? n = ri[Yt] : t10 && (n = gc(t10, e, Yt), n._loaded(), ri[Yt] = n), wt = n, bu === zb && (St[Yt] = wt), Kb();
    };
  }, Xb = function() {
    function t10() {
      t10.done || (t10.done = true, J0 = true, X0 = false, T.each(ri, function(n) {
        n._dom_loaded();
      }));
    }
    function e() {
      try {
        Ye.documentElement.doScroll("left");
      } catch {
        setTimeout(e, 1);
        return;
      }
      t10();
    }
    if (Ye.addEventListener)
      Ye.readyState === "complete" ? t10() : Ye.addEventListener("DOMContentLoaded", t10, false);
    else if (Ye.attachEvent) {
      Ye.attachEvent("onreadystatechange", t10);
      var r = false;
      try {
        r = St.frameElement === null;
      } catch {
      }
      Ye.documentElement.doScroll && r && e();
    }
    T.register_event(St, "load", t10, true);
  };
  function Jb() {
    return bu = K0, wt = new ce(), Yb(), wt.init(), Xb(), wt;
  }
  var Qb = Jb(), Ki = Qb;
  function Au() {
    return typeof window < "u" ? window.location.host.indexOf("discordsays.com") !== -1 : false;
  }
  let fd = false;
  function Gb(t10) {
    var r;
    if (fd)
      return;
    let e = "https://ws.joinplayroom.com";
    if ((r = define_process_env_default) != null && r.REACT_APP_SERVER) {
      const n = define_process_env_default.REACT_APP_SERVER.split("://");
      e = `${n[0] === "wss" ? "https" : "http"}://${n[1]}`;
    }
    t10 && (e = t10), Ki.init("2647310162474a4f7ca66a277c543032", {
      debug: false,
      api_host: `${e}/__mix`
    }), fd = true;
  }
  Gb(
    Au() ? `${window.location.protocol}//${window.location.host}/.proxy/_ws` : null
  );
  let Qo = () => {
    var t10;
    return define_process_env_default.NODE_ENV === "production" || typeof window < "u" && ((t10 = window == null ? void 0 : window._PLAYROOM_CONFIG) == null ? void 0 : t10.sdkMode);
  }, ar = {
    identify: (t10) => {
      try {
        Qo() && Ki.identify(t10);
      } catch (e) {
        console.log(e);
      }
    },
    alias: (t10) => {
      try {
        Qo() && Ki.alias(t10);
      } catch (e) {
        console.log(e);
      }
    },
    track: (t10, e) => {
      try {
        Qo() && Ki.track(t10, e);
      } catch (r) {
        console.log(r);
      }
    },
    people: {
      set: (t10) => {
        try {
          Qo() && Ki.people.set(t10);
        } catch (e) {
          console.log(e);
        }
      }
    }
  };
  var Zs = {}, Zb = {
    get exports() {
      return Zs;
    },
    set exports(t10) {
      Zs = t10;
    }
  }, mc = {}, $b = {
    get exports() {
      return mc;
    },
    set exports(t10) {
      mc = t10;
    }
  };
  (function() {
    var t10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = {
      // Bit-wise rotation left
      rotl: function(r, n) {
        return r << n | r >>> 32 - n;
      },
      // Bit-wise rotation right
      rotr: function(r, n) {
        return r << 32 - n | r >>> n;
      },
      // Swap big-endian to little-endian and vice versa
      endian: function(r) {
        if (r.constructor == Number)
          return e.rotl(r, 8) & 16711935 | e.rotl(r, 24) & 4278255360;
        for (var n = 0; n < r.length; n++)
          r[n] = e.endian(r[n]);
        return r;
      },
      // Generate an array of any length of random bytes
      randomBytes: function(r) {
        for (var n = []; r > 0; r--)
          n.push(Math.floor(Math.random() * 256));
        return n;
      },
      // Convert a byte array to big-endian 32-bit words
      bytesToWords: function(r) {
        for (var n = [], i = 0, o = 0; i < r.length; i++, o += 8)
          n[o >>> 5] |= r[i] << 24 - o % 32;
        return n;
      },
      // Convert big-endian 32-bit words to a byte array
      wordsToBytes: function(r) {
        for (var n = [], i = 0; i < r.length * 32; i += 8)
          n.push(r[i >>> 5] >>> 24 - i % 32 & 255);
        return n;
      },
      // Convert a byte array to a hex string
      bytesToHex: function(r) {
        for (var n = [], i = 0; i < r.length; i++)
          n.push((r[i] >>> 4).toString(16)), n.push((r[i] & 15).toString(16));
        return n.join("");
      },
      // Convert a hex string to a byte array
      hexToBytes: function(r) {
        for (var n = [], i = 0; i < r.length; i += 2)
          n.push(parseInt(r.substr(i, 2), 16));
        return n;
      },
      // Convert a byte array to a base-64 string
      bytesToBase64: function(r) {
        for (var n = [], i = 0; i < r.length; i += 3)
          for (var o = r[i] << 16 | r[i + 1] << 8 | r[i + 2], s = 0; s < 4; s++)
            i * 8 + s * 6 <= r.length * 8 ? n.push(t10.charAt(o >>> 6 * (3 - s) & 63)) : n.push("=");
        return n.join("");
      },
      // Convert a base-64 string to a byte array
      base64ToBytes: function(r) {
        r = r.replace(/[^A-Z0-9+\/]/ig, "");
        for (var n = [], i = 0, o = 0; i < r.length; o = ++i % 4)
          o != 0 && n.push((t10.indexOf(r.charAt(i - 1)) & Math.pow(2, -2 * o + 8) - 1) << o * 2 | t10.indexOf(r.charAt(i)) >>> 6 - o * 2);
        return n;
      }
    };
    $b.exports = e;
  })();
  var yc = {
    // UTF-8 encoding
    utf8: {
      // Convert a string to a byte array
      stringToBytes: function(t10) {
        return yc.bin.stringToBytes(unescape(encodeURIComponent(t10)));
      },
      // Convert a byte array to a string
      bytesToString: function(t10) {
        return decodeURIComponent(escape(yc.bin.bytesToString(t10)));
      }
    },
    // Binary encoding
    bin: {
      // Convert a string to a byte array
      stringToBytes: function(t10) {
        for (var e = [], r = 0; r < t10.length; r++)
          e.push(t10.charCodeAt(r) & 255);
        return e;
      },
      // Convert a byte array to a string
      bytesToString: function(t10) {
        for (var e = [], r = 0; r < t10.length; r++)
          e.push(String.fromCharCode(t10[r]));
        return e.join("");
      }
    }
  }, dd = yc;
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  var e3 = function(t10) {
    return t10 != null && (Q0(t10) || t3(t10) || !!t10._isBuffer);
  };
  function Q0(t10) {
    return !!t10.constructor && typeof t10.constructor.isBuffer == "function" && t10.constructor.isBuffer(t10);
  }
  function t3(t10) {
    return typeof t10.readFloatLE == "function" && typeof t10.slice == "function" && Q0(t10.slice(0, 0));
  }
  (function() {
    var t10 = mc, e = dd.utf8, r = e3, n = dd.bin, i = function(o, s) {
      o.constructor == String ? s && s.encoding === "binary" ? o = n.stringToBytes(o) : o = e.stringToBytes(o) : r(o) ? o = Array.prototype.slice.call(o, 0) : !Array.isArray(o) && o.constructor !== Uint8Array && (o = o.toString());
      for (var a = t10.bytesToWords(o), l = o.length * 8, c = 1732584193, u = -271733879, f = -1732584194, d = 271733878, h = 0; h < a.length; h++)
        a[h] = (a[h] << 8 | a[h] >>> 24) & 16711935 | (a[h] << 24 | a[h] >>> 8) & 4278255360;
      a[l >>> 5] |= 128 << l % 32, a[(l + 64 >>> 9 << 4) + 14] = l;
      for (var g = i._ff, p = i._gg, y = i._hh, b = i._ii, h = 0; h < a.length; h += 16) {
        var x = c, S = u, C = f, _ = d;
        c = g(c, u, f, d, a[h + 0], 7, -680876936), d = g(d, c, u, f, a[h + 1], 12, -389564586), f = g(f, d, c, u, a[h + 2], 17, 606105819), u = g(u, f, d, c, a[h + 3], 22, -1044525330), c = g(c, u, f, d, a[h + 4], 7, -176418897), d = g(d, c, u, f, a[h + 5], 12, 1200080426), f = g(f, d, c, u, a[h + 6], 17, -1473231341), u = g(u, f, d, c, a[h + 7], 22, -45705983), c = g(c, u, f, d, a[h + 8], 7, 1770035416), d = g(d, c, u, f, a[h + 9], 12, -1958414417), f = g(f, d, c, u, a[h + 10], 17, -42063), u = g(u, f, d, c, a[h + 11], 22, -1990404162), c = g(c, u, f, d, a[h + 12], 7, 1804603682), d = g(d, c, u, f, a[h + 13], 12, -40341101), f = g(f, d, c, u, a[h + 14], 17, -1502002290), u = g(u, f, d, c, a[h + 15], 22, 1236535329), c = p(c, u, f, d, a[h + 1], 5, -165796510), d = p(d, c, u, f, a[h + 6], 9, -1069501632), f = p(f, d, c, u, a[h + 11], 14, 643717713), u = p(u, f, d, c, a[h + 0], 20, -373897302), c = p(c, u, f, d, a[h + 5], 5, -701558691), d = p(d, c, u, f, a[h + 10], 9, 38016083), f = p(f, d, c, u, a[h + 15], 14, -660478335), u = p(u, f, d, c, a[h + 4], 20, -405537848), c = p(c, u, f, d, a[h + 9], 5, 568446438), d = p(d, c, u, f, a[h + 14], 9, -1019803690), f = p(f, d, c, u, a[h + 3], 14, -187363961), u = p(u, f, d, c, a[h + 8], 20, 1163531501), c = p(c, u, f, d, a[h + 13], 5, -1444681467), d = p(d, c, u, f, a[h + 2], 9, -51403784), f = p(f, d, c, u, a[h + 7], 14, 1735328473), u = p(u, f, d, c, a[h + 12], 20, -1926607734), c = y(c, u, f, d, a[h + 5], 4, -378558), d = y(d, c, u, f, a[h + 8], 11, -2022574463), f = y(f, d, c, u, a[h + 11], 16, 1839030562), u = y(u, f, d, c, a[h + 14], 23, -35309556), c = y(c, u, f, d, a[h + 1], 4, -1530992060), d = y(d, c, u, f, a[h + 4], 11, 1272893353), f = y(f, d, c, u, a[h + 7], 16, -155497632), u = y(u, f, d, c, a[h + 10], 23, -1094730640), c = y(c, u, f, d, a[h + 13], 4, 681279174), d = y(d, c, u, f, a[h + 0], 11, -358537222), f = y(f, d, c, u, a[h + 3], 16, -722521979), u = y(u, f, d, c, a[h + 6], 23, 76029189), c = y(c, u, f, d, a[h + 9], 4, -640364487), d = y(d, c, u, f, a[h + 12], 11, -421815835), f = y(f, d, c, u, a[h + 15], 16, 530742520), u = y(u, f, d, c, a[h + 2], 23, -995338651), c = b(c, u, f, d, a[h + 0], 6, -198630844), d = b(d, c, u, f, a[h + 7], 10, 1126891415), f = b(f, d, c, u, a[h + 14], 15, -1416354905), u = b(u, f, d, c, a[h + 5], 21, -57434055), c = b(c, u, f, d, a[h + 12], 6, 1700485571), d = b(d, c, u, f, a[h + 3], 10, -1894986606), f = b(f, d, c, u, a[h + 10], 15, -1051523), u = b(u, f, d, c, a[h + 1], 21, -2054922799), c = b(c, u, f, d, a[h + 8], 6, 1873313359), d = b(d, c, u, f, a[h + 15], 10, -30611744), f = b(f, d, c, u, a[h + 6], 15, -1560198380), u = b(u, f, d, c, a[h + 13], 21, 1309151649), c = b(c, u, f, d, a[h + 4], 6, -145523070), d = b(d, c, u, f, a[h + 11], 10, -1120210379), f = b(f, d, c, u, a[h + 2], 15, 718787259), u = b(u, f, d, c, a[h + 9], 21, -343485551), c = c + x >>> 0, u = u + S >>> 0, f = f + C >>> 0, d = d + _ >>> 0;
      }
      return t10.endian([c, u, f, d]);
    };
    i._ff = function(o, s, a, l, c, u, f) {
      var d = o + (s & a | ~s & l) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._gg = function(o, s, a, l, c, u, f) {
      var d = o + (s & l | a & ~l) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._hh = function(o, s, a, l, c, u, f) {
      var d = o + (s ^ a ^ l) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._ii = function(o, s, a, l, c, u, f) {
      var d = o + (a ^ (s | ~l)) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._blocksize = 16, i._digestsize = 16, Zb.exports = function(o, s) {
      if (o == null)
        throw new Error("Illegal argument " + o);
      var a = t10.wordsToBytes(i(o, s));
      return s && s.asBytes ? a : s && s.asString ? n.bytesToString(a) : t10.bytesToHex(a);
    };
  })();
  const $t = {
    roomLimitExceed: {
      code: 4444,
      reason: "ROOM_LIMIT_EXCEEDED"
    },
    roomSpectatorsLimitExceed: {
      code: 4445,
      reason: "ROOM_SPECTATORS_LIMIT_EXCEEDED"
    },
    playerKicked: {
      code: 4999,
      reason: "PLAYER_KICKED"
    },
    playerLeave: {
      code: 4998,
      reason: "PLAYER_LEAVED"
    },
    unknown: {
      code: 0,
      reason: "UNKNOWN"
    }
  };
  function r3(t10, e) {
    e || (e = {}), typeof e == "function" && (e = { cmp: e });
    var r = typeof e.cycles == "boolean" ? e.cycles : false, n = e.cmp && /* @__PURE__ */ function(o) {
      return function(s) {
        return function(a, l) {
          var c = { key: a, value: s[a] }, u = { key: l, value: s[l] };
          return o(c, u);
        };
      };
    }(e.cmp), i = [];
    return function o(s) {
      if (s && s.toJSON && typeof s.toJSON == "function" && (s = s.toJSON()), s !== void 0) {
        if (typeof s == "number")
          return isFinite(s) ? "" + s : "null";
        if (typeof s != "object")
          return JSON.stringify(s);
        var a, l;
        if (Array.isArray(s)) {
          for (l = "[", a = 0; a < s.length; a++)
            a && (l += ","), l += o(s[a]) || "null";
          return l + "]";
        }
        if (s === null)
          return "null";
        if (i.indexOf(s) !== -1) {
          if (r)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var c = i.push(s) - 1, u = Object.keys(s).sort(n && n(s));
        for (l = "", a = 0; a < u.length; a++) {
          var f = u[a], d = o(s[f]);
          d && (l && (l += ","), l += JSON.stringify(f) + ":" + d);
        }
        return i.splice(c, 1), "{" + l + "}";
      }
    }(t10);
  }
  function xn(t10) {
    var e = wu();
    return e[t10];
  }
  function wu() {
    var t10 = window.location.hash;
    t10 && (t10 = t10.split("#")[1]);
    var e = t10.split("&"), r = {};
    return e.forEach(function(n, i) {
      n = n.split("="), n[0] !== "" && (r[n[0]] = n[1]);
    }), r;
  }
  function G0(t10) {
    var e = Object.keys(t10), r = Object.values(t10), n = [];
    e.forEach(function(o, s) {
      o !== "" && n.push(e[s] + "=" + r[s]);
    });
    var i = n.join("&");
    window.location.hash = i;
  }
  function $s(t10, e) {
    var r = wu();
    r[t10] = e, e === void 0 && delete r[t10], G0(r);
  }
  const bc = {
    getUrlHashParameter: xn,
    getUrlHashParameters: wu,
    setUrlHashParameter: $s,
    setUrlHashParameters: G0
  };
  function Z0(t10) {
    return Object.keys(t10).forEach((e) => {
      t10[e] && typeof t10[e] == "object" ? Z0(t10[e]) : (t10[e] === void 0 || t10[e] === null) && delete t10[e];
    }), t10;
  }
  function n3(t10, e) {
    return Object.keys(t10).map(function(r) {
      return e + encodeURIComponent(r) + "=" + encodeURIComponent(t10[r]);
    }).join("&");
  }
  function i3(t10) {
    const e = t10 != null && t10.profile ? n3(t10.profile, "profile_") : "", r = t10 != null && t10.reconnectGracePeriod ? `reconnectGracePeriod=${t10.reconnectGracePeriod}` : "", n = t10 != null && t10.maxPlayersPerRoom ? `maxPlayersPerRoom=${t10.maxPlayersPerRoom}` : "", i = t10 != null && t10.maxSpectatorsPerRoom ? `maxSpectatorsPerRoom=${t10.maxSpectatorsPerRoom}` : "", o = t10 != null && t10.gameId ? `gameId=${t10.gameId}` : "", s = sessionStorage.getItem("pr_dcd_jwt"), a = s ? `discord_jwt=${s}` : "";
    return [
      e,
      r,
      i,
      n,
      o,
      a
    ].filter(Boolean).join("&");
  }
  function ea(t10, e = true) {
    let r = "wss://ws.joinplayroom.com";
    return Au() && (r = `wss://${window.location.host}/.proxy/_ws`), t10 != null && t10.websocketBaseUrl && (r = t10 == null ? void 0 : t10.websocketBaseUrl), {}.VITE_APP_SERVER && (r = {}.VITE_APP_SERVER), e ? r : r.replace("wss://", "https://").replace("ws://", "http://");
  }
  class kl extends ru {
    constructor({
      isHost: e,
      roomId: r,
      isSpectator: n,
      letEveryoneWriteState: i = false,
      enableDeltaCompression: o = false,
      sdkOptions: s
    }) {
      super(), this.hostname = ea(s), this.isHost = e, this.isSpectator = n, this.roomId = r, this.myId = Eb(), this.renderServerId = null, this.lastSeenTimestamp = 0, this.lastUpdateOrderSeen = 0, this.lastUpdateSyncMessageSeen = void 0, this.enableDeltaCompression = o, this.sdkOptions = s, this.playerStates = {}, this.autoAdmitPlayers = true, this.waitingPlayerStates = {}, this.syncIntervalTime = u0.SyncIntervalTime, this.pendingDeletionPlayerIds = [], this.spectatorStates = {}, this.ignoreNextSync = false, this.bootDate = Date.now(), this.wsHeartbeatInterval = 0, this.iUpdatedStateAt = {}, this.requestSyncs = true, this.rpcIdWasCalled = {}, this.rpcCallbacks = {}, this.globalState = JSON.parse(
        JSON.stringify((s == null ? void 0 : s.defaultStates) ?? {})
      ), this.defaultGlobalState = JSON.parse(
        JSON.stringify((s == null ? void 0 : s.defaultStates) ?? {})
      ), this.globalStateReadTime = {}, this.letEveryoneWriteState = i, this.reconnectAttempts = 0, this.joinWebsocket(), ar.identify(M0()), this.spectators = {};
    }
    isRenderServer() {
      return this.myId === this.renderServerId;
    }
    stateHash(e) {
      let r = JSON.stringify(e || this.getAllState());
      const n = ["defaultPlayersStates", "defaultGlobalState"];
      let i = Z0(
        JSON.parse(r)
      );
      return n.forEach((o) => {
        delete i[o];
      }), Zs(r3(i));
    }
    getBootDate() {
      return this.bootDate;
    }
    getAllState() {
      var e = {
        ...this.globalState,
        defaultGlobalState: this.defaultGlobalState,
        defaultPlayersStates: {},
        __players: {}
      };
      return Object.keys(this.playerStates).forEach((r) => {
        e.__players[r] = this.playerStates[r].getState(), e.defaultPlayersStates[r] = this.playerStates[r].getDefaultState();
      }), Object.keys(this.waitingPlayerStates).length > 0 ? (e.waitingPlayers = [], Object.keys(this.waitingPlayerStates).forEach((r) => {
        e.waitingPlayers.push(this.waitingPlayerStates[r].id);
      })) : delete e.waitingPlayers, e;
    }
    broadcastGlobalState(e = false) {
      const r = this.getAllState();
      let n = { sync: r, o: this.stateHash(r) };
      e && (n.force = true), this.websocketSend(JSON.stringify(n));
    }
    joinWebsocket(e = false) {
      let r = new WebSocket(
        this.hostname + "/api/room/" + this.roomId + "/websocket/" + (this.myId || "new") + // re-use the id I had previously (if any)
        (this.isHost && !e ? "/host" : "") + // make me host (if isHost is set)
        (this.isSpectator ? "/spectator" : "") + (this.sdkOptions ? "?" + i3(this.sdkOptions) : "")
      );
      r.addEventListener("open", (n) => {
        this.reconnectAttempts = 0, this.emit("connection_opened"), this.ws = r, this.wsHeartbeatInterval = setInterval(() => {
          if (this.isRenderServerOrHostIfNotCasting)
            this.websocketSend(JSON.stringify({ beat: Date.now() })), this.broadcastGlobalState();
          else if (this.requestSyncs) {
            if (this.ignoreNextSync) {
              this.ignoreNextSync = false;
              return;
            }
            const i = this.stateHash();
            this.enableDeltaCompression ? this.websocketSend(
              JSON.stringify({
                beat: Date.now(),
                syncO: i
              })
            ) : this.websocketSend(JSON.stringify({ beat: Date.now() }));
          }
        }, this.syncIntervalTime);
      }), r.addEventListener("error", (n) => {
        throw new Error(n.error);
      }), r.onerror = (n) => {
        throw new Error(
          n.message + " " + (this.hostname + "/api/room/" + this.roomId + "/websocket/" + (this.myId || "new") + // re-use the id I had previously (if any)
          (this.isHost ? "/host" : "") + // make me host (if isHost is set)
          (this.isSpectator ? "/spectator" : ""))
        );
      }, r.addEventListener("message", (n) => {
        var s;
        let i = JSON.parse(n.data);
        if (i.error)
          this.emit("error", { type: "websocket", error: i.error });
        else if (i.newId) {
          if (this.myId = i.newId, ct.set("myId", i.newId), !this.playerStates[this.myId] && !this.isSpectator && (this.playerStates[this.myId] = this.createPlayerState(this.myId)), i.profile && !this.isSpectator) {
            var o = this.playerStates[this.myId].getState("profile") || {};
            this.playerStates[this.myId].setState("profile", {
              ...o,
              ...i.profile
            });
          }
          i.bootDate && (this.bootDate = i.bootDate), this.isHost ? (this.emit("before_initial_sync"), this.broadcastGlobalState(), this.once("sync", (a) => {
            this.emit("connected");
          })) : this.emit("connected");
        } else if (i.joined && this.isRenderServerOrHostIfNotCasting)
          if (this.autoAdmitPlayers) {
            if (!this.playerStates[i.joined]) {
              this.playerStates[i.joined] = this.createPlayerState(
                i.joined,
                false,
                i.proxyBy,
                i.profile
              );
              let a = this.getState("__pOrder") || [];
              a.includes(i.joined) || (a.push(i.joined), this.setState("__pOrder", a));
            }
            this.emitPlayerJoined(this.playerStates[i.joined]);
          } else
            this.pendingDeletionPlayerIds.includes(i.joined) && this.playerStates[i.joined] ? this.playerStates[i.joined].startWebrtc() : this.waitingPlayerStates[i.joined] = this.createPlayerState(
              i.joined
            ), this.pendingDeletionPlayerIds.includes(i.joined) && (this.pendingDeletionPlayerIds = this.pendingDeletionPlayerIds.filter(
              (a) => a !== i.joined
            ));
        else if (i.renderServerUpdate)
          this.renderServerId !== i.renderServerUpdate && (this.renderServerId = i.renderServerUpdate, this.bootDate = i.bootDate, this.isRenderServer() ? (Object.keys(this.playerStates).forEach((a) => {
            this.playerStates[a].startWebrtc();
          }), Object.keys(this.spectatorStates).forEach((a) => {
            this.spectatorStates[a].startWebrtc();
          })) : this.playerStates[this.myId].startWebrtc());
        else if (i.hostUpdate)
          this.isHost = i.hostUpdate === this.myId, this.emit("host_updated", this.isHost), this.isHost && this.isRenderServerOrHostIfNotCasting ? Object.keys(this.playerStates).forEach((a) => {
            this.playerStates[a].startWebrtc();
          }) : this.isSpectator || this.playerStates[this.myId].startWebrtc();
        else if (i.hostUpdateFailed)
          this.emit("host_updated_failed", i.hostUpdateFailed);
        else if (i.switchRole) {
          const a = i.switchRole.id, l = i.switchRole.isSpectator;
          a === this.myId && (this.isSpectator = l), this.playerStates[a] && (this.playerStates[a].playerIsSpectator = l, l ? this.spectatorStates[a] = this.playerStates[a] : delete this.spectatorStates[a]), this.emit("role_switched", i.switchRole), this.emit("players", this.playerStates);
        } else if (i.switchRoleFailed)
          this.emit("role_switch_failed", i.switchRoleFailed);
        else if (i.spectators)
          this.spectators = i.spectators;
        else if (i.spectator)
          this.spectatorStates[i.spectator] || (this.spectatorStates[i.spectator] = this.createPlayerState(
            i.spectator,
            true
          ), this.spectatorStates[i.spectator] && (this.playerStates[i.spectator] = this.spectatorStates[i.spectator], this.emit("players", this.playerStates)), this.emit("spectator_joined", this.spectatorStates[i.spectator]));
        else if (i.quit)
          this.playerStates[i.quit] && this.isRenderServerOrHostIfNotCasting && this.autoAdmitPlayers && this.playerStates[i.quit].disconnect(), this.playerStates[i.quit] && this.isRenderServerOrHostIfNotCasting && !this.autoAdmitPlayers && this.pendingDeletionPlayerIds.push(i.quit), this.waitingPlayerStates[i.quit] && this.waitingPlayerStates[i.quit].disconnect(), Se("pquit", i.quit, this.renderServerId), this.renderServerId, i.quit;
        else if (i.signal)
          this.isRenderServerOrHostIfNotCasting && this.myId !== i.id && (this.playerStates[i.id] || this.spectatorStates[i.id]) ? (Se(
            "signal to host",
            i.signal,
            `from ${this.playerStates[i.id] ? "player" : ""}${this.spectatorStates[i.id] ? "spectator" : ""}`
          ), this.playerStates[i.id] && this.playerStates[i.id].signal(i.signal), this.spectatorStates[i.id] && this.spectatorStates[i.id].signal(i.signal)) : !this.isRenderServerOrHostIfNotCasting && this.myId === i.for && (Se("signal to client", i.signal), this.playerStates[this.myId] && this.playerStates[this.myId].signal(i.signal), this.spectatorStates[this.myId] && this.spectatorStates[this.myId].signal(i.signal));
        else if (i.pinput && this.isRenderServerOrHostIfNotCasting)
          this.passPlayerInput(i.id, i.pinput);
        else if (i.pong && this.isRenderServer())
          this.playerStates[i.id] && this.playerStates[i.id].handlePingResponse(i);
        else if (i.ping && !this.isRenderServer() && i.for === this.myId)
          this.websocketSend(
            JSON.stringify({
              pong: i.ping
            })
          );
        else if (i.pstate)
          this.setPlayerState(i);
        else if (i.gstate)
          this.setLocalStateFromServerGlobalState(i.gstate[0], i.gstate[1]);
        else if (i.sync) {
          if (this.emit("sync", i.sync), !this.isRenderServerOrHostIfNotCasting) {
            const { defaultGlobalState: a, ...l } = i.sync;
            this.setFullLocalState(l, i.o), this.setFullDefaultLocalState(a, i.o);
          }
          this.emit("post_sync", i.sync);
        } else if (i.dsync) {
          const a = N0.applyObjectPatch(this.getAllState(), i.dsync);
          this.emit("sync", a), this.emit("dsync", a), this.setFullLocalState(a, i.o), this.emit("post_dsync", a);
        } else
          i.kick ? this.myId === i.kick || this.isRenderServerOrHostIfNotCasting && ((s = this.playerStates[i.kick]) != null && s.isProxyPlayer()) && this.removeProxyPlayer(i.kick) : i.rpc ? this.rpcHandle(i, true) : i.rpcResp ? this.rpcResponseHandle(i, true) : i.default_gstate ? this.setLocalDefaultState(
            i.default_gstate[0],
            i.default_gstate[1]
          ) : i.default_pstate ? this.setDefaultPlayerState(i) : i.timestamp > this.lastSeenTimestamp && (this.emit("message", { type: "reliable", data: i }), this.lastSeenTimestamp = i.timestamp);
      }), r.addEventListener("close", (n) => {
        const i = Object.values($t).map(
          (o) => o.code
        );
        Se("WebSocket closed, reconnecting:", n.code, n.reason), clearInterval(this.wsHeartbeatInterval), n.code === 4e3 ? (this.emit("permission_error"), this.disconnect(n.code)) : n.code === 4001 || n.code === 4002 ? this.disconnect(n.code) : n.reason === "PLAYER_KICKED" ? this.disconnect(n.code, n.reason) : n.reason === "PLAYER_LEAVED" ? this.disconnect(n.code, n.reason) : this.wasDisconnectedManually ? (Se("Websocket was closed manually, not reconnecting"), clearInterval(this.wsHeartbeatInterval)) : i.indexOf(n.code) === -1 && this.reconnectAttempts < 3 ? (clearInterval(this.wsHeartbeatInterval), this.reconnectAttempts++, setTimeout(
          () => {
            var s;
            const o = JSON.parse(
              JSON.stringify(((s = this.playerStates[this.myId]) == null ? void 0 : s.getState()) || {})
            );
            this.joinWebsocket(true), this.isRenderServerOrHostIfNotCasting || this.once("post_dsync", (a) => {
              Object.keys(o).forEach((l) => {
                var c;
                (c = this.playerStates[this.myId]) == null || c.setState(
                  l,
                  o[l],
                  true
                );
              });
            });
          },
          this.isHost ? 1e3 : 1500
        )) : this.disconnect(n.code);
      }), r.addEventListener("error", (n) => {
        Se("WebSocket error, reconnecting:", n, typeof n), clearInterval(this.wsHeartbeatInterval);
      });
    }
    get isRenderServerOrHostIfNotCasting() {
      return !!(this.isRenderServer() || !this.getState("casting") && this.isHost);
    }
    setAutoAdmitPlayers(e) {
      this.isRenderServerOrHostIfNotCasting && this.autoAdmitPlayers !== e && (Se("setAutoAdmitPlayers", e), !this.autoAdmitPlayers && e && (Object.keys(this.waitingPlayerStates).length > 0 && Object.keys(this.waitingPlayerStates).forEach((r) => {
        this.playerStates[r] = this.waitingPlayerStates[r], this.emitPlayerJoined(this.playerStates[r]);
      }), this.waitingPlayerStates = {}, this.pendingDeletionPlayerIds.forEach((r) => {
        this.playerStates[r] && this.playerStates[r].disconnect();
      }), this.pendingDeletionPlayerIds = []), this.autoAdmitPlayers = e);
    }
    addProxyPlayer() {
      if (this.isRenderServerOrHostIfNotCasting) {
        var e = ka(9);
        return this.broadcast({ joined: e }, true), this.playerStates[e] = this.createPlayerState(e, false, true), this.playerStates[e];
      }
    }
    removeProxyPlayer(e) {
      this.playerStates[e] && this.broadcast({ quit: e }, true);
    }
    kickPlayer(e, r) {
      this.broadcast({ kick: e }, true);
      const n = this.on("player_quit", (i) => {
        i === e && (n(), r());
      });
    }
    leavePlayer(e, r) {
      this.broadcast({ leave: e }, true);
      const n = this.on("player_quit", (i) => {
        i === e && (n(), r());
      });
      $s("r", void 0);
    }
    transferHost(e, r, n) {
      this.broadcast({ transfer: e }, true), this.once("host_updated", () => {
        r();
      }), this.once("host_updated_failed", (i) => {
        n(i);
      });
    }
    switchRole(e, r) {
      this.websocketSend(JSON.stringify({ switchRole: { isSpectator: !this.isSpectator } })), this.once("role_switched", () => {
        e();
      }), this.once("role_switch_failed", (n) => {
        r(n);
      });
    }
    createPlayerState(e, r, n = false, i) {
      var l, c, u, f;
      const o = r === void 0 ? (l = this.spectatorStates[e]) == null ? void 0 : l.playerIsSpectator : r;
      let s = JSON.parse(
        JSON.stringify(((c = this.sdkOptions) == null ? void 0 : c.defaultPlayerStates) ?? {})
      );
      i && (s.profile = i);
      var a = new xb({
        websocketSend: (d) => this.websocketSend(d),
        id: e,
        myId: this.myId,
        // isHost: this.isHost,
        isRenderServer: () => this.isRenderServer(),
        isRenderServerOrHostIfNotCasting: () => this.isRenderServerOrHostIfNotCasting,
        playerIsSpectator: o,
        playerIsProxy: n,
        broadcastUnreliable: this.broadcastUnreliable.bind(this),
        setPlayerState: this.setPlayerState.bind(this),
        getBootDate: this.getBootDate.bind(this),
        avatarList: (u = this.sdkOptions) == null ? void 0 : u.avatars,
        kickPlayer: this.kickPlayer.bind(this),
        leavePlayer: this.leavePlayer.bind(this),
        state: s,
        defaultPlayerState: JSON.parse(
          JSON.stringify(((f = this.sdkOptions) == null ? void 0 : f.defaultPlayerStates) ?? {})
        )
      });
      return (this.isRenderServerOrHostIfNotCasting || e === this.myId) && (Se(
        "startWebrtc::createPlayerState",
        e,
        this.isRenderServerOrHostIfNotCasting
      ), a.startWebrtc()), a.on("quit", () => {
        Se("pquit", a.id), delete this.playerStates[a.id], this.emit("players", this.playerStates), this.emit("player_quit", a.id), this.waitingPlayerStates[a.id] && delete this.waitingPlayerStates[a.id];
      }), a.on("global_state_unreliable", (d) => {
        this.setLocalState(d[0], d[1], true);
      }), a.on("rpc_call_unreliable", this.rpcHandle.bind(this)), a;
    }
    emitPlayerJoined(e) {
      kb(e, "profile").then(() => {
        this.emit("joined", e), this.emit("players", this.playerStates);
      });
    }
    broadcastUnreliable(e) {
      Object.keys(this.playerStates).forEach((r) => {
        if (r !== this.myId)
          try {
            Se("broadcast unreliable", r, e), this.playerStates[r].send(e, false, true);
          } catch (n) {
            Se(n);
          }
      });
    }
    websocketSend(e) {
      try {
        this.ws.send(e);
      } catch (r) {
        Se(r);
      }
    }
    rpcHandle(e, r) {
      this.rpcIdWasCalled[e.rid] || (this.rpcIdWasCalled[e.rid] = true, this.emit("rpc", e, r));
    }
    rpcCall(e, r) {
      return this.ws && this.websocketSend(JSON.stringify(e)), new Promise((n, i) => {
        this.rpcCallbacks[e.rid] = {
          resolve: (o) => {
            r && r(o), n(o);
          },
          reject: i
        };
      });
    }
    rpcResponse(e) {
      this.ws && this.websocketSend(JSON.stringify(e));
    }
    rpcResponseHandle(e) {
      this.rpcCallbacks[e.rid] && (this.rpcCallbacks[e.rid].resolve(e.rpcResp), delete this.rpcCallbacks[e.rid]);
    }
    broadcast(e, r) {
      r ? this.ws && this.websocketSend(JSON.stringify(e)) : (Object.keys(this.spectatorStates).forEach((n) => {
        n !== this.myId && this.spectatorStates[n].send(e, r);
      }), Object.keys(this.playerStates).forEach((n) => {
        n !== this.myId && this.playerStates[n].send(e, r);
      }));
    }
    // used by non-hosts, to setState about other players
    setPlayerState(e) {
      var r = false;
      this.playerStates[e.pstate] && (r = this.playerStates[e.pstate].setLocalState(
        e.d[0],
        e.d[1],
        e.o
      )), this.waitingPlayerStates[e.pstate] && (r = this.waitingPlayerStates[e.pstate].setLocalState(
        e.d[0],
        e.d[1],
        e.o
      )), r && (this.ignoreNextSync = true);
    }
    // used by host, triggered when user input is sent to us (via network or controller(for local player))
    passPlayerInput(e, r) {
      this.playerStates[e] ? this.playerStates[e].handleInput(r, true) : this.waitingPlayerStates[e] && this.waitingPlayerStates[e].handleInput(r, true);
    }
    getState(e) {
      return e ? typeof this.globalState[e] == "object" ? JSON.parse(JSON.stringify(this.globalState[e])) : this.globalState[e] : this.globalState || {};
    }
    // public method to change state object (used by host only). This is then synced with all clients.
    setState(e, r, n = true) {
      const i = typeof r == "object" ? JSON.parse(JSON.stringify(r)) : r, o = this.setLocalState(e, i);
      (this.isHost || this.isRenderServer() || this.letEveryoneWriteState) && o && (this.iUpdatedStateAt[e] = Date.now(), this.broadcast({ gstate: [e, i] }, n));
    }
    // update local state from the server globalThis state
    setLocalStateFromServerGlobalState(e, r) {
      switch (e) {
        case "round.timer": {
          const n = this.getState("round.timer"), i = r > n ? r : n;
          this.setLocalState(e, i);
          break;
        }
        default: {
          this.setLocalState(e, r);
          break;
        }
      }
    }
    // just change local state without broadcasting
    setLocalState(e, r, n = false) {
      return JSON.stringify(this.globalState[e]) === JSON.stringify(r) ? false : (r === void 0 ? delete this.globalState[e] : this.globalState[e] = r, n && (this.ignoreNextSync = true), this.emit("state", this.globalState, e), true);
    }
    // used to change all of local state to what came from server
    setFullLocalState(e, r) {
      this.lastUpdateOrderSeen = r, this.lastUpdateSyncMessageSeen = JSON.parse(JSON.stringify(e)), this.isHost && (e.path = e.path || this.globalState.path);
      var n = e.__players || {};
      delete e.__players, Object.keys(e).forEach((i) => {
        (!this.iUpdatedStateAt[i] || this.iUpdatedStateAt[i] + this.syncIntervalTime < Date.now()) && this.setLocalState(i, e[i]);
      }), Object.keys(this.globalState).forEach((i) => {
        var o;
        (!this.iUpdatedStateAt[i] || this.iUpdatedStateAt[i] + this.syncIntervalTime < Date.now()) && !e[i] && e[i] !== 0 && (Se("set default states for the globalState"), this.setLocalState(i, (o = this.defaultGlobalState) == null ? void 0 : o[i]));
      }), Object.keys(n).forEach((i) => {
        var o;
        this.playerStates[i] || (this.playerStates[i] = this.createPlayerState(i, this.spectators[i]), delete this.spectators[i], this.emitPlayerJoined(this.playerStates[i])), this.playerStates[i].setFullLocalState(
          n[i],
          r
        ), (o = e == null ? void 0 : e.defaultPlayersStates) != null && o[i] && this.playerStates[i].setFullDefaultLocalState(
          e.defaultPlayersStates[i],
          r
        );
      }), Object.keys(this.playerStates).forEach((i) => {
        i !== this.myId && !n[i] && (e.waitingPlayers || []).indexOf(i) === -1 && (Se("player removed in state, disconnecting them", i), this.playerStates[i].disconnect());
      });
    }
    getDefaultState(e) {
      return e ? typeof this.defaultGlobalState[e] == "object" ? JSON.parse(JSON.stringify(this.defaultGlobalState[e])) : this.defaultGlobalState[e] : this.defaultGlobalState || {};
    }
    /**
     * store default globalThis states. This will come in handy when we reset the states,
     * we will replace the states with these default states.
     */
    setDefaultState(e, r) {
      const n = typeof r == "object" ? JSON.parse(JSON.stringify(r)) : r, i = this.setLocalDefaultState(e, n);
      (this.isHost || this.isRenderServer() || this.letEveryoneWriteState) && i && this.broadcast({ default_gstate: [e, n] }, true);
    }
    setLocalDefaultState(e, r) {
      return JSON.stringify(this.defaultGlobalState[e]) === JSON.stringify(r) ? false : (r == null ? delete this.defaultGlobalState[e] : this.defaultGlobalState[e] = r, true);
    }
    setFullDefaultLocalState(e) {
      this.defaultGlobalState = {
        ...this.defaultGlobalState,
        ...e
      };
    }
    setDefaultPlayerState(e) {
      this.playerStates[e.default_pstate] && this.playerStates[e.default_pstate].setDefaultLocalState(
        e.d[0],
        e.d[1],
        e.o
      );
    }
    getHostname(e = true) {
      return ea(this.sdkOptions, e);
    }
    disconnect(e, r) {
      Se("disconnecting with eventCode:", e, r), r === "MANUAL_DISCONNECT" && (this.wasDisconnectedManually = true), this.emit("disconnected", { eventCode: e, reason: r }), Object.keys(this.playerStates).forEach((n) => {
        this.playerStates[n].disconnect({ eventCode: e });
      }), Object.keys(this.waitingPlayerStates).forEach((n) => {
        this.waitingPlayerStates[n].disconnect({ eventCode: e });
      }), this.ws && this.ws.close();
    }
  }
  function ta(t10, e) {
    e || (e = "123456789ABCDEFGHIJKLMNPQRSTUVWXYZ");
    for (var r = "", n = t10; n > 0; --n)
      r += e[Math.floor(Math.random() * e.length)];
    return r;
  }
  const o3 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], Ri = {
    ROOMSTATE: "ROOMSTATE",
    GAMESTATE: "GAMESTATE"
  }, s3 = {
    ROOMSTATE: "Room",
    GAMESTATE: "Game",
    USERSTATE: "User"
  };
  async function a3(t10) {
    var e, r;
    if (t10.t = Date.now(), t10.timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone, t10.localTime = (/* @__PURE__ */ new Date()).toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }), t10.weekday = o3[(/* @__PURE__ */ new Date()).getDay()], typeof window < "u" && ((e = window == null ? void 0 : window._PLAYROOM_CONFIG) != null && e.sdkMode)) {
      if (t10.sdkMode = true, t10.sdkVersion = (r = window == null ? void 0 : window._PLAYROOM_CONFIG) == null ? void 0 : r.sdkVersion, define_process_env_default.NODE_ENV !== "production")
        return Se("analytics:", t10);
      try {
        ar.track(
          `${s3[t10.type]}: ${t10.event || ""}`,
          t10
        );
      } catch (n) {
        console.error(n);
      }
    }
  }
  function hd(t10, e) {
    return ea(t10, false) + e;
  }
  let Pr, It, ra;
  async function l3(t10, e, r) {
    if (!t10.gameId) {
      r("gameId is required for Discord mode");
      return;
    }
    if (It) {
      let u = "DCRD_" + It.instanceId;
      t10.persistentMode && (u = "PER_" + u);
      let f = await pd(), d = {
        ...t10,
        skipLobby: true,
        roomCode: u,
        profile: f
      };
      console.log(d, "modifiedOptions"), e(d);
      return;
    }
    if (!Au()) {
      console.warn(
        "Discord mock mode is active. To see the Discord mode in action, run the game inside Discord."
      );
      let u = {
        ...t10,
        skipLobby: true
      };
      e(u);
      return;
    }
    let n = null;
    const i = ["identify", "guilds.members.read", "email"];
    let o = typeof t10.discord == "object" ? t10.discord : {};
    const s = Array.isArray(o.scope) ? o.scope : [], a = /* @__PURE__ */ new Set([
      ...s,
      ...i,
      ...s.length ? [] : ["applications.commands"]
    ]);
    o.scope = Array.from(a), o.prompt || (o.prompt = "none"), o.state || (o.state = "");
    let l;
    try {
      ra = await g3();
      const { DiscordSDK: u } = ra, f = await fetch(
        `${hd(t10, "/api/discord/client_id")}?gameId=${t10.gameId}`
      ), { client_id: d } = await f.json(), h = new u(d);
      await h.ready();
      const { code: g } = await h.commands.authorize({
        ...o,
        client_id: d,
        response_type: "code"
      });
      It = h, l = "DCRD_" + It.instanceId, t10.persistentMode && (l = "PER_" + l);
      const p = await fetch(
        `${hd(t10, "/api/discord/auth")}?gameId=${t10.gameId}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            code: g,
            redirect_uri: window.location.href,
            roomId: l
          })
        }
      ), { access_token: y, jwt: b } = await p.json();
      b && sessionStorage.setItem("pr_dcd_jwt", b), Pr = await It.commands.authenticate({
        access_token: y
      }), n = await pd(), n._discord_id && ct.set("myId", "DCD-" + n._discord_id);
    } catch (u) {
      r(u);
      return;
    }
    let c = {
      ...t10,
      skipLobby: true,
      roomCode: l,
      profile: n
    };
    e(c);
  }
  async function pd() {
    if (!Pr)
      return { name: "", photo: "", _discord_id: "" };
    const t10 = Pr.user;
    let e = null, r = "";
    if (It != null && It.guildId) {
      const { user: i, avatarSrc: o } = await c3({ auth: Pr });
      e = i, r = o;
    }
    if (!e) {
      const { user: i, avatarSrc: o } = await u3({ auth: Pr });
      e = i, r = o;
    }
    return r || (r = f3(t10)), { name: d3({ discordUser: e }) ?? "", photo: r, _discord_id: t10.id };
  }
  async function c3(t10) {
    try {
      const { auth: e } = t10, r = e.user, i = await (await fetch(
        `https://discord.com/api/users/@me/guilds/${It.guildId}/member`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${e.access_token}`
          }
        }
      )).json();
      let o = "";
      return i != null && i.avatar ? o = `https://cdn.discordapp.com/guilds/${It.guildId}/users/${r.id}/avatars/${i.avatar}.png?size=256` : r != null && r.avatar && (o = $0(r)), { avatarSrc: o, user: i };
    } catch (e) {
      return console.log(e), { avatarSrc: "", user: null };
    }
  }
  async function u3(t10) {
    try {
      const { auth: e } = t10, r = e.user;
      let n = "";
      return r.avatar && (n = $0(r)), { avatarSrc: n, user: r };
    } catch (e) {
      return console.log(e), { avatarSrc: "", user: null };
    }
  }
  function f3(t10) {
    const e = parseInt(t10.discriminator);
    return `https://cdn.discordapp.com/embed/avatars/${Number.isNaN(e) ? 0 : e % 5}.png`;
  }
  function $0(t10) {
    return `https://cdn.discordapp.com/avatars/${t10.id}/${t10 == null ? void 0 : t10.avatar}.png?size=256`;
  }
  function d3(t10) {
    var r, n;
    const { discordUser: e } = t10;
    return e ? h3(e) ? (e == null ? void 0 : e.nick) || ((r = e == null ? void 0 : e.user) == null ? void 0 : r.global_name) || ((n = e == null ? void 0 : e.user) == null ? void 0 : n.username) : p3(e) ? (e == null ? void 0 : e.global_name) || (e == null ? void 0 : e.username) : "" : "";
  }
  function h3(t10) {
    return "nick" in t10;
  }
  function p3(t10) {
    return "global_name" in t10 || "username" in t10;
  }
  async function _E() {
    if (!It || !ra)
      throw new Error(
        "Discord not initialized. Call insertCoin() first with 'discord' option set."
      );
    const { PermissionUtils: t10, Permissions: e } = ra;
    try {
      const { permissions: r } = await It.commands.getChannelPermissions();
      if (t10.can(e.CREATE_INSTANT_INVITE, r))
        await It.commands.openInviteDialog();
      else
        throw console.warn("User does not have CREATE_INSTANT_INVITE permissions"), new Error("User does not have CREATE_INSTANT_INVITE permissions");
    } catch {
      throw new Error("Failed to open invite dialog");
    }
  }
  function Cs() {
    return It;
  }
  function SE() {
    return Pr == null ? void 0 : Pr.access_token;
  }
  function EE() {
    return Pr;
  }
  async function g3() {
    return await Promise.resolve().then(() => index);
  }
  class m3 extends ru {
    constructor(e = {}) {
      super(), this.connection = false, this.currentRoom = false, this.isConnected = false, this.singlePlayerMode = false, this.letEveryoneWriteState = false, this.sdkOptions = e;
    }
    createRoom(e, r = false, n = false) {
      this.letEveryoneWriteState = r, e || (e = this._generateRoomId()), e = e.toUpperCase(), this.connection = new kl({
        isHost: true,
        roomId: e,
        letEveryoneWriteState: this.letEveryoneWriteState,
        enableDeltaCompression: n,
        sdkOptions: this.sdkOptions
      }), this.currentRoom = e, this.listenToEvents(), this.emit("connection_initiated");
    }
    isRenderServer() {
      if (this.connection)
        return this.connection.isRenderServer();
    }
    // Abstracted helper functions
    get isMultiplayerCastScreen() {
      return !!(!this.singlePlayerMode && this.isSpectator() && !this.isHost());
    }
    get isHost() {
      return this.connection ? this.connection.isHost : false;
    }
    get isSpectator() {
      return this.connection ? this.connection.isSpectator : false;
    }
    get isRenderServerOrHostIfNotCasting() {
      return !!(this.connection && this.connection.isRenderServerOrHostIfNotCasting);
    }
    listenToEvents() {
      this.connection.on("joined", (e) => {
        this.emit("joined", e), this.isRenderServerOrHostIfNotCasting && this.roomLog(Ri.ROOMSTATE, "player_joined", {
          playerId: e.id
        });
      }), this.connection.on("player_quit", (e) => {
        this.isRenderServerOrHostIfNotCasting && this.roomLog(Ri.ROOMSTATE, "player_quit", {
          playerId: e
        });
      }), this.connection.on("state", (e, r) => {
        this.emit("state", e, r);
      }), this.connection.on("host_updated", (e) => {
        e && (this.getState("uid") || (this.setState("uid", ka(7)), this.setState("id", this.currentRoom), this.setState("meta", {
          creatorUserId: this.connection.myId,
          creatorPermId: M0()
        })));
      }), this.connection.on("rpc", (e) => {
        this.emit("rpc", e);
      }), this.connection.on("connected", () => {
        this.isConnected = true, this.emit("connected"), this.isHost && (this.emit("room_created", { id: this.currentRoom }), this.roomLog(Ri.ROOMSTATE, "room_created", {
          host: this.connection.myId
        }));
      }), this.connection.on("reconnecting", () => {
        this.emit("reconnecting");
      }), this.connection.on("permission_error", () => {
        this.isHost ? this.createRoom() : (this.isConnected = false, this.emit("permission_error"));
      }), this.connection.on("host_left", () => {
        this.isConnected = false, this.emit("host_left");
      }), this.connection.on("disconnected", (e) => {
        this.isConnected = false, this.emit("disconnected", e);
      }), this.connection.on("players", (e) => {
        Object.keys(this.connection.playerStates).length > 0 && (this.singlePlayerMode = false), this.emit("players", e);
      }), this.connection.on("host_updated", (e) => {
        this.emit("host_updated", e);
      });
    }
    _waitforConnection() {
      return new Promise((e) => {
        this.isConnected ? e() : this.once("connected", e);
      });
    }
    on(e, r, n) {
      return e === "joined" && this._waitforConnection().then(() => {
        const i = this.getState("__pOrder") || [];
        Object.keys(
          this.connection.playerStates
        ).sort((s, a) => {
          const l = i.indexOf(s), c = i.indexOf(a);
          return l === -1 && c === -1 ? 0 : l === -1 ? 1 : c === -1 ? -1 : l - c;
        }).forEach((s) => {
          r(this.connection.playerStates[s]);
        });
      }), e === "players" && this._waitforConnection().then(() => {
        r(this.connection.playerStates);
      }), super.on(e, r, n);
    }
    once(e, r) {
      return e === "connection_initiated" && this.connection && r(), super.once(e, r);
    }
    setDeltaCompression(e) {
      this.connection.enableDeltaCompression = e;
    }
    joinRoom(e, r = false, n = false) {
      this.letEveryoneWriteState = r, e || (e = this._generateRoomId()), e = e.toUpperCase(), this.connection = new kl({
        isHost: false,
        roomId: e,
        letEveryoneWriteState: this.letEveryoneWriteState,
        enableDeltaCompression: n,
        sdkOptions: this.sdkOptions
      }), this.currentRoom = e, this.listenToEvents(), this.emit("connection_initiated");
    }
    _generateRoomId() {
      var e;
      return (e = this.sdkOptions) != null && e.persistentMode ? `PER_${ta(26)}` : ta(4);
    }
    spectateRoom(e, r, n = false, i = false) {
      this.letEveryoneWriteState = n, e || (e = this._generateRoomId()), r && (this.singlePlayerMode = true), e = e.toUpperCase(), this.connection = new kl({
        isSpectator: true,
        roomId: e,
        letEveryoneWriteState: this.letEveryoneWriteState,
        enableDeltaCompression: i,
        sdkOptions: this.sdkOptions
      }), this.currentRoom = e, this.listenToEvents(), this.emit("connection_initiated");
    }
    leaveRoom() {
      this.connection.disconnect(void 0, "MANUAL_DISCONNECT"), this.currentRoom = false, delete this.connection;
    }
    getState(e) {
      return this.connection ? e ? this.connection.getState(e) : this.connection.getState() : e === void 0 ? {} : void 0;
    }
    // get default globalThis state
    getDefaultState(e) {
      return this.connection ? e ? this.connection.getDefaultState(e) : this.connection.getDefaultState() : e === void 0 ? {} : void 0;
    }
    // host only: public method to change state object. This is then synced with all clients.
    setState(e, r, n = true) {
      this.connection && (this.isSpectator && !this.isRenderServer() || this.connection.setState(e, r, n));
    }
    /**
     * store default globalThis states. This will come in handy when we reset the states,
     * we will replace the states with these default states.
     */
    setDefaultState(e, r) {
      this.connection && (this.isSpectator && !this.isRenderServer() || this.connection.setDefaultState(e, r));
    }
    setRoundState(e, r, n = true) {
      this.connection && (this.isSpectator && !this.isRenderServer() || this.connection.setState(`round.${e}`, r, n));
    }
    getRoundState(e) {
      if (!this.connection)
        return {};
      if (e)
        return this.connection.getState(`round.${e}`);
      {
        let r = {};
        return Object.keys(this.connection.getState()).forEach((n) => {
          n.startsWith("round.") && (r[n.substring(6)] = this.connection.getState(n));
        }), r;
      }
    }
    resetRoundState() {
      Object.keys(this.connection.getState()).forEach((e) => {
        e.startsWith("round.") && this.connection.setState(e, void 0);
      }), Object.keys(this.connection.playerStates).forEach((e) => {
        this.connection.playerStates[e].resetRoundState();
      }), Object.keys(this.connection.spectatorStates).forEach((e) => {
        this.connection.spectatorStates[e].resetRoundState();
      });
    }
    // host only: we maintain a running log of winner per game, we use this to calculate leaderboard score
    addToWinLog(e, r) {
      let n = this.getState("winslog") || [];
      const i = Date.now();
      if (Se("winnerPlayerId in addToWinLog:", r), typeof r == "object") {
        const o = r.map((s, a) => (this.gameLog("winner", { winnerId: s, gameId: e }), [e, s, i]));
        n = n.concat(o);
      } else
        this.gameLog("winner", { winnerId: r, gameId: e }), n.push([e, r, i]);
      Se("currentLog (to be winslog): ", n), this.setState("winslog", n);
    }
    getMyPlayerState() {
      if (this.connection)
        return this.isSpectator ? this.connection.spectatorStates[this.connection.myId] : this.connection.playerStates[this.connection.myId];
    }
    // RenderServer only: add a stream to all spectator's webrtc
    addRenderStream(e) {
      if (!this.isRenderServer)
        return;
      const r = Object.values(this.connection.spectatorStates).filter(
        (i) => i.id !== this.connection.myId
      );
      return Se("addRenderStream", r), r.forEach((i) => i.peer.addStream(e)), this.connection.on("spectator_joined", (i) => {
        Se("spectator_joined", i), i.once("webrtc_connected", () => {
          setTimeout(() => {
            Se("adding stream"), i.peer.addStream(e);
          }, 5e3);
        });
      });
    }
    // RenderServer only: remove a stream to all spectator's webrtc
    removeRenderStream(e) {
      if (!this.isRenderServer)
        return;
      const r = Object.values(this.connection.spectatorStates).filter(
        (n) => n.id !== this.connection.myId
      );
      Se("removeRenderStream", r), r.forEach((n) => n.peer.removeStream(e));
    }
    getPlayers() {
      return this.connection ? this.singlePlayerMode ? this.connection.spectatorStates : this.connection.playerStates : {};
    }
    getSpectators() {
      return this.connection ? Object.values(this.connection.playerStates).filter(
        (e) => e.playerIsSpectator
      ) : {};
    }
    getParticipants() {
      return this.connection ? Object.values(this.connection.playerStates).filter(
        (e) => !e.playerIsSpectator
      ) : {};
    }
    attachController(e) {
      this.detachControllerLegacy();
      var r = this.connection.playerStates[this.connection.myId];
      r && r.attachControllerLegacy(e);
    }
    detachControllerLegacy() {
      var e = this.connection.playerStates[this.connection.myId];
      e && e.detachControllerLegacy();
    }
    navigate(e, r) {
      if (this.connection && (this.isRenderServer() || this.isHost)) {
        var n = { pathname: e };
        r && (n.state = JSON.stringify(r)), this.setState("path", n), this.roomLog(Ri.ROOMSTATE, "navigate", n);
      }
    }
    async roomLog(e, r, n) {
      var i;
      if (this.connection && this.isRenderServerOrHostIfNotCasting) {
        const o = { ...n };
        o.type = e, o.event = r, o.roomId = this.currentRoom, o.roomUid = this.getState("uid"), this.getState("meta") && (n = { ...n, ...this.getState("meta") });
        const s = Object.keys(this.getPlayers());
        o.playersInRoom = s.length, this.getState("playlist") && (o.playlist = this.getState("playlist")), (i = this.sdkOptions) != null && i.gameId && (o.gameId = this.sdkOptions.gameId), await a3(o);
      }
    }
    async gameLog(e, r) {
      this.connection && this.isRenderServerOrHostIfNotCasting && (r = r || {}, await this.roomLog(Ri.GAMESTATE, e, r, true));
    }
    shareEditorConfigurationWithAllClients(e, r, n) {
      this.connection && this.connection.setState(e, r, n);
    }
    setSDKOptions(e) {
      this.sdkOptions = e;
    }
    _getPersistentRoomId() {
      var r, n, i;
      if ((r = this.sdkOptions) != null && r.discord) {
        var e = Cs();
        return e ? `PER_DCRD_G${(n = this.sdkOptions) == null ? void 0 : n.gameId}_${e.guildId || e.channelId}` : `PER_${(i = this.sdkOptions) == null ? void 0 : i.gameId}_${this.currentRoom}`;
      }
      return this.currentRoom;
    }
    async setPersistentData(e, r) {
      if (!this.connection)
        return;
      const n = this.connection.getHostname(false) + "/api/room/" + this._getPersistentRoomId() + "/persistence_set", o = await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          key: e,
          value: r
        })
      });
      if (o.status !== 200)
        throw new Error("Failed to set persistent state");
      {
        const s = await o.json();
        return s.data ? s.data[0] : void 0;
      }
    }
    async getPersistentData(e) {
      if (!this.connection)
        return;
      const r = this.connection.getHostname(false) + "/api/room/" + this._getPersistentRoomId() + "/persistence_get", i = await fetch(r, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          key: e
        })
      });
      if (i.status !== 200)
        throw new Error("Failed to get persistent state");
      {
        const o = await i.json();
        return o.data ? o.data[0] : void 0;
      }
    }
    async insertPersistentData(e, r) {
      if (!this.connection)
        return;
      const n = this.connection.getHostname(false) + "/api/room/" + this._getPersistentRoomId() + "/persistence_insert", o = await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          key: e,
          value: r
        })
      });
      if (o.status !== 200)
        throw new Error("Failed to insert persistent state");
      return (await o.json()).index;
    }
  }
  const we = (() => {
    let t10 = null;
    const e = (r) => {
      var n;
      return t10 && !((n = t10 == null ? void 0 : t10.getState) != null && n.call(t10, "__launched")) && r && t10.setSDKOptions(r), t10 || (t10 = new m3(r)), t10;
    };
    return e.reset = () => {
      t10 = null;
    }, e;
  })();
  function Cl(t10, e) {
    return Object.keys(t10).map((i) => t10[i]).sort((i, o) => {
      const s = e.indexOf(i.id), a = e.indexOf(o.id);
      return s === -1 && a === -1 ? 0 : s === -1 ? 1 : a === -1 ? -1 : s - a;
    });
  }
  function Ei(t10) {
    const e = we(), r = reactExports.useRef(null), [n, i] = reactExports.useState(
      Cl(e.getPlayers(), e.getState("__pOrder") || [])
    );
    return e1(() => {
      t10 && i(
        Cl(
          e.getPlayers(),
          e.getState("__pOrder") || []
        )
      );
    }), reactExports.useEffect(() => {
      const o = () => {
        r.current && r.current();
        const s = we();
        r.current = s.on(
          "players",
          (a) => {
            i(
              Cl(a, s.getState("__pOrder") || [])
            );
          },
          true
        );
      };
      return document.addEventListener("SDKInit", o), o(), () => {
        document.removeEventListener("SDKInit", o), r.current && r.current();
      };
    }, []), n;
  }
  function y3(t10, e) {
    const r = we(), n = reactExports.useRef(null), i = r.getDefaultState(t10) ?? e;
    i !== void 0 && r.getState(t10) === void 0 && r.setDefaultState(t10, i);
    const [o, s] = reactExports.useState(
      r.getState(t10) !== void 0 ? r.getState(t10) : i
    );
    return reactExports.useEffect(() => {
      r.getState(t10) !== o && s(r.getState(t10) ?? i);
      const a = () => {
        n.current && n.current();
        const l = we();
        n.current = l.on("state", (c, u) => {
          t10 && u === t10 ? c !== c[u] && s(c[u]) : t10 || s(c);
        });
      };
      return document.addEventListener("SDKInit", a), a(), () => {
        document.removeEventListener("SDKInit", a), n.current && n.current();
      };
    }, []), o;
  }
  function e1(t10) {
    const e = reactExports.useRef([]);
    reactExports.useEffect(() => {
      const r = () => {
        e.current.length > 0 && e.current.forEach((i) => i());
        const n = we();
        e.current.push(
          n.on(
            "joined",
            (i) => {
              e.current.push(
                i.on(
                  "state",
                  (o, s) => {
                    t10(i.id, o, i.state, i);
                  },
                  true
                )
              );
            },
            true
          )
        );
      };
      return document.addEventListener("SDKInit", r), r(), () => {
        document.removeEventListener("SDKInit", r), e.current.length > 0 && e.current.forEach((n) => n());
      };
    }, []);
  }
  function b3(t10, e, r) {
    const n = reactExports.useRef(null), i = t10.getDefaultState(e) ?? r;
    i !== void 0 && t10.getState(e) === void 0 && t10.setDefaultState(e, i);
    const [o, s] = reactExports.useState(
      t10.getState(e) !== void 0 ? t10.getState(e) : i
    );
    return reactExports.useEffect(() => {
      const a = () => {
        n.current && n.current(), n.current = t10.on("state", (l, c) => {
          l === e && s(t10.getState(e));
        });
      };
      return document.addEventListener("SDKInit", a), a(), () => {
        document.removeEventListener("SDKInit", a), n.current && n.current();
      };
    }, []), o;
  }
  function xu(t10, e, r) {
    const [n, i] = reactExports.useState(Math.random());
    return reactExports.useEffect(() => {
      const o = t10.map(
        (s) => s.on(
          "state",
          (a, l) => {
            a === e && i(Math.random());
          },
          true
        )
      );
      return () => {
        o.forEach((s) => s());
      };
    }, [t10, e]), (t10 == null ? void 0 : t10.map((o) => ({
      playerId: o.id,
      state: o.getState(e)
    }))) || r || [];
  }
  function kE(t10) {
    const e = Ei();
    return xu(e, t10, void 0).map((n) => ({
      player: e.find((i) => i.id === n.playerId),
      state: n.state
    }));
  }
  function _u() {
    const t10 = we(), e = reactExports.useRef(null), [r, n] = reactExports.useState(t10.isHost);
    return reactExports.useEffect(() => {
      const i = () => {
        e.current && e.current();
        const o = we();
        e.current = o.on("host_updated", () => {
          n(o.isHost);
        }), setTimeout(() => {
          n(o.isHost);
        }, 50);
      };
      return document.addEventListener("SDKInit", i), i(), () => {
        document.removeEventListener("SDKInit", i), e.current && e.current();
      };
    }, [t10.isHost]), r;
  }
  function v3(t10) {
    return Ei(t10).filter((r) => r.playerIsSpectator);
  }
  function A3(t10) {
    return Ei(t10).filter((r) => !r.playerIsSpectator);
  }
  function CE(t10) {
    const e = v3();
    return xu(e, t10, void 0).map((n) => ({
      player: e.find((i) => i.id === n.playerId),
      state: n.state
    }));
  }
  function TE(t10) {
    const e = A3();
    return xu(e, t10, void 0).map((n) => ({
      player: e.find((i) => i.id === n.playerId),
      state: n.state
    }));
  }
  function si(t10, e) {
    return [
      y3(t10, e),
      (r, n) => we().setState(t10, r, n)
    ];
  }
  function IE(t10, e, r) {
    return [
      b3(t10, e, r),
      (n, i) => t10.setState(e, n, i)
    ];
  }
  async function OE(t10 = []) {
    return new Promise((e, r) => {
      try {
        const n = we(), i = [
          "id",
          "meta",
          "uid",
          "__launched",
          "casting",
          "__pOrder"
        ], o = n.getState();
        Object.keys(o).forEach((s) => {
          if (!i.includes(s) && !t10.includes(s)) {
            const a = n.getDefaultState(s);
            n.setState(s, a);
          }
        }), e(true);
      } catch (n) {
        r(n);
      }
    });
  }
  function PE(t10 = []) {
    return new Promise((e, r) => {
      try {
        const n = we(), i = [
          "profile",
          "__proxyBy",
          "__gamepad",
          "__bot"
        ], o = n == null ? void 0 : n.getPlayers();
        Object.keys(o).forEach((s) => {
          var l;
          const a = (l = o[s]) == null ? void 0 : l.state;
          a && Object.keys(a).forEach((c) => {
            if (!i.includes(c) && !t10.includes(c)) {
              const u = o[s].getDefaultState(c);
              o[s].setState(c, u);
            }
          });
        }), e(true);
      } catch (n) {
        r(n);
      }
    });
  }
  function RE(t10) {
    let e = null;
    const r = () => {
      e = we().on("joined", t10);
    };
    return document.addEventListener("SDKInit", r), r(), () => {
      document.removeEventListener("SDKInit", r), e && e();
    };
  }
  function DE(t10) {
    return we().on("live:tiktok:msg", t10);
  }
  function ME(t10, e, r) {
    we().setState(t10, e, r);
  }
  function NE(t10) {
    return we().getState(t10);
  }
  function LE() {
    return we().isHost;
  }
  function w3() {
    return we().isSpectator;
  }
  function BE() {
    return we().isSpectator;
  }
  function t1(t10, e) {
    const n = we().getMyPlayerState();
    e ? n.handleKeyDown(t10) : n.handleKeyUp(t10);
  }
  function FE(t10) {
    t1(t10, true);
  }
  function jE(t10) {
    t1(t10, false);
  }
  function Ln() {
    return we().getMyPlayerState();
  }
  function WE() {
    return we().getSpectators();
  }
  function UE() {
    return we().getParticipants();
  }
  function r1(t10) {
    return t10.replace(
      /https:\/\/play\.joinplayroom\.app\/games\//,
      ""
    ).split("/")[0];
  }
  function n1(t10) {
    const e = /https:\/\/play\.joinplayroom\.app/;
    return new RegExp(e, "g").test(t10);
  }
  function x3(t10, e) {
    return n1(t10) ? `https://joinplayroom.com/launch/${r1(t10)}/R${e ?? ""}` : `${t10}R${e ?? ""}`;
  }
  function _3(t10, e) {
    return n1(t10) ? `https://joinplayroom.com/app-launcher.html?game=${r1(t10)}&room=R${e}` : `${t10}R${e ?? ""}`;
  }
  function zE() {
    return we().currentRoom;
  }
  function VE(t10) {
    return we().connection.on("disconnected", (r) => {
      let n;
      Object.values($t).forEach((i) => {
        r.eventCode === i.code && (n = i);
      }), t10(n || $t.unknown);
    });
  }
  const no = {
    ALL: 0,
    OTHERS: 1,
    HOST: 2
  };
  function S3(t10, e) {
    let r = null;
    const n = () => {
      const i = we();
      r = i.on("rpc", async (o) => {
        const [s, a, l, c] = o.rpc, u = o.rid;
        if (a !== t10)
          return;
        switch (c) {
          case no.ALL:
            break;
          case no.OTHERS:
            if (s === i.getMyPlayerState().id)
              return;
            break;
          case no.HOST:
            if (!i.isHost)
              return;
            break;
          default:
            return;
        }
        const f = i.getPlayers()[s], d = await e(l, f, c);
        d !== void 0 && i.connection.rpcResponse({ rpcResp: d, rid: u });
      });
    };
    return document.addEventListener("SDKInit", n), n(), () => {
      document.removeEventListener("SDKInit", n), r && r();
    };
  }
  function E3(t10, e, r = no.ALL, n) {
    const i = we(), o = ta(5);
    return i.connection.rpcCall(
      {
        rpc: [
          i.getMyPlayerState().id,
          // sender
          t10,
          // RPC identifier
          e,
          // RPC payload,
          r
          // RPC mode
        ],
        rid: o
      },
      n
    );
  }
  function k3(t10, e) {
    return we().setPersistentData(t10, e);
  }
  function i1(t10) {
    return we().getPersistentData(t10);
  }
  function C3(t10, e) {
    return we().insertPersistentData(t10, e);
  }
  const qE = {
    Mode: no,
    register: S3,
    call: E3
  };
  async function HE() {
    const t10 = we();
    if (t10.isHost)
      return t10.setState("__matchmakingqueue", true), new Promise((e, r) => {
        t10.once("matchmaking_room_joined", e);
      });
    throw new Error("Only host can start matchmaking");
  }
  async function KE(t10) {
    const e = we();
    return new Promise((r, n) => {
      if (typeof t10 != "string" && n("Input is not of the string type."), e.isHost) {
        if (!e.connection.playerStates[t10]) {
          n(`Player: ${t10} is not belonged to this room.`);
          return;
        }
      } else {
        n("Only the host can transfer.");
        return;
      }
      e.connection.transferHost(t10, r, n);
    });
  }
  async function YE() {
    const t10 = we();
    return new Promise((e, r) => {
      if (t10.isHost) {
        r("Role switch failed: Host cannot switch roles.");
        return;
      }
      if (t10.connection.isSpectator && Object.values(t10.connection.playerStates).filter((n) => !n.playerIsSpectator).length >= t10.connection.sdkOptions.maxPlayersPerRoom) {
        r("Role switch failed: Room is full for players.");
        return;
      }
      if (!t10.connection.isSpectator && Object.values(t10.connection.playerStates).filter((n) => n.playerIsSpectator).length >= t10.connection.sdkOptions.maxSpectatorsPerRoom) {
        r("Role switch failed: Room is full for spectators.");
        return;
      }
      t10.connection.switchRole(e, r);
    });
  }
  function o1() {
    const t10 = navigator.userAgent || navigator.vendor || window.opera, e = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(t10), r = /iPhone|iPad|iPod/i.test(t10) && !window.MSStream && (window.navigator.standalone || t10.includes("Safari") && !t10.includes("CriOS") && !t10.includes("FxiOS")), n = /android/i.test(t10) && t10.includes("wv");
    return e || r || n;
  }
  const T3 = {
    listen: true
  };
  class I3 {
    constructor(e, r = T3) {
      this.playerState = e, this.keyboardConfig = r, this.keysPressed = /* @__PURE__ */ new Set(), this.debounceTimeout = 0, this.debounceDelay = 20, this.validCombinations = /* @__PURE__ */ new Set([
        "S",
        "DS",
        "D",
        "DW",
        "W",
        "AW",
        "A",
        "AS"
      ]), this.state = { isPressed: false, angle: 0, keysPressed: "" }, this.handleKeyDown = this.handleKeyDown.bind(this), this.handleKeyUp = this.handleKeyUp.bind(this), this.updateState = this.updateState.bind(this), this.debounceUpdate = this.debounceUpdate.bind(this), this.playerState.id === Ln().id && this.keyboardConfig.listen && this.listen();
    }
    handleKeyDown(e) {
      const r = e.key.toUpperCase();
      ["W", "A", "S", "D"].includes(r) && (this.keysPressed.add(r), this.debounceUpdate());
    }
    handleKeyUp(e) {
      const r = e.key.toUpperCase();
      ["W", "A", "S", "D"].includes(r) && (this.keysPressed.delete(r), this.debounceUpdate());
    }
    debounceUpdate() {
      clearTimeout(this.debounceTimeout), this.debounceTimeout = window.setTimeout(
        this.updateState,
        this.debounceDelay
      );
    }
    updateState() {
      const e = Array.from(this.keysPressed).sort().join("");
      let r = this.state.angle;
      switch (e) {
        case "S":
          r = 0;
          break;
        case "DS":
          r = Math.PI / 4;
          break;
        case "D":
          r = Math.PI / 2;
          break;
        case "DW":
          r = 3 * Math.PI / 4;
          break;
        case "W":
          r = Math.PI;
          break;
        case "AW":
          r = 5 * Math.PI / 4;
          break;
        case "A":
          r = -Math.PI / 2;
          break;
        case "AS":
          r = -Math.PI / 4;
          break;
      }
      this.state = {
        isPressed: this.validCombinations.has(e),
        // Check if keys form a valid combination
        angle: r,
        keysPressed: e
      }, this.playerState.id === Ln().id && (this.playerState.setState("ctr-joystick", this.state.isPressed), this.playerState.setState("ctr-angle", this.state.angle), this.playerState.setState("ctr-keys", this.state.keysPressed));
    }
    isPressed() {
      return this.playerState.getState("ctr-joystick") || false;
    }
    angle() {
      return this.playerState.getState("ctr-angle") || 0;
    }
    keys() {
      return this.playerState.getState("ctr-keys") || "";
    }
    listen() {
      window.addEventListener("keydown", this.handleKeyDown), window.addEventListener("keyup", this.handleKeyUp);
    }
    destroy() {
      clearTimeout(this.debounceTimeout), window.removeEventListener("keydown", this.handleKeyDown), window.removeEventListener("keyup", this.handleKeyUp), this.playerState.setState("ctr-joystick", false), this.playerState.setState("ctr-angle", 0), this.playerState.setState("ctr-keys", "");
    }
  }
  function Di(t10) {
    let e = {};
    return t10.type === "pointerdown" || t10.type === "pointermove" || t10.type === "pointerup" ? e.changedTouches = [
      {
        clientX: t10.clientX,
        clientY: t10.clientY,
        identifier: t10.pointerId
      }
    ] : (t10.type === "touchstart" || t10.type === "touchmove" || t10.type === "touchend") && (e = t10), e;
  }
  function O3(t10) {
    var e = Math.PI / 2, r, n;
    t10 > -e && t10 < e ? r = "right" : r = "left", t10 > 0 ? n = "up" : n = "down";
    let i = {};
    return r && (i.x = r), n && (i.y = n), i;
  }
  function P3(t10) {
    var e = Math.PI / 4, r;
    return t10 > e && t10 < e * 3 ? r = "up" : t10 > -e && t10 <= e ? r = "right" : t10 > -e * 3 && t10 <= -e ? r = "down" : r = "left", r;
  }
  const Go = {
    userSelect: "none",
    position: "fixed",
    transition: "opacity 0.3s 0.1s",
    willChange: "opacity",
    height: "70px",
    width: "95px",
    right: "0px",
    backgroundSize: "25px",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    fontSize: "15px",
    fontFamily: "sans-serif"
  }, Zo = {
    position: "absolute",
    top: "calc(50% - 30px)",
    left: "calc(50% - 30px)",
    height: "60px",
    width: "60px",
    border: "2px solid #fff",
    borderRadius: "10px",
    boxSizing: "border-box",
    opacity: "0.25",
    willChange: "opacity"
  }, gd = {
    position: "absolute",
    backgroundSize: "25px",
    top: "10px",
    left: "10px",
    width: "calc(100% - 20px)",
    height: "calc(100% - 20px)",
    display: "flex",
    backgroundRepeat: "no-repeat",
    color: "#fff",
    fontSize: "15px",
    fontFamily: "sans-serif"
  }, $o = [
    {
      element: { ...Go, bottom: "15px" },
      border: { ...Zo }
    },
    {
      element: { ...Go, bottom: "calc(70px + 15px)" },
      border: { ...Zo }
    },
    {
      element: { ...Go, bottom: "calc(70px * 2 + 15px)" },
      border: { ...Zo }
    },
    {
      element: { ...Go, bottom: "calc(70px * 3 + 15px)" },
      border: { ...Zo }
    }
  ], vc = {
    type: "angular",
    buttons: [],
    zones: {},
    keyboard: true
  };
  function R3(t10 = {}) {
    if (t10.type = t10.type || vc.type, t10.zones = t10.zones || vc.zones, t10.buttons && t10.buttons.length > 0) {
      if ($o.length < t10.buttons.length)
        throw new Error(`Only ${$o.length} buttons are supported.`);
      t10.buttons = t10.buttons.map((e, r) => {
        var i, o;
        let n = {
          ...e,
          css: {
            element: {
              ...$o[r].element,
              ...(i = e.css) == null ? void 0 : i.element
            },
            border: { ...$o[r].border, ...(o = e.css) == null ? void 0 : o.border }
          }
        };
        return e.icon && (n.css.element.backgroundImage = `url(${e.icon})`), n;
      });
    }
    return t10;
  }
  class Ac {
    constructor(e, r = vc) {
      var n, i, o;
      this.buttons = {}, this.joystick = {}, this.playerState = e, this.multiplayer = we(), this.allowGamepads = (i = (n = this.multiplayer) == null ? void 0 : n.sdkOptions) == null ? void 0 : i.allowGamepads, this.requestAnimationFrameId = null, this.allowGamepads && (!r.buttons || r.buttons.length === 0) && (r.buttons = [
        { id: "button1", label: "A" },
        { id: "button2", label: "B" },
        { id: "button3", label: "X" },
        { id: "button4", label: "Y" }
      ]), r = R3(r), this.validateConfig(r), this.config = r, this.multiplayer.sdkOptions && (this.multiplayer.sdkOptions.joystickConfig = this.config), e.id === Ln().id && this.initControls(r), (o = this.config) != null && o.keyboard && (this.keyboardControllerInstance = new I3(this.playerState));
    }
    validateConfig(e) {
      if (this.allowGamepads && e.zones && Object.keys(e.zones).length > 0)
        throw new Error(
          "Joystick zones don't work when allowGamepads is enabled"
        );
    }
    isAnyButtonPressed() {
      return (this.config.buttons || []).some((e) => this.isPressed(e.id));
    }
    isPressed(e) {
      return this.playerState.getState("ctr-" + e) || false;
    }
    isJoystickPressed() {
      return this.isPressed("joystick") || false;
    }
    angle() {
      return this.playerState.getState("ctr-angle") || 0;
    }
    dpad() {
      return this.playerState.getState("ctr-dpad") || {};
    }
    initControls(e) {
      (o1() || !e.keyboard) && this.setupJoystick(e.zones), e.buttons && e.buttons.length > 0 && e.buttons.forEach((r) => {
        this.setupButton(r);
      });
    }
    setupJoystick(e) {
      this.joystick.active = false, this.joystick.$element = document.createElement("div"), this.joystick.$element.id = "pr-joystick", this.joystick.$element.style.userSelect = "none", this.joystick.$element.style.position = "fixed", this.joystick.$element.style.bottom = "10px", this.joystick.$element.style.left = "10px", this.joystick.$element.style.width = "170px", this.joystick.$element.style.height = "170px", this.joystick.$element.style.borderRadius = "50%", this.joystick.$element.style.transition = "opacity 0.3s 0.0s", this.joystick.$element.style.willChange = "opacity", document.body.appendChild(this.joystick.$element), this.joystick.$cursor = document.createElement("div"), this.joystick.$cursor.style.position = "absolute", this.joystick.$cursor.style.top = "calc(50% - 30px)", this.joystick.$cursor.style.left = "calc(50% - 30px)", this.joystick.$cursor.style.width = "60px", this.joystick.$cursor.style.height = "60px", this.joystick.$cursor.style.border = "2px solid #ffffff", this.joystick.$cursor.style.borderRadius = "50%", this.joystick.$cursor.style.boxSizing = "border-box", this.joystick.$cursor.style.pointerEvents = "none", this.joystick.$cursor.style.willChange = "transform", this.joystick.$element.appendChild(this.joystick.$cursor), this.joystick.$limit = document.createElement("div"), this.joystick.$limit.style.position = "absolute", this.joystick.$limit.style.top = "calc(50% - 75px)", this.joystick.$limit.style.left = "calc(50% - 75px)", this.joystick.$limit.style.width = "150px", this.joystick.$limit.style.height = "150px", this.joystick.$limit.style.border = "2px solid #ffffff", this.joystick.$limit.style.borderRadius = "50%", this.joystick.$limit.style.opacity = "0.25", this.joystick.$limit.style.pointerEvents = "none", this.joystick.$limit.style.boxSizing = "border-box", this.joystick.$element.appendChild(this.joystick.$limit), Object.keys(e).forEach((r) => {
        const n = e[r], i = document.createElement("div");
        Object.keys(gd).forEach((o) => {
          i.style[o] = gd[o];
        }), n.icon && (i.style.backgroundImage = `url(${n.icon})`), r === "up" && (i.style.backgroundPosition = "center top", i.style.justifyContent = "center", i.style.alignItems = "flex-start"), r === "down" && (i.style.backgroundPosition = "center bottom", i.style.justifyContent = "center", i.style.alignItems = "flex-end"), r === "left" && (i.style.backgroundPosition = "left center", i.style.justifyContent = "flex-start", i.style.alignItems = "center"), r === "right" && (i.style.backgroundPosition = "right center", i.style.justifyContent = "flex-end", i.style.alignItems = "center"), n.label && (i.innerHTML = n.label), this.joystick.$limit.appendChild(i);
      }), this.joystick.angle = {}, this.joystick.angle.offset = Math.PI * 0.5, this.joystick.angle.center = {}, this.joystick.angle.center.x = 0, this.joystick.angle.center.y = 0, this.joystick.angle.current = {}, this.joystick.angle.current.x = 0, this.joystick.angle.current.y = 0, this.joystick.angle.originalValue = 0, this.joystick.angle.value = -Math.PI * 0.5, this.joystick.resize = () => {
        const r = this.joystick.$element.getBoundingClientRect();
        this.joystick.angle.center.x = r.left + r.width * 0.5, this.joystick.angle.center.y = r.top + r.height * 0.5;
      }, window.addEventListener("resize", this.joystick.resize), this.joystick.resize(), this.updateJoystick(), this.joystick.events = {}, this.joystick.touchIdentifier = null, this.joystick.events.touchstart = (r) => {
        r.preventDefault();
        const n = Di(r).changedTouches[0];
        n && (this.joystick.active = true, this.playerState.setState("ctr-joystick", true), this.joystick.touchIdentifier = n.identifier, this.joystick.angle.current.x = n.clientX, this.joystick.angle.current.y = n.clientY, this.joystick.$limit.style.opacity = "0.5", this.joystick.$element.addEventListener("pointerup", this.joystick.events.touchend), this.joystick.$element.addEventListener("touchend", this.joystick.events.touchend), this.joystick.$element.addEventListener(
          "pointermove",
          this.joystick.events.touchmove,
          { passive: false }
        ), this.joystick.$element.addEventListener("touchmove", this.joystick.events.touchmove, {
          passive: false
        }));
      }, this.joystick.events.touchmove = (r) => {
        r.preventDefault();
        const i = [...Di(r).changedTouches].find(
          (o) => o.identifier === this.joystick.touchIdentifier
        );
        i && (this.joystick.angle.current.x = i.clientX, this.joystick.angle.current.y = i.clientY);
      }, this.joystick.events.touchend = (r) => {
        [...Di(r).changedTouches].find(
          (o) => o.identifier === this.joystick.touchIdentifier
        ) && (this.joystick.active = false, this.playerState.setState("ctr-joystick", false), this.config.type === "dpad" && this.playerState.setState("ctr-dpad", void 0), this.config.zones && Object.keys(this.config.zones).forEach((o) => {
          this.playerState.setState(
            `ctr-${this.config.zones[o].id}`,
            false
          );
        }), this.joystick.$limit.style.opacity = "0.25", this.joystick.$cursor.style.transform = "translateX(0px) translateY(0px)", this.joystick.$element.removeEventListener(
          "pointerup",
          this.joystick.events.touchend
        ), this.joystick.$element.removeEventListener("touchend", this.joystick.events.touchend));
      }, this.joystick.$element.addEventListener(
        "pointerdown",
        this.joystick.events.touchstart,
        { passive: false }
      ), this.joystick.$element.addEventListener(
        "touchstart",
        this.joystick.events.touchstart,
        { passive: false }
      );
    }
    setupButton({ id: e, label: r, css: n }) {
      let i = {};
      i.id = e, i.value = false, i.$element = document.createElement("div"), r && (i.$element.innerHTML = r), Object.keys(n.element).forEach((o) => {
        i.$element.style[o] = n.element[o];
      }), document.body.appendChild(i.$element), i.$border = document.createElement("div"), Object.keys(n.border).forEach((o) => {
        i.$border.style[o] = n.border[o];
      }), i.$element.appendChild(i.$border), i.events = {}, i.touchIdentifier = null, i.events.touchstart = (o) => {
        o.preventDefault();
        const s = Di(o).changedTouches[0];
        s && (i.touchIdentifier = s.identifier, i.value = true, this.playerState.setState(`ctr-${i.id}`, true), i.$border.style.opacity = "0.5", this.joystick.$element.addEventListener("pointerup", i.events.touchend), this.joystick.$element.addEventListener("touchend", i.events.touchend));
      }, i.events.touchend = (o) => {
        [...Di(o).changedTouches].find(
          (l) => l.identifier === i.touchIdentifier
        ) && (i.value = false, this.playerState.setState(`ctr-${i.id}`, false), i.$border.style.opacity = "0.25", this.joystick.$element.removeEventListener("pointerup", i.events.touchend), this.joystick.$element.removeEventListener("touchend", i.events.touchend));
      }, i.$element.addEventListener("pointerdown", i.events.touchstart), i.$element.addEventListener("touchstart", i.events.touchstart), this.buttons[i.id] = i;
    }
    updateJoystick() {
      if (this.joystick.active) {
        if (this.joystick.angle.originalValue = -Math.atan2(
          this.joystick.angle.current.y - this.joystick.angle.center.y,
          this.joystick.angle.current.x - this.joystick.angle.center.x
        ), this.joystick.angle.value = this.joystick.angle.originalValue + this.joystick.angle.offset, this.config.type === "angular" ? this.playerState.setState("ctr-angle", this.joystick.angle.value) : this.config.type === "dpad" && this.playerState.setState(
          "ctr-dpad",
          O3(this.joystick.angle.originalValue)
        ), this.config.zones) {
          let o = P3(
            this.joystick.angle.originalValue
          );
          this.config.zones[o] && this.playerState.setState(
            `ctr-${this.config.zones[o].id}`,
            true
          ), Object.keys(this.config.zones).forEach((s) => {
            s !== o && this.playerState.setState(
              `ctr-${this.config.zones[s].id}`,
              false
            );
          });
        }
        const e = Math.hypot(
          this.joystick.angle.current.y - this.joystick.angle.center.y,
          this.joystick.angle.current.x - this.joystick.angle.center.x
        );
        let r = e;
        r > 20 && (r = 20 + Math.log(e - 20) * 5), r > 43 && (r = 43);
        const n = Math.sin(this.joystick.angle.originalValue + Math.PI * 0.5) * r, i = Math.cos(this.joystick.angle.originalValue + Math.PI * 0.5) * r;
        this.joystick.$cursor.style.transform = `translateX(${n}px) translateY(${i}px)`;
      }
      this.requestAnimationFrameId = window.requestAnimationFrame(
        this.updateJoystick.bind(this)
      );
    }
    destroy() {
      var e, r, n, i, o;
      this.requestAnimationFrameId && (cancelAnimationFrame(this.requestAnimationFrameId), this.requestAnimationFrameId = null), (n = (r = (e = this.joystick) == null ? void 0 : e.$element) == null ? void 0 : r.remove) == null || n.call(r), Object.values(this.buttons).forEach((s) => {
        s.$element.remove();
      }), window.removeEventListener("resize", this.joystick.resize), this.buttons = {}, this.joystick = {}, this.playerState.setState("ctr-joystick", false), this.playerState.setState("ctr-dpad", void 0), this.playerState.setState("ctr-angle", 0), (i = this.config) != null && i.keyboard && ((o = this.keyboardControllerInstance) == null || o.destroy());
    }
  }
  function Oa(t10, e, r) {
    t10 += "";
    var n = { "00": { A: { env: ["#ff2f2b"], clo: ["#fff", "#000"], head: ["#fff"], mouth: ["#fff", "#000", "#000"], eyes: ["#000", "none", "#00FFFF"], top: ["#fff", "#fff"] }, B: { env: ["#ff1ec1"], clo: ["#000", "#fff"], head: ["#ffc1c1"], mouth: ["#fff", "#000", "#000"], eyes: ["#FF2D00", "#fff", "none"], top: ["#a21d00", "#fff"] }, C: { env: ["#0079b1"], clo: ["#0e00b1", "#d1fffe"], head: ["#f5aa77"], mouth: ["#fff", "#000", "#000"], eyes: ["#0c00de", "#fff", "none"], top: ["#acfffd", "#acfffd"] } }, "01": { A: { env: ["#a50000"], clo: ["#f06", "#8e0039"], head: ["#85492C"], mouth: ["#000"], eyes: ["#000", "#ff9809"], top: ["#ff9809", "#ff9809", "none", "none"] }, B: { env: ["#40E83B"], clo: ["#00650b", "#62ce5a"], head: ["#f7c1a6"], mouth: ["#6e1c1c"], eyes: ["#000", "#ff833b"], top: ["#67FFCC", "none", "none", "#ecff3b"] }, C: { env: ["#ff2c2c"], clo: ["#fff", "#000"], head: ["#ffce8b"], mouth: ["#000"], eyes: ["#000", "#0072ff"], top: ["#ff9809", "none", "#ffc809", "none"] } }, "02": { A: { env: ["#ff7520"], clo: ["#d12823"], head: ["#fee3c5"], mouth: ["#d12823"], eyes: ["#000", "none"], top: ["#000", "none", "none", "#FFCC00", "red"] }, B: { env: ["#ff9700"], clo: ["#000"], head: ["#d2ad6d"], mouth: ["#000"], eyes: ["#000", "#00ffdc"], top: ["#fdff00", "#fdff00", "none", "none", "none"] }, C: { env: ["#26a7ff"], clo: ["#d85cd7"], head: ["#542e02"], mouth: ["#f70014"], eyes: ["#000", "magenta"], top: ["#FFCC00", "#FFCC00", "#FFCC00", "#ff0000", "yellow"] } }, "03": { A: { env: ["#6FC30E"], clo: ["#b4e1fa", "#5b5d6e", "#515262", "#a0d2f0", "#a0d2f0"], head: ["#fae3b9"], mouth: ["#fff", "#000"], eyes: ["#000"], top: ["#8eff45", "#8eff45", "none", "none"] }, B: { env: ["#00a58c"], clo: ["#000", "none", "none", "none", "none"], head: ["#FAD2B9"], mouth: ["#fff", "#000"], eyes: ["#000"], top: ["#FFC600", "none", "#FFC600", "none"] }, C: { env: ["#ff501f"], clo: ["#000", "#ff0000", "#ff0000", "#7d7d7d", "#7d7d7d"], head: ["#fff3dc"], mouth: ["#d2001b", "none"], eyes: ["#000"], top: ["#D2001B", "none", "none", "#D2001B"] } }, "04": { A: { env: ["#fc0"], clo: ["#901e0e", "#ffbe1e", "#ffbe1e", "#c55f54"], head: ["#f8d9ad"], mouth: ["#000", "none", "#000", "none"], eyes: ["#000"], top: ["#583D00", "#AF892E", "#462D00", "#a0a0a0"] }, B: { env: ["#386465"], clo: ["#fff", "#333", "#333", "#333"], head: ["#FFD79D"], mouth: ["#000", "#000", "#000", "#000"], eyes: ["#000"], top: ["#27363C", "#5DCAD4", "#314652", "#333"] }, C: { env: ["#DFFF00"], clo: ["#304267", "#aab0b1", "#aab0b1", "#aab0b1"], head: ["#e6b876"], mouth: ["#50230a", "#50230a", "#50230a", "#50230a"], eyes: ["#000"], top: ["#333", "#afafaf", "#222", "#6d3a1d"] } }, "05": { A: { env: ["#a09300"], clo: ["#c7d4e2", "#435363", "#435363", "#141720", "#141720", "#e7ecf2", "#e7ecf2"], head: ["#f5d4a6"], mouth: ["#000", "#cf9f76"], eyes: ["#000", "#000", "#000", "#000", "#000", "#000", "#fff", "#fff", "#fff", "#fff", "#000", "#000"], top: ["none", "#fdff00"] }, B: { env: ["#b3003e"], clo: ["#000", "#435363", "#435363", "#000", "none", "#e7ecf2", "#e7ecf2"], head: ["#f5d4a6"], mouth: ["#000", "#af9f94"], eyes: ["#9ff3ff;opacity:0.96", "#000", "#9ff3ff;opacity:0.96", "#000", "#2f508a", "#000", "#000", "#000", "none", "none", "none", "none"], top: ["#ff9a00", "#ff9a00"] }, C: { env: ["#884f00"], clo: ["#ff0000", "#fff", "#fff", "#141720", "#141720", "#e7ecf2", "#e7ecf2"], head: ["#c57b14"], mouth: ["#000", "#cf9f76"], eyes: ["none", "#000", "none", "#000", "#5a0000", "#000", "#000", "#000", "none", "none", "none", "none"], top: ["#efefef", "none"] } }, "06": { A: { env: ["#8acf00"], clo: ["#ee2829", "#ff0"], head: ["#ffce73"], mouth: ["#fff", "#000"], eyes: ["#000"], top: ["#000", "#000", "none", "#000", "#ff4e4e", "#000"] }, B: { env: ["#00d2a3"], clo: ["#0D0046", "#ffce73"], head: ["#ffce73"], mouth: ["#000", "none"], eyes: ["#000"], top: ["#000", "#000", "#000", "none", "#ffb358", "#000", "none", "none"] }, C: { env: ["#ff184e"], clo: ["#000", "none"], head: ["#ffce73"], mouth: ["#ff0000", "none"], eyes: ["#000"], top: ["none", "none", "none", "none", "none", "#ffc107", "none", "none"] } }, "07": { A: { env: ["#00deae"], clo: ["#ff0000"], head: ["#ffce94"], mouth: ["#f73b6c", "#000"], eyes: ["#e91e63", "#000", "#e91e63", "#000", "#000", "#000"], top: ["#dd104f", "#dd104f", "#f73b6c", "#dd104f"] }, B: { env: ["#181284"], clo: ["#491f49", "#ff9809", "#491f49"], head: ["#f6ba97"], mouth: ["#ff9809", "#000"], eyes: ["#c4ffe4", "#000", "#c4ffe4", "#000", "#000", "#000"], top: ["none", "none", "#d6f740", "#516303"] }, C: { env: ["#bcf700"], clo: ["#ff14e4", "#000", "#14fffd"], head: ["#7b401e"], mouth: ["#666", "#000"], eyes: ["#00b5b4", "#000", "#00b5b4", "#000", "#000", "#000"], top: ["#14fffd", "#14fffd", "#14fffd", "#0d3a62"] } }, "08": { A: { env: ["#0df"], clo: ["#571e57", "#ff0"], head: ["#f2c280"], eyes: ["#795548", "#000"], mouth: ["#ff0000"], top: ["#de3b00", "none"] }, B: { env: ["#B400C2"], clo: ["#0D204A", "#00ffdf"], head: ["#ca8628"], eyes: ["#cbbdaf", "#000"], mouth: ["#1a1a1a"], top: ["#000", "#000"] }, C: { env: ["#ffe926"], clo: ["#00d6af", "#000"], head: ["#8c5100"], eyes: ["none", "#000"], mouth: ["#7d0000"], top: ["#f7f7f7", "none"] } }, "09": { A: { env: ["#4aff0c"], clo: ["#101010", "#fff", "#fff"], head: ["#dbbc7f"], mouth: ["#000"], eyes: ["#000", "none", "none"], top: ["#531148", "#531148", "#531148", "none"] }, B: { env: ["#FFC107"], clo: ["#033c58", "#fff", "#fff"], head: ["#dbc97f"], mouth: ["#000"], eyes: ["none", "#fff", "#000"], top: ["#FFEB3B", "#FFEB3B", "none", "#FFEB3B"] }, C: { env: ["#FF9800"], clo: ["#b40000", "#fff", "#fff"], head: ["#E2AF6B"], mouth: ["#000"], eyes: ["none", "#fff", "#000"], top: ["#ec0000", "#ec0000", "none", "none"] } }, 10: { A: { env: ["#104c8c"], clo: ["#354B65", "#3D8EBB", "#89D0DA", "#00FFFD"], head: ["#cc9a5c"], mouth: ["#222", "#fff"], eyes: ["#000", "#000"], top: ["#fff", "#fff", "none"] }, B: { env: ["#0DC15C"], clo: ["#212121", "#fff", "#212121", "#fff"], head: ["#dca45f"], mouth: ["#111", "#633b1d"], eyes: ["#000", "#000"], top: ["none", "#792B74", "#792B74"] }, C: { env: ["#ffe500"], clo: ["#1e5e80", "#fff", "#1e5e80", "#fff"], head: ["#e8bc86"], mouth: ["#111", "none"], eyes: ["#000", "#000"], top: ["none", "none", "#633b1d"] } }, 11: { A: { env: ["#4a3f73"], clo: ["#e6e9ee", "#f1543f", "#ff7058", "#fff", "#fff"], head: ["#b27e5b"], mouth: ["#191919", "#191919"], eyes: ["#000", "#000", "#57FFFD"], top: ["#ffc", "#ffc", "#ffc"] }, B: { env: ["#00a08d"], clo: ["#FFBA32", "#484848", "#4e4e4e", "#fff", "#fff"], head: ["#ab5f2c"], mouth: ["#191919", "#191919"], eyes: ["#000", "#ff23fa;opacity:0.39", "#000"], top: ["#ff90f4", "#ff90f4", "#ff90f4"] }, C: { env: ["#22535d"], clo: ["#000", "#ff2500", "#ff2500", "#fff", "#fff"], head: ["#a76c44"], mouth: ["#191919", "#191919"], eyes: ["#000", "none", "#000"], top: ["none", "#00efff", "none"] } }, 12: { A: { env: ["#2668DC"], clo: ["#2385c6", "#b8d0e0", "#b8d0e0"], head: ["#ad8a60"], mouth: ["#000", "#4d4d4d"], eyes: ["#7fb5a2", "#d1eddf", "#301e19"], top: ["#fff510", "#fff510"] }, B: { env: ["#643869"], clo: ["#D67D1B", "#b8d0e0", "#b8d0e0"], head: ["#CC985A", "none0000"], mouth: ["#000", "#ececec"], eyes: ["#1f2644", "#9b97ce", "#301e19"], top: ["#00eaff", "none"] }, C: { env: ["#F599FF"], clo: ["#2823C6", "#b8d0e0", "#b8d0e0"], head: ["#C7873A"], mouth: ["#000", "#4d4d4d"], eyes: ["#581b1b", "#FF8B8B", "#000"], top: ["none", "#9c0092"] } }, 13: { A: { env: ["#d10084"], clo: ["#efedee", "#00a1e0", "#00a1e0", "#efedee", "#ffce1c"], head: ["#b35f49"], mouth: ["#3a484a", "#000"], eyes: ["#000"], top: ["#000", "none", "#000", "none"] }, B: { env: ["#E6C117"], clo: ["#efedee", "#ec0033", "#ec0033", "#efedee", "#f2ff05"], head: ["#ffc016"], mouth: ["#4a3737", "#000"], eyes: ["#000"], top: ["#ffe900", "#ffe900", "none", "#ffe900"] }, C: { env: ["#1d8c00"], clo: ["#e000cb", "#fff", "#fff", "#e000cb", "#ffce1c"], head: ["#b96438"], mouth: ["#000", "#000"], eyes: ["#000"], top: ["#53ffff", "#53ffff", "none", "none"] } }, 14: { A: { env: ["#fc0065"], clo: ["#708913", "#fdea14", "#708913", "#fdea14", "#708913"], head: ["#DEA561"], mouth: ["#444", "#000"], eyes: ["#000"], top: ["#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f"] }, B: { env: ["#81f72e"], clo: ["#ff0000", "#ffc107", "#ff0000", "#ffc107", "#ff0000"], head: ["#ef9831"], mouth: ["#6b0000", "#000"], eyes: ["#000"], top: ["#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "none", "none", "none", "none"] }, C: { env: ["#00D872"], clo: ["#590D00", "#FD1336", "#590D00", "#FD1336", "#590D00"], head: ["#c36c00"], mouth: ["#56442b", "#000"], eyes: ["#000"], top: ["#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "none", "none", "none", "none", "none", "none", "none", "none"] } }, 15: { A: { env: ["#111"], clo: ["#000", "#00FFFF"], head: ["#755227"], mouth: ["#fff", "#000"], eyes: ["black", "#008;opacity:0.67", "aqua"], top: ["#fff", "#fff", "#fff", "#fff", "#fff"] }, B: { env: ["#00D0D4"], clo: ["#000", "#fff"], head: ["#755227"], mouth: ["#fff", "#000"], eyes: ["black", "#1df7ff;opacity:0.64", "#fcff2c"], top: ["#fff539", "none", "#fff539", "none", "#fff539"] }, C: { env: ["#DC75FF"], clo: ["#000", "#FFBDEC"], head: ["#997549"], mouth: ["#fff", "#000"], eyes: ["black", "black", "aqua"], top: ["#00fffd", "none", "none", "none", "none"] } } }, i = [], o = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 231 231">', s = "</svg>", a = '<path d="M33.83,33.83a115.5,115.5,0,1,1,0,163.34,115.49,115.49,0,0,1,0-163.34Z" style="fill:#01;"/>', l = '<path d="m115.5 51.75a63.75 63.75 0 0 0-10.5 126.63v14.09a115.5 115.5 0 0 0-53.729 19.027 115.5 115.5 0 0 0 128.46 0 115.5 115.5 0 0 0-53.729-19.029v-14.084a63.75 63.75 0 0 0 53.25-62.881 63.75 63.75 0 0 0-63.65-63.75 63.75 63.75 0 0 0-0.09961 0z" style="fill:#000;"/>', c = "stroke-linecap:round;stroke-linejoin:round;stroke-width:";
    i["00"] = [], i["00"].env = a, i["00"].clo = '<path d="m141.74 195a114.93 114.93 0 0 1 37.912 16.45l0.07 0.05c-1.17 0.79-2.3601 1.55-3.5601 2.29a115.55 115.55 0 0 1-120.95 0.21q-2.0001-1.23-4.0002-2.54a114.79 114.79 0 0 1 38.002-16.5 116.21 116.21 0 0 1 15.791-2.49v-14.57c1.32 0.22 2.6501 0.39 4.0002 0.51 2.0001 0.19 4.0002 0.28 6.1202 0.29a64.333 64.33 0 0 0 8.8804-0.62c0.67003-0.09 1.3401-0.2 2.0001-0.31v14.69a118 118 0 0 1 15.741 2.54z" style="fill:#fff;"/><path d="m79.292 212a3.4601 3.46 0 0 0 3.8902 5.07 3.3801 3.38 0 0 0 2.1001-1.61 3.4701 3.47 0 0 0-1.2801-4.72 3.4201 3.42 0 0 0-2.6201-0.34 3.5101 3.51 0 0 0-2.0901 1.6zm60.122 0.46a3.4901 3.49 0 0 0 1.21 4.7h0.06a3.4601 3.46 0 0 0 4.7202-1.27l0.07-0.13a3.4601 3.46 0 0 0-1.34-4.6 3.4601 3.46 0 0 0-2.5801-0.32 3.5301 3.53 0 0 0-2.1001 1.61zm9.8004 5.7 5.8602 5.87c-1.39 0.5-2.7901 1-4.2102 1.44l-4.4802-4.47a7.5203 7.52 0 0 1-1.9401 0.81 7.8303 7.83 0 0 1-6.0002-0.79 7.8703 7.87 0 0 1-2.9201-10.69v-0.07a7.8903 7.89 0 0 1 10.77-2.88l0.12 0.07a7.8603 7.86 0 0 1 2.7901 10.62v0.07zm-37.701-2.36-9.5004 9.51v4.9c-1.35-0.16-2.6801-0.33-4.0002-0.54v-6l0.58002-0.58 10.1-10.09a7.8703 7.87 0 1 1 2.8401 2.86zm7.3203-5.91a3.4601 3.46 0 1 0-1.6101 2.1 3.3801 3.38 0 0 0 1.6101-2.1zm-29.741 7.82 3.0901 3.1 0.59002 0.59v7.36c-1.3401-0.26-2.6801-0.55-4.0002-0.87v-4.84l-2.5101-2.51a7.5203 7.52 0 0 1-1.9401 0.81 7.8803 7.88 0 1 1 1.9101-14.43 7.8703 7.87 0 0 1 2.8901 10.75z" style="fill:#1a1a1a;"/>', i["00"].head = l, i["00"].mouth = '<path d="m94.19 136.84h42.632a3.7801 3.78 0 0 1 3.7802 3.78v3.22a15.231 15.23 0 0 1-15.211 15.16h-19.781a15.251 15.25 0 0 1-15.221-15.16v-3.22a3.8002 3.8 0 0 1 3.7802-3.78z" style="fill:#fff;' + c + '3px;stroke:#1a1a1a;"/><path d="m130.96 136.84v21.16m-30.911-21.16v21.16m10.34-21.16v22.16m10.31-22.2v22.2" style="fill:none;' + c + '3px;stroke:#1a1a1a;"/>', i["00"].eyes = '<path d="m83.739 83.92h63.533a19.101 19.1 0 0 1 19.051 19 19.111 19.11 0 0 1-19.051 19h-63.533a19.091 19.09 0 0 1-19.001-19 19.091 19.09 0 0 1 19.001-19z" style="fill:#1a1a1a;"/><path d="m140.23 93.54a9.3804 9.38 0 1 0 9.3804 9.38 9.3804 9.38 0 0 0-9.3804-9.38zm-49.402 0a9.3804 9.38 0 1 0 9.3804 9.38 9.3904 9.39 0 0 0-9.3804-9.38z" style="fill:#e6e7e8;"/><rect x="79.795" y="98.627" width="71.471" height="8.5859" ry="4.2929" style="fill:#b3b3b3;"/>', i["00"].top = '<path d="m32.902 67.662c-0.36295 1.7227-6.2342 30.695 5.6133 52.596 4.5843 8.4743 9.0081 13.239 12.75 15.893a67.7 67.7 0 0 1-3.4688-21.35 67.7 67.7 0 0 1 2.332-17.658c-4.4914-2.4646-10.868-6.9012-13.834-13.52-4.1626-9.285-3.6155-14.673-3.3926-15.961zm165.19 0c0.22292 1.2882 0.77005 6.6759-3.3926 15.961-2.9664 6.6183-9.3426 11.055-13.834 13.52a67.7 67.7 0 0 1 2.332 17.658 67.7 67.7 0 0 1-3.4688 21.35c3.7419-2.6532 8.1657-7.4183 12.75-15.893 11.847-21.9 5.9762-50.873 5.6133-52.596z" style="fill:#fff;"/><path d="m115.73 13.191c-7.3787-0.13351-13.509 5.7888-13.631 13.168-0.10128 5.8827 3.4508 10.518 8.0566 12.52 1.061 0.46115 2.1869 0.78009 3.3418 0.95703v8.4291c0.66778-0.02035 1.3358-0.03077 2.0039-0.03125 0.66547-9e-5 1.3309 0.0097 1.9961 0.0293v-8.4115c2.6002-0.38406 5.1586-1.5484 7.3086-3.625 4.2322-4.0878 4.9991-9.8755 3.1582-14.549-1.8407-4.6726-6.3502-8.3834-12.232-8.4863z" style="fill:#fff;"/>', i["01"] = [], i["01"].env = a, i["01"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5c0 10.76 11.75 19.48 26.25 19.48s26.25-8.72 26.25-19.48z" style="fill:#1a1a1a;"/><path d="m92.502 194.27v0.70391c0 4.3033 2.4373 8.2583 6.3807 11.183 4.2199 3.1204 10.106 5.0508 16.661 5.0508 6.548 0 12.434-1.9303 16.654-5.0508 3.9434-2.9245 6.388-6.8795 6.388-11.183v-0.67489c1.0768 0.21771 2.1463 0.44994 3.2158 0.69666h-7e-3c1.0695 0.24672 2.1318 0.50798 3.1867 0.791-0.27648 6.103-3.6524 11.553-8.9708 15.493-5.2821 3.9114-12.521 6.328-20.466 6.328-7.9449 0-15.184-2.4165-20.474-6.328-5.333-3.9477-8.7089-9.4194-8.9708-15.544 1.055-0.27577 2.1099-0.53702 3.1722-0.78376 1.0695-0.23947 2.1463-0.46443 3.2304-0.68213z" style="fill:#b3b3b3;"/>', i["01"].head = l, i["01"].mouth = '<path d="m100.35 143.85a7.67 7.67 0 0 0 7.58 7.7v0a7.66 7.66 0 0 0 7.57-7.7 7.66 7.66 0 0 0 7.57 7.7v0a7.67 7.67 0 0 0 7.58-7.7" style="fill:none;' + c + '6.3998px;stroke:#333;"/>', i["01"].eyes = '<path d="m78.73 111a10.9 10.9 0 0 1 15.19 0m43.16 0a10.9 10.9 0 0 1 15.19 0" style="fill:none;' + c + '6.1999px;stroke:#333;"/><path d="m79.804 123.74h7.07m57.273 0h7.05" style="fill:none;' + c + '5.9998px;stroke:#b8b8b8;"/>', i["01"].top = '<path d="m57.534 142.03c-6.9383-31.75-0.57294-52.577 14.174-62.344 22.562-12.283 62.082-12.222 83.484-1.8846 21.348 11.177 22.124 37.396 18.498 63.733 8.1279-14.155 13.164-31.598 14.085-48.902 1.0828-11.795-1.1756-18.866-7.4833-27.972-26.465-37.685-103.45-31.56-129.66-2.8372-7.8504 9.4615-9.6006 17.478-9.275 26.667 1.0024 18.667 6.9688 38.508 16.18 53.54z" style="fill:#b3b3b3;"/><path d="m111.26 3.0423c-6.013 0.1128-12.629 2.6924-15.291 7.9082-1.1676 3.2383-1.6758 6.2069-1.6758 8.8926 0.89228-0.2661 1.8005-0.5164 2.7266-0.7441 3.7502-1.0672 7.4851-1.7135 11.129-1.9981 1.1007-0.086 2.1953-0.1391 3.2773-0.1601h2e-3c5.6969-0.1133 11.09 0.6603 15.904 2.0527 0.0552-3.042-0.70696-5.9824-2.1738-8.5-1.8411-3.1599-4.7033-5.5568-8.4297-6.8262-1.6883-0.4952-3.5163-0.662-5.4688-0.625zm3.0664 17.449c-0.69317-0.01-1.3919-0.01-2.0938 0h-2e-3c-1.1591 0.019-2.3326 0.064-3.5117 0.1386-3.9035 0.246-7.9025 0.8061-11.92 1.7285-15.159 3.0075-26.469 9.9279-22.068 19.682 22.891-8.7773 52.315-10.403 76.023-2.2129 2.1414-9.5529-14.939-19.081-36.428-19.34z" style="fill:#b3b3b3;"/><path d="m165.62 16.981c-0.8575 0-1.9406 0.54389-3.3476 1.3574-7.3382 4.7652-13.452 10.867-19.516 18.363 9.2734 2.1825 17.903 5.6706 25.213 10.604 1.1512-9.1263 1.9137-18.503 0.055-26.996-0.57-2.4184-1.3017-3.3267-2.4043-3.3281zm-104.09 1.6934c-1.1026 0-1.8342 0.91165-2.4043 3.3301-1.8794 8.5869-1.0806 18.078 0.092 27.299 7.0559-4.6638 15.687-8.3667 25.111-10.984-6.043-7.4601-12.139-13.537-19.451-18.285-1.407-0.81353-2.4901-1.3605-3.3477-1.3594z" style="fill:#b3b3b3;"/><path d="m162.45 16.686c-2.3175 2e-3 -4.6276 0.57608-6.8926 1.668-8.4768 6.0155-11.113 13.349-10.133 19.787 10.323 2.7077 19.762 7.0658 27.346 13.279 9.848-4.9363 11.32-17.137 4.6152-25.852-4.7104-6.1222-9.8371-8.8878-14.936-8.8828zm-97.318 4.1387c-2.4569 0.0556-5.1642 0.54474-8.1172 1.5176-13.487 4.4433-19.06 21.215-3.6484 31.84 7.2476-6.0694 16.961-10.896 27.892-14.229 0.2193-3.3241-0.3201-7.0817-1.8691-11.236-2.8049-4.8445-7.2233-7.721-13.221-7.8906-0.3408-0.01-0.6861-0.01-1.0371-2e-3z" style="fill:#b3b3b3;"/>', i["02"] = [], i["02"].env = a, i["02"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5c0 10.76 11.75 19.48 26.25 19.48s26.25-8.72 26.25-19.48z" style="fill:#5a5a5a;"/>', i["02"].head = l, i["02"].mouth = '<path d="m115.5 161.71c-8.24 0-14.46-4.15-19.19-11.25 3.37-2.44 6.51-4.57 10-6.79a5.25 5.25 0 0 1 5.48-0.17 28.19 28.19 0 0 1 3.68 2.75 28.19 28.19 0 0 1 3.68-2.75 5.25 5.25 0 0 1 5.48 0.17c3.52 2.22 6.66 4.35 10 6.79-4.74 7.1-11 11.25-19.19 11.25z" style="fill:#5a5a5a;"/>', i["02"].eyes = '<path d="m172.7 90.75h-6.54c-0.14-0.1-0.26-0.22-0.4-0.3-4.48-2.76-22.75-2.11-33.71 1.2-1 0.3-1.91 0.61-2.75 0.94-1.8937 0.79244-3.8739 1.3597-5.9 1.69-5.5051 0.79002-10.403 0.79002-15.908 0-2.0261-0.33034-4.0063-0.89756-5.9-1.69-0.84-0.33-1.76-0.64-2.75-0.94-11-3.31-29.23-4-33.71-1.2-0.13832 0.08869-0.2688 0.18906-0.39 0.3h-6.55c-1.1046 0-2 0.89543-2 2v4.66c-0.0013 0.98185 0.49088 1.8986 1.31 2.44l1.9 1.27c0.59238 0.38889 0.93475 1.0622 0.9 1.77-0.14175 5.4854 0.88072 10.939 3 16 3.58 8.38 16 10.9 24.93 10.9 2.6976 0.0771 5.3921-0.2361 8-0.93 4.35-1.43 8.24-7.36 10.45-12.42 1.7607-3.8506 2.7493-8.009 2.91-12.24 7.3e-4 -0.7138 0.38183-1.3731 1-1.73 3.2281-1.951 6.5798-1.951 9.8079 0 0.61817 0.3569 0.99927 1.0162 1 1.73 0.16067 4.231 1.1493 8.3894 2.91 12.24 2.21 5.06 6.1 11 10.45 12.42 2.6079 0.6939 5.3024 1.0071 8 0.93 8.92 0 21.35-2.52 24.93-10.9 2.1193-5.0614 3.1418-10.515 3-16-0.0348-0.70778 0.30762-1.3811 0.9-1.77l1.9-1.27c0.81913-0.54136 1.3113-1.4582 1.31-2.44v-4.6c0.0336-1.1048-0.83521-2.0274-1.94-2.06z" style="fill:#1a1a1a;' + c + '2.5;stroke:#b3b3b3;"/>', i["02"].top = '<path d="m124.22 13.61c-19.783 0-36.945 8.0887-39.695 24.106-15.332 0.23539-31.831 2.7712-41.663 15.782-6.0238 7.9604-7.0402 19.901-6.8476 31.724 0.46007 28.503 10.742 64.228-4.3012 89.714 16.584 5.7777 43.086 10.742 73.59 11.662v-8.6558c-1.851-0.35308-3.6592-0.78105-5.4353-1.2732-30.953-8.4632-50.672-36.635-47.259-68.669 1.5514-10.603 4.6221-19.665 10.025-27.69 5.3818-7.9925 13.267-15.717 23.892-21.41 0.40658 0.72757 1.9901 3.5843 2.4074 4.3012 7.5003 12.775 17.986 23.849 33.157 26.866 12.433 2.4609 23.849 3.4666 36.346 1.1555 4.2584-0.78106 10.667-2.3967 14.851-2.4181 14.861 33.404-1.0806 75.035-40.668 87.457-2.2255 0.70616-4.5258 1.316-6.8904 1.8189 0 2.707-0.0428 5.6493-0.0642 8.5274 23.603-0.72757 48.682-4.0444 72.874-11.234-18.521-32.152 0.81315-89.083-10.036-121.46-9.0731-26.973-38.85-40.315-64.282-40.305z" style="fill:#c5c5c5;"/><path d="m33.147 172.32c-2.6535 5.1143-6.088 9.9504-10.1 12.411 7.8427 10.453 17.387 19.516 28.257 26.781 16.038-10.731 35.629-17.055 54-18.606v-9.0089c-30.065-0.94155-56.108-5.8847-72.157-11.577zm164.06 0.55637c-23.731 7.0723-48.361 10.325-71.525 11.042-0.0321 3.1242-0.0535 6.2377-0.0107 9.0517 19.227 1.7226 37.908 7.8534 53.989 18.542 0.0107 0 0.0107 0 0.0214 0.0107 10.731-7.1686 20.179-16.081 27.958-26.374-4.2798-2.3967-7.832-6.9653-10.432-12.272z" style="fill:#c5c5c5;"/><path d="m50.02 46.5c-2.9297 1.9143-6.1313 3.8826-10.154 7.9805-14.091 14.359-16.145 27.701-6.1406 44.018 4.2049 6.8583 6.1414 13.706-0.24609 20.5-7.7143 8.1957-21.559 4.2912-21.537 16.061 0.0214 8.613 15.063 7.9178 22.531 13.984 3.7662 3.0707 5.0836 8.3992 2.0664 12.508-4.2156 5.7456-16.006 7.3715-22.629 8.9336 5.8811 10.843 13.45 20.638 22.355 29.033l0.0039 0.0234 0.0059-0.0137c2e-3 2e-3 0.0038 4e-3 0.0059 6e-3 0.0034-0.0112 0.0063-0.0219 0.0098-0.0332 14.775-12.218 20.268-20.965 49.461-28.434-17.404-10.258-30.68-27.122-24.143-35.34 4.4123-5.5444 5.6612-7.8633 6.4062-12.078 2.3582-13.339-10.208-22.335-9.2363-32.715 1.9432-8.2346 11.379-11.173 16.947-15.115 5.4577-3.9082 9.8014-8.7695 10.799-16.918-13.558-4.8896-17.609-5.8617-36.506-12.4zm140.87 19.357c-3.4404-0.91243-23.311 122.43 4.4121 133.14 8.9661-8.5809 16.552-18.584 22.404-29.658 0-0.31029-25.133-3.9922-25.979-14.018-0.10699-1.1769 0.11822-1.4855 0.86718-2.502 6.6764-9.2122 30.716-11.416 29.646-23.496-0.27818-3.1563-4.1617-5.2334-6.7402-6.4531-12.155-5.767-32.942-9.6494-15.031-24.543 9.2122-7.3505 10.43-8.4323 0.59766-14.691-9.4583-6.0238-9.394-11.993-9.7578-16.326-0.0767-0.93035-0.22089-1.4003-0.41992-1.4531z" style="fill:#c5c5c5;"/><path d="m133.83 39.909c-11.33 1.393-9.5492 16.204-2e-3 16.643-4.5102 10.717 9.0165 16.181 14.441 8.3125 6.562 8.6765 18.596 0.94751 14.457-8.3125 11.718-1.5381 9.2769-16.099 0-16.643 4.503-10.867-9.4883-16.101-14.457-8.3301-6.8832-9.0411-18.509-0.47321-14.439 8.3301z" style="fill:#333;"/><path d="m153.86 48.222c0-3.0528-2.5184-5.5648-5.5791-5.5648-3.0783 0-5.5793 2.512-5.5793 5.5648 0 3.0703 2.501 5.5648 5.5793 5.5648 3.0606 0 5.5791-2.4946 5.5791-5.5648z" style="fill:#f9f9f9;"/>', i["03"] = [], i["03"].env = a, i["03"].clo = '<path d="m141.75 195c13.563 3.1499 26.439 8.7409 38 16.5-38.873 26.001-89.587 26.001-128.46 0 11.561-7.7591 24.437-13.35 38-16.5 8.4869 8.8011 26.21 25.619 26.21 25.619s17.603-16.972 26.25-25.619z" style="fill:#d6d6d6;"/><path d="m109 230.81 1.6836-14.33h9.6328l1.6836 14.33c-2.16 0.12-4.33 0.19-6.51 0.19s-4.35-0.07-6.51-0.19z" style="fill:#5e5e5e;"/><path d="m124.17 210.6h-17.349v5.53a3.8828 3.29 0 0 0 3.8828 3.29h9.583a3.8828 3.29 0 0 0 3.8828-3.29z" style="fill:#535353;"/><path d="m140.57 190.36-25.066 20.245c5.9686 3.2455 11.597 7.0814 16.8 11.45 1.5989 1.3338 3.9762 1.1189 5.31-0.48 0.21005-0.25749 0.38802-0.53956 0.52999-0.84l10.826-23.805-4-6c-0.90256-1.351-2.7298-1.7137-4.08-0.81-0.11612 0.0786-0.22641 0.16549-0.33 0.26z" style="fill:#c6c6c6;"/><path d="m90.434 190.36 25.066 20.245c-5.9686 3.2455-11.597 7.0814-16.8 11.45-1.5989 1.3338-3.9762 1.1189-5.31-0.48-0.21005-0.25749-0.38802-0.53956-0.52999-0.84l-10.826-23.805 4-6c0.90256-1.351 2.7298-1.7137 4.08-0.81 0.11612 0.0786 0.22641 0.16549 0.33 0.26z" style="fill:#c6c6c6;"/>', i["03"].head = l, i["03"].mouth = '<path d="m136.21 147.09a21.77 21.77 0 0 1-40.13 0z" style="fill:#fff;' + c + '3.4999px;stroke:#000;"/>', i["03"].eyes = '<path d="m145.39 104.7-11.52 11.2h17.26m-65.52-11.2 11.52 11.2h-17.26" style="fill:none;' + c + '5.4998px;stroke:#000;"/>', i["03"].top = '<path d="m43.891 77.836c-5.1124 28.237 2.1347 61.004 24.792 81.332-6.2362-12.503-9.5362-33.948-9.4887-45.458-0.50203-37.473 41.439-46.335 56.149-17.614 18.8-31.2 52.825-16.872 54.062 13.714 0.56018 13.844-0.43568 25.598-7.0962 48.966 18.372-12.47 28.012-53.959 23.545-80.941-47.486-2.2552-94.831-2.5724-141.96 0z" style="fill:#1a1a1a;"/><path d="m111.26 12.782c-18.508 0.0791-32.594 3.6163-32.594 3.6163 24.513 5.6002 32.807 10.504 31.743 19.835-0.87227 9.702-11.092 10.875-20.811 11.554-5.2548 0.36414-10.949 0.71523-16.391 1.7525-11.862 2.2818-19.946 4.3736-24.447 11.956-1.7012 2.8662-3.7945 10.428-4.8689 16.34h141.96c-5.7242-38.563-32.557-65.073-74.595-65.054z" style="fill:#1a1a1a;"/><path d="m73.292 44.77c-11.788 2.2816-18.923 5.5444-23.394 13.126-2.8484 6.7586-4.8454 13.238-6.0072 19.939h141.96c-1.9772-14.576-6.8677-28.248-19.277-32.098-28.834-6.3308-63.774-6.3553-93.285-0.96761z" style="fill:#1a1a1a;"/><path d="m165.95 35.642c-11.178 21.829-91.89 19.36-103.98 2.3011-9.703 12.267-15.605 25.883-18.079 39.892h141.96c-3.0096-17.158-9.7424-32.688-19.902-42.193z" style="fill:#1a1a1a;"/>', i["04"] = [], i["04"].env = a, i["04"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l15.71 15.75h21z" style="fill:#949494;"/><path d="m115.45 211.34-10.55 10.54a2.51 2.51 0 0 1-3.5599 0 2 2 0 0 1-0.26999-0.30994l-18.48-25.4 5.8901-5.8899a2.52 2.52 0 0 1 3.5199-0.0791l23.49 21.14z" style="fill:#c0c0c0;"/><path d="m115.45 211.34 10.55 10.54a2.51 2.51 0 0 0 3.5599 0 2 2 0 0 0 0.26999-0.30994l18.48-25.4-5.8901-5.8899a2.52 2.52 0 0 0-3.4699-0.089l-23.49 21.14z" style="fill:#c0c0c0;"/><path d="m158.41 199.58-10.11-3.2401v29.93q5.1601-1.5299 10.11-3.51zm-75.82 26.66v-29.9l-10.1 3.2401v23.14c3.2901 1.3199 6.67 2.4999 10.1 3.5199z" style="fill:#7c7c7c;"/>', i["04"].head = l, i["04"].mouth = '<path d="m118.05 148.38c-1.5064 0.59192-2.595 2.0264-2.6191 3.9863-0.0574 1.3977 0.53421 3.5611 3.6758 5.7949 8.0544 4.9446 21.507 3.6862 21.255-7.1658-4.664 4.8219-10.021 5.6377-14.773 0.73907-1.2328-1.1599-2.3694-2.4032-3.9294-3.1408-1.0946-0.50424-2.2257-0.61071-3.6096-0.21337z" style="fill:#333;"/><path d="m133.61 154.93c3.0731-0.48816 5.5702-2.8457 5.4438-4.5059-0.47801-4.8311-5.7317-3.0917-4.3369-0.31405-2.8103-1.4445-1.8343-3.8862 0.50427-4.7324 2.0509-0.79942 5.0937 0.34314 6.2002 2.6376 2.2229 7.3422-3.4376 11.68-10.384 12.561z" style="fill:#333;"/><path d="m112.81 148.38c1.5064 0.59192 2.595 2.0264 2.6191 3.9863 0.0574 1.3977-0.53421 3.5611-3.6758 5.7949-8.0544 4.9446-21.507 3.6862-21.255-7.1658 4.664 4.8219 10.021 5.6377 14.773 0.73907 1.2328-1.1599 2.3694-2.4032 3.9294-3.1408 1.0946-0.50424 2.2257-0.61071 3.6096-0.21337z" style="fill:#333;"/><path d="m97.252 154.93c-3.0731-0.48816-5.5702-2.8457-5.4438-4.5059 0.47801-4.8311 5.7317-3.0917 4.3369-0.31405 2.8103-1.4445 1.8343-3.8862-0.50427-4.7324-2.0509-0.79942-5.0937 0.34314-6.2002 2.6376-2.2229 7.3422 3.4376 11.68 10.384 12.561z" style="fill:#333;"/>', i["04"].eyes = '<path d="m131.64 114.09 7.5801-7.5801 7.5801 7.5801m-62.6 0 7.5801-7.5801 7.5799 7.5801" style="fill:none;' + c + '6.4998px;stroke:#000;"/>', i["04"].top = '<path d="m137.38 11.148c-12.23 1.9593-18.511 14.606-43.436 9.4915-11.285-3.2054-16.406-3.573-20.389 0.58594-4.1548 4.3384-7.033 12.435-9.8184 21.706-2.1354 7.4136-3.7187 14.381-4.7461 21.646h112.7c-3.4878-24.293-10.822-43.281-25.182-51.061-3.5314-1.623-6.5274-2.2959-9.1289-2.3613z" style="fill:#b3b3b3;"/><path d="m114.37 43.383c-19.445 0.088-38.524 2.0724-52.379 5.6992-1.2766 4.5795-2.4317 10.169-3.2285 16.807h113.11c-0.83731-6.0107-1.9164-11.674-3.3184-16.924-15.229-3.8842-34.873-5.6693-54.18-5.582z" style="fill:#e6e6e6;"/><path d="m115.5 55.773c-58.39 0-105.73 15.476-105.73 34.57h0.0312c0 11.295 16.496 21.319 42.126 27.627-0.10331-7.7704 2.788-21.904 5.2734-31.031 6.0935-1.7168 6.9294-1.8971 13.167-2.9919 14.874-2.8256 29.99-4.2037 45.133-4.1153 15.143-0.0884 30.259 1.2897 45.133 4.1153 6.2372 1.0947 7.2065 1.2751 13.3 2.9919 2.4854 9.1267 5.3768 23.26 5.2734 31.031 25.63-6.3082 41.993-16.332 41.993-27.627h0.0312c0-19.093-47.34-34.57-105.73-34.57z" style="fill:#818181;"/><path d="m72.088 83.533c-6.9765 1.1147-13.357 2.856-18.439 4.3477-1.1861 7.415-2.0038 18.858-1.8926 26.293 4.3278-0.62795 10.155-1.3644 13.295-1.6465-0.40554 0.30198 2.7344-17.827 7.0371-28.994zm86.824 0c4.3028 11.167 7.4426 29.296 7.0371 28.994 3.1396 0.28213 8.9671 1.0185 13.295 1.6465 0.11119-7.4351-0.70652-18.878-1.8926-26.293-5.0822-1.4916-11.463-3.2329-18.439-4.3477z" style="fill:#434343;"/>', i["05"] = [], i["05"].env = a, i["05"].clo = '<path d="m141.75 194.98a114.79 114.78 0 0 1 38 16.498 115.53 115.52 0 0 1-128.46 0 114.79 114.78 0 0 1 38-16.498l15.71 15.748h21z" style="fill:#d2d2d2;"/><path d="m70 200.88v20.77c-2.22-0.95325-4.3999-1.9698-6.5399-3.0496h-0.10088v-14.621c2.17-1.1 4.39-2.1399 6.64-3.0996z" style="fill:#505050;"/><path d="m161 200.88v20.77c1.9-0.80986 3.7702-1.6798 5.6201-2.5898l0.0989-0.0494 0.82005-0.40997h0.10088v-14.621c-2.17-1.1-4.39-2.1399-6.6402-3.0996z" style="fill:#505050;"/><polygon transform="matrix(1 0 0 .99987 4e-5 -3e-5)" points="97.32 201.93 115.5 223.72 133.68 201.93" style="fill:#171717;"/><path d="m111.2 230.88 1.31-16.908c0.32992 1.2798 5.6399 1.2798 5.9999 0l1.3201 16.938c-1.4301 0.0494-2.8601 0.089-4.3 0.089s-2.87 0-4.3-0.089z" style="fill:#171717;"/><path d="m115.49 201.79v0.0692l-7.55 12.678-7.0001 11.809-19.19-26.487c0.60999-0.42995 1.22-0.89985 1.8001-1.3899a52 51.993 0 0 0 10.07-10.619l21.79 13.878z" style="fill:#ebebeb;"/><path d="m149.24 199.86-19.08 26.517-7.0001-11.809-7.57-12.678-0.0593-0.10086 21.94-13.998a52.21 52.203 0 0 0 10.08 10.699c0.58013 0.47009 1.1502 0.92002 1.7301 1.3399z" style="fill:#ebebeb;"/>', i["05"].head = l, i["05"].mouth = '<path d="m122.83 151.88a10.49 10.489 0 0 1-14.66 0" style="fill:none;' + c + '6.1996px;stroke:#333;"/>', i["05"].eyes = '<path d="m70.959 94.985h35.031c2.4086 1e-5 4.3612 1.9523 4.3612 4.3606l-2.5864 17.511c-0.3515 2.3799-1.7218 4.3606-3.8457 4.3606h-30.9c-2.1239-1e-5 -3.8457-1.9523-3.8457-4.3606l-2.5864-17.511c1e-5 -2.4082 1.9526-4.3606 4.3612-4.3606z" style="fill:#1a1a1a;' + c + '3.0045px;stroke:#333;"/><path d="m160.05 94.985h-35.031c-2.4086 1e-5 -4.3612 1.9523-4.3612 4.3606l2.5864 17.511c0.35149 2.3799 1.7218 4.3606 3.8457 4.3606h30.9c2.1239-1e-5 3.8457-1.9523 3.8457-4.3606l2.5864-17.511c-1e-5 -2.4082-1.9526-4.3606-4.3612-4.3606z" style="fill:#1a1a1a;' + c + '3.0045px;stroke:#333;"/><path d="m90.607 102.35a4.6337 4.6332 0 1 0 4.6892 4.6337 4.6337 4.6332 0 0 0-4.6892-4.6337zm49.72 0a4.6337 4.6332 0 1 0 4.6444 4.6337 4.6337 4.6332 0 0 0-4.6444-4.6337z" style="fill:#1a1a1a;"/><path d="m70.66 94.985h-11.775" style="fill:none;' + c + '3.0045px;stroke:#333;"/><path d="m172.13 94.985h-19.484" style="fill:none;' + c + '3.0045px;stroke:#333;"/><path d="m109.32 106.2c4.2045-2.427 9.3036-1.913 12.353-0.0258" style="fill:none;' + c + '3.0045px;stroke:#333;"/><path d="m148.33 109.79-5.7626-8.2324" style="fill:none;' + c + '4;stroke:#fff;"/><path d="m156.27 105-2.403-3.4328" style="fill:none;' + c + '4;stroke:#fff;"/><path d="m82.748 114.34-8.9489-12.784" style="fill:none;' + c + '4;stroke:#fff;"/><path d="m91.408 109.79-5.7626-8.2324" style="fill:none;' + c + '4;stroke:#fff;"/>', i["05"].top = '<path d="m41.835 75.131c-2.8674 12.582 1.2304 27.241 6.0238 39.031 0.25861 0.63658 0.51208 1.3075 0.79989 1.9683 0.71726 1.658 2.1184 3.9751 3.0038 3.9266 0.56895-0.0312 0.71637-1.5512 1.0228-3.1562 2.1988-19.097 8.8981-27.915 15.636-38.107 2.8783-4.0645 3.8616-7.2293 1.0644-9.9325-6.3236-3.5596-14.924-2.8574-21.367-0.67406-3.2312 1.4765-5.2427 3.4773-6.1842 6.9439zm125.65-8.5679c7.65-0.70616 19.714-0.1307 21.694 8.5679 1.455 6.4083 0.26915 17.747-1.0542 24.579-1.1961 5.3203-3.8066 14.231-7.8782 19.75-0.5565 0.44544-0.96888 0.13656-1.4159-1.1606-0.90692-3.0353-1.4298-7.8372-2.2556-10.727-3.4822-12.79-8.2195-21.875-14.429-29.94-5.5782-6.8415-4.2152-9.7207 5.3393-11.069z" style="fill:#4d4d4d;"/><path d="m112.27 73.826c-18.585-7.5217-34.987-14.797-48.939 5.018-4.9752 7.083-3.7876 8.8056-4.9217 0.0749-1.637-12.476-4.7505-34.174 1.9259-45.194 7.6822-12.7 19.323-13.128 31.039-5.3818 10.796 7.7784 24.277 14.647 38.015 12.219 12.732-2.2576 15.835-7.7464 15.707-19.912-0.0215-2.6-0.0963-5.2106-0.2033-7.7999 13.631 3.9267 24.609 14.776 26.513 29.049 0.88804 6.6336 0.26749 12.722-1.9259 19.013-5.9702 17.108-30.119 20.896-45.74 16.841-3.9588-1.0378-7.6822-2.4181-11.47-3.9267z" style="fill:#4d4d4d;"/>', i["06"] = [], i["06"].env = a, i["06"].clo = '<path d="m115.5 231a115 115 0 0 0 64.23-19.5 114.79 114.79 0 0 0-38-16.5l-2.41-9a125.19 125.19 0 0 0-13.32-2.28v8.75q3.52 0.32 7 0.84l-17.5 17.48-17.5-17.48q3.45-0.52 7-0.84v-8.75a125.55 125.55 0 0 0-13.34 2.28l-2.41 9a114.79 114.79 0 0 0-38 16.5 114.94 114.94 0 0 0 64.25 19.5z" style="fill:#646464;"/><path d="m132.98 193.33-36.185 36.155-2.4-0.42 36.108-36.081z" style="fill:#e3e3e3;"/>', i["06"].head = l, i["06"].mouth = '<path d="m127.84 146.73c-2.24 8.93-6.92 15.08-12.34 15.08s-10.1-6.15-12.34-15.08z" style="fill:#fff;' + c + '2.9999px;stroke:#1a1a1a;"/>', i["06"].eyes = '<path d="m129.31 114.14 20-5.37m-47.66 5.37-20-5.37" style="fill:none;' + c + '4.9998px;stroke:#1a1a1a;"/>', i["06"].top = '<path d="m169.65 90.998c3.137 11.94 4.9371 36.484-3.4118 58.213l5.129 3.1164c10.044-15.199 14.959-39.163 13.943-61.33z" style="fill:#1a1a1a;"/><path d="m45.081 90.989c-0.88085 4.9304-0.87534 14.953-0.15027 21.75 2.1318 19.98 16.671 42.505 16.671 42.505l5.7352-4.4331s-13.244-31.348-6.0571-52.751c0.52108-1.5517 0.95592-2.916 1.3462-4.1835z" style="fill:#1a1a1a;"/><path d="m117 3.4883c-8.2136-0.19887-19.13 7.933-18.494 9.3516 1.6214 3.6186 11.176 22.55 11.889 23.963h10.148c2.6022-6.3102 11.32-26.531 11.32-26.531s-4.1382-4.138-12.416-6.4375c-0.77605-0.21556-1.5976-0.32513-2.4473-0.3457z" style="fill:#1a1a1a;"/><path d="m115.95 4.5428c-3.1563 0-6.3123 0.57462-9.2165 1.715-5.8084 2.2817-10.532 6.808-12.779 12.245v-5e-3c-1.8166 4.397-2.0233 9.3441-0.58058 13.857 0.69352 2.1687 1.7693 4.2296 3.1533 6.0968h38.893c0.71032-0.95769 1.3441-1.9641 1.8787-3.0144 2.6811-5.2673 2.9296-11.542 0.67253-16.975-2.257-5.4337-6.9893-9.9522-12.802-12.224-2.9064-1.1335-6.0633-1.6987-9.2196-1.6956z" style="fill:#1a1a1a;"/><path d="m92.512 28.125c0.13387 1.4318 0.41877 2.8511 0.85962 4.2306 1.4429 4.5127 4.5278 8.5654 8.6411 11.353 4.1135 2.7873 9.2311 4.2913 14.336 4.2165 5.1052-0.0764 10.168-1.7333 14.181-4.6419 2.8754-2.0834 5.2132-4.7932 6.7665-7.8447 1.2005-2.3586 1.9085-4.9188 2.127-7.5156-15.037-2.6407-31.421-3.4671-46.912 0.20253z" style="fill:#b3b3b3;"/><path d="m34.426 90.63c14.714 4.0779 22.683 6.4085 45.254 7.4257 2.5318-18.185 4.6689-28.672 10.023-38.352 3.2025 13.403 3.8346 25.22 2.9106 42.253l11.172-0.23161c1.4706-11.886 3.8989-29.213 2.1636-42.021 10.416 12.631 11.373 23.624 13.077 39.726 30.174-0.76004 59.808-4.5121 77.845-10.128-10.76-38.608-41.475-55.66-80.38-56.104-38.182-0.45134-74.543 22.405-82.065 57.432z" style="fill:#1a1a1a;"/>', i["07"] = [], i["07"].env = a, i["07"].clo = '<path d="m88.18 194.11c-4.2079 1.021-8.3545 2.2792-12.42 3.7695v26.072a115.5 115.5 0 0 0 79.48 0v-26.072c-4.0858-1.4904-8.2529-2.7486-12.48-3.7695v8.7051c0 9.3888-7.6112 17-17 17h-20.58c-9.3888 0-17-7.6112-17-17v-8.7051z" style="fill:#efefef;"/>', i["07"].head = l, i["07"].mouth = '<polygon points="121.61 160.74 109.39 160.74 115.5 171.31" style="fill:#797979;"/><path d="m132.64 144.06a34.42 34.42 0 0 1-34.24 0" style="fill:none;' + c + '5.9998px;stroke:#000;"/>', i["07"].eyes = '<path d="m170.25 100c1.69 9.62-4.79 29.23-22.4 29.23-6.81 0-15-3.66-20.23-10-4.34-5.33-7.56-12.87-6.2-19.45 1.63-7.89 7.07-11.45 14.67-12.92a68.16 68.16 0 0 1 12.52-1c10.77 0 19.78 3.61 21.64 14.22z" style="fill:#565656;stroke-width:3.99px;stroke:#000;"/><path d="m60.75 100c-1.69 9.62 4.79 29.23 22.4 29.23 6.81 0 15-3.66 20.23-10 4.34-5.33 7.56-12.87 6.2-19.45-1.63-7.89-7.07-11.45-14.67-12.92a68.16 68.16 0 0 0-12.52-1c-10.77 0-19.78 3.61-21.64 14.22z" style="fill:#565656;stroke-width:3.99px;stroke:#000;"/><line x1="100.2" x2="130.8" y1="87.92" y2="87.92" style="fill:none;' + c + '3.99px;stroke:#000;"/><path d="m109.87 101.73c0-2.59 2.52-4.69 5.63-4.69s5.63 2.1 5.63 4.69" style="fill:none;stroke-width:3.99px;stroke:#000;"/>', i["07"].top = '<path d="m30.622 70.381c2.0971-3.9374 4.6649-7.9604 7.6822-12.037 3.0172-4.0765 6.0987-7.6929 9.2229-10.817l22.897 22.897c-4.4402 4.4403-8.2278 9.5439-11.213 15.14z" style="fill:#999;"/><path d="m160.58 70.423 22.907-22.897c3.1242 3.1242 6.2056 6.7406 9.2229 10.817 3.0065 4.0765 5.5744 8.0994 7.6715 12.037l-28.578 15.182c-2.9851-5.5958-6.7727-10.689-11.224-15.14z" style="fill:#999;"/><path d="m92.411 15.247c3.8197-0.87736 7.6715-1.5407 11.534-1.9794 4.0765-0.46007 7.9282-0.69546 11.555-0.69546 1.53 0 3.1563 0.0428 4.8682 0.1391l1.851 22.255 5.767-21.57c3.1028 0.37449 6.0666 0.86666 8.8912 1.4658l-10.55 49.763c-1.9259-0.41729-3.702-0.70617-5.3176-0.87736-1.423-0.14979-3.2633-0.22468-5.5102-0.22468-2.2362 0-4.237 0.10699-5.981 0.29958-1.9473 0.22469-3.8732 0.55636-5.767 0.99504z" style="fill:#999;"/><path d="m92.411 15.247c1.9152-0.43869 4.023-0.84526 6.3233-1.2304 2.065-0.34238 4.1514-0.62057 6.2698-0.84525l5.1785 50.565c-1.0913 0.10699-2.1827 0.25679-3.2954 0.43868-0.86665 0.14979-1.9152 0.36378-3.1349 0.64196z" style="fill:#4d4d4d;"/>', i["08"] = [], i["08"].env = a, i["08"].clo = '<path d="m141.89 195a114.79 114.79 0 0 1 38 16.5 115.55 115.55 0 0 1-128.47 0 114.79 114.79 0 0 1 38-16.5l15.75 15.75h21z" style="fill:#353535;"/><path d="m146.4 196.14-17.4 17.44-1.17 1.17h-24.34l-1.18-1.17-17.43-17.44c1.49-0.41 3-0.79 4.51-1.14l4.67-1 12.74 12.74h17.69l12.73-12.74 4.67 1c1.52 0.35 3 0.73 4.51 1.14z" style="fill:#919191;"/>', i["08"].head = l, i["08"].mouth = '<path d="m115.68 160.64c7.08 0 13.11-4.93 15.46-11.84a2.14 2.14 0 0 0-1.51-2.6101 2.3 2.3 0 0 0-0.73995-0.0593h-26.42a2.12 2.12 0 0 0-2.31 1.9099 1.85 1.85 0 0 0 0.0593 0.73995c2.3401 6.9301 8.3802 11.86 15.46 11.86z" style="fill:#2f2f2f;"/>', i["08"].eyes = '<path d="m145.38 95.628c-5.1601 2.2597-11.03 2.2597-16.19 0m-47.29 1.75c5.1755-2.2694 11.065-2.2694 16.24 0" style="fill:none;' + c + '5.9998px;stroke:#5e5e5e;"/><path d="m90.016 106.28c-4.4506-0.0105-6.6902 5.3657-3.5508 8.5195 3.1394 3.1539 8.5252 0.93887 8.5352-3.5117 0.0063-2.7522-2.2204-4.9898-4.9727-4.9961l-0.011719-0.01172zm47.281 0c-4.4506-0.0105-6.6902 5.3657-3.5508 8.5195 3.1394 3.1539 8.5252 0.93887 8.5352-3.5117 6e-3 -2.7522-2.2204-4.9898-4.9727-4.9961l-0.01171-0.01172z" style="fill:#1a1a1a;"/>', i["08"].top = '<path d="m108.37 22.019c-6.2698-12.829-17.151-13.396-18.949 1.1769-11.448-9.4583-26.021-4.483-20.361 12.422-12.251-7.9282-24.919 1.7761-17.076 20.853-27.08 2.3646-22.715 24.726-10.111 31.435-9.9002 3.3566-10.701 9.4006-8.464 14.497 2.6574 4.7842 9.0126 6.4737 11.545 9.6519-6.624 0.59419-8.4112 5.6011-5.7404 9.5192 1.6896 2.4787 5.2756 4.2218 8.5971 5.5455 1.0485 0.40658 3.702 1.2732 3.9053 2.4181 0.18744 1.2156-6.7884 3.0055-5.7281 5.2612 0.60648 1.4227 1.7764 2.7151 2.6466 3.7156 1.2807 1.6595 10.755 8.0351 9.4583 4.2049-1.0271-3.7234-2.2148-7.4682-3.1456-11.192-1.1662-5.3069-1.7868-10.721-1.102-16.156 1.4223-5.455 5.069-4.4265 7.7837-8.3588 3.5264-5.7505 2.0296-11.614 2.124-13.575 0.107-1.7868 1.5407-1.1876 3.1884-1.4337 4.3868-0.64196 7.0081-2.1185 8.8377-6.2698 0.77035-1.9259 0.62057-9.7578 0.52426-11.78 0.36378-4.6328 4.1835 0 6.548 0.64196 3.2633 0.88805 6.8797 0.21399 9.0731-2.5037 1.7547-2.3753 2.0864-2.8888 4.6114-0.80245 2.6856 2.2148 4.0979 3.1349 7.6929 3.274 5.5637 0.20329 8.7735-6.2698 11.32-5.6386 3.5201 0.87735 3.6057 5.4567 10.261 4.8682 2.386-0.20329 3.8304-0.86665 5.4032-2.6428 0.88805-0.99505 1.958-2.5037 3.4345-2.6214 1.4658-0.1177 2.3218 2.3646 3.0065 3.4452 1.1926 2.6755 4.0295 3.6513 6.2377 3.3168 1.958-0.17119 3.854-1.4115 5.4268-2.4707 0.99679-0.66102 1.8284-0.81128 1.9256 0.2071 0.29592 2.2271 0.0862 7.7025 0.1596 8.4821 0.10556 8.4609 5.37 10.569 13.223 10.333-0.31871 3.7464 0.0583 11.28 5.4353 14.562 3.9481 2.7604 6.6657 1.2732 6.7299 7.8534 7e-3 6.1914-0.43693 13.061-1.2946 18.189-0.69547 4.0444-1.2412 6.4838-2.5251 10.378-0.64196 1.9152-0.81315 1.9687 1.4123 1.0699 7.1472-3.1456 10.539-11.48 8.3562-18.842-0.43869-2.0436 0.84525-1.7226 2.8781-2.6106 9.5248-4.2363 8.1264-11.335-0.75967-14.273 11.988-3.0926 13.886-8.9002 6.6871-15.375 7.3077-5.9168 3.6378-16.177-2.8032-16.991 12.422-7.0937 5.7349-22.062-5.1036-18.499 4.1728-12.037-5.5637-26.203-21.121-16.894 6.9653-11.373 2.065-22.661-12.101-10.785-3.4559-18.382-15.14-16.584-23.902-5.018 0.09435-20.075-16.001-17.42-18.146-2.5892z" style="fill:#1a1a1a;"/><path d="m5.4353 80.502c7.4468 9.1373 15.632 8.8912 15.632 8.8912s-6.0772 3.7983-6.8369 9.8755c-0.75966 6.088 4.5579 9.6295 8.0994 10.646 3.5522 1.0058 7.0937-2.7925 7.0937-2.7925s-5.8312 10.646-1.5193 15.964c4.3012 5.3176 11.908 3.0386 11.908 3.0386s-5.3283 10.132 1.0057 14.187c5.8312 3.7234 18.542 7.6715 20.511 8.2706-6.0666-9.7472-9.576-21.249-9.576-33.575v-0.0428c0-35.201 28.546-63.747 63.747-63.747 35.212 0 63.758 28.546 63.758 63.747 0 12.476-3.5843 24.116-9.7899 33.949h0.53496s13.931-1.0057 16.21-9.3727c2.279-8.3562 0.75967-9.8756 0.75967-9.8756s10.635 2.0329 13.417-7.5966l2.7926-9.6295s10.132 0 10.892-7.083c0.75963-7.0937-7.0295-12.411-7.0295-12.411s11.459 0.82385 14.498-10.453c1.0164-3.7555 0.83456-8.2171 0.1391-12.497-17.665-41.161-58.569-69.995-106.18-69.995-30.632 0-60.034 12.187-81.679 33.831v0.0107c-13.171 13.171-22.833 29.22-28.386 46.66z" style="fill:#1a1a1a;"/>', i["09"] = [], i["09"].env = a, i["09"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l13.85 13.85v-1.2h17.86v3.1h5z" style="fill:#333;"/><polygon points="115.36 207.65 123.37 224.2 148.3 196.86 143.08 189.95" style="fill:#fff;"/><polygon points="115.36 207.65 107.35 224.2 82.42 196.86 87.63 189.95" style="fill:#fff;"/>', i["09"].head = l, i["09"].mouth = '<path d="m126.28 149.82c-6.16 2.43-15.52 2.42-21.56 0" style="fill:none;' + c + '5.9998px;stroke:#1c1c1c;"/>', i["09"].eyes = '<path d="m83.527 103.98v10h10v-10h-10zm53.945 0v10h10v-10h-10z" style="fill:#1a1a1a;"/><path d="m56.621 94.906v11.688h5.3418v6.4922h5.3418v6.1055h5.3223v6.2324h26.846v-6.2324h5.3047v-6.1055h5.1445v-6.0039h11.154v6.0039h5.1446v6.1055h5.3066v6.2324h26.846v-6.2324h5.3203v-6.1055h5.3438v-6.4922h5.3418v-11.688z" style="fill:#1a1a1a;"/><path d="m67.387 100.65v5.9394h5.1992v-5.9394zm5.1992 5.9394v6.4922h5.4238v-6.4922zm5.4238 0h5.1992v-5.9394h-5.1992zm5.1992 0v6.4922h5.4258v-6.4922zm5.4258 6.4922v6.1055h5.1426v-6.1055zm-10.625 0v6.1055h5.1445v-6.1055zm48.281-12.432v5.9394h5.1992v-5.9394zm5.1992 5.9394v6.4922h5.4238v-6.4922zm5.4238 0h5.1992v-5.9394h-5.1992zm5.1992 0v6.4922h5.4258v-6.4922zm5.4258 6.4922v6.1055h5.1426v-6.1055zm-10.625 0v6.1055h5.1445v-6.1055z" style="fill:#fff;"/>', i["09"].top = '<path d="m157.79 67.5a61.31 61.31 0 0 1-42.79 17.43h-55.7c18.16-37.74 68.27-46.85 98.49-17.43z" style="fill:#4d4d4d;"/><path d="m122.93 7.0078c-10.503-0.15729-21.09 1.6448-29.545 5.4316-17.141 7.8999-32.169 23.297-43.973 38.779-5.1703 6.8631-8.7779 13.46-8.1855 18.395 0.93114 12.312 10.372 26.483 11.068 36.9 15.663-72.081 105.99-70.452 124.91-7.0525l4e-3 0.0156c5.616-10.926 8.0682-20.188 8.352-27.653 0.43654-15.607-7.8088-21.149-21.735-28.249 1.7934-3.7704 1.7273-7.5023 2.0625-10.154-0.79964-7.8568-3.6796-13.51-10.43-17.758-5.9434-3.7404-13.06-6.0867-18.463-7.2266-4.5319-0.87895-9.2901-1.3562-14.064-1.4277z" style="fill:#4d4d4d;"/><path d="m42.426 75.338c0.52158 18.689 10.557 74.338-18.115 101.25 12.38 10.603 28.352 19.061 46.025 24.594 11.032-4.6874 22.88-7.4147 34.817-8.5046l0.0633-14.477c-22.49-4.3813-40.766-18.898-48.862-39.967-8.096-21.07-4.7931-44.72 9.2478-62.393zm124.67 2.7207c7.8997 10.886 11.743 24.64 11.787 37.441-0.36632 30.178-22.389 57.576-53.12 62.708l0.0238 14.471c12.282 1.1216 24.518 3.9888 35.825 8.9128 15.488-5.1448 30.007-13.325 42.396-25.043-13.136-22.051-23.282-63.045-18.694-101.55z" style="fill:#4d4d4d;"/><path d="m143.61 46.383c-11.639 0.12482-20.998 1.8906-20.998 1.8906l-9 3.5059c0.63003-0.0191 1.2603-0.0289 1.8906-0.0293h0.0996c35.169 0.055 60.959 27.235 63.283 63.383 7.4e-4 31.157-22.742 57.213-53.106 63.079l-0.0216 14.498c11.567 1.0563 23.154 3.6067 33.887 8.0463 35.952-15.315 55.082-52.303 36.709-68.279-5.018-7.9035-10.44-15.409-9.5544-23.03 5.0545-50.452 0.39626-63.561-43.189-63.064zm-69.966 21.09c-15.286 3.244-17.096 3.73-31.734 6.6953 3.0304 13.081 3.0583 22.274 1.2085 30.012-3.8004 11.361-8.9712 19.787-12.286 28.764-6.8823 22.459-2.9157 31.982 12.093 46.165 8.6595 8.0693 19.861 16.209 30.939 20.647 2.669-1.0316 5.3729-1.9628 8.106-2.792 7.4979-2.275 15.388-3.6535 23.206-4.3673l0.0433-14.393c-23.933-4.5937-44.283-21.98-50.77-45.817-6.3319-23.265 0.51104-48.752 19.195-64.914z" style="fill:#4d4d4d;"/>', i[10] = [], i[10].env = a, i[10].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l15.71 15.75h21z" style="fill:#666;"/><path d="m89.291 195a114.79 114.79 0 0 0-38.002 16.5 115.53 115.53 0 0 0 38.002 16.482zm52.434 0v32.982a115.53 115.53 0 0 0 38-16.482 114.79 114.79 0 0 0-38-16.5z" style="fill:#999;"/><path d="m157.15 199.75c0.2548 7.4501 1.54 14.855 4.9512 21.432a115.53 115.53 0 0 0 17.619-9.6797 114.79 114.79 0 0 0-22.57-11.752zm-83.295 2e-3a114.79 114.79 0 0 0-22.57 11.75 115.53 115.53 0 0 0 17.621 9.6797c3.411-6.5765 4.6944-13.98 4.9492-21.43z" style="fill:#ccc;"/><path d="m99.197 204.97v2e-3l16.302 16.301 16.301-16.301v-2e-3z" style="fill:#fff;"/>', i[10].head = l, i[10].mouth = '<path d="m100.19 152.09c2.8726 4.0616 9.8095 4.7232 15.119-0.45432 5.0656 4.5134 11.167 5.6898 15.495 0.31458" style="fill:none;' + c + '5.8949;stroke:#333;"/><path d="m109.67 135.53c-0.9758 0.0743-2.05 0.45327-3.1485 0.99414-4.3235 2.1399-7.3862 4.2557-10.639 7.1406-0.6251 0.5715 0.1168 0.77785 1.4238 0.87304 5.6967 0.0536 14.384 0.41404 15.098-0.875 1.9251-2.0788 1.7969-5.3303-0.1816-7.3008-0.701-0.67533-1.5769-0.90632-2.5527-0.83203zm11.656 0c-0.9758-0.0743-1.8517 0.1567-2.5527 0.83203-1.9785 1.9705-2.1067 5.222-0.1817 7.3008 0.7142 1.289 9.401 0.9286 15.098 0.875 1.307-0.0952 2.0489-0.30154 1.4238-0.87304-3.2524-2.8849-6.3151-5.0007-10.639-7.1406-1.0985-0.54087-2.1727-0.91985-3.1485-0.99414z" style="fill:#333;"/>', i[10].eyes = '<path d="m97.56 107.84a10.63 10.63 0 0 1-15 0.13l-0.13-0.13" style="fill:none;' + c + '6.3px;stroke:#000;"/><path d="m148.59 107.84a10.63 10.63 0 0 1-15 0.13l-0.13-0.13" style="fill:none;' + c + '6.3px;stroke:#000;"/>', i[10].top = '<path d="m41.668 87.073c-9.2319-0.0231-11.63 6.5104 2.2676 17.66-14.015 1.1231-4.3662 16.457 4.875 24.66 4.0686 3.0199 6.4647 5.4657 5.5078 1.1348-1.2079-4.9178-1.8184-9.9634-1.8184-15.027 3.26e-4 -7.5692 1.2547-15.016 3.7883-22.183 0.57048-1.7876 1.0689-2.0306-0.37721-2.6839-5.5405-2.4478-10.375-3.5511-14.243-3.5608z" style="fill:#ccc;"/><path d="m185.48 89.513c-2.4418-0.11189-5.4618 0.81187-9.5148 3.2121-1.314 0.81729-0.70075 1.995-0.32301 3.2653 3.194 10.982 3.8215 22.462 1.2538 33.628-0.31613 1.688-0.47649 3.569 2.6953 1.3516 7.7016-5.371 19.17-18.734 16.918-26.105-1.4251-3.9177-11.4-0.35546-11.4-0.35546s4.987-4.2755 5.3437-9.6191c0.20048-3.0057-1.5237-5.2189-4.9726-5.377z" style="fill:#ccc;"/><path d="m91.689 36.108c-3.7298-7.3864-9.5859-10.504-17.578-6.7891-9.5194 4.5907-15.629 18.444-13.416 29.232 0 0-8.5511-4.9878-18.17-3.5625-19.623 8.094-1.4102 29.869 10.817 37.342 2.075 1.297 2.5792 1.7432 3.4291-0.37685 2.6746-6.5374 6.1886-12.722 11.297-17.709 4.1039 8.7427 14.629 4.1809 20.006-0.14062 4.4873 9.6838 10.377 6.3535 15.377 3.4785 4.0764 7.8829 10.756 7.25 17.631 0.0625 4.875 4.5625 14.713 4.1867 15.555-3.426 8.4753 2.6244 14.012 10.437 22.962-1.4764 8.8552 6.8221 14.407 16.853 17.122 27.51 0.34 1.554 1.175 0.85565 2.2212 0.44315 10.255-4.286 22.842-15.749 15.705-23.975-3.5623-3.5623-13.539-2.1387-13.539-2.1387s6.77-7.1233 9.2637-18.168c2.4936-11.043-23.514-4.9883-23.514-4.9883s7.4818-5.6993 12.113-13.537c4.6314-7.8378-2.4943-11.756-11.045-11.043-8.5496 0.71204-17.1 7.4805-17.1 7.4805s3.3946-7.8055-3.5625-12.826c-9.5935-6.9234-23.869 6.4121-23.869 6.4121-4.2562-26.835-24.872-6.386-31.707 8.1953z" style="fill:#ccc;"/>', i[11] = [], i[11].env = a, i[11].clo = '<path d="m116 203.13c-0.12 0-0.25 0.12-0.49 0.12s-0.25-0.12-0.49-0.12zm-27.29-8c0.87-0.25 1.72-0.47 2.56-0.69a32.37 32.37 0 0 0 0.3 8.57 21.5 21.5 0 0 0 7 6.88c6.41-6 16.8-6.64 16.8-6.64s10.5 0.58 17 6.69a21.61 21.61 0 0 0 6.93-6.66 32.34 32.34 0 0 0 0.35-8.84l2.13 0.56a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.64 114.64 0 0 1 37.38-16.37z" style="fill:#e9e9e9;"/><path d="m126.15 206-3.92 7.83h-13.46l-3.92-7.83a36.59 36.59 0 0 1 10.65-2.7 35.66 35.66 0 0 1 10.65 2.7z" style="fill:#818181;"/><path d="m124.54 230.65-2.18-16.74h-13.47l-2.19 16.76c2.9 0.22 5.84 0.33 8.8 0.33s6.06-0.12 9-0.35z" style="fill:#989898;"/><path d="m134.84 186s0.86 9.8-19.34 17.26c0 0 15.79 0.86 20.57 11.76 0.12 0.49 9.3-23.26-1.23-29z" style="fill:#fff;"/><path d="m96.16 186c-10.41 5.76-1.35 29.39-1.1 29 4.65-10.78 20.56-11.76 20.56-11.76-20.32-7.45-19.46-17.24-19.46-17.24z" style="fill:#fff;"/>', i[11].head = l, i[11].mouth = '<path d="m118.57 165.14a8.66 8.66 0 0 0-2.76-4.23h-0.62a8 8 0 0 0-2.76 4.22c-0.52 1.89 2.07 10.61 2.76 12.53h0.62c0.64-1.76 3.19-10.82 2.76-12.52z" style="fill:#333;"/><path d="m102.81 152.24a2.4921 2.4921 0 1 1 1.19-4.84l0.21 0.06a37.1 37.1 0 0 0 5.43 1.12 44.52 44.52 0 0 0 11.76 0 37.1 37.1 0 0 0 5.43-1.12 2.4903 2.4903 0 0 1 1.59 4.72l-0.21 0.06a43.08 43.08 0 0 1-6.15 1.29 48.55 48.55 0 0 1-13.08 0 42.79 42.79 0 0 1-6.17-1.29z" style="fill:#333;"/>', i[11].eyes = '<path d="m86.851 100.39a4.94 4.94 0 1 0 4.9297 5 5 5 0 0 0-4.9297-5zm57.221 0a4.94 4.94 0 1 0 4.9394 4.9394 4.94 4.94 0 0 0-4.9394-4.9394z" style="fill:#333;"/><path d="m86.207 89.365c-25.504 0-21.503 6.8561-21.035 19.596 0.80177 18.121 17.763 16.514 21.201 16.639 14.758-0.041 20.518-8.227 22.951-22.932 1.8166-10.731-9.251-13.174-23.117-13.303zm58.598 0c-13.866 0.1284-24.936 2.5717-23.119 13.303 2.4332 14.705 8.1936 22.891 22.951 22.932 3.4383-0.125 20.399 1.4828 21.201-16.639 0-18.965-0.47958-19.596-21.033-19.596z" style="fill:#4d4d4d;"/><path d="m169.87 90.255a0.51 0.51 0 0 0-0.43991-0.52 167.64 167.64 0 0 0-22.6-1.6801c-12 0-27.47 3.7601-30.17 3.7601h-2.4c-1.2499 0-5.29-0.80996-10.45-1.6801a124.35 124.35 0 0 0-19.72-2.08 166.18 166.18 0 0 0-19.31 1.24c-1.56 0.17999-2.69 0.35009-3.2899 0.44009a0.51 0.51 0 0 0-0.44007 0.52l-0.091 6.4501a0.57 0.57 0 0 0 0.33012 0.52l0.73994 0.23992c1.08 0.41992 1.0001 19.85 6.78 24.71 3.4401 2.8599 6.51 4.4899 19.42 4.4899 7.4699 0 12.17-1.9999 16.63-8 3.21-4.32 6.0999-14.55 6.0999-14.55 0.82006-4.07 3.7702-4.52 4.43-4.5801h0.12068c0.11078 0 3.66 0.0593 4.57 4.5801 0 0 2.8599 10.22 6.0699 14.54 4.4601 5.9999 9.1601 8 16.63 8 12.91 0 16-1.63 19.42-4.4901 5.7898-4.86 5.6998-24.29 6.78-24.71l0.73994-0.23993a0.57 0.57 0 0 0 0.32996-0.52l-0.12068-6.4501zm-65 23c-1.9101 4.5-6.8 10.29-13.7 10.64-20.7 0.99985-21.65-4.7401-23-9.3201a31.45 31.45 0 0 1-1.2099-13.18c0.53997-4.5799 1.7-7.2699 3.7801-8.6201a9.3 9.3 0 0 1 4.3499-1.51 85.07 85.07 0 0 1 11.4-0.52 59.23 59.23 0 0 1 9.2099 0.69999c7.37 1.2 12.35 3.7001 12.35 6.1601a46.12 46.12 0 0 1-3.23 15.64zm58 1.3201c-1.34 4.5799-2.29 10.36-23 9.3201-6.91-0.3501-11.81-6.1401-13.71-10.64a46.35 46.35 0 0 1-3.22-15.64c0-3.39 9.43-6.8599 21.56-6.8599 12.13 0 14 0.89996 15.75 1.9999 2.08 1.3502 3.2398 4 3.77 8.6201a31.23 31.23 0 0 1-1.1601 13.17z" style="fill:#333;"/>', i[11].top = '<path d="m156.1 15.879c-0.38556 5.3015-1.7049 9.4762-3.6602 12.76-0.41226 23.773-9.2343 35.229-15.154 42.797l15.062-4.6641c-0.66253 2.8135-2.4628 7.156-0.34766 12.137 1.6334-2.3144 7.9395-5.807 13-3.3477-0.43442 3.5532-0.95271 7.094-1.4512 10.639l8.9648 0.85937c0.83453 3.8792 0.51719 9.3449-0.59961 11.736l5.5508 2.0098c0.20764 2.7646 0.10001 5.4906-0.74609 8.875 8.4545-1.7225 14.213-4.3896 19.641-13.188 2.8639-4.7524 4.9018-10.483 4.7305-17.242-4.1612 4.916-9.6484 7.2485-15.26 10.109 6.507-11.065 8.8648-22.768 8.1367-30.58-7.3456 10.251-11.649 13.06-19.918 16.9 1.2386-11.4 5.5249-18.582 12.461-27.27-11.392-1.3025-16.301 1.4749-24.891 6.4395 4.5466-14.036 2.2208-26.679-5.5195-38.971zm-117.76 28.682c9.3378 3.6366 19.581 9.0234 21.129 18.549-7.6182 0.0414-14.897-3.5072-20.242-7.1894-0.15967 8.2309 2.8451 12.252 6.7734 19.08-7.2127 1.6129-12.084 4.8315-17.471 9.4805 7.2948-0.15715 12.299-1.0502 16.891 4.2793-6.0512 5.0164-11.99 10.79-11.99 19.24 9.257-6.1688 12.495-5.9486 21.137-2.2012 1.2906-8.0996 2.3978-14.872 2.7869-16.435 2.4719-0.73247 3.5247-0.94807 5.9221-1.2938-2.1556-7.4281 1.0996-9.5176 2.4141-11.6l7.543 1.5059c-3.9093-6.1699 2.6565-12.483 7.1445-15.51-4.4474-7.2082-5.6649-11.558-7.377-16.797-11.198-8.2947-23.895-6.2742-34.66-1.1094z" style="fill:#f9f9f9;"/><path d="m101.9 7.6408c-10.047 6.2416-12.441 28.646-12.131 33.289-6.9249-5.8258-7.8992-13.75-7.7695-19.203-9.6235 6.0158-10.666 14.421-9 23.943 1.1061 5.1411 2.3972 10.461 7.377 16.797 2e-3 -1e-3 4e-3 -3e-3 6e-3 -4e-3 2.7742 2.8742 5.4644 5.5941 8.3477 8.3574 0.41187-6.971 0.45449-13.622 7.1856-15.824 3.9532 2.8169 7.4123 5.9388 11.084 9.1035l10.559-10.25c5.6447 3.961 5.4531 6.5652 6.5215 14.104 2.153-1.7546 8.719-9.0037 15.844-10.139 0.98706 4.1261-0.99388 10.308-2.6387 13.621 0 0 14.32-11.846 15.195-27.971 0.33968-6.2599 0.2237-11.146-0.041-14.826-3.2125 5.5652-8.7118 8.7799-13.789 10.15-4.2715-9.2486-2.4785-21.435-0.48047-29.309-12.21 3.0195-20.932 18.337-22.172 25.07-9.2678-7.397-13.605-16.146-14.098-26.91z" style="fill:#f9f9f9;"/>', i[12] = [], i[12].env = a, i[12].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l26.23 13 26.27-13z" style="fill:#131111;"/><polygon points="115.5 208.03 115.5 207.74 82.72 188.91 80.45 198.86 101.46 222.72" style="fill:#cbcbcb;"/><polygon points="115.5 208.03 115.5 207.74 148.28 188.91 150.55 198.86 129.54 222.72" style="fill:#cbcbcb;"/>', i[12].head = l, i[12].mouth = '<path d="m123.07 154.05a10.61 10.61 0 0 1-15 0.14l-0.14-0.14" style="fill:none;' + c + '6.3px;stroke:#000;"/><path d="m120.1 142.22 0.19-0.11c3-1.87 5.45-2.4 7.3-1.46 2.15 1.1 3.12 3.84 4.84 5.5a5.18 5.18 0 0 0 6.68 0.73m-28.21-4.66-0.19-0.11c-3-1.87-5.45-2.4-7.3-1.46-2.15 1.1-3.12 3.84-4.84 5.5a5.18 5.18 0 0 1-6.68 0.73" style="fill:none;' + c + '5.9998px;stroke:#4d4d4d;"/>', i[12].eyes = '<path d="m161.73 86.016h-92.51c-3.37 0-6.0001 2.3998-6.0001 5.2999v28.45c0 3.0002 2.74 5.3001 6.0001 5.3001h32.36c7.0901 0 7.44-19.43 13.82-19.43s6.8801 19.44 13.83 19.44h32.36c3.37 0 5.9999-2.4 5.9999-5.3001v-28.46c0.14043-2.9001-2.6-5.2999-5.9-5.2999z" style="fill:#8f8f8f;"/><path d="m161.73 86.016h-92.51c-3.37 0-6.0001 2.3998-6.0001 5.2999v28.45l104.55-28.45c0-2.9001-2.74-5.2999-5.9999-5.2999z" style="fill:#e3e3e3;"/><path d="m161.73 86.016h-92.51c-3.37 0-6.0001 2.3998-6.0001 5.2999v28.45c0 3.0002 2.74 5.3001 6.0001 5.3001h32.36c7.0901 0 7.44-19.43 13.82-19.43s6.8801 19.44 13.83 19.44h32.36c3.37 0 5.9999-2.4 5.9999-5.3001v-28.46c0.14043-2.9001-2.6-5.2999-5.9-5.2999z" style="fill:none;' + c + '4.0026px;stroke:#232323;"/>', i[12].top = '<path d="m69.834 33.826c-8.2001-0.0626-16.444 2.6753-23.152 7.7038-8.5298 6.9899-12.159 19.61-12.329 32.68-0.2041 15.476 1.6092 34.752 1.7464 51.915 0.10414 13.047 0.53485 25.984-2.9197 33.995-2.4994 5.81-9.0955 9.6006-16.196 12.311 7.9599 2.8301 25.009 2.8094 33.58 1.5393 10.8-1.59 17.238-6.5294 17.159-22.699-0.0911-15.93-1.3894-29.23-1.559-45.83-0.3208-11.983-1.569-24.291 4.9774-33.987 4.2139-6.1265 10.452-10.521 17.116-13.588 3.9292-1.8575 8.0384-3.3083 12.263-4.3297-6.8718-13.574-18.732-19.618-30.687-19.709z" style="fill:#b3b3b3;"/><path d="m90.8 76.246c11.918-17.125 31.996-23.218 49.743-17.488 11.81 3.9496 20.692 13.389 22.313 28.237 0.51051 6.2098 0.63413 12.445 0.37007 18.67-0.23973 11.2-0.72946 23.82-1.0995 34.08-0.82005 22.43 0.0593 35.1 24.589 36.3 8.5635 0.32122 17.137-0.22845 25.59-1.6405h-0.0198c-10.74-3.3799-17.98-15.609-19.3-26.289-1.29-10.41-0.6098-23.43-0.7898-38.091-0.1701-14.96 1.0398-29.819 0.28008-42.089-1.414-22.777-14.947-38.505-34.126-45.152-27.813-7.35-51.083 0.091-61.672 17.343-5.4698 8.9112-7.7413 20.07-5.8788 36.121z" style="fill:#b3b3b3;"/>', i[13] = [], i[13].env = a, i[13].clo = '<path d="M61.11,205.59l3.49,3.69-6.26,6.6A115.45,115.45,0,0,0,72,222.51v-22a115.19,115.19,0,0,0-10.85,5.1Z" style="fill:#eee;"/><path d="M93.24,228.85V199l-4-4A114.43,114.43,0,0,0,72,200.49v22a114.43,114.43,0,0,0,21.28,6.34Z" style="fill:#787878;"/><path d="m159 222.51v-22a114.63 114.63 0 0 0-17.25-5.51l-4 4v29.86a114.16 114.16 0 0 0 21.25-6.35z" style="fill:#787878;"/><path d="m169.89 205.59-3.49 3.69 6.26 6.6a115.45 115.45 0 0 1-13.66 6.63v-22a115.19 115.19 0 0 1 10.85 5.1z" style="fill:#eee;"/><path d="M115.5,219.62A28.5,28.5,0,0,1,87.25,195c2.93-.74,5.92-1.36,8.94-1.87a19.41,19.41,0,0,0,38.62,0c3,.51,6,1.13,8.94,1.87a28.49,28.49,0,0,1-28.25,24.63Z" style="fill:#c9c9c9;"/>', i[13].head = l, i[13].mouth = '<path d="m115.5 153.93a14 14 0 0 1-10.5-4.69 3.4209 3.4209 0 0 1 5-4.67l0.08 0.08 0.08 0.09a7.35 7.35 0 0 0 10.39 0.37l0.37-0.37a3.4206 3.4206 0 1 1 5.23 4.41l-0.08 0.09a14 14 0 0 1-10.53 4.69z" /><path d="m115.27 127.32c-7.6627-0.03-15.251 1.4419-20.646 5.1465-7.62 5.33-9.9053 11.512-14.127 18.109-3.4379 5.2447-9.326 10.024-13.467 6.334 25.425 29.755 71.409 29.786 96.875 0.0664-6.8104 3.9305-11.545-2.47-13.508-6.4004-10.697-17.605-14.115-22.656-35.127-23.256zm-0.26758 8.3984c7.457 0.0802 14.986 1.2966 17.146 5.9522 2.5765 11.319-7.5878 17.454-16.681 17.515-6.09-0.05-12.2-2.3802-15.26-7.7402-6.36-11.16 3.6349-15.607 14.795-15.727z" style="fill:#404040;"/>', i[13].eyes = '<path d="m91.72 97.36v11.4m47.56-11.4v11.4" style="fill:none;' + c + '7.9999px;stroke:#333;"/>', i[13].top = '<path d="m52.107 57.293c-1.3411 14.839-3.8707 52.771 1.3145 72.715-0.67572-43.829 12.389-70.177 62.078-70.187 49.689 0.010061 62.754 26.359 62.078 70.187 5.1852-19.944 2.6556-57.876 1.3145-72.715h-63.393-63.393z" style="fill:#4d4d4d;"/><path d="m52.339 30.629c-1.3825 24.448-2.1216 45.905-1.4497 66.517 9.4643-48.304 112.77-54.916 129.22 0 0.67191-20.612-0.3798-47.256-1.4928-66.517-32.241 14.296-91.346 18.861-126.28 0z" style="fill:#4d4d4d;"/><path d="m115.5 24.92c-22.25 0-44.5 4.2296-56.72 12.69-3.32 2.3-5.0602 6.4392-5.5903 10.269-0.45275 3.23-0.84043 6.7561-1.1785 10.461h126.98c-0.33704-3.7047-0.72492-7.2306-1.1775-10.461-0.53009-3.8301-2.2697-7.9992-5.5897-10.269-12.22-8.4601-34.47-12.69-56.72-12.69z" style="fill:#4d4d4d;"/><path d="m76.521 39.139c21.233 3.3965 33.116-13.392 37.59-31.72 4.3614 17.158 14.175 34.968 36.577 31.584-33.921 20.594-57.646 11.594-74.167 0.1345z" style="fill:#4d4d4d;"/>', i[14] = [], i[14].env = a, i[14].clo = '<path d="m91.92 194.41a101.47 101.47 0 0 1 23.58 17.09 101.47 101.47 0 0 1 23.58-17.09c0.89 0.19 1.78 0.38 2.67 0.59a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5c0.88-0.21 1.78-0.4 2.67-0.59z" style="fill:#757575;"/><path d="m73.65 199.82c16.59 8.23 28.72 18.91 34.27 30.93a114.86 114.86 0 0 1-56.65-19.25 115.06 115.06 0 0 1 22.38-11.68z" style="fill:#d8d8d8;"/><path d="m60.63 205.85c12.35 5.94 21.93 13.44 27.59 21.91a114.7 114.7 0 0 1-36.95-16.26q4.53-3 9.36-5.65z" style="fill:#757575;"/><path d="m157.35 199.82c-16.6 8.23-28.72 18.91-34.27 30.93a114.86 114.86 0 0 0 56.65-19.25 115.06 115.06 0 0 0-22.38-11.68z" style="fill:#d8d8d8;"/><path d="m170.37 205.85c-12.35 5.94-21.93 13.44-27.59 21.91a114.7 114.7 0 0 0 36.95-16.26q-4.53-3-9.36-5.65z" style="fill:#757575;"/>', i[14].head = l, i[14].mouth = '<path d="m115.5 131c-17.71 0.65-27 9.41-29.61 23.69-1 5.62-0.43 7.06 2.76 7.17 22.76 0.76 22.23 18.21 26.85 18.89 4.62-0.68 4.09-18.13 26.85-18.89 3.19-0.11 3.79-1.55 2.76-7.17-2.62-14.28-11.9-23-29.61-23.69zm0 29.31c-10 0-18-5-18-11.17s8.08-11.17 18-11.17 18 5 18 11.17-8.08 11.17-18 11.17z" style="fill:#333;"/><path d="m123.54 148.46a11.53 11.53 0 0 1-16.09 0" style="fill:none;' + c + '6.7998px;stroke:#000;"/>', i[14].eyes = '<path d="m133 108.17h14.17m-63.26 0h14.09m-20.69-8.93a21.31 21.31 0 0 1 27.29 0m21.8 0a21.31 21.31 0 0 1 27.29 0" style="fill:none;' + c + '4.8243px;stroke:#000;"/>', i[14].top = '<path d="m115.5 51.75c-38.702 5.3101-54.215 18.038-59.863 35.101" style="fill:none;' + c + '12;stroke:#333;"/><path d="m115.5 51.75c-7.8393 3.6337-5.5974 16.583-14.341 23.452" style="fill:none;' + c + '12;stroke:#333;"/><path d="m111.35 48.614c-22.634-6.9181-42.457-3.1988-55.733 2.5105" style="fill:none;' + c + '12;stroke:#333;"/><path d="m115.47 54.008c0.1965-6.7774-0.1436-26.309 0.05-38.184" style="fill:none;' + c + '12;stroke:#333;"/><path d="m68.874 28.177c34.115-3.382 41.987 13.321 45.17 19.602" style="fill:none;' + c + '12;stroke:#333;"/><path d="m116.49 48.69c2.8876-6.3019 10.358-21.518 43.469-22.326" style="fill:none;' + c + '12;stroke:#333;"/><path d="m116.92 51.766c1.5094 6.3991 3.4988 15.595 10.088 23.058" style="fill:none;' + c + '12;stroke:#333;"/><path d="m113.81 51.532c22.03-7.8674 46.709-7.3614 59.444-2.0465" style="fill:none;' + c + '12;stroke:#333;"/><path d="m114.53 52.278c36.226 4.8583 52.414 17.092 59.373 33.347" style="fill:none;' + c + '12;stroke:#333;"/><path d="m55.637 86.851c-4.1213 12.452-2.9877 27.213-1.777 43.084" style="fill:none;' + c + '12;stroke:#333;"/><path d="m55.614 51.124c-13.422 5.5019-21.908 16.409-24.712 28.774-1.8322 8.4632-1.9809 18.156-1.6096 28.486" style="fill:none;' + c + '12;stroke:#333;"/><path d="m173.26 49.486c24.917 10.399 26.707 36.537 27.209 59.62" style="fill:none;' + c + '12;stroke:#333;"/><path d="m173.9 85.625c5.4042 12.625 5.2413 27.675 4.5745 43.58" style="fill:none;' + c + '12;stroke:#333;"/><path d="m53.86 129.93c1.293 16.951 2.6738 35.169-2.1664 53.193" style="fill:none;' + c + '12;stroke:#333;"/><path d="m29.292 108.38c0.6173 17.177 2.6722 36.119 0.8158 54.108" style="fill:none;' + c + '12;stroke:#333;"/><path d="m200.47 109.11c0.3586 18.529-1.2751 36.94 1.9231 48.985" style="fill:none;' + c + '12;stroke:#333;"/><path d="m178.48 129.2c-0.7279 17.362-2.0563 35.743 2.6011 53.099" style="fill:none;' + c + '12;stroke:#333;"/>', i[15] = [], i[15].env = a, i[15].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5 115.77 115.77 0 0 1 15.71-2.53v-14.09a63.8 63.8 0 0 0 21 0v14.09a116.6 116.6 0 0 1 15.75 2.53z" style="fill:#1a1a1a;"/><path d="m60.984 205.66 6.2675 2.2051 3.4074-6.819 2.8018-1.1353-3.9911 7.9907 27.222-3.0857 3.2541-11.739 2.1451-0.2692-3.2833 11.819 20.393-1.6011-14.191-15.945v-2.4379l17.606-5.7274 3.3855-0.473v1.47l-19.167 6.2295 14.731 16.542 19.839-7.7432 3.3636 0.8223-21.371 8.34 20.532 13.842 2.6777-21.687 1.9481 0.5604-2.7726 22.378 0.0584 0.0364 8.5075 4.9923-2.4807 0.85145-6.4718-3.7916-1.2987 6.0622-2.1524 0.53125 1.3425-6.2804-17.037 8.8348-5.0271 0.35661 21.59-11.193-20.962-14.133-7.5006 25.457-2.0721-0.0364 7.6392-25.915-21.05 1.652 9.0109 24.052-1.4155-0.0946-0.49615-0.0437-0.073-7e-3 -0.2043-0.0145-8.3688-22.342-10.127 19.242-1.9846-0.52399 10.514-19.962-26.04 2.9547 13.425 16.418-3.4438-1.0625-12.083-14.781-8.1645 5.9675-1.9043-1.077 8.128-5.9385-6.9898-2.4598 2.3348-1.2881zm92.509-7.2556 14.228 20.093-1.8095 0.89514-15.614-22.043z" style="fill:#b2b2b2;"/>', i[15].head = l, i[15].mouth = '<path d="m97.06 144.59a20.15 20.15 0 0 0 36.88 4.53z" style="fill:#fff;' + c + '2.9999px;stroke:#000;"/>', i[15].eyes = '<line x1="85.29" x2="85.29" y1="98.73" y2="109.79" style="fill:none;' + c + '8.7999px;stroke:#000;"/><path d="m108.28 72.16h62.18c9.19 0 13.32 1.21 14.71 8.52 3.61 18.95 2.2 33.49-0.44 43.75a65.07 65.07 0 0 1-5.89 14.78 73.52 73.52 0 0 1-7.06 10.26c-1.8 2.27-5.17 1.21-4.19-1.09 0.14-0.47 0.27-1 0.4-1.48a14.29 14.29 0 0 0 0.52-6.62 12.52 12.52 0 0 0-3.88-6.3c-4.17-3.9-12.81-8.71-32.53-13.66-6.4-1.6-10.69-2.24-11.76-2.79a7.08 7.08 0 0 1-3.85-6.31v-9c0-2.39 0.18-4.55-1.56-6.57s-4.16-2.13-6.65-2.14a6 6 0 0 1-6-6v-9.35a6 6 0 0 1 6-6z" style="fill:#1a1a1a;"/><path d="m135.9 98.73v9.27m15.22-9.29v9.29" style="fill:none;' + c + '7.7998px;stroke:#b2b2b2;"/>', i[15].top = '<path d="m109.99 15.57c-13.46 3.6301-19.789 11.95-24.069 24.08-6.9996-7-8.7307-10.82-7.5606-21.43a41 41 0 0 0-9.2698 24.988c0.0366 7.6776 5.6462 13.939 12.697 15.297-13.315 5.8106-15.258 22.033-14.045 33.524 5.7687-11.861 14.254-20.981 27.258-22.951-0.43017 6.6-2.5099 10.22-7.29 17.66 18.29-2.8601 25.119-7.8199 37.15-18.24 0.46001 0 1.0001 0.089 1.4606 0.12058-0.33023 3.5601-1.0906 6.5598-5.0004 12.46 9.5298-1.32 14.721-5.8006 17.539-11.671 8.8862 0.95314 15.836 6.785 21.26 14.818 1.928-15.211-4.4766-26.6-19.807-34.036 1.4167-2.6974 8.0143-11.925 17.661-15.721-1.424-0.28569-2.8883-0.49486-4.4033-0.61125-5.71-0.41992-13.62-0.99982-24.89 4.1703 2.8501-8.5101 10.21-11 18.05-13.12-15.131-1.2501-28.61-2.5898-40.53 8.1801-1.8997-6.21-0.18055-12.54 3.7889-17.52z" style="fill:#fff;"/><path d="m172.63 69.954c1.2292 14.064 0.93841 29.96 0.34635 45.169 1.7887 6.796 3.0379 13.235 3.8842 18.388l0.13973-0.011c1.0001 6.56 2.3597 13.18 3.2698 19.73 2.0002-6.5699 2.5303-18.25 3.2405-25.43 1.2597-13 1.8296-29.311-0.43017-41.931-0.85041-4.72-2.0007-7.6896-2.0007-8.4796 4.6205 3.5601 8.6606 9.2204 13.001 14.15-0.6751-3.4318-1.347-6.6004-2.0567-9.5273-4.047-5.7183-13.726-12.154-19.393-12.06z" style="fill:#fff;"/><path d="m157.97 34.471c-10.339 2.7579-17.715 13.543-19.132 16.24 15.33 7.4361 20.783 17.96 21.278 33.517 5.9534 8.8179 10.066 20.289 12.857 30.895 0.87636-13.178 1.8186-27.726 0.26566-44.28 2.5698 0.44857 9.1372 1.3934 18.781 11.17-2.1158-8.7321-4.5671-15.31-8.4539-20.283-4.5598-5.8401-10.999-10.431-23.809-13 9.6502-3.34 16.27-0.76993 25.5 2.1301-8.1388-7.4315-16.474-14.219-27.287-16.389z" style="fill:#fff;"/><path d="m61.473 73.354c-7.256-0.77501-13.024 2.3746-16.262 5.3879 0.73789-0.45409 1.3868-0.74208 1.8489-0.74208 0 0-1.5198 10.359-1.6197 11.519-1.56 19.73 0.99957 43.401 6.37 62.471 1.3099 4.6899 1.1895 3.0893 1.8898-0.9107 1.7526-10.061 3.3891-24.703 6.9739-38.864-5.068-17.627-4.2508-32.403 0.79937-38.861z" style="fill:#fff;"/><path d="m69.09 43.21c-0.0253 1.0803-8e-3 2.1612 0.0523 3.2402-3.8402 0-12.46 0.71984-16 2.1598-4.4504 1.8001-8.48 5.4801-11.67 11.83 7.2999-3.94 11.899-3.8502 16.66-1.8102-10.39 3.45-19.52 11.37-20.32 26.9 1.1456-1.5053 4.6079-4.9789 7.1393-6.6285 0.09-0.0587 0.17427-0.10556 0.26167-0.15946 3.7141-2.3211 9.0494-5.1247 15.181-4.9553-5.0501 6.4577-6.6824 20.434 0.28207 38.428 1.7866-7.0567 4.0574-13.994 7.0681-20.184-1e-3 -11.664 2.0764-27.774 15.391-33.585-7.0508-2.1538-12.709-7.991-14.043-15.236z" style="fill:#fff;"/>';
    var u = u || function(S, C) {
      var _ = {}, L = _.lib = {}, F = function() {
      }, V = L.Base = { extend: function(O) {
        F.prototype = this;
        var q = new F();
        return O && q.mixIn(O), q.hasOwnProperty("init") || (q.init = function() {
          q.$super.init.apply(this, arguments);
        }), q.init.prototype = q, q.$super = this, q;
      }, create: function() {
        var O = this.extend();
        return O.init.apply(O, arguments), O;
      }, init: function() {
      }, mixIn: function(O) {
        for (var q in O)
          O.hasOwnProperty(q) && (this[q] = O[q]);
        O.hasOwnProperty("toString") && (this.toString = O.toString);
      }, clone: function() {
        return this.init.prototype.extend(this);
      } }, W = L.WordArray = V.extend({ init: function(O, q) {
        O = this.words = O || [], this.sigBytes = q != C ? q : 4 * O.length;
      }, toString: function(O) {
        return (O || G).stringify(this);
      }, concat: function(O) {
        var q = this.words, te = O.words, Y = this.sigBytes;
        if (O = O.sigBytes, this.clamp(), Y % 4)
          for (var K = 0; K < O; K++)
            q[Y + K >>> 2] |= (te[K >>> 2] >>> 24 - K % 4 * 8 & 255) << 24 - (Y + K) % 4 * 8;
        else if (65535 < te.length)
          for (K = 0; K < O; K += 4)
            q[Y + K >>> 2] = te[K >>> 2];
        else
          q.push.apply(q, te);
        return this.sigBytes += O, this;
      }, clamp: function() {
        var O = this.words, q = this.sigBytes;
        O[q >>> 2] &= 4294967295 << 32 - q % 4 * 8, O.length = S.ceil(q / 4);
      }, clone: function() {
        var O = V.clone.call(this);
        return O.words = this.words.slice(0), O;
      }, random: function(O) {
        for (var q = [], te = 0; te < O; te += 4)
          q.push(4294967296 * S.random() | 0);
        return new W.init(q, O);
      } }), X = _.enc = {}, G = X.Hex = { stringify: function(O) {
        var q = O.words;
        O = O.sigBytes;
        for (var te = [], Y = 0; Y < O; Y++) {
          var K = q[Y >>> 2] >>> 24 - Y % 4 * 8 & 255;
          te.push((K >>> 4).toString(16)), te.push((15 & K).toString(16));
        }
        return te.join("");
      }, parse: function(O) {
        for (var q = O.length, te = [], Y = 0; Y < q; Y += 2)
          te[Y >>> 3] |= parseInt(O.substr(Y, 2), 16) << 24 - Y % 8 * 4;
        return new W.init(te, q / 2);
      } }, ie = X.Latin1 = { stringify: function(O) {
        var q = O.words;
        O = O.sigBytes;
        for (var te = [], Y = 0; Y < O; Y++)
          te.push(String.fromCharCode(q[Y >>> 2] >>> 24 - Y % 4 * 8 & 255));
        return te.join("");
      }, parse: function(O) {
        for (var q = O.length, te = [], Y = 0; Y < q; Y++)
          te[Y >>> 2] |= (255 & O.charCodeAt(Y)) << 24 - Y % 4 * 8;
        return new W.init(te, q);
      } }, P10 = X.Utf8 = { stringify: function(O) {
        try {
          return decodeURIComponent(escape(ie.stringify(O)));
        } catch {
          throw Error("Malformed UTF-8 data");
        }
      }, parse: function(O) {
        return ie.parse(unescape(encodeURIComponent(O)));
      } }, z10 = L.BufferedBlockAlgorithm = V.extend({ reset: function() {
        this._data = new W.init(), this._nDataBytes = 0;
      }, _append: function(O) {
        typeof O == "string" && (O = P10.parse(O)), this._data.concat(O), this._nDataBytes += O.sigBytes;
      }, _process: function(O) {
        var q = this._data, te = q.words, Y = q.sigBytes, K = this.blockSize, $ = Y / (4 * K), $;
        if (O = ($ = O ? S.ceil($) : S.max((0 | $) - this._minBufferSize, 0)) * K, Y = S.min(4 * O, Y), O) {
          for (var se = 0; se < O; se += K)
            this._doProcessBlock(te, se);
          se = te.splice(0, O), q.sigBytes -= Y;
        }
        return new W.init(se, Y);
      }, clone: function() {
        var O = V.clone.call(this);
        return O._data = this._data.clone(), O;
      }, _minBufferSize: 0 });
      L.Hasher = z10.extend({ cfg: V.extend(), init: function(O) {
        this.cfg = this.cfg.extend(O), this.reset();
      }, reset: function() {
        z10.reset.call(this), this._doReset();
      }, update: function(O) {
        return this._append(O), this._process(), this;
      }, finalize: function(O) {
        return O && this._append(O), this._doFinalize();
      }, blockSize: 16, _createHelper: function(O) {
        return function(q, te) {
          return new O.init(te).finalize(q);
        };
      }, _createHmacHelper: function(O) {
        return function(q, te) {
          return new B.HMAC.init(O, te).finalize(q);
        };
      } });
      var B = _.algo = {};
      return _;
    }(Math);
    (function(S) {
      for (var C = u, O, _ = (O = C.lib).WordArray, L = O.Hasher, O = C.algo, F = [], V = [], W = function(te) {
        return 4294967296 * (te - (0 | te)) | 0;
      }, X = 2, G = 0; 64 > G; ) {
        var ie;
        e: {
          ie = X;
          for (var P10 = S.sqrt(ie), z10 = 2; z10 <= P10; z10++)
            if (!(ie % z10)) {
              ie = false;
              break e;
            }
          ie = true;
        }
        ie && (8 > G && (F[G] = W(S.pow(X, 0.5))), V[G] = W(S.pow(X, 1 / 3)), G++), X++;
      }
      var B = [], O = O.SHA256 = L.extend({ _doReset: function() {
        this._hash = new _.init(F.slice(0));
      }, _doProcessBlock: function(q, te) {
        for (var Y = this._hash.words, K = Y[0], $ = Y[1], se = Y[2], he = Y[3], de = Y[4], pe = Y[5], j = Y[6], H = Y[7], Z = 0; 64 > Z; Z++) {
          if (16 > Z)
            B[Z] = 0 | q[te + Z];
          else {
            var oe = B[Z - 15], ue = B[Z - 2];
            B[Z] = ((oe << 25 | oe >>> 7) ^ (oe << 14 | oe >>> 18) ^ oe >>> 3) + B[Z - 7] + ((ue << 15 | ue >>> 17) ^ (ue << 13 | ue >>> 19) ^ ue >>> 10) + B[Z - 16];
          }
          oe = H + ((de << 26 | de >>> 6) ^ (de << 21 | de >>> 11) ^ (de << 7 | de >>> 25)) + (de & pe ^ ~de & j) + V[Z] + B[Z], ue = ((K << 30 | K >>> 2) ^ (K << 19 | K >>> 13) ^ (K << 10 | K >>> 22)) + (K & $ ^ K & se ^ $ & se), H = j, j = pe, pe = de, de = he + oe | 0, he = se, se = $, $ = K, K = oe + ue | 0;
        }
        Y[0] = Y[0] + K | 0, Y[1] = Y[1] + $ | 0, Y[2] = Y[2] + se | 0, Y[3] = Y[3] + he | 0, Y[4] = Y[4] + de | 0, Y[5] = Y[5] + pe | 0, Y[6] = Y[6] + j | 0, Y[7] = Y[7] + H | 0;
      }, _doFinalize: function() {
        var q = this._data, te = q.words, Y = 8 * this._nDataBytes, K = 8 * q.sigBytes;
        return te[K >>> 5] |= 128 << 24 - K % 32, te[14 + (K + 64 >>> 9 << 4)] = S.floor(Y / 4294967296), te[15 + (K + 64 >>> 9 << 4)] = Y, q.sigBytes = 4 * te.length, this._process(), this._hash;
      }, clone: function() {
        var q = L.clone.call(this);
        return q._hash = this._hash.clone(), q;
      } });
      C.SHA256 = L._createHelper(O), C.HmacSHA256 = L._createHmacHelper(O);
    })(Math);
    var f = "";
    if (t10.length == 0)
      return f;
    f = u.SHA256(t10).toString().replace(/\D/g, "").substring(0, 12);
    var d = [];
    for (var h in d.env = f[0] + "" + f[1], d.env = Math.round(0.47 * d.env) + "", d.clo = f[2] + "" + f[3], d.clo = Math.round(0.47 * d.clo) + "", d.head = f[4] + "" + f[5], d.head = Math.round(0.47 * d.head) + "", d.mouth = f[6] + "" + f[7], d.mouth = Math.round(0.47 * d.mouth) + "", d.eyes = f[8] + "" + f[9], d.eyes = Math.round(0.47 * d.eyes) + "", d.top = f[10] + "" + f[11], d.top = Math.round(0.47 * d.top) + "", d) {
      var g = d[h];
      g > 31 ? ((g = g - 32 + "").length == 1 && (g = "0" + g), d[h] = g + "C") : g > 15 ? ((g = g - 16 + "").length == 1 && (g = "0" + g), d[h] = g + "B") : d[h] = (g + "").length == 1 ? "0" + g + "A" : g + "A";
    }
    var p = [];
    for (var h in d) {
      var y = d[h].substring(0, 2), b = d[h].substring(2, 3);
      p[h] = x(h, y, b);
    }
    function x(S, C, _) {
      var L = n[C][_][S], F = i[C][S], V = /#(.*?);/g, W = F.match(V), X = F;
      if (W != null)
        for (var G = 0; G < W.length; G++)
          X = X.replace(W[G], L[G] + ";");
      return X;
    }
    return o + p.env + p.head + p.clo + p.top + p.eyes + p.mouth + s;
  }
  function Pa(t10) {
    return "data:image/svg+xml," + encodeURIComponent(t10).replace(/'/g, "%27").replace(/"/g, "%22");
  }
  var dt = {};
  (function(t10) {
    function e(P10, z10) {
      if (!P10)
        throw z10 = z10 || "Assertion failed", typeof Error < "u" ? new Error(z10) : z10;
    }
    var r = false, n = 0, i = function() {
      if (r)
        return r = false, n;
      var P10 = 2 * Math.random() - 1, z10 = 2 * Math.random() - 1, B = P10 * P10 + z10 * z10;
      if (B == 0 || B > 1)
        return i();
      var O = Math.sqrt(-2 * Math.log(B) / B);
      return n = z10 * O, r = true, P10 * O;
    }, o = function(P10, z10) {
      return Math.random() * (z10 - P10) + P10;
    }, s = function(P10, z10) {
      return Math.floor(Math.random() * (z10 - P10) + P10);
    }, a = function(P10, z10) {
      return P10 + i() * z10;
    }, l = function(P10) {
      if (typeof P10 > "u" || isNaN(P10))
        return [];
      if (typeof ArrayBuffer > "u") {
        for (var z10 = new Array(P10), B = 0; B < P10; B++)
          z10[B] = 0;
        return z10;
      } else
        return new Float64Array(P10);
    }, c = function(P10, z10) {
      this.n = P10, this.d = z10, this.w = l(P10 * z10), this.dw = l(P10 * z10);
    };
    c.prototype = {
      get: function(P10, z10) {
        var B = this.d * P10 + z10;
        return e(B >= 0 && B < this.w.length), this.w[B];
      },
      set: function(P10, z10, B) {
        var O = this.d * P10 + z10;
        e(O >= 0 && O < this.w.length), this.w[O] = B;
      },
      setFrom: function(P10) {
        for (var z10 = 0, B = P10.length; z10 < B; z10++)
          this.w[z10] = P10[z10];
      },
      setColumn: function(P10, z10) {
        for (var B = 0, O = P10.w.length; B < O; B++)
          this.w[this.d * B + z10] = P10.w[B];
      },
      toJSON: function() {
        var P10 = {};
        return P10.n = this.n, P10.d = this.d, P10.w = this.w, P10;
      },
      fromJSON: function(P10) {
        this.n = P10.n, this.d = P10.d, this.w = l(this.n * this.d), this.dw = l(this.n * this.d);
        for (var z10 = 0, B = this.n * this.d; z10 < B; z10++)
          this.w[z10] = P10.w[z10];
      }
    };
    var u = function(P10) {
      var z10 = new c(P10.n, P10.d);
      return z10.setFrom(P10.w), z10;
    }, f = function(P10) {
      var z10 = {};
      for (var B in P10)
        P10.hasOwnProperty(B) && (z10[B] = u(P10[B]));
      return z10;
    }, d = function(P10, z10) {
      for (var B = 0, O = P10.n * P10.d; B < O; B++)
        P10.dw[B] !== 0 && (P10.w[B] += -z10 * P10.dw[B], P10.dw[B] = 0);
    }, h = function(P10, z10) {
      for (var B in P10)
        P10.hasOwnProperty(B) && d(P10[B], z10);
    }, g = function(P10) {
      var z10 = {};
      for (var B in P10)
        P10.hasOwnProperty(B) && (z10[B] = P10[B].toJSON());
      return z10;
    }, p = function(P10) {
      var z10 = {};
      for (var B in P10)
        P10.hasOwnProperty(B) && (z10[B] = new c(1, 1), z10[B].fromJSON(P10[B]));
      return z10;
    }, y = function(P10) {
      for (var z10 in P10)
        if (P10.hasOwnProperty(z10)) {
          var B = P10[z10];
          C(B, 0);
        }
    }, b = function(P10) {
      var z10 = 0;
      for (var B in P10)
        if (P10.hasOwnProperty(B)) {
          var O = P10[B];
          z10 += O.dw.length;
        }
      var q = new c(z10, 1), te = 0;
      for (var B in P10)
        if (P10.hasOwnProperty(B))
          for (var O = P10[B], Y = 0, K = O.dw.length; Y < K; Y++)
            q.w[te] = O.dw[Y], te++;
      return q;
    }, x = function(P10, z10, B, O) {
      var q = new c(P10, z10);
      return S(q, B, O), q;
    }, S = function(P10, z10, B) {
      for (var O = 0, q = P10.w.length; O < q; O++)
        P10.w[O] = a(z10, B);
    }, C = function(P10, z10) {
      for (var B = 0, O = P10.dw.length; B < O; B++)
        P10.dw[B] = z10;
    }, _ = function(P10) {
      typeof P10 > "u" && (P10 = true), this.needs_backprop = P10, this.backprop = [];
    };
    _.prototype = {
      backward: function() {
        for (var P10 = this.backprop.length - 1; P10 >= 0; P10--)
          this.backprop[P10]();
      },
      rowPluck: function(P10, z10) {
        e(z10 >= 0 && z10 < P10.n);
        for (var B = P10.d, O = new c(B, 1), q = 0, te = B; q < te; q++)
          O.w[q] = P10.w[B * z10 + q];
        if (this.needs_backprop) {
          var Y = function() {
            for (var K = 0, $ = B; K < $; K++)
              P10.dw[B * z10 + K] += O.dw[K];
          };
          this.backprop.push(Y);
        }
        return O;
      },
      tanh: function(P10) {
        for (var z10 = new c(P10.n, P10.d), B = P10.w.length, O = 0; O < B; O++)
          z10.w[O] = Math.tanh(P10.w[O]);
        if (this.needs_backprop) {
          var q = function() {
            for (var te = 0; te < B; te++) {
              var Y = z10.w[te];
              P10.dw[te] += (1 - Y * Y) * z10.dw[te];
            }
          };
          this.backprop.push(q);
        }
        return z10;
      },
      sigmoid: function(P10) {
        for (var z10 = new c(P10.n, P10.d), B = P10.w.length, O = 0; O < B; O++)
          z10.w[O] = X(P10.w[O]);
        if (this.needs_backprop) {
          var q = function() {
            for (var te = 0; te < B; te++) {
              var Y = z10.w[te];
              P10.dw[te] += Y * (1 - Y) * z10.dw[te];
            }
          };
          this.backprop.push(q);
        }
        return z10;
      },
      relu: function(P10) {
        for (var z10 = new c(P10.n, P10.d), B = P10.w.length, O = 0; O < B; O++)
          z10.w[O] = Math.max(0, P10.w[O]);
        if (this.needs_backprop) {
          var q = function() {
            for (var te = 0; te < B; te++)
              P10.dw[te] += P10.w[te] > 0 ? z10.dw[te] : 0;
          };
          this.backprop.push(q);
        }
        return z10;
      },
      mul: function(P10, z10) {
        e(P10.d === z10.n, "matmul dimensions misaligned");
        for (var B = P10.n, O = z10.d, q = new c(B, O), te = 0; te < P10.n; te++)
          for (var Y = 0; Y < z10.d; Y++) {
            for (var K = 0, $ = 0; $ < P10.d; $++)
              K += P10.w[P10.d * te + $] * z10.w[z10.d * $ + Y];
            q.w[O * te + Y] = K;
          }
        if (this.needs_backprop) {
          var se = function() {
            for (var he = 0; he < P10.n; he++)
              for (var de = 0; de < z10.d; de++)
                for (var pe = 0; pe < P10.d; pe++) {
                  var j = q.dw[O * he + de];
                  P10.dw[P10.d * he + pe] += z10.w[z10.d * pe + de] * j, z10.dw[z10.d * pe + de] += P10.w[P10.d * he + pe] * j;
                }
          };
          this.backprop.push(se);
        }
        return q;
      },
      add: function(P10, z10) {
        e(P10.w.length === z10.w.length);
        for (var B = new c(P10.n, P10.d), O = 0, q = P10.w.length; O < q; O++)
          B.w[O] = P10.w[O] + z10.w[O];
        if (this.needs_backprop) {
          var te = function() {
            for (var Y = 0, K = P10.w.length; Y < K; Y++)
              P10.dw[Y] += B.dw[Y], z10.dw[Y] += B.dw[Y];
          };
          this.backprop.push(te);
        }
        return B;
      },
      dot: function(P10, z10) {
        e(P10.w.length === z10.w.length);
        for (var B = new c(1, 1), O = 0, q = 0, te = P10.w.length; q < te; q++)
          O += P10.w[q] * z10.w[q];
        if (B.w[0] = O, this.needs_backprop) {
          var Y = function() {
            for (var K = 0, $ = P10.w.length; K < $; K++)
              P10.dw[K] += z10.w[K] * B.dw[0], z10.dw[K] += P10.w[K] * B.dw[0];
          };
          this.backprop.push(Y);
        }
        return B;
      },
      eltmul: function(P10, z10) {
        e(P10.w.length === z10.w.length);
        for (var B = new c(P10.n, P10.d), O = 0, q = P10.w.length; O < q; O++)
          B.w[O] = P10.w[O] * z10.w[O];
        if (this.needs_backprop) {
          var te = function() {
            for (var Y = 0, K = P10.w.length; Y < K; Y++)
              P10.dw[Y] += z10.w[Y] * B.dw[Y], z10.dw[Y] += P10.w[Y] * B.dw[Y];
          };
          this.backprop.push(te);
        }
        return B;
      }
    };
    var L = function(P10) {
      for (var z10 = new c(P10.n, P10.d), B = -999999, O = 0, q = P10.w.length; O < q; O++)
        P10.w[O] > B && (B = P10.w[O]);
      for (var te = 0, O = 0, q = P10.w.length; O < q; O++)
        z10.w[O] = Math.exp(P10.w[O] - B), te += z10.w[O];
      for (var O = 0, q = P10.w.length; O < q; O++)
        z10.w[O] /= te;
      return z10;
    }, F = function() {
      this.decay_rate = 0.999, this.smooth_eps = 1e-8, this.step_cache = {};
    };
    F.prototype = {
      step: function(P10, z10, B, O) {
        var q = {}, te = 0, Y = 0;
        for (var K in P10)
          if (P10.hasOwnProperty(K)) {
            var $ = P10[K];
            K in this.step_cache || (this.step_cache[K] = new c($.n, $.d));
            for (var se = this.step_cache[K], he = 0, de = $.w.length; he < de; he++) {
              var pe = $.dw[he];
              se.w[he] = se.w[he] * this.decay_rate + (1 - this.decay_rate) * pe * pe, pe > O && (pe = O, te++), pe < -O && (pe = -O, te++), Y++, $.w[he] += -z10 * pe / Math.sqrt(se.w[he] + this.smooth_eps) - B * $.w[he], $.dw[he] = 0;
            }
          }
        return q.ratio_clipped = te * 1 / Y, q;
      }
    };
    var V = function(P10, z10, B) {
      for (var O = {}, q = 0; q < z10.length; q++) {
        var te = q === 0 ? P10 : z10[q - 1], Y = z10[q];
        O["Wix" + q] = new x(Y, te, 0, 0.08), O["Wih" + q] = new x(Y, Y, 0, 0.08), O["bi" + q] = new c(Y, 1), O["Wfx" + q] = new x(Y, te, 0, 0.08), O["Wfh" + q] = new x(Y, Y, 0, 0.08), O["bf" + q] = new c(Y, 1), O["Wox" + q] = new x(Y, te, 0, 0.08), O["Woh" + q] = new x(Y, Y, 0, 0.08), O["bo" + q] = new c(Y, 1), O["Wcx" + q] = new x(Y, te, 0, 0.08), O["Wch" + q] = new x(Y, Y, 0, 0.08), O["bc" + q] = new c(Y, 1);
      }
      return O.Whd = new x(B, Y, 0, 0.08), O.bd = new c(B, 1), O;
    }, W = function(P10, z10, B, O, q) {
      if (q == null || typeof q.h > "u")
        for (var te = [], Y = [], K = 0; K < B.length; K++)
          te.push(new dt.Mat(B[K], 1)), Y.push(new dt.Mat(B[K], 1));
      else
        var te = q.h, Y = q.c;
      for (var $ = [], se = [], K = 0; K < B.length; K++) {
        var he = K === 0 ? O : $[K - 1], de = te[K], pe = Y[K], j = P10.mul(z10["Wix" + K], he), H = P10.mul(z10["Wih" + K], de), Z = P10.sigmoid(P10.add(P10.add(j, H), z10["bi" + K])), oe = P10.mul(z10["Wfx" + K], he), ue = P10.mul(z10["Wfh" + K], de), R = P10.sigmoid(P10.add(P10.add(oe, ue), z10["bf" + K])), k = P10.mul(z10["Wox" + K], he), ee = P10.mul(z10["Woh" + K], de), re = P10.sigmoid(P10.add(P10.add(k, ee), z10["bo" + K])), ye = P10.mul(z10["Wcx" + K], he), I = P10.mul(z10["Wch" + K], de), v = P10.tanh(P10.add(P10.add(ye, I), z10["bc" + K])), w = P10.eltmul(R, pe), D = P10.eltmul(Z, v), Q = P10.add(w, D), ae = P10.eltmul(re, P10.tanh(Q));
        $.push(ae), se.push(Q);
      }
      var fe = P10.add(P10.mul(z10.Whd, $[$.length - 1]), z10.bd);
      return { h: $, c: se, o: fe };
    }, X = function(P10) {
      return 1 / (1 + Math.exp(-P10));
    }, G = function(P10) {
      for (var z10 = P10[0], B = 0, O = 1, q = P10.length; O < q; O++) {
        var te = P10[O];
        te > z10 && (B = O, z10 = te);
      }
      return B;
    }, ie = function(P10) {
      for (var z10 = o(0, 1), B = 0, O = 0; ; ) {
        if (B += P10[O], B > z10)
          return O;
        O++;
      }
      return P10.length - 1;
    };
    t10.assert = e, t10.zeros = l, t10.maxi = G, t10.samplei = ie, t10.randi = s, t10.randn = a, t10.softmax = L, t10.Mat = c, t10.RandMat = x, t10.forwardLSTM = W, t10.initLSTM = V, t10.updateMat = d, t10.updateNet = h, t10.copyMat = u, t10.copyNet = f, t10.netToJSON = g, t10.netFromJSON = p, t10.netZeroGrads = y, t10.netFlattenGrads = b, t10.Solver = F, t10.Graph = _;
  })(dt);
  var s1 = {};
  (function(t10) {
    var e = function(u, f, d) {
      return typeof u > "u" ? d : typeof u[f] < "u" ? u[f] : d;
    }, r = dt.zeros, n = dt.assert, i = dt.randi;
    dt.randf;
    var o = function(u, f) {
      for (var d = 0, h = u.length; d < h; d++)
        u[d] = f;
    }, s = function(u) {
      for (var f = Math.random(), d = 0, h = 0, g = u.length; h < g; h++)
        if (d += u[h], d >= f)
          return h;
      n(false, "wtf");
    }, a = function(u, f) {
      this.V = null, this.P = null, this.env = u, this.gamma = e(f, "gamma", 0.75), this.reset();
    };
    a.prototype = {
      reset: function() {
        this.ns = this.env.getNumStates(), this.na = this.env.getMaxNumActions(), this.V = r(this.ns), this.P = r(this.ns * this.na);
        for (var u = 0; u < this.ns; u++)
          for (var f = this.env.allowedActions(u), d = 0, h = f.length; d < h; d++)
            this.P[f[d] * this.ns + u] = 1 / f.length;
      },
      act: function(u) {
        for (var f = this.env.allowedActions(u), d = [], h = 0, g = f.length; h < g; h++) {
          var p = f[h], y = this.P[p * this.ns + u];
          d.push(y);
        }
        var b = s(d);
        return f[b];
      },
      learn: function() {
        self.evaluatePolicy(), self.updatePolicy();
      },
      evaluatePolicy: function() {
        for (var u = r(this.ns), f = 0; f < this.ns; f++) {
          for (var d = 0, h = this.env.allowedActions(f), g = 0, p = h.length; g < p; g++) {
            var y = h[g], b = this.P[y * this.ns + f];
            if (b !== 0) {
              var x = this.env.nextStateDistribution(f, y), S = this.env.reward(f, y, x);
              d += b * (S + this.gamma * this.V[x]);
            }
          }
          u[f] = d;
        }
        this.V = u;
      },
      updatePolicy: function() {
        for (var u = 0; u < this.ns; u++) {
          for (var f = this.env.allowedActions(u), d, h, g = [], p = 0, y = f.length; p < y; p++) {
            var b = f[p], x = this.env.nextStateDistribution(u, b), S = this.env.reward(u, b, x), C = S + this.gamma * this.V[x];
            g.push(C), p === 0 || C > d ? (d = C, h = 1) : C === d && (h += 1);
          }
          for (var p = 0, y = f.length; p < y; p++) {
            var b = f[p];
            this.P[b * this.ns + u] = g[p] === d ? 1 / h : 0;
          }
        }
      }
    };
    var l = function(u, f) {
      this.update = e(f, "update", "qlearn"), this.gamma = e(f, "gamma", 0.75), this.epsilon = e(f, "epsilon", 0.1), this.alpha = e(f, "alpha", 0.01), this.smooth_policy_update = e(f, "smooth_policy_update", false), this.beta = e(f, "beta", 0.01), this.lambda = e(f, "lambda", 0), this.replacing_traces = e(f, "replacing_traces", true), this.q_init_val = e(f, "q_init_val", 0), this.planN = e(f, "planN", 0), this.Q = null, this.P = null, this.e = null, this.env_model_s = null, this.env_model_r = null, this.env = u, this.reset();
    };
    l.prototype = {
      reset: function() {
        this.ns = this.env.getNumStates(), this.na = this.env.getMaxNumActions(), this.Q = r(this.ns * this.na), this.q_init_val !== 0 && o(this.Q, this.q_init_val), this.P = r(this.ns * this.na), this.e = r(this.ns * this.na), this.env_model_s = r(this.ns * this.na), o(this.env_model_s, -1), this.env_model_r = r(this.ns * this.na), this.sa_seen = [], this.pq = r(this.ns * this.na);
        for (var u = 0; u < this.ns; u++)
          for (var f = this.env.allowedActions(u), d = 0, h = f.length; d < h; d++)
            this.P[f[d] * this.ns + u] = 1 / f.length;
        this.r0 = null, this.s0 = null, this.s1 = null, this.a0 = null, this.a1 = null;
      },
      resetEpisode: function() {
      },
      act: function(u) {
        for (var f = this.env.allowedActions(u), d = [], h = 0, g = f.length; h < g; h++)
          d.push(this.P[f[h] * this.ns + u]);
        if (Math.random() < this.epsilon) {
          var p = f[i(0, f.length)];
          this.explored = true;
        } else {
          var p = f[s(d)];
          this.explored = false;
        }
        return this.s0 = this.s1, this.a0 = this.a1, this.s1 = u, this.a1 = p, p;
      },
      learn: function(u) {
        this.r0 != null && (this.learnFromTuple(this.s0, this.a0, this.r0, this.s1, this.a1, this.lambda), this.planN > 0 && (this.updateModel(this.s0, this.a0, this.r0, this.s1), this.plan())), this.r0 = u;
      },
      updateModel: function(u, f, d, h) {
        var g = f * this.ns + u;
        this.env_model_s[g] === -1 && this.sa_seen.push(f * this.ns + u), this.env_model_s[g] = h, this.env_model_r[g] = d;
      },
      plan: function() {
        for (var u = [], f = 0, d = this.sa_seen.length; f < d; f++) {
          var h = this.sa_seen[f], g = this.pq[h];
          g > 1e-5 && u.push({ sa: h, p: g });
        }
        u.sort(function(V, W) {
          return V.p < W.p ? 1 : -1;
        });
        for (var p = Math.min(this.planN, u.length), y = 0; y < p; y++) {
          var b = u[y].sa;
          this.pq[b] = 0;
          var x = b % this.ns, S = Math.floor(b / this.ns), C = this.env_model_r[b], _ = this.env_model_s[b], L = -1;
          if (this.update === "sarsa")
            var F = this.env.allowedActions(_), L = F[i(0, F.length)];
          this.learnFromTuple(x, S, C, _, L, 0);
        }
      },
      learnFromTuple: function(u, f, d, h, g, p) {
        var y = f * this.ns + u;
        if (this.update === "qlearn") {
          for (var b = this.env.allowedActions(h), x = 0, S = 0, C = b.length; S < C; S++) {
            var _ = b[S] * this.ns + h, L = this.Q[_];
            (S === 0 || L > x) && (x = L);
          }
          var F = d + this.gamma * x;
        } else if (this.update === "sarsa")
          var V = g * this.ns + h, F = d + this.gamma * this.Q[V];
        if (p > 0) {
          this.replacing_traces ? this.e[y] = 1 : this.e[y] += 1;
          for (var W = p * this.gamma, X = r(this.ns), G = 0; G < this.ns; G++)
            for (var b = this.env.allowedActions(G), S = 0; S < b.length; S++) {
              var ie = b[S], P10 = ie * this.ns + G, z10 = this.e[P10], B = this.alpha * z10 * (F - this.Q[P10]);
              this.Q[P10] += B, this.updatePriority(G, ie, B), this.e[P10] *= W;
              var O = Math.abs(B);
              O > X[G] && (X[G] = O);
            }
          for (var G = 0; G < this.ns; G++)
            X[G] > 1e-5 && this.updatePolicy(G);
          this.explored && this.update === "qlearn" && (this.e = r(this.ns * this.na));
        } else {
          var B = this.alpha * (F - this.Q[y]);
          this.Q[y] += B, this.updatePriority(u, f, B), this.updatePolicy(u);
        }
      },
      updatePriority: function(u, f, d) {
        if (d = Math.abs(d), !(d < 1e-5) && this.planN !== 0)
          for (var h = 0; h < this.ns; h++)
            for (var g = 0; g < this.na; g++) {
              var p = g * this.ns + h;
              this.env_model_s[p] === u && (this.pq[p] += d);
            }
      },
      updatePolicy: function(u) {
        for (var f = this.env.allowedActions(u), d, h, g = [], p = 0, y = f.length; p < y; p++) {
          var b = f[p], x = this.Q[b * this.ns + u];
          g.push(x), p === 0 || x > d ? (d = x, h = 1) : x === d && (h += 1);
        }
        for (var S = 0, p = 0, y = f.length; p < y; p++) {
          var b = f[p], C = g[p] === d ? 1 / h : 0, _ = b * this.ns + u;
          this.smooth_policy_update ? (this.P[_] += this.beta * (C - this.P[_]), S += this.P[_]) : this.P[_] = C;
        }
        if (this.smooth_policy_update)
          for (var p = 0, y = f.length; p < y; p++) {
            var b = f[p];
            this.P[b * this.ns + u] /= S;
          }
      }
    };
    var c = function(u, f) {
      this.gamma = e(f, "gamma", 0.75), this.epsilon = e(f, "epsilon", 0.1), this.alpha = e(f, "alpha", 0.01), this.experience_add_every = e(f, "experience_add_every", 25), this.experience_size = e(f, "experience_size", 5e3), this.learning_steps_per_iteration = e(f, "learning_steps_per_iteration", 10), this.tderror_clamp = e(f, "tderror_clamp", 1), this.num_hidden_units = e(f, "num_hidden_units", 100), this.env = u, this.reset();
    };
    c.prototype = {
      reset: function() {
        this.nh = this.num_hidden_units, this.ns = this.env.getNumStates(), this.na = this.env.getMaxNumActions(), this.net = {}, this.net.W1 = new dt.RandMat(this.nh, this.ns, 0, 0.01), this.net.b1 = new dt.Mat(this.nh, 1, 0, 0.01), this.net.W2 = new dt.RandMat(this.na, this.nh, 0, 0.01), this.net.b2 = new dt.Mat(this.na, 1, 0, 0.01), this.exp = [], this.expi = 0, this.t = 0, this.r0 = null, this.s0 = null, this.s1 = null, this.a0 = null, this.a1 = null, this.tderror = 0;
      },
      toJSON: function() {
        var u = {};
        return u.nh = this.nh, u.ns = this.ns, u.na = this.na, u.net = dt.netToJSON(this.net), u;
      },
      fromJSON: function(u) {
        this.nh = u.nh, this.ns = u.ns, this.na = u.na, this.net = dt.netFromJSON(u.net);
      },
      forwardQ: function(u, f, d) {
        var h = new dt.Graph(d), g = h.add(h.mul(u.W1, f), u.b1), p = h.tanh(g), y = h.add(h.mul(u.W2, p), u.b2);
        return this.lastG = h, y;
      },
      act: function(u) {
        var f = new dt.Mat(this.ns, 1);
        if (f.setFrom(u), Math.random() < this.epsilon)
          var d = i(0, this.na);
        else
          var h = this.forwardQ(this.net, f, false), d = dt.maxi(h.w);
        return this.s0 = this.s1, this.a0 = this.a1, this.s1 = f, this.a1 = d, d;
      },
      learn: function(u) {
        if (this.r0 != null && this.alpha > 0) {
          var f = this.learnFromTuple(this.s0, this.a0, this.r0, this.s1, this.a1);
          this.tderror = f, this.t % this.experience_add_every === 0 && (this.exp[this.expi] = [this.s0, this.a0, this.r0, this.s1, this.a1], this.expi += 1, this.expi > this.experience_size && (this.expi = 0)), this.t += 1;
          for (var d = 0; d < this.learning_steps_per_iteration; d++) {
            var h = i(0, this.exp.length), g = this.exp[h];
            this.learnFromTuple(g[0], g[1], g[2], g[3], g[4]);
          }
        }
        this.r0 = u;
      },
      learnFromTuple: function(u, f, d, h, g) {
        var p = this.forwardQ(this.net, h, false), y = d + this.gamma * p.w[dt.maxi(p.w)], b = this.forwardQ(this.net, u, true), x = b.w[f] - y, S = this.tderror_clamp;
        return Math.abs(x) > S && (x > S && (x = S), x < -S && (x = -S)), b.dw[f] = x, this.lastG.backward(), dt.updateNet(this.net, this.alpha), x;
      }
    }, t10.DPAgent = a, t10.TDAgent = l, t10.DQNAgent = c;
  })(s1);
  /*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   */
  function Fo(t10) {
    return t10 + 0.5 | 0;
  }
  const Kr = (t10, e, r) => Math.max(Math.min(t10, r), e);
  function Yi(t10) {
    return Kr(Fo(t10 * 2.55), 0, 255);
  }
  function tn(t10) {
    return Kr(Fo(t10 * 255), 0, 255);
  }
  function Cr(t10) {
    return Kr(Fo(t10 / 2.55) / 100, 0, 1);
  }
  function md(t10) {
    return Kr(Fo(t10 * 100), 0, 100);
  }
  const Vt = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, wc = [..."0123456789ABCDEF"], D3 = (t10) => wc[t10 & 15], M3 = (t10) => wc[(t10 & 240) >> 4] + wc[t10 & 15], es = (t10) => (t10 & 240) >> 4 === (t10 & 15), N3 = (t10) => es(t10.r) && es(t10.g) && es(t10.b) && es(t10.a);
  function L3(t10) {
    var e = t10.length, r;
    return t10[0] === "#" && (e === 4 || e === 5 ? r = {
      r: 255 & Vt[t10[1]] * 17,
      g: 255 & Vt[t10[2]] * 17,
      b: 255 & Vt[t10[3]] * 17,
      a: e === 5 ? Vt[t10[4]] * 17 : 255
    } : (e === 7 || e === 9) && (r = {
      r: Vt[t10[1]] << 4 | Vt[t10[2]],
      g: Vt[t10[3]] << 4 | Vt[t10[4]],
      b: Vt[t10[5]] << 4 | Vt[t10[6]],
      a: e === 9 ? Vt[t10[7]] << 4 | Vt[t10[8]] : 255
    })), r;
  }
  const B3 = (t10, e) => t10 < 255 ? e(t10) : "";
  function F3(t10) {
    var e = N3(t10) ? D3 : M3;
    return t10 ? "#" + e(t10.r) + e(t10.g) + e(t10.b) + B3(t10.a, e) : void 0;
  }
  const j3 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function a1(t10, e, r) {
    const n = e * Math.min(r, 1 - r), i = (o, s = (o + t10 / 30) % 12) => r - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
    return [i(0), i(8), i(4)];
  }
  function W3(t10, e, r) {
    const n = (i, o = (i + t10 / 60) % 6) => r - r * e * Math.max(Math.min(o, 4 - o, 1), 0);
    return [n(5), n(3), n(1)];
  }
  function U3(t10, e, r) {
    const n = a1(t10, 1, 0.5);
    let i;
    for (e + r > 1 && (i = 1 / (e + r), e *= i, r *= i), i = 0; i < 3; i++)
      n[i] *= 1 - e - r, n[i] += e;
    return n;
  }
  function z3(t10, e, r, n, i) {
    return t10 === i ? (e - r) / n + (e < r ? 6 : 0) : e === i ? (r - t10) / n + 2 : (t10 - e) / n + 4;
  }
  function Su(t10) {
    const r = t10.r / 255, n = t10.g / 255, i = t10.b / 255, o = Math.max(r, n, i), s = Math.min(r, n, i), a = (o + s) / 2;
    let l, c, u;
    return o !== s && (u = o - s, c = a > 0.5 ? u / (2 - o - s) : u / (o + s), l = z3(r, n, i, u, o), l = l * 60 + 0.5), [l | 0, c || 0, a];
  }
  function Eu(t10, e, r, n) {
    return (Array.isArray(e) ? t10(e[0], e[1], e[2]) : t10(e, r, n)).map(tn);
  }
  function ku(t10, e, r) {
    return Eu(a1, t10, e, r);
  }
  function V3(t10, e, r) {
    return Eu(U3, t10, e, r);
  }
  function q3(t10, e, r) {
    return Eu(W3, t10, e, r);
  }
  function l1(t10) {
    return (t10 % 360 + 360) % 360;
  }
  function H3(t10) {
    const e = j3.exec(t10);
    let r = 255, n;
    if (!e)
      return;
    e[5] !== n && (r = e[6] ? Yi(+e[5]) : tn(+e[5]));
    const i = l1(+e[2]), o = +e[3] / 100, s = +e[4] / 100;
    return e[1] === "hwb" ? n = V3(i, o, s) : e[1] === "hsv" ? n = q3(i, o, s) : n = ku(i, o, s), {
      r: n[0],
      g: n[1],
      b: n[2],
      a: r
    };
  }
  function K3(t10, e) {
    var r = Su(t10);
    r[0] = l1(r[0] + e), r = ku(r), t10.r = r[0], t10.g = r[1], t10.b = r[2];
  }
  function Y3(t10) {
    if (!t10)
      return;
    const e = Su(t10), r = e[0], n = md(e[1]), i = md(e[2]);
    return t10.a < 255 ? `hsla(${r}, ${n}%, ${i}%, ${Cr(t10.a)})` : `hsl(${r}, ${n}%, ${i}%)`;
  }
  const yd = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  }, bd = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function X3() {
    const t10 = {}, e = Object.keys(bd), r = Object.keys(yd);
    let n, i, o, s, a;
    for (n = 0; n < e.length; n++) {
      for (s = a = e[n], i = 0; i < r.length; i++)
        o = r[i], a = a.replace(o, yd[o]);
      o = parseInt(bd[s], 16), t10[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];
    }
    return t10;
  }
  let ts;
  function J3(t10) {
    ts || (ts = X3(), ts.transparent = [0, 0, 0, 0]);
    const e = ts[t10.toLowerCase()];
    return e && {
      r: e[0],
      g: e[1],
      b: e[2],
      a: e.length === 4 ? e[3] : 255
    };
  }
  const Q3 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function G3(t10) {
    const e = Q3.exec(t10);
    let r = 255, n, i, o;
    if (e) {
      if (e[7] !== n) {
        const s = +e[7];
        r = e[8] ? Yi(s) : Kr(s * 255, 0, 255);
      }
      return n = +e[1], i = +e[3], o = +e[5], n = 255 & (e[2] ? Yi(n) : Kr(n, 0, 255)), i = 255 & (e[4] ? Yi(i) : Kr(i, 0, 255)), o = 255 & (e[6] ? Yi(o) : Kr(o, 0, 255)), {
        r: n,
        g: i,
        b: o,
        a: r
      };
    }
  }
  function Z3(t10) {
    return t10 && (t10.a < 255 ? `rgba(${t10.r}, ${t10.g}, ${t10.b}, ${Cr(t10.a)})` : `rgb(${t10.r}, ${t10.g}, ${t10.b})`);
  }
  const Tl = (t10) => t10 <= 31308e-7 ? t10 * 12.92 : Math.pow(t10, 1 / 2.4) * 1.055 - 0.055, Hn = (t10) => t10 <= 0.04045 ? t10 / 12.92 : Math.pow((t10 + 0.055) / 1.055, 2.4);
  function $3(t10, e, r) {
    const n = Hn(Cr(t10.r)), i = Hn(Cr(t10.g)), o = Hn(Cr(t10.b));
    return {
      r: tn(Tl(n + r * (Hn(Cr(e.r)) - n))),
      g: tn(Tl(i + r * (Hn(Cr(e.g)) - i))),
      b: tn(Tl(o + r * (Hn(Cr(e.b)) - o))),
      a: t10.a + r * (e.a - t10.a)
    };
  }
  function rs(t10, e, r) {
    if (t10) {
      let n = Su(t10);
      n[e] = Math.max(0, Math.min(n[e] + n[e] * r, e === 0 ? 360 : 1)), n = ku(n), t10.r = n[0], t10.g = n[1], t10.b = n[2];
    }
  }
  function c1(t10, e) {
    return t10 && Object.assign(e || {}, t10);
  }
  function vd(t10) {
    var e = { r: 0, g: 0, b: 0, a: 255 };
    return Array.isArray(t10) ? t10.length >= 3 && (e = { r: t10[0], g: t10[1], b: t10[2], a: 255 }, t10.length > 3 && (e.a = tn(t10[3]))) : (e = c1(t10, { r: 0, g: 0, b: 0, a: 1 }), e.a = tn(e.a)), e;
  }
  function e2(t10) {
    return t10.charAt(0) === "r" ? G3(t10) : H3(t10);
  }
  class yo {
    constructor(e) {
      if (e instanceof yo)
        return e;
      const r = typeof e;
      let n;
      r === "object" ? n = vd(e) : r === "string" && (n = L3(e) || J3(e) || e2(e)), this._rgb = n, this._valid = !!n;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var e = c1(this._rgb);
      return e && (e.a = Cr(e.a)), e;
    }
    set rgb(e) {
      this._rgb = vd(e);
    }
    rgbString() {
      return this._valid ? Z3(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? F3(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? Y3(this._rgb) : void 0;
    }
    mix(e, r) {
      if (e) {
        const n = this.rgb, i = e.rgb;
        let o;
        const s = r === o ? 0.5 : r, a = 2 * s - 1, l = n.a - i.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
        o = 1 - c, n.r = 255 & c * n.r + o * i.r + 0.5, n.g = 255 & c * n.g + o * i.g + 0.5, n.b = 255 & c * n.b + o * i.b + 0.5, n.a = s * n.a + (1 - s) * i.a, this.rgb = n;
      }
      return this;
    }
    interpolate(e, r) {
      return e && (this._rgb = $3(this._rgb, e._rgb, r)), this;
    }
    clone() {
      return new yo(this.rgb);
    }
    alpha(e) {
      return this._rgb.a = tn(e), this;
    }
    clearer(e) {
      const r = this._rgb;
      return r.a *= 1 - e, this;
    }
    greyscale() {
      const e = this._rgb, r = Fo(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
      return e.r = e.g = e.b = r, this;
    }
    opaquer(e) {
      const r = this._rgb;
      return r.a *= 1 + e, this;
    }
    negate() {
      const e = this._rgb;
      return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
    }
    lighten(e) {
      return rs(this._rgb, 2, e), this;
    }
    darken(e) {
      return rs(this._rgb, 2, -e), this;
    }
    saturate(e) {
      return rs(this._rgb, 1, e), this;
    }
    desaturate(e) {
      return rs(this._rgb, 1, -e), this;
    }
    rotate(e) {
      return K3(this._rgb, e), this;
    }
  }
  /*!
   * Chart.js v4.4.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   */
  function _r() {
  }
  const t2 = /* @__PURE__ */ (() => {
    let t10 = 0;
    return () => t10++;
  })();
  function Re(t10) {
    return t10 === null || typeof t10 > "u";
  }
  function Ge(t10) {
    if (Array.isArray && Array.isArray(t10))
      return true;
    const e = Object.prototype.toString.call(t10);
    return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
  }
  function Ie(t10) {
    return t10 !== null && Object.prototype.toString.call(t10) === "[object Object]";
  }
  function ot(t10) {
    return (typeof t10 == "number" || t10 instanceof Number) && isFinite(+t10);
  }
  function Nt(t10, e) {
    return ot(t10) ? t10 : e;
  }
  function ke(t10, e) {
    return typeof t10 > "u" ? e : t10;
  }
  const r2 = (t10, e) => typeof t10 == "string" && t10.endsWith("%") ? parseFloat(t10) / 100 : +t10 / e, u1 = (t10, e) => typeof t10 == "string" && t10.endsWith("%") ? parseFloat(t10) / 100 * e : +t10;
  function Je(t10, e, r) {
    if (t10 && typeof t10.call == "function")
      return t10.apply(r, e);
  }
  function Ve(t10, e, r, n) {
    let i, o, s;
    if (Ge(t10))
      if (o = t10.length, n)
        ;
      else
        for (i = 0; i < o; i++)
          e.call(r, t10[i], i);
    else if (Ie(t10))
      for (s = Object.keys(t10), o = s.length, i = 0; i < o; i++)
        e.call(r, t10[s[i]], s[i]);
  }
  function na(t10, e) {
    let r, n, i, o;
    if (!t10 || !e || t10.length !== e.length)
      return false;
    for (r = 0, n = t10.length; r < n; ++r)
      if (i = t10[r], o = e[r], i.datasetIndex !== o.datasetIndex || i.index !== o.index)
        return false;
    return true;
  }
  function ia(t10) {
    if (Ge(t10))
      return t10.map(ia);
    if (Ie(t10)) {
      const e = /* @__PURE__ */ Object.create(null), r = Object.keys(t10), n = r.length;
      let i = 0;
      for (; i < n; ++i)
        e[r[i]] = ia(t10[r[i]]);
      return e;
    }
    return t10;
  }
  function f1(t10) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(t10) === -1;
  }
  function n2(t10, e, r, n) {
    if (!f1(t10))
      return;
    const i = e[t10], o = r[t10];
    Ie(i) && Ie(o) ? bo(i, o, n) : e[t10] = ia(o);
  }
  function bo(t10, e, r) {
    const n = Ge(e) ? e : [
      e
    ], i = n.length;
    if (!Ie(t10))
      return t10;
    r = r || {};
    const o = r.merger || n2;
    let s;
    for (let a = 0; a < i; ++a) {
      if (s = n[a], !Ie(s))
        continue;
      const l = Object.keys(s);
      for (let c = 0, u = l.length; c < u; ++c)
        o(l[c], t10, s, r);
    }
    return t10;
  }
  function io(t10, e) {
    return bo(t10, e, {
      merger: i2
    });
  }
  function i2(t10, e, r) {
    if (!f1(t10))
      return;
    const n = e[t10], i = r[t10];
    Ie(n) && Ie(i) ? io(n, i) : Object.prototype.hasOwnProperty.call(e, t10) || (e[t10] = ia(i));
  }
  const Ad = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (t10) => t10,
    // default resolvers
    x: (t10) => t10.x,
    y: (t10) => t10.y
  };
  function o2(t10) {
    const e = t10.split("."), r = [];
    let n = "";
    for (const i of e)
      n += i, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (r.push(n), n = "");
    return r;
  }
  function s2(t10) {
    const e = o2(t10);
    return (r) => {
      for (const n of e) {
        if (n === "")
          break;
        r = r && r[n];
      }
      return r;
    };
  }
  function sn(t10, e) {
    return (Ad[e] || (Ad[e] = s2(e)))(t10);
  }
  function Cu(t10) {
    return t10.charAt(0).toUpperCase() + t10.slice(1);
  }
  const vo = (t10) => typeof t10 < "u", an = (t10) => typeof t10 == "function", wd = (t10, e) => {
    if (t10.size !== e.size)
      return false;
    for (const r of t10)
      if (!e.has(r))
        return false;
    return true;
  };
  function a2(t10) {
    return t10.type === "mouseup" || t10.type === "click" || t10.type === "contextmenu";
  }
  const $e = Math.PI, Ze = 2 * $e, l2 = Ze + $e, oa = Number.POSITIVE_INFINITY, c2 = $e / 180, at = $e / 2, mn = $e / 4, xd = $e * 2 / 3, Yr = Math.log10, vr = Math.sign;
  function oo(t10, e, r) {
    return Math.abs(t10 - e) < r;
  }
  function _d(t10) {
    const e = Math.round(t10);
    t10 = oo(t10, e, t10 / 1e3) ? e : t10;
    const r = Math.pow(10, Math.floor(Yr(t10))), n = t10 / r;
    return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * r;
  }
  function u2(t10) {
    const e = [], r = Math.sqrt(t10);
    let n;
    for (n = 1; n < r; n++)
      t10 % n === 0 && (e.push(n), e.push(t10 / n));
    return r === (r | 0) && e.push(r), e.sort((i, o) => i - o).pop(), e;
  }
  function pi(t10) {
    return !isNaN(parseFloat(t10)) && isFinite(t10);
  }
  function f2(t10, e) {
    const r = Math.round(t10);
    return r - e <= t10 && r + e >= t10;
  }
  function d1(t10, e, r) {
    let n, i, o;
    for (n = 0, i = t10.length; n < i; n++)
      o = t10[n][r], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));
  }
  function sr(t10) {
    return t10 * ($e / 180);
  }
  function Tu(t10) {
    return t10 * (180 / $e);
  }
  function Sd(t10) {
    if (!ot(t10))
      return;
    let e = 1, r = 0;
    for (; Math.round(t10 * e) / e !== t10; )
      e *= 10, r++;
    return r;
  }
  function h1(t10, e) {
    const r = e.x - t10.x, n = e.y - t10.y, i = Math.sqrt(r * r + n * n);
    let o = Math.atan2(n, r);
    return o < -0.5 * $e && (o += Ze), {
      angle: o,
      distance: i
    };
  }
  function xc(t10, e) {
    return Math.sqrt(Math.pow(e.x - t10.x, 2) + Math.pow(e.y - t10.y, 2));
  }
  function d2(t10, e) {
    return (t10 - e + l2) % Ze - $e;
  }
  function Lt(t10) {
    return (t10 % Ze + Ze) % Ze;
  }
  function Ao(t10, e, r, n) {
    const i = Lt(t10), o = Lt(e), s = Lt(r), a = Lt(o - i), l = Lt(s - i), c = Lt(i - o), u = Lt(i - s);
    return i === o || i === s || n && o === s || a > l && c < u;
  }
  function ht(t10, e, r) {
    return Math.max(e, Math.min(r, t10));
  }
  function h2(t10) {
    return ht(t10, -32768, 32767);
  }
  function Rr(t10, e, r, n = 1e-6) {
    return t10 >= Math.min(e, r) - n && t10 <= Math.max(e, r) + n;
  }
  function Iu(t10, e, r) {
    r = r || ((s) => t10[s] < e);
    let n = t10.length - 1, i = 0, o;
    for (; n - i > 1; )
      o = i + n >> 1, r(o) ? i = o : n = o;
    return {
      lo: i,
      hi: n
    };
  }
  const Dr = (t10, e, r, n) => Iu(t10, r, n ? (i) => {
    const o = t10[i][e];
    return o < r || o === r && t10[i + 1][e] === r;
  } : (i) => t10[i][e] < r), p2 = (t10, e, r) => Iu(t10, r, (n) => t10[n][e] >= r);
  function g2(t10, e, r) {
    let n = 0, i = t10.length;
    for (; n < i && t10[n] < e; )
      n++;
    for (; i > n && t10[i - 1] > r; )
      i--;
    return n > 0 || i < t10.length ? t10.slice(n, i) : t10;
  }
  const p1 = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function m2(t10, e) {
    if (t10._chartjs) {
      t10._chartjs.listeners.push(e);
      return;
    }
    Object.defineProperty(t10, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          e
        ]
      }
    }), p1.forEach((r) => {
      const n = "_onData" + Cu(r), i = t10[r];
      Object.defineProperty(t10, r, {
        configurable: true,
        enumerable: false,
        value(...o) {
          const s = i.apply(this, o);
          return t10._chartjs.listeners.forEach((a) => {
            typeof a[n] == "function" && a[n](...o);
          }), s;
        }
      });
    });
  }
  function Ed(t10, e) {
    const r = t10._chartjs;
    if (!r)
      return;
    const n = r.listeners, i = n.indexOf(e);
    i !== -1 && n.splice(i, 1), !(n.length > 0) && (p1.forEach((o) => {
      delete t10[o];
    }), delete t10._chartjs);
  }
  function g1(t10) {
    const e = new Set(t10);
    return e.size === t10.length ? t10 : Array.from(e);
  }
  const m1 = function() {
    return typeof window > "u" ? function(t10) {
      return t10();
    } : window.requestAnimationFrame;
  }();
  function y1(t10, e) {
    let r = [], n = false;
    return function(...i) {
      r = i, n || (n = true, m1.call(window, () => {
        n = false, t10.apply(e, r);
      }));
    };
  }
  function y2(t10, e) {
    let r;
    return function(...n) {
      return e ? (clearTimeout(r), r = setTimeout(t10, e, n)) : t10.apply(this, n), e;
    };
  }
  const Ou = (t10) => t10 === "start" ? "left" : t10 === "end" ? "right" : "center", At = (t10, e, r) => t10 === "start" ? e : t10 === "end" ? r : (e + r) / 2, b2 = (t10, e, r, n) => t10 === (n ? "left" : "right") ? r : t10 === "center" ? (e + r) / 2 : e;
  function b1(t10, e, r) {
    const n = e.length;
    let i = 0, o = n;
    if (t10._sorted) {
      const { iScale: s, _parsed: a } = t10, l = s.axis, { min: c, max: u, minDefined: f, maxDefined: d } = s.getUserBounds();
      f && (i = ht(Math.min(
        // @ts-expect-error Need to type _parsed
        Dr(a, l, c).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        r ? n : Dr(e, l, s.getPixelForValue(c)).lo
      ), 0, n - 1)), d ? o = ht(Math.max(
        // @ts-expect-error Need to type _parsed
        Dr(a, s.axis, u, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        r ? 0 : Dr(e, l, s.getPixelForValue(u), true).hi + 1
      ), i, n) - i : o = n - i;
    }
    return {
      start: i,
      count: o
    };
  }
  function v1(t10) {
    const { xScale: e, yScale: r, _scaleRanges: n } = t10, i = {
      xmin: e.min,
      xmax: e.max,
      ymin: r.min,
      ymax: r.max
    };
    if (!n)
      return t10._scaleRanges = i, true;
    const o = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== r.min || n.ymax !== r.max;
    return Object.assign(n, i), o;
  }
  const ns = (t10) => t10 === 0 || t10 === 1, kd = (t10, e, r) => -(Math.pow(2, 10 * (t10 -= 1)) * Math.sin((t10 - e) * Ze / r)), Cd = (t10, e, r) => Math.pow(2, -10 * t10) * Math.sin((t10 - e) * Ze / r) + 1, so = {
    linear: (t10) => t10,
    easeInQuad: (t10) => t10 * t10,
    easeOutQuad: (t10) => -t10 * (t10 - 2),
    easeInOutQuad: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 : -0.5 * (--t10 * (t10 - 2) - 1),
    easeInCubic: (t10) => t10 * t10 * t10,
    easeOutCubic: (t10) => (t10 -= 1) * t10 * t10 + 1,
    easeInOutCubic: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 : 0.5 * ((t10 -= 2) * t10 * t10 + 2),
    easeInQuart: (t10) => t10 * t10 * t10 * t10,
    easeOutQuart: (t10) => -((t10 -= 1) * t10 * t10 * t10 - 1),
    easeInOutQuart: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 * t10 : -0.5 * ((t10 -= 2) * t10 * t10 * t10 - 2),
    easeInQuint: (t10) => t10 * t10 * t10 * t10 * t10,
    easeOutQuint: (t10) => (t10 -= 1) * t10 * t10 * t10 * t10 + 1,
    easeInOutQuint: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 * t10 * t10 : 0.5 * ((t10 -= 2) * t10 * t10 * t10 * t10 + 2),
    easeInSine: (t10) => -Math.cos(t10 * at) + 1,
    easeOutSine: (t10) => Math.sin(t10 * at),
    easeInOutSine: (t10) => -0.5 * (Math.cos($e * t10) - 1),
    easeInExpo: (t10) => t10 === 0 ? 0 : Math.pow(2, 10 * (t10 - 1)),
    easeOutExpo: (t10) => t10 === 1 ? 1 : -Math.pow(2, -10 * t10) + 1,
    easeInOutExpo: (t10) => ns(t10) ? t10 : t10 < 0.5 ? 0.5 * Math.pow(2, 10 * (t10 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t10 * 2 - 1)) + 2),
    easeInCirc: (t10) => t10 >= 1 ? t10 : -(Math.sqrt(1 - t10 * t10) - 1),
    easeOutCirc: (t10) => Math.sqrt(1 - (t10 -= 1) * t10),
    easeInOutCirc: (t10) => (t10 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t10 * t10) - 1) : 0.5 * (Math.sqrt(1 - (t10 -= 2) * t10) + 1),
    easeInElastic: (t10) => ns(t10) ? t10 : kd(t10, 0.075, 0.3),
    easeOutElastic: (t10) => ns(t10) ? t10 : Cd(t10, 0.075, 0.3),
    easeInOutElastic(t10) {
      return ns(t10) ? t10 : t10 < 0.5 ? 0.5 * kd(t10 * 2, 0.1125, 0.45) : 0.5 + 0.5 * Cd(t10 * 2 - 1, 0.1125, 0.45);
    },
    easeInBack(t10) {
      return t10 * t10 * ((1.70158 + 1) * t10 - 1.70158);
    },
    easeOutBack(t10) {
      return (t10 -= 1) * t10 * ((1.70158 + 1) * t10 + 1.70158) + 1;
    },
    easeInOutBack(t10) {
      let e = 1.70158;
      return (t10 /= 0.5) < 1 ? 0.5 * (t10 * t10 * (((e *= 1.525) + 1) * t10 - e)) : 0.5 * ((t10 -= 2) * t10 * (((e *= 1.525) + 1) * t10 + e) + 2);
    },
    easeInBounce: (t10) => 1 - so.easeOutBounce(1 - t10),
    easeOutBounce(t10) {
      return t10 < 1 / 2.75 ? 7.5625 * t10 * t10 : t10 < 2 / 2.75 ? 7.5625 * (t10 -= 1.5 / 2.75) * t10 + 0.75 : t10 < 2.5 / 2.75 ? 7.5625 * (t10 -= 2.25 / 2.75) * t10 + 0.9375 : 7.5625 * (t10 -= 2.625 / 2.75) * t10 + 0.984375;
    },
    easeInOutBounce: (t10) => t10 < 0.5 ? so.easeInBounce(t10 * 2) * 0.5 : so.easeOutBounce(t10 * 2 - 1) * 0.5 + 0.5
  };
  function Pu(t10) {
    if (t10 && typeof t10 == "object") {
      const e = t10.toString();
      return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
    }
    return false;
  }
  function Td(t10) {
    return Pu(t10) ? t10 : new yo(t10);
  }
  function Il(t10) {
    return Pu(t10) ? t10 : new yo(t10).saturate(0.5).darken(0.1).hexString();
  }
  const v2 = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ], A2 = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function w2(t10) {
    t10.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    }), t10.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
    }), t10.set("animations", {
      colors: {
        type: "color",
        properties: A2
      },
      numbers: {
        type: "number",
        properties: v2
      }
    }), t10.describe("animations", {
      _fallback: "animation"
    }), t10.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (e) => e | 0
          }
        }
      }
    });
  }
  function x2(t10) {
    t10.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  const Id = /* @__PURE__ */ new Map();
  function _2(t10, e) {
    e = e || {};
    const r = t10 + JSON.stringify(e);
    let n = Id.get(r);
    return n || (n = new Intl.NumberFormat(t10, e), Id.set(r, n)), n;
  }
  function jo(t10, e, r) {
    return _2(e, r).format(t10);
  }
  const A1 = {
    values(t10) {
      return Ge(t10) ? t10 : "" + t10;
    },
    numeric(t10, e, r) {
      if (t10 === 0)
        return "0";
      const n = this.chart.options.locale;
      let i, o = t10;
      if (r.length > 1) {
        const c = Math.max(Math.abs(r[0].value), Math.abs(r[r.length - 1].value));
        (c < 1e-4 || c > 1e15) && (i = "scientific"), o = S2(t10, r);
      }
      const s = Yr(Math.abs(o)), a = isNaN(s) ? 1 : Math.max(Math.min(-1 * Math.floor(s), 20), 0), l = {
        notation: i,
        minimumFractionDigits: a,
        maximumFractionDigits: a
      };
      return Object.assign(l, this.options.ticks.format), jo(t10, n, l);
    },
    logarithmic(t10, e, r) {
      if (t10 === 0)
        return "0";
      const n = r[e].significand || t10 / Math.pow(10, Math.floor(Yr(t10)));
      return [
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(n) || e > 0.8 * r.length ? A1.numeric.call(this, t10, e, r) : "";
    }
  };
  function S2(t10, e) {
    let r = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
    return Math.abs(r) >= 1 && t10 !== Math.floor(t10) && (r = t10 - Math.floor(t10)), r;
  }
  var Ra = {
    formatters: A1
  };
  function E2(t10) {
    t10.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (e, r) => r.lineWidth,
        tickColor: (e, r) => r.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ra.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    }), t10.route("scale.ticks", "color", "", "color"), t10.route("scale.grid", "color", "", "borderColor"), t10.route("scale.border", "color", "", "borderColor"), t10.route("scale.title", "color", "", "color"), t10.describe("scale", {
      _fallback: false,
      _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
      _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
    }), t10.describe("scales", {
      _fallback: "scale"
    }), t10.describe("scale.ticks", {
      _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
      _indexable: (e) => e !== "backdropPadding"
    });
  }
  const Bn = /* @__PURE__ */ Object.create(null), _c = /* @__PURE__ */ Object.create(null);
  function ao(t10, e) {
    if (!e)
      return t10;
    const r = e.split(".");
    for (let n = 0, i = r.length; n < i; ++n) {
      const o = r[n];
      t10 = t10[o] || (t10[o] = /* @__PURE__ */ Object.create(null));
    }
    return t10;
  }
  function Ol(t10, e, r) {
    return typeof e == "string" ? bo(ao(t10, e), r) : bo(ao(t10, ""), e);
  }
  class k2 {
    constructor(e, r) {
      this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ], this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      }, this.hover = {}, this.hoverBackgroundColor = (n, i) => Il(i.backgroundColor), this.hoverBorderColor = (n, i) => Il(i.borderColor), this.hoverColor = (n, i) => Il(i.color), this.indexAxis = "x", this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(e), this.apply(r);
    }
    set(e, r) {
      return Ol(this, e, r);
    }
    get(e) {
      return ao(this, e);
    }
    describe(e, r) {
      return Ol(_c, e, r);
    }
    override(e, r) {
      return Ol(Bn, e, r);
    }
    route(e, r, n, i) {
      const o = ao(this, e), s = ao(this, n), a = "_" + r;
      Object.defineProperties(o, {
        [a]: {
          value: o[r],
          writable: true
        },
        [r]: {
          enumerable: true,
          get() {
            const l = this[a], c = s[i];
            return Ie(l) ? Object.assign({}, c, l) : ke(l, c);
          },
          set(l) {
            this[a] = l;
          }
        }
      });
    }
    apply(e) {
      e.forEach((r) => r(this));
    }
  }
  var st = /* @__PURE__ */ new k2({
    _scriptable: (t10) => !t10.startsWith("on"),
    _indexable: (t10) => t10 !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    w2,
    x2,
    E2
  ]);
  function C2(t10) {
    return !t10 || Re(t10.size) || Re(t10.family) ? null : (t10.style ? t10.style + " " : "") + (t10.weight ? t10.weight + " " : "") + t10.size + "px " + t10.family;
  }
  function sa(t10, e, r, n, i) {
    let o = e[i];
    return o || (o = e[i] = t10.measureText(i).width, r.push(i)), o > n && (n = o), n;
  }
  function T2(t10, e, r, n) {
    n = n || {};
    let i = n.data = n.data || {}, o = n.garbageCollect = n.garbageCollect || [];
    n.font !== e && (i = n.data = {}, o = n.garbageCollect = [], n.font = e), t10.save(), t10.font = e;
    let s = 0;
    const a = r.length;
    let l, c, u, f, d;
    for (l = 0; l < a; l++)
      if (f = r[l], f != null && !Ge(f))
        s = sa(t10, i, o, s, f);
      else if (Ge(f))
        for (c = 0, u = f.length; c < u; c++)
          d = f[c], d != null && !Ge(d) && (s = sa(t10, i, o, s, d));
    t10.restore();
    const h = o.length / 2;
    if (h > r.length) {
      for (l = 0; l < h; l++)
        delete i[o[l]];
      o.splice(0, h);
    }
    return s;
  }
  function yn(t10, e, r) {
    const n = t10.currentDevicePixelRatio, i = r !== 0 ? Math.max(r / 2, 0.5) : 0;
    return Math.round((e - i) * n) / n + i;
  }
  function Od(t10, e) {
    e = e || t10.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t10.width, t10.height), e.restore();
  }
  function Sc(t10, e, r, n) {
    w1(t10, e, r, n, null);
  }
  function w1(t10, e, r, n, i) {
    let o, s, a, l, c, u, f, d;
    const h = e.pointStyle, g = e.rotation, p = e.radius;
    let y = (g || 0) * c2;
    if (h && typeof h == "object" && (o = h.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) {
      t10.save(), t10.translate(r, n), t10.rotate(y), t10.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t10.restore();
      return;
    }
    if (!(isNaN(p) || p <= 0)) {
      switch (t10.beginPath(), h) {
        default:
          i ? t10.ellipse(r, n, i / 2, p, 0, 0, Ze) : t10.arc(r, n, p, 0, Ze), t10.closePath();
          break;
        case "triangle":
          u = i ? i / 2 : p, t10.moveTo(r + Math.sin(y) * u, n - Math.cos(y) * p), y += xd, t10.lineTo(r + Math.sin(y) * u, n - Math.cos(y) * p), y += xd, t10.lineTo(r + Math.sin(y) * u, n - Math.cos(y) * p), t10.closePath();
          break;
        case "rectRounded":
          c = p * 0.516, l = p - c, s = Math.cos(y + mn) * l, f = Math.cos(y + mn) * (i ? i / 2 - c : l), a = Math.sin(y + mn) * l, d = Math.sin(y + mn) * (i ? i / 2 - c : l), t10.arc(r - f, n - a, c, y - $e, y - at), t10.arc(r + d, n - s, c, y - at, y), t10.arc(r + f, n + a, c, y, y + at), t10.arc(r - d, n + s, c, y + at, y + $e), t10.closePath();
          break;
        case "rect":
          if (!g) {
            l = Math.SQRT1_2 * p, u = i ? i / 2 : l, t10.rect(r - u, n - l, 2 * u, 2 * l);
            break;
          }
          y += mn;
        case "rectRot":
          f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + d, n - s), t10.lineTo(r + f, n + a), t10.lineTo(r - d, n + s), t10.closePath();
          break;
        case "crossRot":
          y += mn;
        case "cross":
          f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + f, n + a), t10.moveTo(r + d, n - s), t10.lineTo(r - d, n + s);
          break;
        case "star":
          f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + f, n + a), t10.moveTo(r + d, n - s), t10.lineTo(r - d, n + s), y += mn, f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + f, n + a), t10.moveTo(r + d, n - s), t10.lineTo(r - d, n + s);
          break;
        case "line":
          s = i ? i / 2 : Math.cos(y) * p, a = Math.sin(y) * p, t10.moveTo(r - s, n - a), t10.lineTo(r + s, n + a);
          break;
        case "dash":
          t10.moveTo(r, n), t10.lineTo(r + Math.cos(y) * (i ? i / 2 : p), n + Math.sin(y) * p);
          break;
        case false:
          t10.closePath();
          break;
      }
      t10.fill(), e.borderWidth > 0 && t10.stroke();
    }
  }
  function Mr(t10, e, r) {
    return r = r || 0.5, !e || t10 && t10.x > e.left - r && t10.x < e.right + r && t10.y > e.top - r && t10.y < e.bottom + r;
  }
  function Da(t10, e) {
    t10.save(), t10.beginPath(), t10.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t10.clip();
  }
  function Ma(t10) {
    t10.restore();
  }
  function I2(t10, e, r, n, i) {
    if (!e)
      return t10.lineTo(r.x, r.y);
    if (i === "middle") {
      const o = (e.x + r.x) / 2;
      t10.lineTo(o, e.y), t10.lineTo(o, r.y);
    } else
      i === "after" != !!n ? t10.lineTo(e.x, r.y) : t10.lineTo(r.x, e.y);
    t10.lineTo(r.x, r.y);
  }
  function O2(t10, e, r, n) {
    if (!e)
      return t10.lineTo(r.x, r.y);
    t10.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? r.cp2x : r.cp1x, n ? r.cp2y : r.cp1y, r.x, r.y);
  }
  function P2(t10, e) {
    e.translation && t10.translate(e.translation[0], e.translation[1]), Re(e.rotation) || t10.rotate(e.rotation), e.color && (t10.fillStyle = e.color), e.textAlign && (t10.textAlign = e.textAlign), e.textBaseline && (t10.textBaseline = e.textBaseline);
  }
  function R2(t10, e, r, n, i) {
    if (i.strikethrough || i.underline) {
      const o = t10.measureText(n), s = e - o.actualBoundingBoxLeft, a = e + o.actualBoundingBoxRight, l = r - o.actualBoundingBoxAscent, c = r + o.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c;
      t10.strokeStyle = t10.fillStyle, t10.beginPath(), t10.lineWidth = i.decorationWidth || 2, t10.moveTo(s, u), t10.lineTo(a, u), t10.stroke();
    }
  }
  function D2(t10, e) {
    const r = t10.fillStyle;
    t10.fillStyle = e.color, t10.fillRect(e.left, e.top, e.width, e.height), t10.fillStyle = r;
  }
  function Fn(t10, e, r, n, i, o = {}) {
    const s = Ge(e) ? e : [
      e
    ], a = o.strokeWidth > 0 && o.strokeColor !== "";
    let l, c;
    for (t10.save(), t10.font = i.string, P2(t10, o), l = 0; l < s.length; ++l)
      c = s[l], o.backdrop && D2(t10, o.backdrop), a && (o.strokeColor && (t10.strokeStyle = o.strokeColor), Re(o.strokeWidth) || (t10.lineWidth = o.strokeWidth), t10.strokeText(c, r, n, o.maxWidth)), t10.fillText(c, r, n, o.maxWidth), R2(t10, r, n, c, o), n += Number(i.lineHeight);
    t10.restore();
  }
  function wo(t10, e) {
    const { x: r, y: n, w: i, h: o, radius: s } = e;
    t10.arc(r + s.topLeft, n + s.topLeft, s.topLeft, 1.5 * $e, $e, true), t10.lineTo(r, n + o - s.bottomLeft), t10.arc(r + s.bottomLeft, n + o - s.bottomLeft, s.bottomLeft, $e, at, true), t10.lineTo(r + i - s.bottomRight, n + o), t10.arc(r + i - s.bottomRight, n + o - s.bottomRight, s.bottomRight, at, 0, true), t10.lineTo(r + i, n + s.topRight), t10.arc(r + i - s.topRight, n + s.topRight, s.topRight, 0, -at, true), t10.lineTo(r + s.topLeft, n);
  }
  const M2 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, N2 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function L2(t10, e) {
    const r = ("" + t10).match(M2);
    if (!r || r[1] === "normal")
      return e * 1.2;
    switch (t10 = +r[2], r[3]) {
      case "px":
        return t10;
      case "%":
        t10 /= 100;
        break;
    }
    return e * t10;
  }
  const B2 = (t10) => +t10 || 0;
  function Ru(t10, e) {
    const r = {}, n = Ie(e), i = n ? Object.keys(e) : e, o = Ie(t10) ? n ? (s) => ke(t10[s], t10[e[s]]) : (s) => t10[s] : () => t10;
    for (const s of i)
      r[s] = B2(o(s));
    return r;
  }
  function x1(t10) {
    return Ru(t10, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function Tn(t10) {
    return Ru(t10, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function Et(t10) {
    const e = x1(t10);
    return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
  }
  function ft(t10, e) {
    t10 = t10 || {}, e = e || st.font;
    let r = ke(t10.size, e.size);
    typeof r == "string" && (r = parseInt(r, 10));
    let n = ke(t10.style, e.style);
    n && !("" + n).match(N2) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
    const i = {
      family: ke(t10.family, e.family),
      lineHeight: L2(ke(t10.lineHeight, e.lineHeight), r),
      size: r,
      style: n,
      weight: ke(t10.weight, e.weight),
      string: ""
    };
    return i.string = C2(i), i;
  }
  function Xi(t10, e, r, n) {
    let o, s, a;
    for (o = 0, s = t10.length; o < s; ++o)
      if (a = t10[o], a !== void 0 && a !== void 0)
        return a;
  }
  function F2(t10, e, r) {
    const { min: n, max: i } = t10, o = u1(e, (i - n) / 2), s = (a, l) => r && a === 0 ? 0 : a + l;
    return {
      min: s(n, -Math.abs(o)),
      max: s(i, o)
    };
  }
  function fn(t10, e) {
    return Object.assign(Object.create(t10), e);
  }
  function Du(t10, e = [
    ""
  ], r, n, i = () => t10[0]) {
    const o = r || t10;
    typeof n > "u" && (n = k1("_fallback", t10));
    const s = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: t10,
      _rootScopes: o,
      _fallback: n,
      _getTarget: i,
      override: (a) => Du([
        a,
        ...t10
      ], e, o, n)
    };
    return new Proxy(s, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(a, l) {
        return delete a[l], delete a._keys, delete t10[0][l], true;
      },
      /**
      * A trap for getting property values.
      */
      get(a, l) {
        return S1(a, l, () => K2(l, e, t10, a));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(a, l) {
        return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(t10[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(a, l) {
        return Rd(a).includes(l);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(a) {
        return Rd(a);
      },
      /**
      * A trap for setting property values.
      */
      set(a, l, c) {
        const u = a._storage || (a._storage = i());
        return a[l] = u[l] = c, delete a._keys, true;
      }
    });
  }
  function gi(t10, e, r, n) {
    const i = {
      _cacheable: false,
      _proxy: t10,
      _context: e,
      _subProxy: r,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _1(t10, n),
      setContext: (o) => gi(t10, o, r, n),
      override: (o) => gi(t10.override(o), e, r, n)
    };
    return new Proxy(i, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(o, s) {
        return delete o[s], delete t10[s], true;
      },
      /**
      * A trap for getting property values.
      */
      get(o, s, a) {
        return S1(o, s, () => W2(o, s, a));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(o, s) {
        return o._descriptors.allKeys ? Reflect.has(t10, s) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(t10, s);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(t10);
      },
      /**
      * A trap for the in operator.
      */
      has(o, s) {
        return Reflect.has(t10, s);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(t10);
      },
      /**
      * A trap for setting property values.
      */
      set(o, s, a) {
        return t10[s] = a, delete o[s], true;
      }
    });
  }
  function _1(t10, e = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable: r = e.scriptable, _indexable: n = e.indexable, _allKeys: i = e.allKeys } = t10;
    return {
      allKeys: i,
      scriptable: r,
      indexable: n,
      isScriptable: an(r) ? r : () => r,
      isIndexable: an(n) ? n : () => n
    };
  }
  const j2 = (t10, e) => t10 ? t10 + Cu(e) : e, Mu = (t10, e) => Ie(e) && t10 !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
  function S1(t10, e, r) {
    if (Object.prototype.hasOwnProperty.call(t10, e))
      return t10[e];
    const n = r();
    return t10[e] = n, n;
  }
  function W2(t10, e, r) {
    const { _proxy: n, _context: i, _subProxy: o, _descriptors: s } = t10;
    let a = n[e];
    return an(a) && s.isScriptable(e) && (a = U2(e, a, t10, r)), Ge(a) && a.length && (a = z2(e, a, t10, s.isIndexable)), Mu(e, a) && (a = gi(a, i, o && o[e], s)), a;
  }
  function U2(t10, e, r, n) {
    const { _proxy: i, _context: o, _subProxy: s, _stack: a } = r;
    if (a.has(t10))
      throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t10);
    a.add(t10);
    let l = e(o, s || n);
    return a.delete(t10), Mu(t10, l) && (l = Nu(i._scopes, i, t10, l)), l;
  }
  function z2(t10, e, r, n) {
    const { _proxy: i, _context: o, _subProxy: s, _descriptors: a } = r;
    if (typeof o.index < "u" && n(t10))
      return e[o.index % e.length];
    if (Ie(e[0])) {
      const l = e, c = i._scopes.filter((u) => u !== l);
      e = [];
      for (const u of l) {
        const f = Nu(c, i, t10, u);
        e.push(gi(f, o, s && s[t10], a));
      }
    }
    return e;
  }
  function E1(t10, e, r) {
    return an(t10) ? t10(e, r) : t10;
  }
  const V2 = (t10, e) => t10 === true ? e : typeof t10 == "string" ? sn(e, t10) : void 0;
  function q2(t10, e, r, n, i) {
    for (const o of e) {
      const s = V2(r, o);
      if (s) {
        t10.add(s);
        const a = E1(s._fallback, r, i);
        if (typeof a < "u" && a !== r && a !== n)
          return a;
      } else if (s === false && typeof n < "u" && r !== n)
        return null;
    }
    return false;
  }
  function Nu(t10, e, r, n) {
    const i = e._rootScopes, o = E1(e._fallback, r, n), s = [
      ...t10,
      ...i
    ], a = /* @__PURE__ */ new Set();
    a.add(n);
    let l = Pd(a, s, r, o || r, n);
    return l === null || typeof o < "u" && o !== r && (l = Pd(a, s, o, l, n), l === null) ? false : Du(Array.from(a), [
      ""
    ], i, o, () => H2(e, r, n));
  }
  function Pd(t10, e, r, n, i) {
    for (; r; )
      r = q2(t10, e, r, n, i);
    return r;
  }
  function H2(t10, e, r) {
    const n = t10._getTarget();
    e in n || (n[e] = {});
    const i = n[e];
    return Ge(i) && Ie(r) ? r : i || {};
  }
  function K2(t10, e, r, n) {
    let i;
    for (const o of e)
      if (i = k1(j2(o, t10), r), typeof i < "u")
        return Mu(t10, i) ? Nu(r, n, t10, i) : i;
  }
  function k1(t10, e) {
    for (const r of e) {
      if (!r)
        continue;
      const n = r[t10];
      if (typeof n < "u")
        return n;
    }
  }
  function Rd(t10) {
    let e = t10._keys;
    return e || (e = t10._keys = Y2(t10._scopes)), e;
  }
  function Y2(t10) {
    const e = /* @__PURE__ */ new Set();
    for (const r of t10)
      for (const n of Object.keys(r).filter((i) => !i.startsWith("_")))
        e.add(n);
    return Array.from(e);
  }
  function C1(t10, e, r, n) {
    const { iScale: i } = t10, { key: o = "r" } = this._parsing, s = new Array(n);
    let a, l, c, u;
    for (a = 0, l = n; a < l; ++a)
      c = a + r, u = e[c], s[a] = {
        r: i.parse(sn(u, o), c)
      };
    return s;
  }
  const X2 = Number.EPSILON || 1e-14, mi = (t10, e) => e < t10.length && !t10[e].skip && t10[e], T1 = (t10) => t10 === "x" ? "y" : "x";
  function J2(t10, e, r, n) {
    const i = t10.skip ? e : t10, o = e, s = r.skip ? e : r, a = xc(o, i), l = xc(s, o);
    let c = a / (a + l), u = l / (a + l);
    c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
    const f = n * c, d = n * u;
    return {
      previous: {
        x: o.x - f * (s.x - i.x),
        y: o.y - f * (s.y - i.y)
      },
      next: {
        x: o.x + d * (s.x - i.x),
        y: o.y + d * (s.y - i.y)
      }
    };
  }
  function Q2(t10, e, r) {
    const n = t10.length;
    let i, o, s, a, l, c = mi(t10, 0);
    for (let u = 0; u < n - 1; ++u)
      if (l = c, c = mi(t10, u + 1), !(!l || !c)) {
        if (oo(e[u], 0, X2)) {
          r[u] = r[u + 1] = 0;
          continue;
        }
        i = r[u] / e[u], o = r[u + 1] / e[u], a = Math.pow(i, 2) + Math.pow(o, 2), !(a <= 9) && (s = 3 / Math.sqrt(a), r[u] = i * s * e[u], r[u + 1] = o * s * e[u]);
      }
  }
  function G2(t10, e, r = "x") {
    const n = T1(r), i = t10.length;
    let o, s, a, l = mi(t10, 0);
    for (let c = 0; c < i; ++c) {
      if (s = a, a = l, l = mi(t10, c + 1), !a)
        continue;
      const u = a[r], f = a[n];
      s && (o = (u - s[r]) / 3, a[`cp1${r}`] = u - o, a[`cp1${n}`] = f - o * e[c]), l && (o = (l[r] - u) / 3, a[`cp2${r}`] = u + o, a[`cp2${n}`] = f + o * e[c]);
    }
  }
  function Z2(t10, e = "x") {
    const r = T1(e), n = t10.length, i = Array(n).fill(0), o = Array(n);
    let s, a, l, c = mi(t10, 0);
    for (s = 0; s < n; ++s)
      if (a = l, l = c, c = mi(t10, s + 1), !!l) {
        if (c) {
          const u = c[e] - l[e];
          i[s] = u !== 0 ? (c[r] - l[r]) / u : 0;
        }
        o[s] = a ? c ? vr(i[s - 1]) !== vr(i[s]) ? 0 : (i[s - 1] + i[s]) / 2 : i[s - 1] : i[s];
      }
    Q2(t10, i, o), G2(t10, o, e);
  }
  function is(t10, e, r) {
    return Math.max(Math.min(t10, r), e);
  }
  function $2(t10, e) {
    let r, n, i, o, s, a = Mr(t10[0], e);
    for (r = 0, n = t10.length; r < n; ++r)
      s = o, o = a, a = r < n - 1 && Mr(t10[r + 1], e), o && (i = t10[r], s && (i.cp1x = is(i.cp1x, e.left, e.right), i.cp1y = is(i.cp1y, e.top, e.bottom)), a && (i.cp2x = is(i.cp2x, e.left, e.right), i.cp2y = is(i.cp2y, e.top, e.bottom)));
  }
  function ev(t10, e, r, n, i) {
    let o, s, a, l;
    if (e.spanGaps && (t10 = t10.filter((c) => !c.skip)), e.cubicInterpolationMode === "monotone")
      Z2(t10, i);
    else {
      let c = n ? t10[t10.length - 1] : t10[0];
      for (o = 0, s = t10.length; o < s; ++o)
        a = t10[o], l = J2(c, a, t10[Math.min(o + 1, s - (n ? 0 : 1)) % s], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
    }
    e.capBezierPoints && $2(t10, r);
  }
  function I1() {
    return typeof window < "u" && typeof document < "u";
  }
  function Lu(t10) {
    let e = t10.parentNode;
    return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
  }
  function aa(t10, e, r) {
    let n;
    return typeof t10 == "string" ? (n = parseInt(t10, 10), t10.indexOf("%") !== -1 && (n = n / 100 * e.parentNode[r])) : n = t10, n;
  }
  const Na = (t10) => t10.ownerDocument.defaultView.getComputedStyle(t10, null);
  function tv(t10, e) {
    return Na(t10).getPropertyValue(e);
  }
  const rv = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function In(t10, e, r) {
    const n = {};
    r = r ? "-" + r : "";
    for (let i = 0; i < 4; i++) {
      const o = rv[i];
      n[o] = parseFloat(t10[e + "-" + o + r]) || 0;
    }
    return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
  }
  const nv = (t10, e, r) => (t10 > 0 || e > 0) && (!r || !r.shadowRoot);
  function iv(t10, e) {
    const r = t10.touches, n = r && r.length ? r[0] : t10, { offsetX: i, offsetY: o } = n;
    let s = false, a, l;
    if (nv(i, o, t10.target))
      a = i, l = o;
    else {
      const c = e.getBoundingClientRect();
      a = n.clientX - c.left, l = n.clientY - c.top, s = true;
    }
    return {
      x: a,
      y: l,
      box: s
    };
  }
  function _n(t10, e) {
    if ("native" in t10)
      return t10;
    const { canvas: r, currentDevicePixelRatio: n } = e, i = Na(r), o = i.boxSizing === "border-box", s = In(i, "padding"), a = In(i, "border", "width"), { x: l, y: c, box: u } = iv(t10, r), f = s.left + (u && a.left), d = s.top + (u && a.top);
    let { width: h, height: g } = e;
    return o && (h -= s.width + a.width, g -= s.height + a.height), {
      x: Math.round((l - f) / h * r.width / n),
      y: Math.round((c - d) / g * r.height / n)
    };
  }
  function ov(t10, e, r) {
    let n, i;
    if (e === void 0 || r === void 0) {
      const o = Lu(t10);
      if (!o)
        e = t10.clientWidth, r = t10.clientHeight;
      else {
        const s = o.getBoundingClientRect(), a = Na(o), l = In(a, "border", "width"), c = In(a, "padding");
        e = s.width - c.width - l.width, r = s.height - c.height - l.height, n = aa(a.maxWidth, o, "clientWidth"), i = aa(a.maxHeight, o, "clientHeight");
      }
    }
    return {
      width: e,
      height: r,
      maxWidth: n || oa,
      maxHeight: i || oa
    };
  }
  const os = (t10) => Math.round(t10 * 10) / 10;
  function sv(t10, e, r, n) {
    const i = Na(t10), o = In(i, "margin"), s = aa(i.maxWidth, t10, "clientWidth") || oa, a = aa(i.maxHeight, t10, "clientHeight") || oa, l = ov(t10, e, r);
    let { width: c, height: u } = l;
    if (i.boxSizing === "content-box") {
      const d = In(i, "border", "width"), h = In(i, "padding");
      c -= h.width + d.width, u -= h.height + d.height;
    }
    return c = Math.max(0, c - o.width), u = Math.max(0, n ? c / n : u - o.height), c = os(Math.min(c, s, l.maxWidth)), u = os(Math.min(u, a, l.maxHeight)), c && !u && (u = os(c / 2)), (e !== void 0 || r !== void 0) && n && l.height && u > l.height && (u = l.height, c = os(Math.floor(u * n))), {
      width: c,
      height: u
    };
  }
  function Dd(t10, e, r) {
    const n = e || 1, i = Math.floor(t10.height * n), o = Math.floor(t10.width * n);
    t10.height = Math.floor(t10.height), t10.width = Math.floor(t10.width);
    const s = t10.canvas;
    return s.style && (r || !s.style.height && !s.style.width) && (s.style.height = `${t10.height}px`, s.style.width = `${t10.width}px`), t10.currentDevicePixelRatio !== n || s.height !== i || s.width !== o ? (t10.currentDevicePixelRatio = n, s.height = i, s.width = o, t10.ctx.setTransform(n, 0, 0, n, 0, 0), true) : false;
  }
  const av = function() {
    let t10 = false;
    try {
      const e = {
        get passive() {
          return t10 = true, false;
        }
      };
      window.addEventListener("test", null, e), window.removeEventListener("test", null, e);
    } catch {
    }
    return t10;
  }();
  function Md(t10, e) {
    const r = tv(t10, e), n = r && r.match(/^(\d+)(\.\d+)?px$/);
    return n ? +n[1] : void 0;
  }
  function Sn(t10, e, r, n) {
    return {
      x: t10.x + r * (e.x - t10.x),
      y: t10.y + r * (e.y - t10.y)
    };
  }
  function lv(t10, e, r, n) {
    return {
      x: t10.x + r * (e.x - t10.x),
      y: n === "middle" ? r < 0.5 ? t10.y : e.y : n === "after" ? r < 1 ? t10.y : e.y : r > 0 ? e.y : t10.y
    };
  }
  function cv(t10, e, r, n) {
    const i = {
      x: t10.cp2x,
      y: t10.cp2y
    }, o = {
      x: e.cp1x,
      y: e.cp1y
    }, s = Sn(t10, i, r), a = Sn(i, o, r), l = Sn(o, e, r), c = Sn(s, a, r), u = Sn(a, l, r);
    return Sn(c, u, r);
  }
  const uv = function(t10, e) {
    return {
      x(r) {
        return t10 + t10 + e - r;
      },
      setWidth(r) {
        e = r;
      },
      textAlign(r) {
        return r === "center" ? r : r === "right" ? "left" : "right";
      },
      xPlus(r, n) {
        return r - n;
      },
      leftForLtr(r, n) {
        return r - n;
      }
    };
  }, fv = function() {
    return {
      x(t10) {
        return t10;
      },
      setWidth(t10) {
      },
      textAlign(t10) {
        return t10;
      },
      xPlus(t10, e) {
        return t10 + e;
      },
      leftForLtr(t10, e) {
        return t10;
      }
    };
  };
  function ai(t10, e, r) {
    return t10 ? uv(e, r) : fv();
  }
  function O1(t10, e) {
    let r, n;
    (e === "ltr" || e === "rtl") && (r = t10.canvas.style, n = [
      r.getPropertyValue("direction"),
      r.getPropertyPriority("direction")
    ], r.setProperty("direction", e, "important"), t10.prevTextDirection = n);
  }
  function P1(t10, e) {
    e !== void 0 && (delete t10.prevTextDirection, t10.canvas.style.setProperty("direction", e[0], e[1]));
  }
  function R1(t10) {
    return t10 === "angle" ? {
      between: Ao,
      compare: d2,
      normalize: Lt
    } : {
      between: Rr,
      compare: (e, r) => e - r,
      normalize: (e) => e
    };
  }
  function Nd({ start: t10, end: e, count: r, loop: n, style: i }) {
    return {
      start: t10 % r,
      end: e % r,
      loop: n && (e - t10 + 1) % r === 0,
      style: i
    };
  }
  function dv(t10, e, r) {
    const { property: n, start: i, end: o } = r, { between: s, normalize: a } = R1(n), l = e.length;
    let { start: c, end: u, loop: f } = t10, d, h;
    if (f) {
      for (c += l, u += l, d = 0, h = l; d < h && s(a(e[c % l][n]), i, o); ++d)
        c--, u--;
      c %= l, u %= l;
    }
    return u < c && (u += l), {
      start: c,
      end: u,
      loop: f,
      style: t10.style
    };
  }
  function D1(t10, e, r) {
    if (!r)
      return [
        t10
      ];
    const { property: n, start: i, end: o } = r, s = e.length, { compare: a, between: l, normalize: c } = R1(n), { start: u, end: f, loop: d, style: h } = dv(t10, e, r), g = [];
    let p = false, y = null, b, x, S;
    const C = () => l(i, S, b) && a(i, S) !== 0, _ = () => a(o, b) === 0 || l(o, S, b), L = () => p || C(), F = () => !p || _();
    for (let V = u, W = u; V <= f; ++V)
      x = e[V % s], !x.skip && (b = c(x[n]), b !== S && (p = l(b, i, o), y === null && L() && (y = a(b, i) === 0 ? V : W), y !== null && F() && (g.push(Nd({
        start: y,
        end: V,
        loop: d,
        count: s,
        style: h
      })), y = null), W = V, S = b));
    return y !== null && g.push(Nd({
      start: y,
      end: f,
      loop: d,
      count: s,
      style: h
    })), g;
  }
  function M1(t10, e) {
    const r = [], n = t10.segments;
    for (let i = 0; i < n.length; i++) {
      const o = D1(n[i], t10.points, e);
      o.length && r.push(...o);
    }
    return r;
  }
  function hv(t10, e, r, n) {
    let i = 0, o = e - 1;
    if (r && !n)
      for (; i < e && !t10[i].skip; )
        i++;
    for (; i < e && t10[i].skip; )
      i++;
    for (i %= e, r && (o += i); o > i && t10[o % e].skip; )
      o--;
    return o %= e, {
      start: i,
      end: o
    };
  }
  function pv(t10, e, r, n) {
    const i = t10.length, o = [];
    let s = e, a = t10[e], l;
    for (l = e + 1; l <= r; ++l) {
      const c = t10[l % i];
      c.skip || c.stop ? a.skip || (n = false, o.push({
        start: e % i,
        end: (l - 1) % i,
        loop: n
      }), e = s = c.stop ? l : null) : (s = l, a.skip && (e = l)), a = c;
    }
    return s !== null && o.push({
      start: e % i,
      end: s % i,
      loop: n
    }), o;
  }
  function gv(t10, e) {
    const r = t10.points, n = t10.options.spanGaps, i = r.length;
    if (!i)
      return [];
    const o = !!t10._loop, { start: s, end: a } = hv(r, i, o, n);
    if (n === true)
      return Ld(t10, [
        {
          start: s,
          end: a,
          loop: o
        }
      ], r, e);
    const l = a < s ? a + i : a, c = !!t10._fullLoop && s === 0 && a === i - 1;
    return Ld(t10, pv(r, s, l, c), r, e);
  }
  function Ld(t10, e, r, n) {
    return !n || !n.setContext || !r ? e : mv(t10, e, r, n);
  }
  function mv(t10, e, r, n) {
    const i = t10._chart.getContext(), o = Bd(t10.options), { _datasetIndex: s, options: { spanGaps: a } } = t10, l = r.length, c = [];
    let u = o, f = e[0].start, d = f;
    function h(g, p, y, b) {
      const x = a ? -1 : 1;
      if (g !== p) {
        for (g += l; r[g % l].skip; )
          g -= x;
        for (; r[p % l].skip; )
          p += x;
        g % l !== p % l && (c.push({
          start: g % l,
          end: p % l,
          loop: y,
          style: b
        }), u = b, f = p % l);
      }
    }
    for (const g of e) {
      f = a ? f : g.start;
      let p = r[f % l], y;
      for (d = f + 1; d <= g.end; d++) {
        const b = r[d % l];
        y = Bd(n.setContext(fn(i, {
          type: "segment",
          p0: p,
          p1: b,
          p0DataIndex: (d - 1) % l,
          p1DataIndex: d % l,
          datasetIndex: s
        }))), yv(y, u) && h(f, d - 1, g.loop, u), p = b, u = y;
      }
      f < d - 1 && h(f, d - 1, g.loop, u);
    }
    return c;
  }
  function Bd(t10) {
    return {
      backgroundColor: t10.backgroundColor,
      borderCapStyle: t10.borderCapStyle,
      borderDash: t10.borderDash,
      borderDashOffset: t10.borderDashOffset,
      borderJoinStyle: t10.borderJoinStyle,
      borderWidth: t10.borderWidth,
      borderColor: t10.borderColor
    };
  }
  function yv(t10, e) {
    if (!e)
      return false;
    const r = [], n = function(i, o) {
      return Pu(o) ? (r.includes(o) || r.push(o), r.indexOf(o)) : o;
    };
    return JSON.stringify(t10, n) !== JSON.stringify(e, n);
  }
  /*!
   * Chart.js v4.4.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   */
  class bv {
    constructor() {
      this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
    }
    _notify(e, r, n, i) {
      const o = r.listeners[i], s = r.duration;
      o.forEach((a) => a({
        chart: e,
        initial: r.initial,
        numSteps: s,
        currentStep: Math.min(n - r.start, s)
      }));
    }
    _refresh() {
      this._request || (this._running = true, this._request = m1.call(window, () => {
        this._update(), this._request = null, this._running && this._refresh();
      }));
    }
    _update(e = Date.now()) {
      let r = 0;
      this._charts.forEach((n, i) => {
        if (!n.running || !n.items.length)
          return;
        const o = n.items;
        let s = o.length - 1, a = false, l;
        for (; s >= 0; --s)
          l = o[s], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(e), a = true) : (o[s] = o[o.length - 1], o.pop());
        a && (i.draw(), this._notify(i, n, e, "progress")), o.length || (n.running = false, this._notify(i, n, e, "complete"), n.initial = false), r += o.length;
      }), this._lastDate = e, r === 0 && (this._running = false);
    }
    _getAnims(e) {
      const r = this._charts;
      let n = r.get(e);
      return n || (n = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      }, r.set(e, n)), n;
    }
    listen(e, r, n) {
      this._getAnims(e).listeners[r].push(n);
    }
    add(e, r) {
      !r || !r.length || this._getAnims(e).items.push(...r);
    }
    has(e) {
      return this._getAnims(e).items.length > 0;
    }
    start(e) {
      const r = this._charts.get(e);
      r && (r.running = true, r.start = Date.now(), r.duration = r.items.reduce((n, i) => Math.max(n, i._duration), 0), this._refresh());
    }
    running(e) {
      if (!this._running)
        return false;
      const r = this._charts.get(e);
      return !(!r || !r.running || !r.items.length);
    }
    stop(e) {
      const r = this._charts.get(e);
      if (!r || !r.items.length)
        return;
      const n = r.items;
      let i = n.length - 1;
      for (; i >= 0; --i)
        n[i].cancel();
      r.items = [], this._notify(e, r, Date.now(), "complete");
    }
    remove(e) {
      return this._charts.delete(e);
    }
  }
  var Er = /* @__PURE__ */ new bv();
  const Fd = "transparent", vv = {
    boolean(t10, e, r) {
      return r > 0.5 ? e : t10;
    },
    color(t10, e, r) {
      const n = Td(t10 || Fd), i = n.valid && Td(e || Fd);
      return i && i.valid ? i.mix(n, r).hexString() : e;
    },
    number(t10, e, r) {
      return t10 + (e - t10) * r;
    }
  };
  class Av {
    constructor(e, r, n, i) {
      const o = r[n];
      i = Xi([
        e.to,
        i,
        o,
        e.from
      ]);
      const s = Xi([
        e.from,
        o,
        i
      ]);
      this._active = true, this._fn = e.fn || vv[e.type || typeof s], this._easing = so[e.easing] || so.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = r, this._prop = n, this._from = s, this._to = i, this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(e, r, n) {
      if (this._active) {
        this._notify(false);
        const i = this._target[this._prop], o = n - this._start, s = this._duration - o;
        this._start = n, this._duration = Math.floor(Math.max(s, e.duration)), this._total += o, this._loop = !!e.loop, this._to = Xi([
          e.to,
          r,
          i,
          e.from
        ]), this._from = Xi([
          e.from,
          i,
          r
        ]);
      }
    }
    cancel() {
      this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
    }
    tick(e) {
      const r = e - this._start, n = this._duration, i = this._prop, o = this._from, s = this._loop, a = this._to;
      let l;
      if (this._active = o !== a && (s || r < n), !this._active) {
        this._target[i] = a, this._notify(true);
        return;
      }
      if (r < 0) {
        this._target[i] = o;
        return;
      }
      l = r / n % 2, l = s && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(o, a, l);
    }
    wait() {
      const e = this._promises || (this._promises = []);
      return new Promise((r, n) => {
        e.push({
          res: r,
          rej: n
        });
      });
    }
    _notify(e) {
      const r = e ? "res" : "rej", n = this._promises || [];
      for (let i = 0; i < n.length; i++)
        n[i][r]();
    }
  }
  class N1 {
    constructor(e, r) {
      this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(r);
    }
    configure(e) {
      if (!Ie(e))
        return;
      const r = Object.keys(st.animation), n = this._properties;
      Object.getOwnPropertyNames(e).forEach((i) => {
        const o = e[i];
        if (!Ie(o))
          return;
        const s = {};
        for (const a of r)
          s[a] = o[a];
        (Ge(o.properties) && o.properties || [
          i
        ]).forEach((a) => {
          (a === i || !n.has(a)) && n.set(a, s);
        });
      });
    }
    _animateOptions(e, r) {
      const n = r.options, i = xv(e, n);
      if (!i)
        return [];
      const o = this._createAnimations(i, n);
      return n.$shared && wv(e.options.$animations, n).then(() => {
        e.options = n;
      }, () => {
      }), o;
    }
    _createAnimations(e, r) {
      const n = this._properties, i = [], o = e.$animations || (e.$animations = {}), s = Object.keys(r), a = Date.now();
      let l;
      for (l = s.length - 1; l >= 0; --l) {
        const c = s[l];
        if (c.charAt(0) === "$")
          continue;
        if (c === "options") {
          i.push(...this._animateOptions(e, r));
          continue;
        }
        const u = r[c];
        let f = o[c];
        const d = n.get(c);
        if (f)
          if (d && f.active()) {
            f.update(d, u, a);
            continue;
          } else
            f.cancel();
        if (!d || !d.duration) {
          e[c] = u;
          continue;
        }
        o[c] = f = new Av(d, e, c, u), i.push(f);
      }
      return i;
    }
    update(e, r) {
      if (this._properties.size === 0) {
        Object.assign(e, r);
        return;
      }
      const n = this._createAnimations(e, r);
      if (n.length)
        return Er.add(this._chart, n), true;
    }
  }
  function wv(t10, e) {
    const r = [], n = Object.keys(e);
    for (let i = 0; i < n.length; i++) {
      const o = t10[n[i]];
      o && o.active() && r.push(o.wait());
    }
    return Promise.all(r);
  }
  function xv(t10, e) {
    if (!e)
      return;
    let r = t10.options;
    if (!r) {
      t10.options = e;
      return;
    }
    return r.$shared && (t10.options = r = Object.assign({}, r, {
      $shared: false,
      $animations: {}
    })), r;
  }
  function jd(t10, e) {
    const r = t10 && t10.options || {}, n = r.reverse, i = r.min === void 0 ? e : 0, o = r.max === void 0 ? e : 0;
    return {
      start: n ? o : i,
      end: n ? i : o
    };
  }
  function _v(t10, e, r) {
    if (r === false)
      return false;
    const n = jd(t10, r), i = jd(e, r);
    return {
      top: i.end,
      right: n.end,
      bottom: i.start,
      left: n.start
    };
  }
  function Sv(t10) {
    let e, r, n, i;
    return Ie(t10) ? (e = t10.top, r = t10.right, n = t10.bottom, i = t10.left) : e = r = n = i = t10, {
      top: e,
      right: r,
      bottom: n,
      left: i,
      disabled: t10 === false
    };
  }
  function L1(t10, e) {
    const r = [], n = t10._getSortedDatasetMetas(e);
    let i, o;
    for (i = 0, o = n.length; i < o; ++i)
      r.push(n[i].index);
    return r;
  }
  function Wd(t10, e, r, n = {}) {
    const i = t10.keys, o = n.mode === "single";
    let s, a, l, c;
    if (e !== null) {
      for (s = 0, a = i.length; s < a; ++s) {
        if (l = +i[s], l === r) {
          if (n.all)
            continue;
          break;
        }
        c = t10.values[l], ot(c) && (o || e === 0 || vr(e) === vr(c)) && (e += c);
      }
      return e;
    }
  }
  function Ev(t10) {
    const e = Object.keys(t10), r = new Array(e.length);
    let n, i, o;
    for (n = 0, i = e.length; n < i; ++n)
      o = e[n], r[n] = {
        x: o,
        y: t10[o]
      };
    return r;
  }
  function Ud(t10, e) {
    const r = t10 && t10.options.stacked;
    return r || r === void 0 && e.stack !== void 0;
  }
  function kv(t10, e, r) {
    return `${t10.id}.${e.id}.${r.stack || r.type}`;
  }
  function Cv(t10) {
    const { min: e, max: r, minDefined: n, maxDefined: i } = t10.getUserBounds();
    return {
      min: n ? e : Number.NEGATIVE_INFINITY,
      max: i ? r : Number.POSITIVE_INFINITY
    };
  }
  function Tv(t10, e, r) {
    const n = t10[e] || (t10[e] = {});
    return n[r] || (n[r] = {});
  }
  function zd(t10, e, r, n) {
    for (const i of e.getMatchingVisibleMetas(n).reverse()) {
      const o = t10[i.index];
      if (r && o > 0 || !r && o < 0)
        return i.index;
    }
    return null;
  }
  function Vd(t10, e) {
    const { chart: r, _cachedMeta: n } = t10, i = r._stacks || (r._stacks = {}), { iScale: o, vScale: s, index: a } = n, l = o.axis, c = s.axis, u = kv(o, s, n), f = e.length;
    let d;
    for (let h = 0; h < f; ++h) {
      const g = e[h], { [l]: p, [c]: y } = g, b = g._stacks || (g._stacks = {});
      d = b[c] = Tv(i, u, p), d[a] = y, d._top = zd(d, s, true, n.type), d._bottom = zd(d, s, false, n.type);
      const x = d._visualValues || (d._visualValues = {});
      x[a] = y;
    }
  }
  function Pl(t10, e) {
    const r = t10.scales;
    return Object.keys(r).filter((n) => r[n].axis === e).shift();
  }
  function Iv(t10, e) {
    return fn(t10, {
      active: false,
      dataset: void 0,
      datasetIndex: e,
      index: e,
      mode: "default",
      type: "dataset"
    });
  }
  function Ov(t10, e, r) {
    return fn(t10, {
      active: false,
      dataIndex: e,
      parsed: void 0,
      raw: void 0,
      element: r,
      index: e,
      mode: "default",
      type: "data"
    });
  }
  function Mi(t10, e) {
    const r = t10.controller.index, n = t10.vScale && t10.vScale.axis;
    if (n) {
      e = e || t10._parsed;
      for (const i of e) {
        const o = i._stacks;
        if (!o || o[n] === void 0 || o[n][r] === void 0)
          return;
        delete o[n][r], o[n]._visualValues !== void 0 && o[n]._visualValues[r] !== void 0 && delete o[n]._visualValues[r];
      }
    }
  }
  const Rl = (t10) => t10 === "reset" || t10 === "none", qd = (t10, e) => e ? t10 : Object.assign({}, t10), Pv = (t10, e, r) => t10 && !e.hidden && e._stacked && {
    keys: L1(r, true),
    values: null
  };
  class lr {
    constructor(e, r) {
      this.chart = e, this._ctx = e.ctx, this.index = r, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
    }
    initialize() {
      const e = this._cachedMeta;
      this.configure(), this.linkScales(), e._stacked = Ud(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
    updateIndex(e) {
      this.index !== e && Mi(this._cachedMeta), this.index = e;
    }
    linkScales() {
      const e = this.chart, r = this._cachedMeta, n = this.getDataset(), i = (f, d, h, g) => f === "x" ? d : f === "r" ? g : h, o = r.xAxisID = ke(n.xAxisID, Pl(e, "x")), s = r.yAxisID = ke(n.yAxisID, Pl(e, "y")), a = r.rAxisID = ke(n.rAxisID, Pl(e, "r")), l = r.indexAxis, c = r.iAxisID = i(l, o, s, a), u = r.vAxisID = i(l, s, o, a);
      r.xScale = this.getScaleForId(o), r.yScale = this.getScaleForId(s), r.rScale = this.getScaleForId(a), r.iScale = this.getScaleForId(c), r.vScale = this.getScaleForId(u);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(e) {
      return this.chart.scales[e];
    }
    _getOtherScale(e) {
      const r = this._cachedMeta;
      return e === r.iScale ? r.vScale : r.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const e = this._cachedMeta;
      this._data && Ed(this._data, this), e._stacked && Mi(e);
    }
    _dataCheck() {
      const e = this.getDataset(), r = e.data || (e.data = []), n = this._data;
      if (Ie(r))
        this._data = Ev(r);
      else if (n !== r) {
        if (n) {
          Ed(n, this);
          const i = this._cachedMeta;
          Mi(i), i._parsed = [];
        }
        r && Object.isExtensible(r) && m2(r, this), this._syncList = [], this._data = r;
      }
    }
    addElements() {
      const e = this._cachedMeta;
      this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
    }
    buildOrUpdateElements(e) {
      const r = this._cachedMeta, n = this.getDataset();
      let i = false;
      this._dataCheck();
      const o = r._stacked;
      r._stacked = Ud(r.vScale, r), r.stack !== n.stack && (i = true, Mi(r), r.stack = n.stack), this._resyncElements(e), (i || o !== r._stacked) && Vd(this, r._parsed);
    }
    configure() {
      const e = this.chart.config, r = e.datasetScopeKeys(this._type), n = e.getOptionScopes(this.getDataset(), r, true);
      this.options = e.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
    }
    parse(e, r) {
      const { _cachedMeta: n, _data: i } = this, { iScale: o, _stacked: s } = n, a = o.axis;
      let l = e === 0 && r === i.length ? true : n._sorted, c = e > 0 && n._parsed[e - 1], u, f, d;
      if (this._parsing === false)
        n._parsed = i, n._sorted = true, d = i;
      else {
        Ge(i[e]) ? d = this.parseArrayData(n, i, e, r) : Ie(i[e]) ? d = this.parseObjectData(n, i, e, r) : d = this.parsePrimitiveData(n, i, e, r);
        const h = () => f[a] === null || c && f[a] < c[a];
        for (u = 0; u < r; ++u)
          n._parsed[u + e] = f = d[u], l && (h() && (l = false), c = f);
        n._sorted = l;
      }
      s && Vd(this, d);
    }
    parsePrimitiveData(e, r, n, i) {
      const { iScale: o, vScale: s } = e, a = o.axis, l = s.axis, c = o.getLabels(), u = o === s, f = new Array(i);
      let d, h, g;
      for (d = 0, h = i; d < h; ++d)
        g = d + n, f[d] = {
          [a]: u || o.parse(c[g], g),
          [l]: s.parse(r[g], g)
        };
      return f;
    }
    parseArrayData(e, r, n, i) {
      const { xScale: o, yScale: s } = e, a = new Array(i);
      let l, c, u, f;
      for (l = 0, c = i; l < c; ++l)
        u = l + n, f = r[u], a[l] = {
          x: o.parse(f[0], u),
          y: s.parse(f[1], u)
        };
      return a;
    }
    parseObjectData(e, r, n, i) {
      const { xScale: o, yScale: s } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i);
      let u, f, d, h;
      for (u = 0, f = i; u < f; ++u)
        d = u + n, h = r[d], c[u] = {
          x: o.parse(sn(h, a), d),
          y: s.parse(sn(h, l), d)
        };
      return c;
    }
    getParsed(e) {
      return this._cachedMeta._parsed[e];
    }
    getDataElement(e) {
      return this._cachedMeta.data[e];
    }
    applyStack(e, r, n) {
      const i = this.chart, o = this._cachedMeta, s = r[e.axis], a = {
        keys: L1(i, true),
        values: r._stacks[e.axis]._visualValues
      };
      return Wd(a, s, o.index, {
        mode: n
      });
    }
    updateRangeFromParsed(e, r, n, i) {
      const o = n[r.axis];
      let s = o === null ? NaN : o;
      const a = i && n._stacks[r.axis];
      i && a && (i.values = a, s = Wd(i, o, this._cachedMeta.index)), e.min = Math.min(e.min, s), e.max = Math.max(e.max, s);
    }
    getMinMax(e, r) {
      const n = this._cachedMeta, i = n._parsed, o = n._sorted && e === n.iScale, s = i.length, a = this._getOtherScale(e), l = Pv(r, n, this.chart), c = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      }, { min: u, max: f } = Cv(a);
      let d, h;
      function g() {
        h = i[d];
        const p = h[a.axis];
        return !ot(h[e.axis]) || u > p || f < p;
      }
      for (d = 0; d < s && !(!g() && (this.updateRangeFromParsed(c, e, h, l), o)); ++d)
        ;
      if (o) {
        for (d = s - 1; d >= 0; --d)
          if (!g()) {
            this.updateRangeFromParsed(c, e, h, l);
            break;
          }
      }
      return c;
    }
    getAllParsedValues(e) {
      const r = this._cachedMeta._parsed, n = [];
      let i, o, s;
      for (i = 0, o = r.length; i < o; ++i)
        s = r[i][e.axis], ot(s) && n.push(s);
      return n;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = r.iScale, i = r.vScale, o = this.getParsed(e);
      return {
        label: n ? "" + n.getLabelForValue(o[n.axis]) : "",
        value: i ? "" + i.getLabelForValue(o[i.axis]) : ""
      };
    }
    _update(e) {
      const r = this._cachedMeta;
      this.update(e || "default"), r._clip = Sv(ke(this.options.clip, _v(r.xScale, r.yScale, this.getMaxOverflow())));
    }
    update(e) {
    }
    draw() {
      const e = this._ctx, r = this.chart, n = this._cachedMeta, i = n.data || [], o = r.chartArea, s = [], a = this._drawStart || 0, l = this._drawCount || i.length - a, c = this.options.drawActiveElementsOnTop;
      let u;
      for (n.dataset && n.dataset.draw(e, o, a, l), u = a; u < a + l; ++u) {
        const f = i[u];
        f.hidden || (f.active && c ? s.push(f) : f.draw(e, o));
      }
      for (u = 0; u < s.length; ++u)
        s[u].draw(e, o);
    }
    getStyle(e, r) {
      const n = r ? "active" : "default";
      return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(e || 0, n);
    }
    getContext(e, r, n) {
      const i = this.getDataset();
      let o;
      if (e >= 0 && e < this._cachedMeta.data.length) {
        const s = this._cachedMeta.data[e];
        o = s.$context || (s.$context = Ov(this.getContext(), e, s)), o.parsed = this.getParsed(e), o.raw = i.data[e], o.index = o.dataIndex = e;
      } else
        o = this.$context || (this.$context = Iv(this.chart.getContext(), this.index)), o.dataset = i, o.index = o.datasetIndex = this.index;
      return o.active = !!r, o.mode = n, o;
    }
    resolveDatasetElementOptions(e) {
      return this._resolveElementOptions(this.datasetElementType.id, e);
    }
    resolveDataElementOptions(e, r) {
      return this._resolveElementOptions(this.dataElementType.id, r, e);
    }
    _resolveElementOptions(e, r = "default", n) {
      const i = r === "active", o = this._cachedDataOpts, s = e + "-" + r, a = o[s], l = this.enableOptionSharing && vo(n);
      if (a)
        return qd(a, l);
      const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, e), f = i ? [
        `${e}Hover`,
        "hover",
        e,
        ""
      ] : [
        e,
        ""
      ], d = c.getOptionScopes(this.getDataset(), u), h = Object.keys(st.elements[e]), g = () => this.getContext(n, i, r), p = c.resolveNamedOptions(d, h, g, f);
      return p.$shared && (p.$shared = l, o[s] = Object.freeze(qd(p, l))), p;
    }
    _resolveAnimations(e, r, n) {
      const i = this.chart, o = this._cachedDataOpts, s = `animation-${r}`, a = o[s];
      if (a)
        return a;
      let l;
      if (i.options.animation !== false) {
        const u = this.chart.config, f = u.datasetAnimationScopeKeys(this._type, r), d = u.getOptionScopes(this.getDataset(), f);
        l = u.createResolver(d, this.getContext(e, n, r));
      }
      const c = new N1(i, l && l.animations);
      return l && l._cacheable && (o[s] = Object.freeze(c)), c;
    }
    getSharedOptions(e) {
      if (e.$shared)
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
    }
    includeOptions(e, r) {
      return !r || Rl(e) || this.chart._animationsDisabled;
    }
    _getSharedOptions(e, r) {
      const n = this.resolveDataElementOptions(e, r), i = this._sharedOptions, o = this.getSharedOptions(n), s = this.includeOptions(r, o) || o !== i;
      return this.updateSharedOptions(o, r, n), {
        sharedOptions: o,
        includeOptions: s
      };
    }
    updateElement(e, r, n, i) {
      Rl(i) ? Object.assign(e, n) : this._resolveAnimations(r, i).update(e, n);
    }
    updateSharedOptions(e, r, n) {
      e && !Rl(r) && this._resolveAnimations(void 0, r).update(e, n);
    }
    _setStyle(e, r, n, i) {
      e.active = i;
      const o = this.getStyle(r, i);
      this._resolveAnimations(r, n, i).update(e, {
        options: !i && this.getSharedOptions(o) || o
      });
    }
    removeHoverStyle(e, r, n) {
      this._setStyle(e, n, "active", false);
    }
    setHoverStyle(e, r, n) {
      this._setStyle(e, n, "active", true);
    }
    _removeDatasetHoverStyle() {
      const e = this._cachedMeta.dataset;
      e && this._setStyle(e, void 0, "active", false);
    }
    _setDatasetHoverStyle() {
      const e = this._cachedMeta.dataset;
      e && this._setStyle(e, void 0, "active", true);
    }
    _resyncElements(e) {
      const r = this._data, n = this._cachedMeta.data;
      for (const [a, l, c] of this._syncList)
        this[a](l, c);
      this._syncList = [];
      const i = n.length, o = r.length, s = Math.min(o, i);
      s && this.parse(0, s), o > i ? this._insertElements(i, o - i, e) : o < i && this._removeElements(o, i - o);
    }
    _insertElements(e, r, n = true) {
      const i = this._cachedMeta, o = i.data, s = e + r;
      let a;
      const l = (c) => {
        for (c.length += r, a = c.length - 1; a >= s; a--)
          c[a] = c[a - r];
      };
      for (l(o), a = e; a < s; ++a)
        o[a] = new this.dataElementType();
      this._parsing && l(i._parsed), this.parse(e, r), n && this.updateElements(o, e, r, "reset");
    }
    updateElements(e, r, n, i) {
    }
    _removeElements(e, r) {
      const n = this._cachedMeta;
      if (this._parsing) {
        const i = n._parsed.splice(e, r);
        n._stacked && Mi(n, i);
      }
      n.data.splice(e, r);
    }
    _sync(e) {
      if (this._parsing)
        this._syncList.push(e);
      else {
        const [r, n, i] = e;
        this[r](n, i);
      }
      this.chart._dataChanges.push([
        this.index,
        ...e
      ]);
    }
    _onDataPush() {
      const e = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - e,
        e
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(e, r) {
      r && this._sync([
        "_removeElements",
        e,
        r
      ]);
      const n = arguments.length - 2;
      n && this._sync([
        "_insertElements",
        e,
        n
      ]);
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  }
  ge(lr, "defaults", {}), ge(lr, "datasetElementType", null), ge(lr, "dataElementType", null);
  function Rv(t10, e) {
    if (!t10._cache.$bar) {
      const r = t10.getMatchingVisibleMetas(e);
      let n = [];
      for (let i = 0, o = r.length; i < o; i++)
        n = n.concat(r[i].controller.getAllParsedValues(t10));
      t10._cache.$bar = g1(n.sort((i, o) => i - o));
    }
    return t10._cache.$bar;
  }
  function Dv(t10) {
    const e = t10.iScale, r = Rv(e, t10.type);
    let n = e._length, i, o, s, a;
    const l = () => {
      s === 32767 || s === -32768 || (vo(a) && (n = Math.min(n, Math.abs(s - a) || n)), a = s);
    };
    for (i = 0, o = r.length; i < o; ++i)
      s = e.getPixelForValue(r[i]), l();
    for (a = void 0, i = 0, o = e.ticks.length; i < o; ++i)
      s = e.getPixelForTick(i), l();
    return n;
  }
  function Mv(t10, e, r, n) {
    const i = r.barThickness;
    let o, s;
    return Re(i) ? (o = e.min * r.categoryPercentage, s = r.barPercentage) : (o = i * n, s = 1), {
      chunk: o / n,
      ratio: s,
      start: e.pixels[t10] - o / 2
    };
  }
  function Nv(t10, e, r, n) {
    const i = e.pixels, o = i[t10];
    let s = t10 > 0 ? i[t10 - 1] : null, a = t10 < i.length - 1 ? i[t10 + 1] : null;
    const l = r.categoryPercentage;
    s === null && (s = o - (a === null ? e.end - e.start : a - o)), a === null && (a = o + o - s);
    const c = o - (o - Math.min(s, a)) / 2 * l;
    return {
      chunk: Math.abs(a - s) / 2 * l / n,
      ratio: r.barPercentage,
      start: c
    };
  }
  function Lv(t10, e, r, n) {
    const i = r.parse(t10[0], n), o = r.parse(t10[1], n), s = Math.min(i, o), a = Math.max(i, o);
    let l = s, c = a;
    Math.abs(s) > Math.abs(a) && (l = a, c = s), e[r.axis] = c, e._custom = {
      barStart: l,
      barEnd: c,
      start: i,
      end: o,
      min: s,
      max: a
    };
  }
  function B1(t10, e, r, n) {
    return Ge(t10) ? Lv(t10, e, r, n) : e[r.axis] = r.parse(t10, n), e;
  }
  function Hd(t10, e, r, n) {
    const i = t10.iScale, o = t10.vScale, s = i.getLabels(), a = i === o, l = [];
    let c, u, f, d;
    for (c = r, u = r + n; c < u; ++c)
      d = e[c], f = {}, f[i.axis] = a || i.parse(s[c], c), l.push(B1(d, f, o, c));
    return l;
  }
  function Dl(t10) {
    return t10 && t10.barStart !== void 0 && t10.barEnd !== void 0;
  }
  function Bv(t10, e, r) {
    return t10 !== 0 ? vr(t10) : (e.isHorizontal() ? 1 : -1) * (e.min >= r ? 1 : -1);
  }
  function Fv(t10) {
    let e, r, n, i, o;
    return t10.horizontal ? (e = t10.base > t10.x, r = "left", n = "right") : (e = t10.base < t10.y, r = "bottom", n = "top"), e ? (i = "end", o = "start") : (i = "start", o = "end"), {
      start: r,
      end: n,
      reverse: e,
      top: i,
      bottom: o
    };
  }
  function jv(t10, e, r, n) {
    let i = e.borderSkipped;
    const o = {};
    if (!i) {
      t10.borderSkipped = o;
      return;
    }
    if (i === true) {
      t10.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start: s, end: a, reverse: l, top: c, bottom: u } = Fv(t10);
    i === "middle" && r && (t10.enableBorderRadius = true, (r._top || 0) === n ? i = c : (r._bottom || 0) === n ? i = u : (o[Kd(u, s, a, l)] = true, i = c)), o[Kd(i, s, a, l)] = true, t10.borderSkipped = o;
  }
  function Kd(t10, e, r, n) {
    return n ? (t10 = Wv(t10, e, r), t10 = Yd(t10, r, e)) : t10 = Yd(t10, e, r), t10;
  }
  function Wv(t10, e, r) {
    return t10 === e ? r : t10 === r ? e : t10;
  }
  function Yd(t10, e, r) {
    return t10 === "start" ? e : t10 === "end" ? r : t10;
  }
  function Uv(t10, { inflateAmount: e }, r) {
    t10.inflateAmount = e === "auto" ? r === 1 ? 0.33 : 0 : e;
  }
  class Ts extends lr {
    parsePrimitiveData(e, r, n, i) {
      return Hd(e, r, n, i);
    }
    parseArrayData(e, r, n, i) {
      return Hd(e, r, n, i);
    }
    parseObjectData(e, r, n, i) {
      const { iScale: o, vScale: s } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? a : l, u = s.axis === "x" ? a : l, f = [];
      let d, h, g, p;
      for (d = n, h = n + i; d < h; ++d)
        p = r[d], g = {}, g[o.axis] = o.parse(sn(p, c), d), f.push(B1(sn(p, u), g, s, d));
      return f;
    }
    updateRangeFromParsed(e, r, n, i) {
      super.updateRangeFromParsed(e, r, n, i);
      const o = n._custom;
      o && r === this._cachedMeta.vScale && (e.min = Math.min(e.min, o.min), e.max = Math.max(e.max, o.max));
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, { iScale: n, vScale: i } = r, o = this.getParsed(e), s = o._custom, a = Dl(s) ? "[" + s.start + ", " + s.end + "]" : "" + i.getLabelForValue(o[i.axis]);
      return {
        label: "" + n.getLabelForValue(o[n.axis]),
        value: a
      };
    }
    initialize() {
      this.enableOptionSharing = true, super.initialize();
      const e = this._cachedMeta;
      e.stack = this.getDataset().stack;
    }
    update(e) {
      const r = this._cachedMeta;
      this.updateElements(r.data, 0, r.data.length, e);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { index: s, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: f, includeOptions: d } = this._getSharedOptions(r, i);
      for (let h = r; h < r + n; h++) {
        const g = this.getParsed(h), p = o || Re(g[a.axis]) ? {
          base: l,
          head: l
        } : this._calculateBarValuePixels(h), y = this._calculateBarIndexPixels(h, u), b = (g._stacks || {})[a.axis], x = {
          horizontal: c,
          base: p.base,
          enableBorderRadius: !b || Dl(g._custom) || s === b._top || s === b._bottom,
          x: c ? p.head : y.center,
          y: c ? y.center : p.head,
          height: c ? y.size : Math.abs(p.size),
          width: c ? Math.abs(p.size) : y.size
        };
        d && (x.options = f || this.resolveDataElementOptions(h, e[h].active ? "active" : i));
        const S = x.options || e[h].options;
        jv(x, S, b, s), Uv(x, S, u.ratio), this.updateElement(e[h], h, x, i);
      }
    }
    _getStacks(e, r) {
      const { iScale: n } = this._cachedMeta, i = n.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped), o = n.options.stacked, s = [], a = (l) => {
        const c = l.controller.getParsed(r), u = c && c[l.vScale.axis];
        if (Re(u) || isNaN(u))
          return true;
      };
      for (const l of i)
        if (!(r !== void 0 && a(l)) && ((o === false || s.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && s.push(l.stack), l.index === e))
          break;
      return s.length || s.push(void 0), s;
    }
    _getStackCount(e) {
      return this._getStacks(void 0, e).length;
    }
    _getStackIndex(e, r, n) {
      const i = this._getStacks(e, n), o = r !== void 0 ? i.indexOf(r) : -1;
      return o === -1 ? i.length - 1 : o;
    }
    _getRuler() {
      const e = this.options, r = this._cachedMeta, n = r.iScale, i = [];
      let o, s;
      for (o = 0, s = r.data.length; o < s; ++o)
        i.push(n.getPixelForValue(this.getParsed(o)[n.axis], o));
      const a = e.barThickness;
      return {
        min: a || Dv(r),
        pixels: i,
        start: n._startPixel,
        end: n._endPixel,
        stackCount: this._getStackCount(),
        scale: n,
        grouped: e.grouped,
        ratio: a ? 1 : e.categoryPercentage * e.barPercentage
      };
    }
    _calculateBarValuePixels(e) {
      const { _cachedMeta: { vScale: r, _stacked: n, index: i }, options: { base: o, minBarLength: s } } = this, a = o || 0, l = this.getParsed(e), c = l._custom, u = Dl(c);
      let f = l[r.axis], d = 0, h = n ? this.applyStack(r, l, n) : f, g, p;
      h !== f && (d = h - f, h = f), u && (f = c.barStart, h = c.barEnd - c.barStart, f !== 0 && vr(f) !== vr(c.barEnd) && (d = 0), d += f);
      const y = !Re(o) && !u ? o : d;
      let b = r.getPixelForValue(y);
      if (this.chart.getDataVisibility(e) ? g = r.getPixelForValue(d + h) : g = b, p = g - b, Math.abs(p) < s) {
        p = Bv(p, r, a) * s, f === a && (b -= p / 2);
        const x = r.getPixelForDecimal(0), S = r.getPixelForDecimal(1), C = Math.min(x, S), _ = Math.max(x, S);
        b = Math.max(Math.min(b, _), C), g = b + p, n && !u && (l._stacks[r.axis]._visualValues[i] = r.getValueForPixel(g) - r.getValueForPixel(b));
      }
      if (b === r.getPixelForValue(a)) {
        const x = vr(p) * r.getLineWidthForValue(a) / 2;
        b += x, p -= x;
      }
      return {
        size: p,
        base: b,
        head: g,
        center: g + p / 2
      };
    }
    _calculateBarIndexPixels(e, r) {
      const n = r.scale, i = this.options, o = i.skipNull, s = ke(i.maxBarThickness, 1 / 0);
      let a, l;
      if (r.grouped) {
        const c = o ? this._getStackCount(e) : r.stackCount, u = i.barThickness === "flex" ? Nv(e, r, i, c) : Mv(e, r, i, c), f = this._getStackIndex(this.index, this._cachedMeta.stack, o ? e : void 0);
        a = u.start + u.chunk * f + u.chunk / 2, l = Math.min(s, u.chunk * u.ratio);
      } else
        a = n.getPixelForValue(this.getParsed(e)[n.axis], e), l = Math.min(s, r.min * r.ratio);
      return {
        base: a - l / 2,
        head: a + l / 2,
        center: a,
        size: l
      };
    }
    draw() {
      const e = this._cachedMeta, r = e.vScale, n = e.data, i = n.length;
      let o = 0;
      for (; o < i; ++o)
        this.getParsed(o)[r.axis] !== null && n[o].draw(this._ctx);
    }
  }
  ge(Ts, "id", "bar"), ge(Ts, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  }), ge(Ts, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  class Is extends lr {
    initialize() {
      this.enableOptionSharing = true, super.initialize();
    }
    parsePrimitiveData(e, r, n, i) {
      const o = super.parsePrimitiveData(e, r, n, i);
      for (let s = 0; s < o.length; s++)
        o[s]._custom = this.resolveDataElementOptions(s + n).radius;
      return o;
    }
    parseArrayData(e, r, n, i) {
      const o = super.parseArrayData(e, r, n, i);
      for (let s = 0; s < o.length; s++) {
        const a = r[n + s];
        o[s]._custom = ke(a[2], this.resolveDataElementOptions(s + n).radius);
      }
      return o;
    }
    parseObjectData(e, r, n, i) {
      const o = super.parseObjectData(e, r, n, i);
      for (let s = 0; s < o.length; s++) {
        const a = r[n + s];
        o[s]._custom = ke(a && a.r && +a.r, this.resolveDataElementOptions(s + n).radius);
      }
      return o;
    }
    getMaxOverflow() {
      const e = this._cachedMeta.data;
      let r = 0;
      for (let n = e.length - 1; n >= 0; --n)
        r = Math.max(r, e[n].size(this.resolveDataElementOptions(n)) / 2);
      return r > 0 && r;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart.data.labels || [], { xScale: i, yScale: o } = r, s = this.getParsed(e), a = i.getLabelForValue(s.x), l = o.getLabelForValue(s.y), c = s._custom;
      return {
        label: n[e] || "",
        value: "(" + a + ", " + l + (c ? ", " + c : "") + ")"
      };
    }
    update(e) {
      const r = this._cachedMeta.data;
      this.updateElements(r, 0, r.length, e);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { iScale: s, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(r, i), u = s.axis, f = a.axis;
      for (let d = r; d < r + n; d++) {
        const h = e[d], g = !o && this.getParsed(d), p = {}, y = p[u] = o ? s.getPixelForDecimal(0.5) : s.getPixelForValue(g[u]), b = p[f] = o ? a.getBasePixel() : a.getPixelForValue(g[f]);
        p.skip = isNaN(y) || isNaN(b), c && (p.options = l || this.resolveDataElementOptions(d, h.active ? "active" : i), o && (p.options.radius = 0)), this.updateElement(h, d, p, i);
      }
    }
    resolveDataElementOptions(e, r) {
      const n = this.getParsed(e);
      let i = super.resolveDataElementOptions(e, r);
      i.$shared && (i = Object.assign({}, i, {
        $shared: false
      }));
      const o = i.radius;
      return r !== "active" && (i.radius = 0), i.radius += ke(n && n._custom, o), i;
    }
  }
  ge(Is, "id", "bubble"), ge(Is, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  }), ge(Is, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function zv(t10, e, r) {
    let n = 1, i = 1, o = 0, s = 0;
    if (e < Ze) {
      const a = t10, l = a + e, c = Math.cos(a), u = Math.sin(a), f = Math.cos(l), d = Math.sin(l), h = (S, C, _) => Ao(S, a, l, true) ? 1 : Math.max(C, C * r, _, _ * r), g = (S, C, _) => Ao(S, a, l, true) ? -1 : Math.min(C, C * r, _, _ * r), p = h(0, c, f), y = h(at, u, d), b = g($e, c, f), x = g($e + at, u, d);
      n = (p - b) / 2, i = (y - x) / 2, o = -(p + b) / 2, s = -(y + x) / 2;
    }
    return {
      ratioX: n,
      ratioY: i,
      offsetX: o,
      offsetY: s
    };
  }
  class Cn extends lr {
    constructor(e, r) {
      super(e, r), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(e, r) {
      const n = this.getDataset().data, i = this._cachedMeta;
      if (this._parsing === false)
        i._parsed = n;
      else {
        let o = (l) => +n[l];
        if (Ie(n[e])) {
          const { key: l = "value" } = this._parsing;
          o = (c) => +sn(n[c], l);
        }
        let s, a;
        for (s = e, a = e + r; s < a; ++s)
          i._parsed[s] = o(s);
      }
    }
    _getRotation() {
      return sr(this.options.rotation - 90);
    }
    _getCircumference() {
      return sr(this.options.circumference);
    }
    _getRotationExtents() {
      let e = Ze, r = -Ze;
      for (let n = 0; n < this.chart.data.datasets.length; ++n)
        if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
          const i = this.chart.getDatasetMeta(n).controller, o = i._getRotation(), s = i._getCircumference();
          e = Math.min(e, o), r = Math.max(r, o + s);
        }
      return {
        rotation: e,
        circumference: r - e
      };
    }
    update(e) {
      const r = this.chart, { chartArea: n } = r, i = this._cachedMeta, o = i.data, s = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, a = Math.max((Math.min(n.width, n.height) - s) / 2, 0), l = Math.min(r2(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: f } = this._getRotationExtents(), { ratioX: d, ratioY: h, offsetX: g, offsetY: p } = zv(f, u, l), y = (n.width - s) / d, b = (n.height - s) / h, x = Math.max(Math.min(y, b) / 2, 0), S = u1(this.options.radius, x), C = Math.max(S * l, 0), _ = (S - C) / this._getVisibleDatasetWeightTotal();
      this.offsetX = g * S, this.offsetY = p * S, i.total = this.calculateTotal(), this.outerRadius = S - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(o, 0, o.length, e);
    }
    _circumference(e, r) {
      const n = this.options, i = this._cachedMeta, o = this._getCircumference();
      return r && n.animation.animateRotate || !this.chart.getDataVisibility(e) || i._parsed[e] === null || i.data[e].hidden ? 0 : this.calculateCircumference(i._parsed[e] * o / Ze);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", s = this.chart, a = s.chartArea, c = s.options.animation, u = (a.left + a.right) / 2, f = (a.top + a.bottom) / 2, d = o && c.animateScale, h = d ? 0 : this.innerRadius, g = d ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: y } = this._getSharedOptions(r, i);
      let b = this._getRotation(), x;
      for (x = 0; x < r; ++x)
        b += this._circumference(x, o);
      for (x = r; x < r + n; ++x) {
        const S = this._circumference(x, o), C = e[x], _ = {
          x: u + this.offsetX,
          y: f + this.offsetY,
          startAngle: b,
          endAngle: b + S,
          circumference: S,
          outerRadius: g,
          innerRadius: h
        };
        y && (_.options = p || this.resolveDataElementOptions(x, C.active ? "active" : i)), b += S, this.updateElement(C, x, _, i);
      }
    }
    calculateTotal() {
      const e = this._cachedMeta, r = e.data;
      let n = 0, i;
      for (i = 0; i < r.length; i++) {
        const o = e._parsed[i];
        o !== null && !isNaN(o) && this.chart.getDataVisibility(i) && !r[i].hidden && (n += Math.abs(o));
      }
      return n;
    }
    calculateCircumference(e) {
      const r = this._cachedMeta.total;
      return r > 0 && !isNaN(e) ? Ze * (Math.abs(e) / r) : 0;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart, i = n.data.labels || [], o = jo(r._parsed[e], n.options.locale);
      return {
        label: i[e] || "",
        value: o
      };
    }
    getMaxBorderWidth(e) {
      let r = 0;
      const n = this.chart;
      let i, o, s, a, l;
      if (!e) {
        for (i = 0, o = n.data.datasets.length; i < o; ++i)
          if (n.isDatasetVisible(i)) {
            s = n.getDatasetMeta(i), e = s.data, a = s.controller;
            break;
          }
      }
      if (!e)
        return 0;
      for (i = 0, o = e.length; i < o; ++i)
        l = a.resolveDataElementOptions(i), l.borderAlign !== "inner" && (r = Math.max(r, l.borderWidth || 0, l.hoverBorderWidth || 0));
      return r;
    }
    getMaxOffset(e) {
      let r = 0;
      for (let n = 0, i = e.length; n < i; ++n) {
        const o = this.resolveDataElementOptions(n);
        r = Math.max(r, o.offset || 0, o.hoverOffset || 0);
      }
      return r;
    }
    _getRingWeightOffset(e) {
      let r = 0;
      for (let n = 0; n < e; ++n)
        this.chart.isDatasetVisible(n) && (r += this._getRingWeight(n));
      return r;
    }
    _getRingWeight(e) {
      return Math.max(ke(this.chart.data.datasets[e].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  }
  ge(Cn, "id", "doughnut"), ge(Cn, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  }), ge(Cn, "descriptors", {
    _scriptable: (e) => e !== "spacing",
    _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
  }), ge(Cn, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(e) {
            const r = e.data;
            if (r.labels.length && r.datasets.length) {
              const { labels: { pointStyle: n, color: i } } = e.legend.options;
              return r.labels.map((o, s) => {
                const l = e.getDatasetMeta(0).controller.getStyle(s);
                return {
                  text: o,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: i,
                  lineWidth: l.borderWidth,
                  pointStyle: n,
                  hidden: !e.getDataVisibility(s),
                  index: s
                };
              });
            }
            return [];
          }
        },
        onClick(e, r, n) {
          n.chart.toggleDataVisibility(r.index), n.chart.update();
        }
      }
    }
  });
  class Os extends lr {
    initialize() {
      this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
    }
    update(e) {
      const r = this._cachedMeta, { dataset: n, data: i = [], _dataset: o } = r, s = this.chart._animationsDisabled;
      let { start: a, count: l } = b1(r, i, s);
      this._drawStart = a, this._drawCount = l, v1(r) && (a = 0, l = i.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;
      const c = this.resolveDatasetElementOptions(e);
      this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(n, void 0, {
        animated: !s,
        options: c
      }, e), this.updateElements(i, a, l, e);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { iScale: s, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: f } = this._getSharedOptions(r, i), d = s.axis, h = a.axis, { spanGaps: g, segment: p } = this.options, y = pi(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || i === "none", x = r + n, S = e.length;
      let C = r > 0 && this.getParsed(r - 1);
      for (let _ = 0; _ < S; ++_) {
        const L = e[_], F = b ? L : {};
        if (_ < r || _ >= x) {
          F.skip = true;
          continue;
        }
        const V = this.getParsed(_), W = Re(V[h]), X = F[d] = s.getPixelForValue(V[d], _), G = F[h] = o || W ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, V, l) : V[h], _);
        F.skip = isNaN(X) || isNaN(G) || W, F.stop = _ > 0 && Math.abs(V[d] - C[d]) > y, p && (F.parsed = V, F.raw = c.data[_]), f && (F.options = u || this.resolveDataElementOptions(_, L.active ? "active" : i)), b || this.updateElement(L, _, F, i), C = V;
      }
    }
    getMaxOverflow() {
      const e = this._cachedMeta, r = e.dataset, n = r.options && r.options.borderWidth || 0, i = e.data || [];
      if (!i.length)
        return n;
      const o = i[0].size(this.resolveDataElementOptions(0)), s = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
      return Math.max(n, o, s) / 2;
    }
    draw() {
      const e = this._cachedMeta;
      e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
    }
  }
  ge(Os, "id", "line"), ge(Os, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  }), ge(Os, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  class lo extends lr {
    constructor(e, r) {
      super(e, r), this.innerRadius = void 0, this.outerRadius = void 0;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart, i = n.data.labels || [], o = jo(r._parsed[e].r, n.options.locale);
      return {
        label: i[e] || "",
        value: o
      };
    }
    parseObjectData(e, r, n, i) {
      return C1.bind(this)(e, r, n, i);
    }
    update(e) {
      const r = this._cachedMeta.data;
      this._updateRadius(), this.updateElements(r, 0, r.length, e);
    }
    getMinMax() {
      const e = this._cachedMeta, r = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      return e.data.forEach((n, i) => {
        const o = this.getParsed(i).r;
        !isNaN(o) && this.chart.getDataVisibility(i) && (o < r.min && (r.min = o), o > r.max && (r.max = o));
      }), r;
    }
    _updateRadius() {
      const e = this.chart, r = e.chartArea, n = e.options, i = Math.min(r.right - r.left, r.bottom - r.top), o = Math.max(i / 2, 0), s = Math.max(n.cutoutPercentage ? o / 100 * n.cutoutPercentage : 1, 0), a = (o - s) / e.getVisibleDatasetCount();
      this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", s = this.chart, l = s.options.animation, c = this._cachedMeta.rScale, u = c.xCenter, f = c.yCenter, d = c.getIndexAngle(0) - 0.5 * $e;
      let h = d, g;
      const p = 360 / this.countVisibleElements();
      for (g = 0; g < r; ++g)
        h += this._computeAngle(g, i, p);
      for (g = r; g < r + n; g++) {
        const y = e[g];
        let b = h, x = h + this._computeAngle(g, i, p), S = s.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;
        h = x, o && (l.animateScale && (S = 0), l.animateRotate && (b = x = d));
        const C = {
          x: u,
          y: f,
          innerRadius: 0,
          outerRadius: S,
          startAngle: b,
          endAngle: x,
          options: this.resolveDataElementOptions(g, y.active ? "active" : i)
        };
        this.updateElement(y, g, C, i);
      }
    }
    countVisibleElements() {
      const e = this._cachedMeta;
      let r = 0;
      return e.data.forEach((n, i) => {
        !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && r++;
      }), r;
    }
    _computeAngle(e, r, n) {
      return this.chart.getDataVisibility(e) ? sr(this.resolveDataElementOptions(e, r).angle || n) : 0;
    }
  }
  ge(lo, "id", "polarArea"), ge(lo, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  }), ge(lo, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(e) {
            const r = e.data;
            if (r.labels.length && r.datasets.length) {
              const { labels: { pointStyle: n, color: i } } = e.legend.options;
              return r.labels.map((o, s) => {
                const l = e.getDatasetMeta(0).controller.getStyle(s);
                return {
                  text: o,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: i,
                  lineWidth: l.borderWidth,
                  pointStyle: n,
                  hidden: !e.getDataVisibility(s),
                  index: s
                };
              });
            }
            return [];
          }
        },
        onClick(e, r, n) {
          n.chart.toggleDataVisibility(r.index), n.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  class Ec extends Cn {
  }
  ge(Ec, "id", "pie"), ge(Ec, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  class Ps extends lr {
    getLabelAndValue(e) {
      const r = this._cachedMeta.vScale, n = this.getParsed(e);
      return {
        label: r.getLabels()[e],
        value: "" + r.getLabelForValue(n[r.axis])
      };
    }
    parseObjectData(e, r, n, i) {
      return C1.bind(this)(e, r, n, i);
    }
    update(e) {
      const r = this._cachedMeta, n = r.dataset, i = r.data || [], o = r.iScale.getLabels();
      if (n.points = i, e !== "resize") {
        const s = this.resolveDatasetElementOptions(e);
        this.options.showLine || (s.borderWidth = 0);
        const a = {
          _loop: true,
          _fullLoop: o.length === i.length,
          options: s
        };
        this.updateElement(n, void 0, a, e);
      }
      this.updateElements(i, 0, i.length, e);
    }
    updateElements(e, r, n, i) {
      const o = this._cachedMeta.rScale, s = i === "reset";
      for (let a = r; a < r + n; a++) {
        const l = e[a], c = this.resolveDataElementOptions(a, l.active ? "active" : i), u = o.getPointPositionForValue(a, this.getParsed(a).r), f = s ? o.xCenter : u.x, d = s ? o.yCenter : u.y, h = {
          x: f,
          y: d,
          angle: u.angle,
          skip: isNaN(f) || isNaN(d),
          options: c
        };
        this.updateElement(l, a, h, i);
      }
    }
  }
  ge(Ps, "id", "radar"), ge(Ps, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  }), ge(Ps, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  class Rs extends lr {
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart.data.labels || [], { xScale: i, yScale: o } = r, s = this.getParsed(e), a = i.getLabelForValue(s.x), l = o.getLabelForValue(s.y);
      return {
        label: n[e] || "",
        value: "(" + a + ", " + l + ")"
      };
    }
    update(e) {
      const r = this._cachedMeta, { data: n = [] } = r, i = this.chart._animationsDisabled;
      let { start: o, count: s } = b1(r, n, i);
      if (this._drawStart = o, this._drawCount = s, v1(r) && (o = 0, s = n.length), this.options.showLine) {
        this.datasetElementType || this.addElements();
        const { dataset: a, _dataset: l } = r;
        a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = n;
        const c = this.resolveDatasetElementOptions(e);
        c.segment = this.options.segment, this.updateElement(a, void 0, {
          animated: !i,
          options: c
        }, e);
      } else
        this.datasetElementType && (delete r.dataset, this.datasetElementType = false);
      this.updateElements(n, o, s, e);
    }
    addElements() {
      const { showLine: e } = this.options;
      !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { iScale: s, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, u = this.resolveDataElementOptions(r, i), f = this.getSharedOptions(u), d = this.includeOptions(i, f), h = s.axis, g = a.axis, { spanGaps: p, segment: y } = this.options, b = pi(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || i === "none";
      let S = r > 0 && this.getParsed(r - 1);
      for (let C = r; C < r + n; ++C) {
        const _ = e[C], L = this.getParsed(C), F = x ? _ : {}, V = Re(L[g]), W = F[h] = s.getPixelForValue(L[h], C), X = F[g] = o || V ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, L, l) : L[g], C);
        F.skip = isNaN(W) || isNaN(X) || V, F.stop = C > 0 && Math.abs(L[h] - S[h]) > b, y && (F.parsed = L, F.raw = c.data[C]), d && (F.options = f || this.resolveDataElementOptions(C, _.active ? "active" : i)), x || this.updateElement(_, C, F, i), S = L;
      }
      this.updateSharedOptions(f, i, u);
    }
    getMaxOverflow() {
      const e = this._cachedMeta, r = e.data || [];
      if (!this.options.showLine) {
        let a = 0;
        for (let l = r.length - 1; l >= 0; --l)
          a = Math.max(a, r[l].size(this.resolveDataElementOptions(l)) / 2);
        return a > 0 && a;
      }
      const n = e.dataset, i = n.options && n.options.borderWidth || 0;
      if (!r.length)
        return i;
      const o = r[0].size(this.resolveDataElementOptions(0)), s = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
      return Math.max(i, o, s) / 2;
    }
  }
  ge(Rs, "id", "scatter"), ge(Rs, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  }), ge(Rs, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var Vv = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController: Ts,
    BubbleController: Is,
    DoughnutController: Cn,
    LineController: Os,
    PieController: Ec,
    PolarAreaController: lo,
    RadarController: Ps,
    ScatterController: Rs
  });
  function bn() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  class Bu {
    constructor(e) {
      ge(this, "options");
      this.options = e || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(e) {
      Object.assign(Bu.prototype, e);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return bn();
    }
    parse() {
      return bn();
    }
    format() {
      return bn();
    }
    add() {
      return bn();
    }
    diff() {
      return bn();
    }
    startOf() {
      return bn();
    }
    endOf() {
      return bn();
    }
  }
  var qv = {
    _date: Bu
  };
  function Hv(t10, e, r, n) {
    const { controller: i, data: o, _sorted: s } = t10, a = i._cachedMeta.iScale;
    if (a && e === a.axis && e !== "r" && s && o.length) {
      const l = a._reversePixels ? p2 : Dr;
      if (n) {
        if (i._sharedOptions) {
          const c = o[0], u = typeof c.getRange == "function" && c.getRange(e);
          if (u) {
            const f = l(o, e, r - u), d = l(o, e, r + u);
            return {
              lo: f.lo,
              hi: d.hi
            };
          }
        }
      } else
        return l(o, e, r);
    }
    return {
      lo: 0,
      hi: o.length - 1
    };
  }
  function Wo(t10, e, r, n, i) {
    const o = t10.getSortedVisibleDatasetMetas(), s = r[e];
    for (let a = 0, l = o.length; a < l; ++a) {
      const { index: c, data: u } = o[a], { lo: f, hi: d } = Hv(o[a], e, s, i);
      for (let h = f; h <= d; ++h) {
        const g = u[h];
        g.skip || n(g, c, h);
      }
    }
  }
  function Kv(t10) {
    const e = t10.indexOf("x") !== -1, r = t10.indexOf("y") !== -1;
    return function(n, i) {
      const o = e ? Math.abs(n.x - i.x) : 0, s = r ? Math.abs(n.y - i.y) : 0;
      return Math.sqrt(Math.pow(o, 2) + Math.pow(s, 2));
    };
  }
  function Ml(t10, e, r, n, i) {
    const o = [];
    return !i && !t10.isPointInArea(e) || Wo(t10, r, e, function(a, l, c) {
      !i && !Mr(a, t10.chartArea, 0) || a.inRange(e.x, e.y, n) && o.push({
        element: a,
        datasetIndex: l,
        index: c
      });
    }, true), o;
  }
  function Yv(t10, e, r, n) {
    let i = [];
    function o(s, a, l) {
      const { startAngle: c, endAngle: u } = s.getProps([
        "startAngle",
        "endAngle"
      ], n), { angle: f } = h1(s, {
        x: e.x,
        y: e.y
      });
      Ao(f, c, u) && i.push({
        element: s,
        datasetIndex: a,
        index: l
      });
    }
    return Wo(t10, r, e, o), i;
  }
  function Xv(t10, e, r, n, i, o) {
    let s = [];
    const a = Kv(r);
    let l = Number.POSITIVE_INFINITY;
    function c(u, f, d) {
      const h = u.inRange(e.x, e.y, i);
      if (n && !h)
        return;
      const g = u.getCenterPoint(i);
      if (!(!!o || t10.isPointInArea(g)) && !h)
        return;
      const y = a(e, g);
      y < l ? (s = [
        {
          element: u,
          datasetIndex: f,
          index: d
        }
      ], l = y) : y === l && s.push({
        element: u,
        datasetIndex: f,
        index: d
      });
    }
    return Wo(t10, r, e, c), s;
  }
  function Nl(t10, e, r, n, i, o) {
    return !o && !t10.isPointInArea(e) ? [] : r === "r" && !n ? Yv(t10, e, r, i) : Xv(t10, e, r, n, i, o);
  }
  function Xd(t10, e, r, n, i) {
    const o = [], s = r === "x" ? "inXRange" : "inYRange";
    let a = false;
    return Wo(t10, r, e, (l, c, u) => {
      l[s](e[r], i) && (o.push({
        element: l,
        datasetIndex: c,
        index: u
      }), a = a || l.inRange(e.x, e.y, i));
    }), n && !a ? [] : o;
  }
  var Jv = {
    modes: {
      index(t10, e, r, n) {
        const i = _n(e, t10), o = r.axis || "x", s = r.includeInvisible || false, a = r.intersect ? Ml(t10, i, o, n, s) : Nl(t10, i, o, false, n, s), l = [];
        return a.length ? (t10.getSortedVisibleDatasetMetas().forEach((c) => {
          const u = a[0].index, f = c.data[u];
          f && !f.skip && l.push({
            element: f,
            datasetIndex: c.index,
            index: u
          });
        }), l) : [];
      },
      dataset(t10, e, r, n) {
        const i = _n(e, t10), o = r.axis || "xy", s = r.includeInvisible || false;
        let a = r.intersect ? Ml(t10, i, o, n, s) : Nl(t10, i, o, false, n, s);
        if (a.length > 0) {
          const l = a[0].datasetIndex, c = t10.getDatasetMeta(l).data;
          a = [];
          for (let u = 0; u < c.length; ++u)
            a.push({
              element: c[u],
              datasetIndex: l,
              index: u
            });
        }
        return a;
      },
      point(t10, e, r, n) {
        const i = _n(e, t10), o = r.axis || "xy", s = r.includeInvisible || false;
        return Ml(t10, i, o, n, s);
      },
      nearest(t10, e, r, n) {
        const i = _n(e, t10), o = r.axis || "xy", s = r.includeInvisible || false;
        return Nl(t10, i, o, r.intersect, n, s);
      },
      x(t10, e, r, n) {
        const i = _n(e, t10);
        return Xd(t10, i, "x", r.intersect, n);
      },
      y(t10, e, r, n) {
        const i = _n(e, t10);
        return Xd(t10, i, "y", r.intersect, n);
      }
    }
  };
  const F1 = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function Ni(t10, e) {
    return t10.filter((r) => r.pos === e);
  }
  function Jd(t10, e) {
    return t10.filter((r) => F1.indexOf(r.pos) === -1 && r.box.axis === e);
  }
  function Li(t10, e) {
    return t10.sort((r, n) => {
      const i = e ? n : r, o = e ? r : n;
      return i.weight === o.weight ? i.index - o.index : i.weight - o.weight;
    });
  }
  function Qv(t10) {
    const e = [];
    let r, n, i, o, s, a;
    for (r = 0, n = (t10 || []).length; r < n; ++r)
      i = t10[r], { position: o, options: { stack: s, stackWeight: a = 1 } } = i, e.push({
        index: r,
        box: i,
        pos: o,
        horizontal: i.isHorizontal(),
        weight: i.weight,
        stack: s && o + s,
        stackWeight: a
      });
    return e;
  }
  function Gv(t10) {
    const e = {};
    for (const r of t10) {
      const { stack: n, pos: i, stackWeight: o } = r;
      if (!n || !F1.includes(i))
        continue;
      const s = e[n] || (e[n] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      s.count++, s.weight += o;
    }
    return e;
  }
  function Zv(t10, e) {
    const r = Gv(t10), { vBoxMaxWidth: n, hBoxMaxHeight: i } = e;
    let o, s, a;
    for (o = 0, s = t10.length; o < s; ++o) {
      a = t10[o];
      const { fullSize: l } = a.box, c = r[a.stack], u = c && a.stackWeight / c.weight;
      a.horizontal ? (a.width = u ? u * n : l && e.availableWidth, a.height = i) : (a.width = n, a.height = u ? u * i : l && e.availableHeight);
    }
    return r;
  }
  function $v(t10) {
    const e = Qv(t10), r = Li(e.filter((c) => c.box.fullSize), true), n = Li(Ni(e, "left"), true), i = Li(Ni(e, "right")), o = Li(Ni(e, "top"), true), s = Li(Ni(e, "bottom")), a = Jd(e, "x"), l = Jd(e, "y");
    return {
      fullSize: r,
      leftAndTop: n.concat(o),
      rightAndBottom: i.concat(l).concat(s).concat(a),
      chartArea: Ni(e, "chartArea"),
      vertical: n.concat(i).concat(l),
      horizontal: o.concat(s).concat(a)
    };
  }
  function Qd(t10, e, r, n) {
    return Math.max(t10[r], e[r]) + Math.max(t10[n], e[n]);
  }
  function j1(t10, e) {
    t10.top = Math.max(t10.top, e.top), t10.left = Math.max(t10.left, e.left), t10.bottom = Math.max(t10.bottom, e.bottom), t10.right = Math.max(t10.right, e.right);
  }
  function eA(t10, e, r, n) {
    const { pos: i, box: o } = r, s = t10.maxPadding;
    if (!Ie(i)) {
      r.size && (t10[i] -= r.size);
      const f = n[r.stack] || {
        size: 0,
        count: 1
      };
      f.size = Math.max(f.size, r.horizontal ? o.height : o.width), r.size = f.size / f.count, t10[i] += r.size;
    }
    o.getPadding && j1(s, o.getPadding());
    const a = Math.max(0, e.outerWidth - Qd(s, t10, "left", "right")), l = Math.max(0, e.outerHeight - Qd(s, t10, "top", "bottom")), c = a !== t10.w, u = l !== t10.h;
    return t10.w = a, t10.h = l, r.horizontal ? {
      same: c,
      other: u
    } : {
      same: u,
      other: c
    };
  }
  function tA(t10) {
    const e = t10.maxPadding;
    function r(n) {
      const i = Math.max(e[n] - t10[n], 0);
      return t10[n] += i, i;
    }
    t10.y += r("top"), t10.x += r("left"), r("right"), r("bottom");
  }
  function rA(t10, e) {
    const r = e.maxPadding;
    function n(i) {
      const o = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      return i.forEach((s) => {
        o[s] = Math.max(e[s], r[s]);
      }), o;
    }
    return n(t10 ? [
      "left",
      "right"
    ] : [
      "top",
      "bottom"
    ]);
  }
  function Ji(t10, e, r, n) {
    const i = [];
    let o, s, a, l, c, u;
    for (o = 0, s = t10.length, c = 0; o < s; ++o) {
      a = t10[o], l = a.box, l.update(a.width || e.w, a.height || e.h, rA(a.horizontal, e));
      const { same: f, other: d } = eA(e, r, a, n);
      c |= f && i.length, u = u || d, l.fullSize || i.push(a);
    }
    return c && Ji(i, e, r, n) || u;
  }
  function ss(t10, e, r, n, i) {
    t10.top = r, t10.left = e, t10.right = e + n, t10.bottom = r + i, t10.width = n, t10.height = i;
  }
  function Gd(t10, e, r, n) {
    const i = r.padding;
    let { x: o, y: s } = e;
    for (const a of t10) {
      const l = a.box, c = n[a.stack] || {
        placed: 0,
        weight: 1
      }, u = a.stackWeight / c.weight || 1;
      if (a.horizontal) {
        const f = e.w * u, d = c.size || l.height;
        vo(c.start) && (s = c.start), l.fullSize ? ss(l, i.left, s, r.outerWidth - i.right - i.left, d) : ss(l, e.left + c.placed, s, f, d), c.start = s, c.placed += f, s = l.bottom;
      } else {
        const f = e.h * u, d = c.size || l.width;
        vo(c.start) && (o = c.start), l.fullSize ? ss(l, o, i.top, d, r.outerHeight - i.bottom - i.top) : ss(l, o, e.top + c.placed, d, f), c.start = o, c.placed += f, o = l.right;
      }
    }
    e.x = o, e.y = s;
  }
  var _t = {
    addBox(t10, e) {
      t10.boxes || (t10.boxes = []), e.fullSize = e.fullSize || false, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
        return [
          {
            z: 0,
            draw(r) {
              e.draw(r);
            }
          }
        ];
      }, t10.boxes.push(e);
    },
    removeBox(t10, e) {
      const r = t10.boxes ? t10.boxes.indexOf(e) : -1;
      r !== -1 && t10.boxes.splice(r, 1);
    },
    configure(t10, e, r) {
      e.fullSize = r.fullSize, e.position = r.position, e.weight = r.weight;
    },
    update(t10, e, r, n) {
      if (!t10)
        return;
      const i = Et(t10.options.layout.padding), o = Math.max(e - i.width, 0), s = Math.max(r - i.height, 0), a = $v(t10.boxes), l = a.vertical, c = a.horizontal;
      Ve(t10.boxes, (p) => {
        typeof p.beforeLayout == "function" && p.beforeLayout();
      });
      const u = l.reduce((p, y) => y.box.options && y.box.options.display === false ? p : p + 1, 0) || 1, f = Object.freeze({
        outerWidth: e,
        outerHeight: r,
        padding: i,
        availableWidth: o,
        availableHeight: s,
        vBoxMaxWidth: o / 2 / u,
        hBoxMaxHeight: s / 2
      }), d = Object.assign({}, i);
      j1(d, Et(n));
      const h = Object.assign({
        maxPadding: d,
        w: o,
        h: s,
        x: i.left,
        y: i.top
      }, i), g = Zv(l.concat(c), f);
      Ji(a.fullSize, h, f, g), Ji(l, h, f, g), Ji(c, h, f, g) && Ji(l, h, f, g), tA(h), Gd(a.leftAndTop, h, f, g), h.x += h.w, h.y += h.h, Gd(a.rightAndBottom, h, f, g), t10.chartArea = {
        left: h.left,
        top: h.top,
        right: h.left + h.w,
        bottom: h.top + h.h,
        height: h.h,
        width: h.w
      }, Ve(a.chartArea, (p) => {
        const y = p.box;
        Object.assign(y, t10.chartArea), y.update(h.w, h.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  class W1 {
    acquireContext(e, r) {
    }
    releaseContext(e) {
      return false;
    }
    addEventListener(e, r, n) {
    }
    removeEventListener(e, r, n) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(e, r, n, i) {
      return r = Math.max(0, r || e.width), n = n || e.height, {
        width: r,
        height: Math.max(0, i ? Math.floor(r / i) : n)
      };
    }
    isAttached(e) {
      return true;
    }
    updateConfig(e) {
    }
  }
  class nA extends W1 {
    acquireContext(e) {
      return e && e.getContext && e.getContext("2d") || null;
    }
    updateConfig(e) {
      e.options.animation = false;
    }
  }
  const Ds = "$chartjs", iA = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  }, Zd = (t10) => t10 === null || t10 === "";
  function oA(t10, e) {
    const r = t10.style, n = t10.getAttribute("height"), i = t10.getAttribute("width");
    if (t10[Ds] = {
      initial: {
        height: n,
        width: i,
        style: {
          display: r.display,
          height: r.height,
          width: r.width
        }
      }
    }, r.display = r.display || "block", r.boxSizing = r.boxSizing || "border-box", Zd(i)) {
      const o = Md(t10, "width");
      o !== void 0 && (t10.width = o);
    }
    if (Zd(n))
      if (t10.style.height === "")
        t10.height = t10.width / (e || 2);
      else {
        const o = Md(t10, "height");
        o !== void 0 && (t10.height = o);
      }
    return t10;
  }
  const U1 = av ? {
    passive: true
  } : false;
  function sA(t10, e, r) {
    t10.addEventListener(e, r, U1);
  }
  function aA(t10, e, r) {
    t10.canvas.removeEventListener(e, r, U1);
  }
  function lA(t10, e) {
    const r = iA[t10.type] || t10.type, { x: n, y: i } = _n(t10, e);
    return {
      type: r,
      chart: e,
      native: t10,
      x: n !== void 0 ? n : null,
      y: i !== void 0 ? i : null
    };
  }
  function la(t10, e) {
    for (const r of t10)
      if (r === e || r.contains(e))
        return true;
  }
  function cA(t10, e, r) {
    const n = t10.canvas, i = new MutationObserver((o) => {
      let s = false;
      for (const a of o)
        s = s || la(a.addedNodes, n), s = s && !la(a.removedNodes, n);
      s && r();
    });
    return i.observe(document, {
      childList: true,
      subtree: true
    }), i;
  }
  function uA(t10, e, r) {
    const n = t10.canvas, i = new MutationObserver((o) => {
      let s = false;
      for (const a of o)
        s = s || la(a.removedNodes, n), s = s && !la(a.addedNodes, n);
      s && r();
    });
    return i.observe(document, {
      childList: true,
      subtree: true
    }), i;
  }
  const xo = /* @__PURE__ */ new Map();
  let $d = 0;
  function z1() {
    const t10 = window.devicePixelRatio;
    t10 !== $d && ($d = t10, xo.forEach((e, r) => {
      r.currentDevicePixelRatio !== t10 && e();
    }));
  }
  function fA(t10, e) {
    xo.size || window.addEventListener("resize", z1), xo.set(t10, e);
  }
  function dA(t10) {
    xo.delete(t10), xo.size || window.removeEventListener("resize", z1);
  }
  function hA(t10, e, r) {
    const n = t10.canvas, i = n && Lu(n);
    if (!i)
      return;
    const o = y1((a, l) => {
      const c = i.clientWidth;
      r(a, l), c < i.clientWidth && r();
    }, window), s = new ResizeObserver((a) => {
      const l = a[0], c = l.contentRect.width, u = l.contentRect.height;
      c === 0 && u === 0 || o(c, u);
    });
    return s.observe(i), fA(t10, o), s;
  }
  function Ll(t10, e, r) {
    r && r.disconnect(), e === "resize" && dA(t10);
  }
  function pA(t10, e, r) {
    const n = t10.canvas, i = y1((o) => {
      t10.ctx !== null && r(lA(o, t10));
    }, t10);
    return sA(n, e, i), i;
  }
  class gA extends W1 {
    acquireContext(e, r) {
      const n = e && e.getContext && e.getContext("2d");
      return n && n.canvas === e ? (oA(e, r), n) : null;
    }
    releaseContext(e) {
      const r = e.canvas;
      if (!r[Ds])
        return false;
      const n = r[Ds].initial;
      [
        "height",
        "width"
      ].forEach((o) => {
        const s = n[o];
        Re(s) ? r.removeAttribute(o) : r.setAttribute(o, s);
      });
      const i = n.style || {};
      return Object.keys(i).forEach((o) => {
        r.style[o] = i[o];
      }), r.width = r.width, delete r[Ds], true;
    }
    addEventListener(e, r, n) {
      this.removeEventListener(e, r);
      const i = e.$proxies || (e.$proxies = {}), s = {
        attach: cA,
        detach: uA,
        resize: hA
      }[r] || pA;
      i[r] = s(e, r, n);
    }
    removeEventListener(e, r) {
      const n = e.$proxies || (e.$proxies = {}), i = n[r];
      if (!i)
        return;
      ({
        attach: Ll,
        detach: Ll,
        resize: Ll
      }[r] || aA)(e, r, i), n[r] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(e, r, n, i) {
      return sv(e, r, n, i);
    }
    isAttached(e) {
      const r = Lu(e);
      return !!(r && r.isConnected);
    }
  }
  function mA(t10) {
    return !I1() || typeof OffscreenCanvas < "u" && t10 instanceof OffscreenCanvas ? nA : gA;
  }
  var Ss;
  let Ur = (Ss = class {
    constructor() {
      ge(this, "x");
      ge(this, "y");
      ge(this, "active", false);
      ge(this, "options");
      ge(this, "$animations");
    }
    tooltipPosition(e) {
      const { x: r, y: n } = this.getProps([
        "x",
        "y"
      ], e);
      return {
        x: r,
        y: n
      };
    }
    hasValue() {
      return pi(this.x) && pi(this.y);
    }
    getProps(e, r) {
      const n = this.$animations;
      if (!r || !n)
        return this;
      const i = {};
      return e.forEach((o) => {
        i[o] = n[o] && n[o].active() ? n[o]._to : this[o];
      }), i;
    }
  }, ge(Ss, "defaults", {}), ge(Ss, "defaultRoutes"), Ss);
  function yA(t10, e) {
    const r = t10.options.ticks, n = bA(t10), i = Math.min(r.maxTicksLimit || n, n), o = r.major.enabled ? AA(e) : [], s = o.length, a = o[0], l = o[s - 1], c = [];
    if (s > i)
      return wA(e, c, o, s / i), c;
    const u = vA(o, e, i);
    if (s > 0) {
      let f, d;
      const h = s > 1 ? Math.round((l - a) / (s - 1)) : null;
      for (as(e, c, u, Re(h) ? 0 : a - h, a), f = 0, d = s - 1; f < d; f++)
        as(e, c, u, o[f], o[f + 1]);
      return as(e, c, u, l, Re(h) ? e.length : l + h), c;
    }
    return as(e, c, u), c;
  }
  function bA(t10) {
    const e = t10.options.offset, r = t10._tickSize(), n = t10._length / r + (e ? 0 : 1), i = t10._maxLength / r;
    return Math.floor(Math.min(n, i));
  }
  function vA(t10, e, r) {
    const n = xA(t10), i = e.length / r;
    if (!n)
      return Math.max(i, 1);
    const o = u2(n);
    for (let s = 0, a = o.length - 1; s < a; s++) {
      const l = o[s];
      if (l > i)
        return l;
    }
    return Math.max(i, 1);
  }
  function AA(t10) {
    const e = [];
    let r, n;
    for (r = 0, n = t10.length; r < n; r++)
      t10[r].major && e.push(r);
    return e;
  }
  function wA(t10, e, r, n) {
    let i = 0, o = r[0], s;
    for (n = Math.ceil(n), s = 0; s < t10.length; s++)
      s === o && (e.push(t10[s]), i++, o = r[i * n]);
  }
  function as(t10, e, r, n, i) {
    const o = ke(n, 0), s = Math.min(ke(i, t10.length), t10.length);
    let a = 0, l, c, u;
    for (r = Math.ceil(r), i && (l = i - n, r = l / Math.floor(l / r)), u = o; u < 0; )
      a++, u = Math.round(o + a * r);
    for (c = Math.max(o, 0); c < s; c++)
      c === u && (e.push(t10[c]), a++, u = Math.round(o + a * r));
  }
  function xA(t10) {
    const e = t10.length;
    let r, n;
    if (e < 2)
      return false;
    for (n = t10[0], r = 1; r < e; ++r)
      if (t10[r] - t10[r - 1] !== n)
        return false;
    return n;
  }
  const _A = (t10) => t10 === "left" ? "right" : t10 === "right" ? "left" : t10, eh = (t10, e, r) => e === "top" || e === "left" ? t10[e] + r : t10[e] - r, th = (t10, e) => Math.min(e || t10, t10);
  function rh(t10, e) {
    const r = [], n = t10.length / e, i = t10.length;
    let o = 0;
    for (; o < i; o += n)
      r.push(t10[Math.floor(o)]);
    return r;
  }
  function SA(t10, e, r) {
    const n = t10.ticks.length, i = Math.min(e, n - 1), o = t10._startPixel, s = t10._endPixel, a = 1e-6;
    let l = t10.getPixelForTick(i), c;
    if (!(r && (n === 1 ? c = Math.max(l - o, s - l) : e === 0 ? c = (t10.getPixelForTick(1) - l) / 2 : c = (l - t10.getPixelForTick(i - 1)) / 2, l += i < e ? c : -c, l < o - a || l > s + a)))
      return l;
  }
  function EA(t10, e) {
    Ve(t10, (r) => {
      const n = r.gc, i = n.length / 2;
      let o;
      if (i > e) {
        for (o = 0; o < i; ++o)
          delete r.data[n[o]];
        n.splice(0, i);
      }
    });
  }
  function Bi(t10) {
    return t10.drawTicks ? t10.tickLength : 0;
  }
  function nh(t10, e) {
    if (!t10.display)
      return 0;
    const r = ft(t10.font, e), n = Et(t10.padding);
    return (Ge(t10.text) ? t10.text.length : 1) * r.lineHeight + n.height;
  }
  function kA(t10, e) {
    return fn(t10, {
      scale: e,
      type: "scale"
    });
  }
  function CA(t10, e, r) {
    return fn(t10, {
      tick: r,
      index: e,
      type: "tick"
    });
  }
  function TA(t10, e, r) {
    let n = Ou(t10);
    return (r && e !== "right" || !r && e === "right") && (n = _A(n)), n;
  }
  function IA(t10, e, r, n) {
    const { top: i, left: o, bottom: s, right: a, chart: l } = t10, { chartArea: c, scales: u } = l;
    let f = 0, d, h, g;
    const p = s - i, y = a - o;
    if (t10.isHorizontal()) {
      if (h = At(n, o, a), Ie(r)) {
        const b = Object.keys(r)[0], x = r[b];
        g = u[b].getPixelForValue(x) + p - e;
      } else
        r === "center" ? g = (c.bottom + c.top) / 2 + p - e : g = eh(t10, r, e);
      d = a - o;
    } else {
      if (Ie(r)) {
        const b = Object.keys(r)[0], x = r[b];
        h = u[b].getPixelForValue(x) - y + e;
      } else
        r === "center" ? h = (c.left + c.right) / 2 - y + e : h = eh(t10, r, e);
      g = At(n, s, i), f = r === "left" ? -at : at;
    }
    return {
      titleX: h,
      titleY: g,
      maxWidth: d,
      rotation: f
    };
  }
  class Vn extends Ur {
    constructor(e) {
      super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
    }
    init(e) {
      this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
    }
    parse(e, r) {
      return e;
    }
    getUserBounds() {
      let { _userMin: e, _userMax: r, _suggestedMin: n, _suggestedMax: i } = this;
      return e = Nt(e, Number.POSITIVE_INFINITY), r = Nt(r, Number.NEGATIVE_INFINITY), n = Nt(n, Number.POSITIVE_INFINITY), i = Nt(i, Number.NEGATIVE_INFINITY), {
        min: Nt(e, n),
        max: Nt(r, i),
        minDefined: ot(e),
        maxDefined: ot(r)
      };
    }
    getMinMax(e) {
      let { min: r, max: n, minDefined: i, maxDefined: o } = this.getUserBounds(), s;
      if (i && o)
        return {
          min: r,
          max: n
        };
      const a = this.getMatchingVisibleMetas();
      for (let l = 0, c = a.length; l < c; ++l)
        s = a[l].controller.getMinMax(this, e), i || (r = Math.min(r, s.min)), o || (n = Math.max(n, s.max));
      return r = o && r > n ? n : r, n = i && r > n ? r : n, {
        min: Nt(r, Nt(n, r)),
        max: Nt(n, Nt(r, n))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const e = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
    }
    getLabelItems(e = this.chart.chartArea) {
      return this._labelItems || (this._labelItems = this._computeLabelItems(e));
    }
    beforeLayout() {
      this._cache = {}, this._dataLimitsCached = false;
    }
    beforeUpdate() {
      Je(this.options.beforeUpdate, [
        this
      ]);
    }
    update(e, r, n) {
      const { beginAtZero: i, grace: o, ticks: s } = this.options, a = s.sampleSize;
      this.beforeUpdate(), this.maxWidth = e, this.maxHeight = r, this._margins = n = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = F2(this, o, i), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
      const l = a < this.ticks.length;
      this._convertTicksToLabels(l ? rh(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = yA(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
    }
    configure() {
      let e = this.options.reverse, r, n;
      this.isHorizontal() ? (r = this.left, n = this.right) : (r = this.top, n = this.bottom, e = !e), this._startPixel = r, this._endPixel = n, this._reversePixels = e, this._length = n - r, this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      Je(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      Je(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
    }
    afterSetDimensions() {
      Je(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(e) {
      this.chart.notifyPlugins(e, this.getContext()), Je(this.options[e], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      Je(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(e) {
      const r = this.options.ticks;
      let n, i, o;
      for (n = 0, i = e.length; n < i; n++)
        o = e[n], o.label = Je(r.callback, [
          o.value,
          n,
          e
        ], this);
    }
    afterTickToLabelConversion() {
      Je(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      Je(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const e = this.options, r = e.ticks, n = th(this.ticks.length, e.ticks.maxTicksLimit), i = r.minRotation || 0, o = r.maxRotation;
      let s = i, a, l, c;
      if (!this._isVisible() || !r.display || i >= o || n <= 1 || !this.isHorizontal()) {
        this.labelRotation = i;
        return;
      }
      const u = this._getLabelSizes(), f = u.widest.width, d = u.highest.height, h = ht(this.chart.width - f, 0, this.maxWidth);
      a = e.offset ? this.maxWidth / n : h / (n - 1), f + 6 > a && (a = h / (n - (e.offset ? 0.5 : 1)), l = this.maxHeight - Bi(e.grid) - r.padding - nh(e.title, this.chart.options.font), c = Math.sqrt(f * f + d * d), s = Tu(Math.min(Math.asin(ht((u.highest.height + 6) / a, -1, 1)), Math.asin(ht(l / c, -1, 1)) - Math.asin(ht(d / c, -1, 1)))), s = Math.max(i, Math.min(o, s))), this.labelRotation = s;
    }
    afterCalculateLabelRotation() {
      Je(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      Je(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const e = {
        width: 0,
        height: 0
      }, { chart: r, options: { ticks: n, title: i, grid: o } } = this, s = this._isVisible(), a = this.isHorizontal();
      if (s) {
        const l = nh(i, r.options.font);
        if (a ? (e.width = this.maxWidth, e.height = Bi(o) + l) : (e.height = this.maxHeight, e.width = Bi(o) + l), n.display && this.ticks.length) {
          const { first: c, last: u, widest: f, highest: d } = this._getLabelSizes(), h = n.padding * 2, g = sr(this.labelRotation), p = Math.cos(g), y = Math.sin(g);
          if (a) {
            const b = n.mirror ? 0 : y * f.width + p * d.height;
            e.height = Math.min(this.maxHeight, e.height + b + h);
          } else {
            const b = n.mirror ? 0 : p * f.width + y * d.height;
            e.width = Math.min(this.maxWidth, e.width + b + h);
          }
          this._calculatePadding(c, u, y, p);
        }
      }
      this._handleMargins(), a ? (this.width = this._length = r.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = r.height - this._margins.top - this._margins.bottom);
    }
    _calculatePadding(e, r, n, i) {
      const { ticks: { align: o, padding: s }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const u = this.getPixelForTick(0) - this.left, f = this.right - this.getPixelForTick(this.ticks.length - 1);
        let d = 0, h = 0;
        l ? c ? (d = i * e.width, h = n * r.height) : (d = n * e.height, h = i * r.width) : o === "start" ? h = r.width : o === "end" ? d = e.width : o !== "inner" && (d = e.width / 2, h = r.width / 2), this.paddingLeft = Math.max((d - u + s) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - f + s) * this.width / (this.width - f), 0);
      } else {
        let u = r.height / 2, f = e.height / 2;
        o === "start" ? (u = 0, f = e.height) : o === "end" && (u = r.height, f = 0), this.paddingTop = u + s, this.paddingBottom = f + s;
      }
    }
    _handleMargins() {
      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
    }
    afterFit() {
      Je(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis: e, position: r } = this.options;
      return r === "top" || r === "bottom" || e === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(e) {
      this.beforeTickToLabelConversion(), this.generateTickLabels(e);
      let r, n;
      for (r = 0, n = e.length; r < n; r++)
        Re(e[r].label) && (e.splice(r, 1), n--, r--);
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let e = this._labelSizes;
      if (!e) {
        const r = this.options.ticks.sampleSize;
        let n = this.ticks;
        r < n.length && (n = rh(n, r)), this._labelSizes = e = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
      }
      return e;
    }
    _computeLabelSizes(e, r, n) {
      const { ctx: i, _longestTextCache: o } = this, s = [], a = [], l = Math.floor(r / th(r, n));
      let c = 0, u = 0, f, d, h, g, p, y, b, x, S, C, _;
      for (f = 0; f < r; f += l) {
        if (g = e[f].label, p = this._resolveTickFontOptions(f), i.font = y = p.string, b = o[y] = o[y] || {
          data: {},
          gc: []
        }, x = p.lineHeight, S = C = 0, !Re(g) && !Ge(g))
          S = sa(i, b.data, b.gc, S, g), C = x;
        else if (Ge(g))
          for (d = 0, h = g.length; d < h; ++d)
            _ = g[d], !Re(_) && !Ge(_) && (S = sa(i, b.data, b.gc, S, _), C += x);
        s.push(S), a.push(C), c = Math.max(S, c), u = Math.max(C, u);
      }
      EA(o, r);
      const L = s.indexOf(c), F = a.indexOf(u), V = (W) => ({
        width: s[W] || 0,
        height: a[W] || 0
      });
      return {
        first: V(0),
        last: V(r - 1),
        widest: V(L),
        highest: V(F),
        widths: s,
        heights: a
      };
    }
    getLabelForValue(e) {
      return e;
    }
    getPixelForValue(e, r) {
      return NaN;
    }
    getValueForPixel(e) {
    }
    getPixelForTick(e) {
      const r = this.ticks;
      return e < 0 || e > r.length - 1 ? null : this.getPixelForValue(r[e].value);
    }
    getPixelForDecimal(e) {
      this._reversePixels && (e = 1 - e);
      const r = this._startPixel + e * this._length;
      return h2(this._alignToPixels ? yn(this.chart, r, 0) : r);
    }
    getDecimalForPixel(e) {
      const r = (e - this._startPixel) / this._length;
      return this._reversePixels ? 1 - r : r;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: e, max: r } = this;
      return e < 0 && r < 0 ? r : e > 0 && r > 0 ? e : 0;
    }
    getContext(e) {
      const r = this.ticks || [];
      if (e >= 0 && e < r.length) {
        const n = r[e];
        return n.$context || (n.$context = CA(this.getContext(), e, n));
      }
      return this.$context || (this.$context = kA(this.chart.getContext(), this));
    }
    _tickSize() {
      const e = this.options.ticks, r = sr(this.labelRotation), n = Math.abs(Math.cos(r)), i = Math.abs(Math.sin(r)), o = this._getLabelSizes(), s = e.autoSkipPadding || 0, a = o ? o.widest.width + s : 0, l = o ? o.highest.height + s : 0;
      return this.isHorizontal() ? l * n > a * i ? a / n : l / i : l * i < a * n ? l / n : a / i;
    }
    _isVisible() {
      const e = this.options.display;
      return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(e) {
      const r = this.axis, n = this.chart, i = this.options, { grid: o, position: s, border: a } = i, l = o.offset, c = this.isHorizontal(), f = this.ticks.length + (l ? 1 : 0), d = Bi(o), h = [], g = a.setContext(this.getContext()), p = g.display ? g.width : 0, y = p / 2, b = function(O) {
        return yn(n, O, p);
      };
      let x, S, C, _, L, F, V, W, X, G, ie, P10;
      if (s === "top")
        x = b(this.bottom), F = this.bottom - d, W = x - y, G = b(e.top) + y, P10 = e.bottom;
      else if (s === "bottom")
        x = b(this.top), G = e.top, P10 = b(e.bottom) - y, F = x + y, W = this.top + d;
      else if (s === "left")
        x = b(this.right), L = this.right - d, V = x - y, X = b(e.left) + y, ie = e.right;
      else if (s === "right")
        x = b(this.left), X = e.left, ie = b(e.right) - y, L = x + y, V = this.left + d;
      else if (r === "x") {
        if (s === "center")
          x = b((e.top + e.bottom) / 2 + 0.5);
        else if (Ie(s)) {
          const O = Object.keys(s)[0], q = s[O];
          x = b(this.chart.scales[O].getPixelForValue(q));
        }
        G = e.top, P10 = e.bottom, F = x + y, W = F + d;
      } else if (r === "y") {
        if (s === "center")
          x = b((e.left + e.right) / 2);
        else if (Ie(s)) {
          const O = Object.keys(s)[0], q = s[O];
          x = b(this.chart.scales[O].getPixelForValue(q));
        }
        L = x - y, V = L - d, X = e.left, ie = e.right;
      }
      const z10 = ke(i.ticks.maxTicksLimit, f), B = Math.max(1, Math.ceil(f / z10));
      for (S = 0; S < f; S += B) {
        const O = this.getContext(S), q = o.setContext(O), te = a.setContext(O), Y = q.lineWidth, K = q.color, $ = te.dash || [], se = te.dashOffset, he = q.tickWidth, de = q.tickColor, pe = q.tickBorderDash || [], j = q.tickBorderDashOffset;
        C = SA(this, S, l), C !== void 0 && (_ = yn(n, C, Y), c ? L = V = X = ie = _ : F = W = G = P10 = _, h.push({
          tx1: L,
          ty1: F,
          tx2: V,
          ty2: W,
          x1: X,
          y1: G,
          x2: ie,
          y2: P10,
          width: Y,
          color: K,
          borderDash: $,
          borderDashOffset: se,
          tickWidth: he,
          tickColor: de,
          tickBorderDash: pe,
          tickBorderDashOffset: j
        }));
      }
      return this._ticksLength = f, this._borderValue = x, h;
    }
    _computeLabelItems(e) {
      const r = this.axis, n = this.options, { position: i, ticks: o } = n, s = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: f } = o, d = Bi(n.grid), h = d + u, g = f ? -u : h, p = -sr(this.labelRotation), y = [];
      let b, x, S, C, _, L, F, V, W, X, G, ie, P10 = "middle";
      if (i === "top")
        L = this.bottom - g, F = this._getXAxisLabelAlignment();
      else if (i === "bottom")
        L = this.top + g, F = this._getXAxisLabelAlignment();
      else if (i === "left") {
        const B = this._getYAxisLabelAlignment(d);
        F = B.textAlign, _ = B.x;
      } else if (i === "right") {
        const B = this._getYAxisLabelAlignment(d);
        F = B.textAlign, _ = B.x;
      } else if (r === "x") {
        if (i === "center")
          L = (e.top + e.bottom) / 2 + h;
        else if (Ie(i)) {
          const B = Object.keys(i)[0], O = i[B];
          L = this.chart.scales[B].getPixelForValue(O) + h;
        }
        F = this._getXAxisLabelAlignment();
      } else if (r === "y") {
        if (i === "center")
          _ = (e.left + e.right) / 2 - h;
        else if (Ie(i)) {
          const B = Object.keys(i)[0], O = i[B];
          _ = this.chart.scales[B].getPixelForValue(O);
        }
        F = this._getYAxisLabelAlignment(d).textAlign;
      }
      r === "y" && (l === "start" ? P10 = "top" : l === "end" && (P10 = "bottom"));
      const z10 = this._getLabelSizes();
      for (b = 0, x = a.length; b < x; ++b) {
        S = a[b], C = S.label;
        const B = o.setContext(this.getContext(b));
        V = this.getPixelForTick(b) + o.labelOffset, W = this._resolveTickFontOptions(b), X = W.lineHeight, G = Ge(C) ? C.length : 1;
        const O = G / 2, q = B.color, te = B.textStrokeColor, Y = B.textStrokeWidth;
        let K = F;
        s ? (_ = V, F === "inner" && (b === x - 1 ? K = this.options.reverse ? "left" : "right" : b === 0 ? K = this.options.reverse ? "right" : "left" : K = "center"), i === "top" ? c === "near" || p !== 0 ? ie = -G * X + X / 2 : c === "center" ? ie = -z10.highest.height / 2 - O * X + X : ie = -z10.highest.height + X / 2 : c === "near" || p !== 0 ? ie = X / 2 : c === "center" ? ie = z10.highest.height / 2 - O * X : ie = z10.highest.height - G * X, f && (ie *= -1), p !== 0 && !B.showLabelBackdrop && (_ += X / 2 * Math.sin(p))) : (L = V, ie = (1 - G) * X / 2);
        let $;
        if (B.showLabelBackdrop) {
          const se = Et(B.backdropPadding), he = z10.heights[b], de = z10.widths[b];
          let pe = ie - se.top, j = 0 - se.left;
          switch (P10) {
            case "middle":
              pe -= he / 2;
              break;
            case "bottom":
              pe -= he;
              break;
          }
          switch (F) {
            case "center":
              j -= de / 2;
              break;
            case "right":
              j -= de;
              break;
          }
          $ = {
            left: j,
            top: pe,
            width: de + se.width,
            height: he + se.height,
            color: B.backdropColor
          };
        }
        y.push({
          label: C,
          font: W,
          textOffset: ie,
          options: {
            rotation: p,
            color: q,
            strokeColor: te,
            strokeWidth: Y,
            textAlign: K,
            textBaseline: P10,
            translation: [
              _,
              L
            ],
            backdrop: $
          }
        });
      }
      return y;
    }
    _getXAxisLabelAlignment() {
      const { position: e, ticks: r } = this.options;
      if (-sr(this.labelRotation))
        return e === "top" ? "left" : "right";
      let i = "center";
      return r.align === "start" ? i = "left" : r.align === "end" ? i = "right" : r.align === "inner" && (i = "inner"), i;
    }
    _getYAxisLabelAlignment(e) {
      const { position: r, ticks: { crossAlign: n, mirror: i, padding: o } } = this.options, s = this._getLabelSizes(), a = e + o, l = s.widest.width;
      let c, u;
      return r === "left" ? i ? (u = this.right + o, n === "near" ? c = "left" : n === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, n === "near" ? c = "right" : n === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : r === "right" ? i ? (u = this.left + o, n === "near" ? c = "right" : n === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, n === "near" ? c = "left" : n === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
        textAlign: c,
        x: u
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror)
        return;
      const e = this.chart, r = this.options.position;
      if (r === "left" || r === "right")
        return {
          top: 0,
          left: this.left,
          bottom: e.height,
          right: this.right
        };
      if (r === "top" || r === "bottom")
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: e.width
        };
    }
    drawBackground() {
      const { ctx: e, options: { backgroundColor: r }, left: n, top: i, width: o, height: s } = this;
      r && (e.save(), e.fillStyle = r, e.fillRect(n, i, o, s), e.restore());
    }
    getLineWidthForValue(e) {
      const r = this.options.grid;
      if (!this._isVisible() || !r.display)
        return 0;
      const i = this.ticks.findIndex((o) => o.value === e);
      return i >= 0 ? r.setContext(this.getContext(i)).lineWidth : 0;
    }
    drawGrid(e) {
      const r = this.options.grid, n = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
      let o, s;
      const a = (l, c, u) => {
        !u.width || !u.color || (n.save(), n.lineWidth = u.width, n.strokeStyle = u.color, n.setLineDash(u.borderDash || []), n.lineDashOffset = u.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(c.x, c.y), n.stroke(), n.restore());
      };
      if (r.display)
        for (o = 0, s = i.length; o < s; ++o) {
          const l = i[o];
          r.drawOnChartArea && a({
            x: l.x1,
            y: l.y1
          }, {
            x: l.x2,
            y: l.y2
          }, l), r.drawTicks && a({
            x: l.tx1,
            y: l.ty1
          }, {
            x: l.tx2,
            y: l.ty2
          }, {
            color: l.tickColor,
            width: l.tickWidth,
            borderDash: l.tickBorderDash,
            borderDashOffset: l.tickBorderDashOffset
          });
        }
    }
    drawBorder() {
      const { chart: e, ctx: r, options: { border: n, grid: i } } = this, o = n.setContext(this.getContext()), s = n.display ? o.width : 0;
      if (!s)
        return;
      const a = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
      let c, u, f, d;
      this.isHorizontal() ? (c = yn(e, this.left, s) - s / 2, u = yn(e, this.right, a) + a / 2, f = d = l) : (f = yn(e, this.top, s) - s / 2, d = yn(e, this.bottom, a) + a / 2, c = u = l), r.save(), r.lineWidth = o.width, r.strokeStyle = o.color, r.beginPath(), r.moveTo(c, f), r.lineTo(u, d), r.stroke(), r.restore();
    }
    drawLabels(e) {
      if (!this.options.ticks.display)
        return;
      const n = this.ctx, i = this._computeLabelArea();
      i && Da(n, i);
      const o = this.getLabelItems(e);
      for (const s of o) {
        const a = s.options, l = s.font, c = s.label, u = s.textOffset;
        Fn(n, c, 0, u, l, a);
      }
      i && Ma(n);
    }
    drawTitle() {
      const { ctx: e, options: { position: r, title: n, reverse: i } } = this;
      if (!n.display)
        return;
      const o = ft(n.font), s = Et(n.padding), a = n.align;
      let l = o.lineHeight / 2;
      r === "bottom" || r === "center" || Ie(r) ? (l += s.bottom, Ge(n.text) && (l += o.lineHeight * (n.text.length - 1))) : l += s.top;
      const { titleX: c, titleY: u, maxWidth: f, rotation: d } = IA(this, l, r, a);
      Fn(e, n.text, 0, 0, o, {
        color: n.color,
        maxWidth: f,
        rotation: d,
        textAlign: TA(a, r, i),
        textBaseline: "middle",
        translation: [
          c,
          u
        ]
      });
    }
    draw(e) {
      this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
    }
    _layers() {
      const e = this.options, r = e.ticks && e.ticks.z || 0, n = ke(e.grid && e.grid.z, -1), i = ke(e.border && e.border.z, 0);
      return !this._isVisible() || this.draw !== Vn.prototype.draw ? [
        {
          z: r,
          draw: (o) => {
            this.draw(o);
          }
        }
      ] : [
        {
          z: n,
          draw: (o) => {
            this.drawBackground(), this.drawGrid(o), this.drawTitle();
          }
        },
        {
          z: i,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: r,
          draw: (o) => {
            this.drawLabels(o);
          }
        }
      ];
    }
    getMatchingVisibleMetas(e) {
      const r = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", i = [];
      let o, s;
      for (o = 0, s = r.length; o < s; ++o) {
        const a = r[o];
        a[n] === this.id && (!e || a.type === e) && i.push(a);
      }
      return i;
    }
    _resolveTickFontOptions(e) {
      const r = this.options.ticks.setContext(this.getContext(e));
      return ft(r.font);
    }
    _maxDigits() {
      const e = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / e;
    }
  }
  class ls {
    constructor(e, r, n) {
      this.type = e, this.scope = r, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(e) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
    }
    register(e) {
      const r = Object.getPrototypeOf(e);
      let n;
      RA(r) && (n = this.register(r));
      const i = this.items, o = e.id, s = this.scope + "." + o;
      if (!o)
        throw new Error("class does not have id: " + e);
      return o in i || (i[o] = e, OA(e, s, n), this.override && st.override(e.id, e.overrides)), s;
    }
    get(e) {
      return this.items[e];
    }
    unregister(e) {
      const r = this.items, n = e.id, i = this.scope;
      n in r && delete r[n], i && n in st[i] && (delete st[i][n], this.override && delete Bn[n]);
    }
  }
  function OA(t10, e, r) {
    const n = bo(/* @__PURE__ */ Object.create(null), [
      r ? st.get(r) : {},
      st.get(e),
      t10.defaults
    ]);
    st.set(e, n), t10.defaultRoutes && PA(e, t10.defaultRoutes), t10.descriptors && st.describe(e, t10.descriptors);
  }
  function PA(t10, e) {
    Object.keys(e).forEach((r) => {
      const n = r.split("."), i = n.pop(), o = [
        t10
      ].concat(n).join("."), s = e[r].split("."), a = s.pop(), l = s.join(".");
      st.route(o, i, l, a);
    });
  }
  function RA(t10) {
    return "id" in t10 && "defaults" in t10;
  }
  class DA {
    constructor() {
      this.controllers = new ls(lr, "datasets", true), this.elements = new ls(Ur, "elements"), this.plugins = new ls(Object, "plugins"), this.scales = new ls(Vn, "scales"), this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...e) {
      this._each("register", e);
    }
    remove(...e) {
      this._each("unregister", e);
    }
    addControllers(...e) {
      this._each("register", e, this.controllers);
    }
    addElements(...e) {
      this._each("register", e, this.elements);
    }
    addPlugins(...e) {
      this._each("register", e, this.plugins);
    }
    addScales(...e) {
      this._each("register", e, this.scales);
    }
    getController(e) {
      return this._get(e, this.controllers, "controller");
    }
    getElement(e) {
      return this._get(e, this.elements, "element");
    }
    getPlugin(e) {
      return this._get(e, this.plugins, "plugin");
    }
    getScale(e) {
      return this._get(e, this.scales, "scale");
    }
    removeControllers(...e) {
      this._each("unregister", e, this.controllers);
    }
    removeElements(...e) {
      this._each("unregister", e, this.elements);
    }
    removePlugins(...e) {
      this._each("unregister", e, this.plugins);
    }
    removeScales(...e) {
      this._each("unregister", e, this.scales);
    }
    _each(e, r, n) {
      [
        ...r
      ].forEach((i) => {
        const o = n || this._getRegistryForType(i);
        n || o.isForType(i) || o === this.plugins && i.id ? this._exec(e, o, i) : Ve(i, (s) => {
          const a = n || this._getRegistryForType(s);
          this._exec(e, a, s);
        });
      });
    }
    _exec(e, r, n) {
      const i = Cu(e);
      Je(n["before" + i], [], n), r[e](n), Je(n["after" + i], [], n);
    }
    _getRegistryForType(e) {
      for (let r = 0; r < this._typedRegistries.length; r++) {
        const n = this._typedRegistries[r];
        if (n.isForType(e))
          return n;
      }
      return this.plugins;
    }
    _get(e, r, n) {
      const i = r.get(e);
      if (i === void 0)
        throw new Error('"' + e + '" is not a registered ' + n + ".");
      return i;
    }
  }
  var dr = /* @__PURE__ */ new DA();
  class MA {
    constructor() {
      this._init = [];
    }
    notify(e, r, n, i) {
      r === "beforeInit" && (this._init = this._createDescriptors(e, true), this._notify(this._init, e, "install"));
      const o = i ? this._descriptors(e).filter(i) : this._descriptors(e), s = this._notify(o, e, r, n);
      return r === "afterDestroy" && (this._notify(o, e, "stop"), this._notify(this._init, e, "uninstall")), s;
    }
    _notify(e, r, n, i) {
      i = i || {};
      for (const o of e) {
        const s = o.plugin, a = s[n], l = [
          r,
          i,
          o.options
        ];
        if (Je(a, l, s) === false && i.cancelable)
          return false;
      }
      return true;
    }
    invalidate() {
      Re(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
    }
    _descriptors(e) {
      if (this._cache)
        return this._cache;
      const r = this._cache = this._createDescriptors(e);
      return this._notifyStateChanges(e), r;
    }
    _createDescriptors(e, r) {
      const n = e && e.config, i = ke(n.options && n.options.plugins, {}), o = NA(n);
      return i === false && !r ? [] : BA(e, o, i, r);
    }
    _notifyStateChanges(e) {
      const r = this._oldCache || [], n = this._cache, i = (o, s) => o.filter((a) => !s.some((l) => a.plugin.id === l.plugin.id));
      this._notify(i(r, n), e, "stop"), this._notify(i(n, r), e, "start");
    }
  }
  function NA(t10) {
    const e = {}, r = [], n = Object.keys(dr.plugins.items);
    for (let o = 0; o < n.length; o++)
      r.push(dr.getPlugin(n[o]));
    const i = t10.plugins || [];
    for (let o = 0; o < i.length; o++) {
      const s = i[o];
      r.indexOf(s) === -1 && (r.push(s), e[s.id] = true);
    }
    return {
      plugins: r,
      localIds: e
    };
  }
  function LA(t10, e) {
    return !e && t10 === false ? null : t10 === true ? {} : t10;
  }
  function BA(t10, { plugins: e, localIds: r }, n, i) {
    const o = [], s = t10.getContext();
    for (const a of e) {
      const l = a.id, c = LA(n[l], i);
      c !== null && o.push({
        plugin: a,
        options: FA(t10.config, {
          plugin: a,
          local: r[l]
        }, c, s)
      });
    }
    return o;
  }
  function FA(t10, { plugin: e, local: r }, n, i) {
    const o = t10.pluginScopeKeys(e), s = t10.getOptionScopes(n, o);
    return r && e.defaults && s.push(e.defaults), t10.createResolver(s, i, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function kc(t10, e) {
    const r = st.datasets[t10] || {};
    return ((e.datasets || {})[t10] || {}).indexAxis || e.indexAxis || r.indexAxis || "x";
  }
  function jA(t10, e) {
    let r = t10;
    return t10 === "_index_" ? r = e : t10 === "_value_" && (r = e === "x" ? "y" : "x"), r;
  }
  function WA(t10, e) {
    return t10 === e ? "_index_" : "_value_";
  }
  function ih(t10) {
    if (t10 === "x" || t10 === "y" || t10 === "r")
      return t10;
  }
  function UA(t10) {
    if (t10 === "top" || t10 === "bottom")
      return "x";
    if (t10 === "left" || t10 === "right")
      return "y";
  }
  function Cc(t10, ...e) {
    if (ih(t10))
      return t10;
    for (const r of e) {
      const n = r.axis || UA(r.position) || t10.length > 1 && ih(t10[0].toLowerCase());
      if (n)
        return n;
    }
    throw new Error(`Cannot determine type of '${t10}' axis. Please provide 'axis' or 'position' option.`);
  }
  function oh(t10, e, r) {
    if (r[e + "AxisID"] === t10)
      return {
        axis: e
      };
  }
  function zA(t10, e) {
    if (e.data && e.data.datasets) {
      const r = e.data.datasets.filter((n) => n.xAxisID === t10 || n.yAxisID === t10);
      if (r.length)
        return oh(t10, "x", r[0]) || oh(t10, "y", r[0]);
    }
    return {};
  }
  function VA(t10, e) {
    const r = Bn[t10.type] || {
      scales: {}
    }, n = e.scales || {}, i = kc(t10.type, e), o = /* @__PURE__ */ Object.create(null);
    return Object.keys(n).forEach((s) => {
      const a = n[s];
      if (!Ie(a))
        return console.error(`Invalid scale configuration for scale: ${s}`);
      if (a._proxy)
        return console.warn(`Ignoring resolver passed as options for scale: ${s}`);
      const l = Cc(s, a, zA(s, t10), st.scales[a.type]), c = WA(l, i), u = r.scales || {};
      o[s] = io(/* @__PURE__ */ Object.create(null), [
        {
          axis: l
        },
        a,
        u[l],
        u[c]
      ]);
    }), t10.data.datasets.forEach((s) => {
      const a = s.type || t10.type, l = s.indexAxis || kc(a, e), u = (Bn[a] || {}).scales || {};
      Object.keys(u).forEach((f) => {
        const d = jA(f, l), h = s[d + "AxisID"] || d;
        o[h] = o[h] || /* @__PURE__ */ Object.create(null), io(o[h], [
          {
            axis: d
          },
          n[h],
          u[f]
        ]);
      });
    }), Object.keys(o).forEach((s) => {
      const a = o[s];
      io(a, [
        st.scales[a.type],
        st.scale
      ]);
    }), o;
  }
  function V1(t10) {
    const e = t10.options || (t10.options = {});
    e.plugins = ke(e.plugins, {}), e.scales = VA(t10, e);
  }
  function q1(t10) {
    return t10 = t10 || {}, t10.datasets = t10.datasets || [], t10.labels = t10.labels || [], t10;
  }
  function qA(t10) {
    return t10 = t10 || {}, t10.data = q1(t10.data), V1(t10), t10;
  }
  const sh = /* @__PURE__ */ new Map(), H1 = /* @__PURE__ */ new Set();
  function cs(t10, e) {
    let r = sh.get(t10);
    return r || (r = e(), sh.set(t10, r), H1.add(r)), r;
  }
  const Fi = (t10, e, r) => {
    const n = sn(e, r);
    n !== void 0 && t10.add(n);
  };
  class HA {
    constructor(e) {
      this._config = qA(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(e) {
      this._config.type = e;
    }
    get data() {
      return this._config.data;
    }
    set data(e) {
      this._config.data = q1(e);
    }
    get options() {
      return this._config.options;
    }
    set options(e) {
      this._config.options = e;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const e = this._config;
      this.clearCache(), V1(e);
    }
    clearCache() {
      this._scopeCache.clear(), this._resolverCache.clear();
    }
    datasetScopeKeys(e) {
      return cs(e, () => [
        [
          `datasets.${e}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(e, r) {
      return cs(`${e}.transition.${r}`, () => [
        [
          `datasets.${e}.transitions.${r}`,
          `transitions.${r}`
        ],
        [
          `datasets.${e}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(e, r) {
      return cs(`${e}-${r}`, () => [
        [
          `datasets.${e}.elements.${r}`,
          `datasets.${e}`,
          `elements.${r}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(e) {
      const r = e.id, n = this.type;
      return cs(`${n}-plugin-${r}`, () => [
        [
          `plugins.${r}`,
          ...e.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(e, r) {
      const n = this._scopeCache;
      let i = n.get(e);
      return (!i || r) && (i = /* @__PURE__ */ new Map(), n.set(e, i)), i;
    }
    getOptionScopes(e, r, n) {
      const { options: i, type: o } = this, s = this._cachedScopes(e, n), a = s.get(r);
      if (a)
        return a;
      const l = /* @__PURE__ */ new Set();
      r.forEach((u) => {
        e && (l.add(e), u.forEach((f) => Fi(l, e, f))), u.forEach((f) => Fi(l, i, f)), u.forEach((f) => Fi(l, Bn[o] || {}, f)), u.forEach((f) => Fi(l, st, f)), u.forEach((f) => Fi(l, _c, f));
      });
      const c = Array.from(l);
      return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), H1.has(r) && s.set(r, c), c;
    }
    chartOptionScopes() {
      const { options: e, type: r } = this;
      return [
        e,
        Bn[r] || {},
        st.datasets[r] || {},
        {
          type: r
        },
        st,
        _c
      ];
    }
    resolveNamedOptions(e, r, n, i = [
      ""
    ]) {
      const o = {
        $shared: true
      }, { resolver: s, subPrefixes: a } = ah(this._resolverCache, e, i);
      let l = s;
      if (YA(s, r)) {
        o.$shared = false, n = an(n) ? n() : n;
        const c = this.createResolver(e, n, a);
        l = gi(s, n, c);
      }
      for (const c of r)
        o[c] = l[c];
      return o;
    }
    createResolver(e, r, n = [
      ""
    ], i) {
      const { resolver: o } = ah(this._resolverCache, e, n);
      return Ie(r) ? gi(o, r, void 0, i) : o;
    }
  }
  function ah(t10, e, r) {
    let n = t10.get(e);
    n || (n = /* @__PURE__ */ new Map(), t10.set(e, n));
    const i = r.join();
    let o = n.get(i);
    return o || (o = {
      resolver: Du(e, r),
      subPrefixes: r.filter((a) => !a.toLowerCase().includes("hover"))
    }, n.set(i, o)), o;
  }
  const KA = (t10) => Ie(t10) && Object.getOwnPropertyNames(t10).reduce((e, r) => e || an(t10[r]), false);
  function YA(t10, e) {
    const { isScriptable: r, isIndexable: n } = _1(t10);
    for (const i of e) {
      const o = r(i), s = n(i), a = (s || o) && t10[i];
      if (o && (an(a) || KA(a)) || s && Ge(a))
        return true;
    }
    return false;
  }
  var XA = "4.4.0";
  const JA = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function lh(t10, e) {
    return t10 === "top" || t10 === "bottom" || JA.indexOf(t10) === -1 && e === "x";
  }
  function ch(t10, e) {
    return function(r, n) {
      return r[t10] === n[t10] ? r[e] - n[e] : r[t10] - n[t10];
    };
  }
  function uh(t10) {
    const e = t10.chart, r = e.options.animation;
    e.notifyPlugins("afterRender"), Je(r && r.onComplete, [
      t10
    ], e);
  }
  function QA(t10) {
    const e = t10.chart, r = e.options.animation;
    Je(r && r.onProgress, [
      t10
    ], e);
  }
  function K1(t10) {
    return I1() && typeof t10 == "string" ? t10 = document.getElementById(t10) : t10 && t10.length && (t10 = t10[0]), t10 && t10.canvas && (t10 = t10.canvas), t10;
  }
  const Ms = {}, fh = (t10) => {
    const e = K1(t10);
    return Object.values(Ms).filter((r) => r.canvas === e).pop();
  };
  function GA(t10, e, r) {
    const n = Object.keys(t10);
    for (const i of n) {
      const o = +i;
      if (o >= e) {
        const s = t10[i];
        delete t10[i], (r > 0 || o > e) && (t10[o + r] = s);
      }
    }
  }
  function ZA(t10, e, r, n) {
    return !r || t10.type === "mouseout" ? null : n ? e : t10;
  }
  function us(t10, e, r) {
    return t10.options.clip ? t10[r] : e[r];
  }
  function $A(t10, e) {
    const { xScale: r, yScale: n } = t10;
    return r && n ? {
      left: us(r, e, "left"),
      right: us(r, e, "right"),
      top: us(n, e, "top"),
      bottom: us(n, e, "bottom")
    } : e;
  }
  class Tr {
    static register(...e) {
      dr.add(...e), dh();
    }
    static unregister(...e) {
      dr.remove(...e), dh();
    }
    constructor(e, r) {
      const n = this.config = new HA(r), i = K1(e), o = fh(i);
      if (o)
        throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
      const s = n.createResolver(n.chartOptionScopes(), this.getContext());
      this.platform = new (n.platform || mA(i))(), this.platform.updateConfig(n);
      const a = this.platform.acquireContext(i, s.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width;
      if (this.id = t2(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new MA(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = y2((f) => this.update(f), s.resizeDelay || 0), this._dataChanges = [], Ms[this.id] = this, !a || !l) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      Er.listen(this, "complete", uh), Er.listen(this, "progress", QA), this._initialize(), this.attached && this.update();
    }
    get aspectRatio() {
      const { options: { aspectRatio: e, maintainAspectRatio: r }, width: n, height: i, _aspectRatio: o } = this;
      return Re(e) ? r && o ? o : i ? n / i : null : e;
    }
    get data() {
      return this.config.data;
    }
    set data(e) {
      this.config.data = e;
    }
    get options() {
      return this._options;
    }
    set options(e) {
      this.config.options = e;
    }
    get registry() {
      return dr;
    }
    _initialize() {
      return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Dd(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
    }
    clear() {
      return Od(this.canvas, this.ctx), this;
    }
    stop() {
      return Er.stop(this), this;
    }
    resize(e, r) {
      Er.running(this) ? this._resizeBeforeDraw = {
        width: e,
        height: r
      } : this._resize(e, r);
    }
    _resize(e, r) {
      const n = this.options, i = this.canvas, o = n.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(i, e, r, o), a = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
      this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, Dd(this, a, true) && (this.notifyPlugins("resize", {
        size: s
      }), Je(n.onResize, [
        this,
        s
      ], this), this.attached && this._doResize(l) && this.render());
    }
    ensureScalesHaveIDs() {
      const r = this.options.scales || {};
      Ve(r, (n, i) => {
        n.id = i;
      });
    }
    buildOrUpdateScales() {
      const e = this.options, r = e.scales, n = this.scales, i = Object.keys(n).reduce((s, a) => (s[a] = false, s), {});
      let o = [];
      r && (o = o.concat(Object.keys(r).map((s) => {
        const a = r[s], l = Cc(s, a), c = l === "r", u = l === "x";
        return {
          options: a,
          dposition: c ? "chartArea" : u ? "bottom" : "left",
          dtype: c ? "radialLinear" : u ? "category" : "linear"
        };
      }))), Ve(o, (s) => {
        const a = s.options, l = a.id, c = Cc(l, a), u = ke(a.type, s.dtype);
        (a.position === void 0 || lh(a.position, c) !== lh(s.dposition)) && (a.position = s.dposition), i[l] = true;
        let f = null;
        if (l in n && n[l].type === u)
          f = n[l];
        else {
          const d = dr.getScale(u);
          f = new d({
            id: l,
            type: u,
            ctx: this.ctx,
            chart: this
          }), n[f.id] = f;
        }
        f.init(a, e);
      }), Ve(i, (s, a) => {
        s || delete n[a];
      }), Ve(n, (s) => {
        _t.configure(this, s, s.options), _t.addBox(this, s);
      });
    }
    _updateMetasets() {
      const e = this._metasets, r = this.data.datasets.length, n = e.length;
      if (e.sort((i, o) => i.index - o.index), n > r) {
        for (let i = r; i < n; ++i)
          this._destroyDatasetMeta(i);
        e.splice(r, n - r);
      }
      this._sortedMetasets = e.slice(0).sort(ch("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: e, data: { datasets: r } } = this;
      e.length > r.length && delete this._stacks, e.forEach((n, i) => {
        r.filter((o) => o === n._dataset).length === 0 && this._destroyDatasetMeta(i);
      });
    }
    buildOrUpdateControllers() {
      const e = [], r = this.data.datasets;
      let n, i;
      for (this._removeUnreferencedMetasets(), n = 0, i = r.length; n < i; n++) {
        const o = r[n];
        let s = this.getDatasetMeta(n);
        const a = o.type || this.config.type;
        if (s.type && s.type !== a && (this._destroyDatasetMeta(n), s = this.getDatasetMeta(n)), s.type = a, s.indexAxis = o.indexAxis || kc(a, this.options), s.order = o.order || 0, s.index = n, s.label = "" + o.label, s.visible = this.isDatasetVisible(n), s.controller)
          s.controller.updateIndex(n), s.controller.linkScales();
        else {
          const l = dr.getController(a), { datasetElementType: c, dataElementType: u } = st.datasets[a];
          Object.assign(l, {
            dataElementType: dr.getElement(u),
            datasetElementType: c && dr.getElement(c)
          }), s.controller = new l(this, n), e.push(s.controller);
        }
      }
      return this._updateMetasets(), e;
    }
    _resetElements() {
      Ve(this.data.datasets, (e, r) => {
        this.getDatasetMeta(r).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements(), this.notifyPlugins("reset");
    }
    update(e) {
      const r = this.config;
      r.update();
      const n = this._options = r.createResolver(r.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !n.animation;
      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
        mode: e,
        cancelable: true
      }) === false)
        return;
      const o = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let s = 0;
      for (let c = 0, u = this.data.datasets.length; c < u; c++) {
        const { controller: f } = this.getDatasetMeta(c), d = !i && o.indexOf(f) === -1;
        f.buildOrUpdateElements(d), s = Math.max(+f.getMaxOverflow(), s);
      }
      s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), i || Ve(o, (c) => {
        c.reset();
      }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
        mode: e
      }), this._layers.sort(ch("z", "_idx"));
      const { _active: a, _lastEvent: l } = this;
      l ? this._eventHandler(l, true) : a.length && this._updateHoverStyles(a, a, true), this.render();
    }
    _updateScales() {
      Ve(this.scales, (e) => {
        _t.removeBox(this, e);
      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const e = this.options, r = new Set(Object.keys(this._listeners)), n = new Set(e.events);
      (!wd(r, n) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
    }
    _updateHiddenIndices() {
      const { _hiddenIndices: e } = this, r = this._getUniformDataChanges() || [];
      for (const { method: n, start: i, count: o } of r) {
        const s = n === "_removeElements" ? -o : o;
        GA(e, i, s);
      }
    }
    _getUniformDataChanges() {
      const e = this._dataChanges;
      if (!e || !e.length)
        return;
      this._dataChanges = [];
      const r = this.data.datasets.length, n = (o) => new Set(e.filter((s) => s[0] === o).map((s, a) => a + "," + s.splice(1).join(","))), i = n(0);
      for (let o = 1; o < r; o++)
        if (!wd(i, n(o)))
          return;
      return Array.from(i).map((o) => o.split(",")).map((o) => ({
        method: o[1],
        start: +o[2],
        count: +o[3]
      }));
    }
    _updateLayout(e) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false)
        return;
      _t.update(this, this.width, this.height, e);
      const r = this.chartArea, n = r.width <= 0 || r.height <= 0;
      this._layers = [], Ve(this.boxes, (i) => {
        n && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers()));
      }, this), this._layers.forEach((i, o) => {
        i._idx = o;
      }), this.notifyPlugins("afterLayout");
    }
    _updateDatasets(e) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode: e,
        cancelable: true
      }) !== false) {
        for (let r = 0, n = this.data.datasets.length; r < n; ++r)
          this.getDatasetMeta(r).controller.configure();
        for (let r = 0, n = this.data.datasets.length; r < n; ++r)
          this._updateDataset(r, an(e) ? e({
            datasetIndex: r
          }) : e);
        this.notifyPlugins("afterDatasetsUpdate", {
          mode: e
        });
      }
    }
    _updateDataset(e, r) {
      const n = this.getDatasetMeta(e), i = {
        meta: n,
        index: e,
        mode: r,
        cancelable: true
      };
      this.notifyPlugins("beforeDatasetUpdate", i) !== false && (n.controller._update(r), i.cancelable = false, this.notifyPlugins("afterDatasetUpdate", i));
    }
    render() {
      this.notifyPlugins("beforeRender", {
        cancelable: true
      }) !== false && (Er.has(this) ? this.attached && !Er.running(this) && Er.start(this) : (this.draw(), uh({
        chart: this
      })));
    }
    draw() {
      let e;
      if (this._resizeBeforeDraw) {
        const { width: n, height: i } = this._resizeBeforeDraw;
        this._resize(n, i), this._resizeBeforeDraw = null;
      }
      if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false)
        return;
      const r = this._layers;
      for (e = 0; e < r.length && r[e].z <= 0; ++e)
        r[e].draw(this.chartArea);
      for (this._drawDatasets(); e < r.length; ++e)
        r[e].draw(this.chartArea);
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(e) {
      const r = this._sortedMetasets, n = [];
      let i, o;
      for (i = 0, o = r.length; i < o; ++i) {
        const s = r[i];
        (!e || s.visible) && n.push(s);
      }
      return n;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false)
        return;
      const e = this.getSortedVisibleDatasetMetas();
      for (let r = e.length - 1; r >= 0; --r)
        this._drawDataset(e[r]);
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(e) {
      const r = this.ctx, n = e._clip, i = !n.disabled, o = $A(e, this.chartArea), s = {
        meta: e,
        index: e.index,
        cancelable: true
      };
      this.notifyPlugins("beforeDatasetDraw", s) !== false && (i && Da(r, {
        left: n.left === false ? 0 : o.left - n.left,
        right: n.right === false ? this.width : o.right + n.right,
        top: n.top === false ? 0 : o.top - n.top,
        bottom: n.bottom === false ? this.height : o.bottom + n.bottom
      }), e.controller.draw(), i && Ma(r), s.cancelable = false, this.notifyPlugins("afterDatasetDraw", s));
    }
    isPointInArea(e) {
      return Mr(e, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, r, n, i) {
      const o = Jv.modes[r];
      return typeof o == "function" ? o(this, e, n, i) : [];
    }
    getDatasetMeta(e) {
      const r = this.data.datasets[e], n = this._metasets;
      let i = n.filter((o) => o && o._dataset === r).pop();
      return i || (i = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: r && r.order || 0,
        index: e,
        _dataset: r,
        _parsed: [],
        _sorted: false
      }, n.push(i)), i;
    }
    getContext() {
      return this.$context || (this.$context = fn(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(e) {
      const r = this.data.datasets[e];
      if (!r)
        return false;
      const n = this.getDatasetMeta(e);
      return typeof n.hidden == "boolean" ? !n.hidden : !r.hidden;
    }
    setDatasetVisibility(e, r) {
      const n = this.getDatasetMeta(e);
      n.hidden = !r;
    }
    toggleDataVisibility(e) {
      this._hiddenIndices[e] = !this._hiddenIndices[e];
    }
    getDataVisibility(e) {
      return !this._hiddenIndices[e];
    }
    _updateVisibility(e, r, n) {
      const i = n ? "show" : "hide", o = this.getDatasetMeta(e), s = o.controller._resolveAnimations(void 0, i);
      vo(r) ? (o.data[r].hidden = !n, this.update()) : (this.setDatasetVisibility(e, n), s.update(o, {
        visible: n
      }), this.update((a) => a.datasetIndex === e ? i : void 0));
    }
    hide(e, r) {
      this._updateVisibility(e, r, false);
    }
    show(e, r) {
      this._updateVisibility(e, r, true);
    }
    _destroyDatasetMeta(e) {
      const r = this._metasets[e];
      r && r.controller && r.controller._destroy(), delete this._metasets[e];
    }
    _stop() {
      let e, r;
      for (this.stop(), Er.remove(this), e = 0, r = this.data.datasets.length; e < r; ++e)
        this._destroyDatasetMeta(e);
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas: e, ctx: r } = this;
      this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Od(e, r), this.platform.releaseContext(r), this.canvas = null, this.ctx = null), delete Ms[this.id], this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...e) {
      return this.canvas.toDataURL(...e);
    }
    bindEvents() {
      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
    }
    bindUserEvents() {
      const e = this._listeners, r = this.platform, n = (o, s) => {
        r.addEventListener(this, o, s), e[o] = s;
      }, i = (o, s, a) => {
        o.offsetX = s, o.offsetY = a, this._eventHandler(o);
      };
      Ve(this.options.events, (o) => n(o, i));
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {});
      const e = this._responsiveListeners, r = this.platform, n = (l, c) => {
        r.addEventListener(this, l, c), e[l] = c;
      }, i = (l, c) => {
        e[l] && (r.removeEventListener(this, l, c), delete e[l]);
      }, o = (l, c) => {
        this.canvas && this.resize(l, c);
      };
      let s;
      const a = () => {
        i("attach", a), this.attached = true, this.resize(), n("resize", o), n("detach", s);
      };
      s = () => {
        this.attached = false, i("resize", o), this._stop(), this._resize(0, 0), n("attach", a);
      }, r.isAttached(this.canvas) ? a() : s();
    }
    unbindEvents() {
      Ve(this._listeners, (e, r) => {
        this.platform.removeEventListener(this, r, e);
      }), this._listeners = {}, Ve(this._responsiveListeners, (e, r) => {
        this.platform.removeEventListener(this, r, e);
      }), this._responsiveListeners = void 0;
    }
    updateHoverStyle(e, r, n) {
      const i = n ? "set" : "remove";
      let o, s, a, l;
      for (r === "dataset" && (o = this.getDatasetMeta(e[0].datasetIndex), o.controller["_" + i + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) {
        s = e[a];
        const c = s && this.getDatasetMeta(s.datasetIndex).controller;
        c && c[i + "HoverStyle"](s.element, s.datasetIndex, s.index);
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(e) {
      const r = this._active || [], n = e.map(({ datasetIndex: o, index: s }) => {
        const a = this.getDatasetMeta(o);
        if (!a)
          throw new Error("No dataset found at index " + o);
        return {
          datasetIndex: o,
          element: a.data[s],
          index: s
        };
      });
      !na(n, r) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, r));
    }
    notifyPlugins(e, r, n) {
      return this._plugins.notify(this, e, r, n);
    }
    isPluginEnabled(e) {
      return this._plugins._cache.filter((r) => r.plugin.id === e).length === 1;
    }
    _updateHoverStyles(e, r, n) {
      const i = this.options.hover, o = (l, c) => l.filter((u) => !c.some((f) => u.datasetIndex === f.datasetIndex && u.index === f.index)), s = o(r, e), a = n ? e : o(e, r);
      s.length && this.updateHoverStyle(s, i.mode, false), a.length && i.mode && this.updateHoverStyle(a, i.mode, true);
    }
    _eventHandler(e, r) {
      const n = {
        event: e,
        replay: r,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      }, i = (s) => (s.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", n, i) === false)
        return;
      const o = this._handleEvent(e, r, n.inChartArea);
      return n.cancelable = false, this.notifyPlugins("afterEvent", n, i), (o || n.changed) && this.render(), this;
    }
    _handleEvent(e, r, n) {
      const { _active: i = [], options: o } = this, s = r, a = this._getActiveElements(e, i, n, s), l = a2(e), c = ZA(e, this._lastEvent, n, l);
      n && (this._lastEvent = null, Je(o.onHover, [
        e,
        a,
        this
      ], this), l && Je(o.onClick, [
        e,
        a,
        this
      ], this));
      const u = !na(a, i);
      return (u || r) && (this._active = a, this._updateHoverStyles(a, i, r)), this._lastEvent = c, u;
    }
    _getActiveElements(e, r, n, i) {
      if (e.type === "mouseout")
        return [];
      if (!n)
        return r;
      const o = this.options.hover;
      return this.getElementsAtEventForMode(e, o.mode, o, i);
    }
  }
  ge(Tr, "defaults", st), ge(Tr, "instances", Ms), ge(Tr, "overrides", Bn), ge(Tr, "registry", dr), ge(Tr, "version", XA), ge(Tr, "getChart", fh);
  function dh() {
    return Ve(Tr.instances, (t10) => t10._plugins.invalidate());
  }
  function e6(t10, e, r) {
    const { startAngle: n, pixelMargin: i, x: o, y: s, outerRadius: a, innerRadius: l } = e;
    let c = i / a;
    t10.beginPath(), t10.arc(o, s, a, n - c, r + c), l > i ? (c = i / l, t10.arc(o, s, l, r + c, n - c, true)) : t10.arc(o, s, i, r + at, n - at), t10.closePath(), t10.clip();
  }
  function t6(t10) {
    return Ru(t10, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function r6(t10, e, r, n) {
    const i = t6(t10.options.borderRadius), o = (r - e) / 2, s = Math.min(o, n * e / 2), a = (l) => {
      const c = (r - Math.min(o, l)) * n / 2;
      return ht(l, 0, Math.min(o, c));
    };
    return {
      outerStart: a(i.outerStart),
      outerEnd: a(i.outerEnd),
      innerStart: ht(i.innerStart, 0, s),
      innerEnd: ht(i.innerEnd, 0, s)
    };
  }
  function Kn(t10, e, r, n) {
    return {
      x: r + t10 * Math.cos(e),
      y: n + t10 * Math.sin(e)
    };
  }
  function ca(t10, e, r, n, i, o) {
    const { x: s, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = e, f = Math.max(e.outerRadius + n + r - c, 0), d = u > 0 ? u + n + r + c : 0;
    let h = 0;
    const g = i - l;
    if (n) {
      const B = u > 0 ? u - n : 0, O = f > 0 ? f - n : 0, q = (B + O) / 2, te = q !== 0 ? g * q / (q + n) : g;
      h = (g - te) / 2;
    }
    const p = Math.max(1e-3, g * f - r / $e) / f, y = (g - p) / 2, b = l + y + h, x = i - y - h, { outerStart: S, outerEnd: C, innerStart: _, innerEnd: L } = r6(e, d, f, x - b), F = f - S, V = f - C, W = b + S / F, X = x - C / V, G = d + _, ie = d + L, P10 = b + _ / G, z10 = x - L / ie;
    if (t10.beginPath(), o) {
      const B = (W + X) / 2;
      if (t10.arc(s, a, f, W, B), t10.arc(s, a, f, B, X), C > 0) {
        const Y = Kn(V, X, s, a);
        t10.arc(Y.x, Y.y, C, X, x + at);
      }
      const O = Kn(ie, x, s, a);
      if (t10.lineTo(O.x, O.y), L > 0) {
        const Y = Kn(ie, z10, s, a);
        t10.arc(Y.x, Y.y, L, x + at, z10 + Math.PI);
      }
      const q = (x - L / d + (b + _ / d)) / 2;
      if (t10.arc(s, a, d, x - L / d, q, true), t10.arc(s, a, d, q, b + _ / d, true), _ > 0) {
        const Y = Kn(G, P10, s, a);
        t10.arc(Y.x, Y.y, _, P10 + Math.PI, b - at);
      }
      const te = Kn(F, b, s, a);
      if (t10.lineTo(te.x, te.y), S > 0) {
        const Y = Kn(F, W, s, a);
        t10.arc(Y.x, Y.y, S, b - at, W);
      }
    } else {
      t10.moveTo(s, a);
      const B = Math.cos(W) * f + s, O = Math.sin(W) * f + a;
      t10.lineTo(B, O);
      const q = Math.cos(X) * f + s, te = Math.sin(X) * f + a;
      t10.lineTo(q, te);
    }
    t10.closePath();
  }
  function n6(t10, e, r, n, i) {
    const { fullCircles: o, startAngle: s, circumference: a } = e;
    let l = e.endAngle;
    if (o) {
      ca(t10, e, r, n, l, i);
      for (let c = 0; c < o; ++c)
        t10.fill();
      isNaN(a) || (l = s + (a % Ze || Ze));
    }
    return ca(t10, e, r, n, l, i), t10.fill(), l;
  }
  function i6(t10, e, r, n, i) {
    const { fullCircles: o, startAngle: s, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: u, borderDash: f, borderDashOffset: d } = l, h = l.borderAlign === "inner";
    if (!c)
      return;
    t10.setLineDash(f || []), t10.lineDashOffset = d, h ? (t10.lineWidth = c * 2, t10.lineJoin = u || "round") : (t10.lineWidth = c, t10.lineJoin = u || "bevel");
    let g = e.endAngle;
    if (o) {
      ca(t10, e, r, n, g, i);
      for (let p = 0; p < o; ++p)
        t10.stroke();
      isNaN(a) || (g = s + (a % Ze || Ze));
    }
    h && e6(t10, e, g), o || (ca(t10, e, r, n, g, i), t10.stroke());
  }
  class Qi extends Ur {
    constructor(r) {
      super();
      ge(this, "circumference");
      ge(this, "endAngle");
      ge(this, "fullCircles");
      ge(this, "innerRadius");
      ge(this, "outerRadius");
      ge(this, "pixelMargin");
      ge(this, "startAngle");
      this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, r && Object.assign(this, r);
    }
    inRange(r, n, i) {
      const o = this.getProps([
        "x",
        "y"
      ], i), { angle: s, distance: a } = h1(o, {
        x: r,
        y: n
      }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: f, circumference: d } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], i), h = (this.options.spacing + this.options.borderWidth) / 2, p = ke(d, c - l) >= Ze || Ao(s, l, c), y = Rr(a, u + h, f + h);
      return p && y;
    }
    getCenterPoint(r) {
      const { x: n, y: i, startAngle: o, endAngle: s, innerRadius: a, outerRadius: l } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], r), { offset: c, spacing: u } = this.options, f = (o + s) / 2, d = (a + l + u + c) / 2;
      return {
        x: n + Math.cos(f) * d,
        y: i + Math.sin(f) * d
      };
    }
    tooltipPosition(r) {
      return this.getCenterPoint(r);
    }
    draw(r) {
      const { options: n, circumference: i } = this, o = (n.offset || 0) / 4, s = (n.spacing || 0) / 2, a = n.circular;
      if (this.pixelMargin = n.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = i > Ze ? Math.floor(i / Ze) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0)
        return;
      r.save();
      const l = (this.startAngle + this.endAngle) / 2;
      r.translate(Math.cos(l) * o, Math.sin(l) * o);
      const c = 1 - Math.sin(Math.min($e, i || 0)), u = o * c;
      r.fillStyle = n.backgroundColor, r.strokeStyle = n.borderColor, n6(r, this, u, s, a), i6(r, this, u, s, a), r.restore();
    }
  }
  ge(Qi, "id", "arc"), ge(Qi, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  }), ge(Qi, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  }), ge(Qi, "descriptors", {
    _scriptable: true,
    _indexable: (r) => r !== "borderDash"
  });
  function Y1(t10, e, r = e) {
    t10.lineCap = ke(r.borderCapStyle, e.borderCapStyle), t10.setLineDash(ke(r.borderDash, e.borderDash)), t10.lineDashOffset = ke(r.borderDashOffset, e.borderDashOffset), t10.lineJoin = ke(r.borderJoinStyle, e.borderJoinStyle), t10.lineWidth = ke(r.borderWidth, e.borderWidth), t10.strokeStyle = ke(r.borderColor, e.borderColor);
  }
  function o6(t10, e, r) {
    t10.lineTo(r.x, r.y);
  }
  function s6(t10) {
    return t10.stepped ? I2 : t10.tension || t10.cubicInterpolationMode === "monotone" ? O2 : o6;
  }
  function X1(t10, e, r = {}) {
    const n = t10.length, { start: i = 0, end: o = n - 1 } = r, { start: s, end: a } = e, l = Math.max(i, s), c = Math.min(o, a), u = i < s && o < s || i > a && o > a;
    return {
      count: n,
      start: l,
      loop: e.loop,
      ilen: c < l && !u ? n + c - l : c - l
    };
  }
  function a6(t10, e, r, n) {
    const { points: i, options: o } = e, { count: s, start: a, loop: l, ilen: c } = X1(i, r, n), u = s6(o);
    let { move: f = true, reverse: d } = n || {}, h, g, p;
    for (h = 0; h <= c; ++h)
      g = i[(a + (d ? c - h : h)) % s], !g.skip && (f ? (t10.moveTo(g.x, g.y), f = false) : u(t10, p, g, d, o.stepped), p = g);
    return l && (g = i[(a + (d ? c : 0)) % s], u(t10, p, g, d, o.stepped)), !!l;
  }
  function l6(t10, e, r, n) {
    const i = e.points, { count: o, start: s, ilen: a } = X1(i, r, n), { move: l = true, reverse: c } = n || {};
    let u = 0, f = 0, d, h, g, p, y, b;
    const x = (C) => (s + (c ? a - C : C)) % o, S = () => {
      p !== y && (t10.lineTo(u, y), t10.lineTo(u, p), t10.lineTo(u, b));
    };
    for (l && (h = i[x(0)], t10.moveTo(h.x, h.y)), d = 0; d <= a; ++d) {
      if (h = i[x(d)], h.skip)
        continue;
      const C = h.x, _ = h.y, L = C | 0;
      L === g ? (_ < p ? p = _ : _ > y && (y = _), u = (f * u + C) / ++f) : (S(), t10.lineTo(C, _), g = L, f = 0, p = y = _), b = _;
    }
    S();
  }
  function Tc(t10) {
    const e = t10.options, r = e.borderDash && e.borderDash.length;
    return !t10._decimated && !t10._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !r ? l6 : a6;
  }
  function c6(t10) {
    return t10.stepped ? lv : t10.tension || t10.cubicInterpolationMode === "monotone" ? cv : Sn;
  }
  function u6(t10, e, r, n) {
    let i = e._path;
    i || (i = e._path = new Path2D(), e.path(i, r, n) && i.closePath()), Y1(t10, e.options), t10.stroke(i);
  }
  function f6(t10, e, r, n) {
    const { segments: i, options: o } = e, s = Tc(e);
    for (const a of i)
      Y1(t10, o, a.style), t10.beginPath(), s(t10, e, a, {
        start: r,
        end: r + n - 1
      }) && t10.closePath(), t10.stroke();
  }
  const d6 = typeof Path2D == "function";
  function h6(t10, e, r, n) {
    d6 && !e.options.segment ? u6(t10, e, r, n) : f6(t10, e, r, n);
  }
  class Xr extends Ur {
    constructor(e) {
      super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, e && Object.assign(this, e);
    }
    updateControlPoints(e, r) {
      const n = this.options;
      if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
        const i = n.spanGaps ? this._loop : this._fullLoop;
        ev(this._points, n, e, i, r), this._pointsUpdated = true;
      }
    }
    set points(e) {
      this._points = e, delete this._segments, delete this._path, this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = gv(this, this.options.segment));
    }
    first() {
      const e = this.segments, r = this.points;
      return e.length && r[e[0].start];
    }
    last() {
      const e = this.segments, r = this.points, n = e.length;
      return n && r[e[n - 1].end];
    }
    interpolate(e, r) {
      const n = this.options, i = e[r], o = this.points, s = M1(this, {
        property: r,
        start: i,
        end: i
      });
      if (!s.length)
        return;
      const a = [], l = c6(n);
      let c, u;
      for (c = 0, u = s.length; c < u; ++c) {
        const { start: f, end: d } = s[c], h = o[f], g = o[d];
        if (h === g) {
          a.push(h);
          continue;
        }
        const p = Math.abs((i - h[r]) / (g[r] - h[r])), y = l(h, g, p, n.stepped);
        y[r] = e[r], a.push(y);
      }
      return a.length === 1 ? a[0] : a;
    }
    pathSegment(e, r, n) {
      return Tc(this)(e, this, r, n);
    }
    path(e, r, n) {
      const i = this.segments, o = Tc(this);
      let s = this._loop;
      r = r || 0, n = n || this.points.length - r;
      for (const a of i)
        s &= o(e, this, a, {
          start: r,
          end: r + n - 1
        });
      return !!s;
    }
    draw(e, r, n, i) {
      const o = this.options || {};
      (this.points || []).length && o.borderWidth && (e.save(), h6(e, this, n, i), e.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
    }
  }
  ge(Xr, "id", "line"), ge(Xr, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  }), ge(Xr, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  }), ge(Xr, "descriptors", {
    _scriptable: true,
    _indexable: (e) => e !== "borderDash" && e !== "fill"
  });
  function hh(t10, e, r, n) {
    const i = t10.options, { [r]: o } = t10.getProps([
      r
    ], n);
    return Math.abs(e - o) < i.radius + i.hitRadius;
  }
  class Ns extends Ur {
    constructor(r) {
      super();
      ge(this, "parsed");
      ge(this, "skip");
      ge(this, "stop");
      this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, r && Object.assign(this, r);
    }
    inRange(r, n, i) {
      const o = this.options, { x: s, y: a } = this.getProps([
        "x",
        "y"
      ], i);
      return Math.pow(r - s, 2) + Math.pow(n - a, 2) < Math.pow(o.hitRadius + o.radius, 2);
    }
    inXRange(r, n) {
      return hh(this, r, "x", n);
    }
    inYRange(r, n) {
      return hh(this, r, "y", n);
    }
    getCenterPoint(r) {
      const { x: n, y: i } = this.getProps([
        "x",
        "y"
      ], r);
      return {
        x: n,
        y: i
      };
    }
    size(r) {
      r = r || this.options || {};
      let n = r.radius || 0;
      n = Math.max(n, n && r.hoverRadius || 0);
      const i = n && r.borderWidth || 0;
      return (n + i) * 2;
    }
    draw(r, n) {
      const i = this.options;
      this.skip || i.radius < 0.1 || !Mr(this, n, this.size(i) / 2) || (r.strokeStyle = i.borderColor, r.lineWidth = i.borderWidth, r.fillStyle = i.backgroundColor, Sc(r, i, this.x, this.y));
    }
    getRange() {
      const r = this.options || {};
      return r.radius + r.hitRadius;
    }
  }
  ge(Ns, "id", "point"), /**
  * @type {any}
  */
  ge(Ns, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  }), /**
  * @type {any}
  */
  ge(Ns, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function J1(t10, e) {
    const { x: r, y: n, base: i, width: o, height: s } = t10.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], e);
    let a, l, c, u, f;
    return t10.horizontal ? (f = s / 2, a = Math.min(r, i), l = Math.max(r, i), c = n - f, u = n + f) : (f = o / 2, a = r - f, l = r + f, c = Math.min(n, i), u = Math.max(n, i)), {
      left: a,
      top: c,
      right: l,
      bottom: u
    };
  }
  function Jr(t10, e, r, n) {
    return t10 ? 0 : ht(e, r, n);
  }
  function p6(t10, e, r) {
    const n = t10.options.borderWidth, i = t10.borderSkipped, o = x1(n);
    return {
      t: Jr(i.top, o.top, 0, r),
      r: Jr(i.right, o.right, 0, e),
      b: Jr(i.bottom, o.bottom, 0, r),
      l: Jr(i.left, o.left, 0, e)
    };
  }
  function g6(t10, e, r) {
    const { enableBorderRadius: n } = t10.getProps([
      "enableBorderRadius"
    ]), i = t10.options.borderRadius, o = Tn(i), s = Math.min(e, r), a = t10.borderSkipped, l = n || Ie(i);
    return {
      topLeft: Jr(!l || a.top || a.left, o.topLeft, 0, s),
      topRight: Jr(!l || a.top || a.right, o.topRight, 0, s),
      bottomLeft: Jr(!l || a.bottom || a.left, o.bottomLeft, 0, s),
      bottomRight: Jr(!l || a.bottom || a.right, o.bottomRight, 0, s)
    };
  }
  function m6(t10) {
    const e = J1(t10), r = e.right - e.left, n = e.bottom - e.top, i = p6(t10, r / 2, n / 2), o = g6(t10, r / 2, n / 2);
    return {
      outer: {
        x: e.left,
        y: e.top,
        w: r,
        h: n,
        radius: o
      },
      inner: {
        x: e.left + i.l,
        y: e.top + i.t,
        w: r - i.l - i.r,
        h: n - i.t - i.b,
        radius: {
          topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)),
          topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)),
          bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)),
          bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r))
        }
      }
    };
  }
  function Bl(t10, e, r, n) {
    const i = e === null, o = r === null, a = t10 && !(i && o) && J1(t10, n);
    return a && (i || Rr(e, a.left, a.right)) && (o || Rr(r, a.top, a.bottom));
  }
  function y6(t10) {
    return t10.topLeft || t10.topRight || t10.bottomLeft || t10.bottomRight;
  }
  function b6(t10, e) {
    t10.rect(e.x, e.y, e.w, e.h);
  }
  function Fl(t10, e, r = {}) {
    const n = t10.x !== r.x ? -e : 0, i = t10.y !== r.y ? -e : 0, o = (t10.x + t10.w !== r.x + r.w ? e : 0) - n, s = (t10.y + t10.h !== r.y + r.h ? e : 0) - i;
    return {
      x: t10.x + n,
      y: t10.y + i,
      w: t10.w + o,
      h: t10.h + s,
      radius: t10.radius
    };
  }
  class Ls extends Ur {
    constructor(e) {
      super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
    }
    draw(e) {
      const { inflateAmount: r, options: { borderColor: n, backgroundColor: i } } = this, { inner: o, outer: s } = m6(this), a = y6(s.radius) ? wo : b6;
      e.save(), (s.w !== o.w || s.h !== o.h) && (e.beginPath(), a(e, Fl(s, r, o)), e.clip(), a(e, Fl(o, -r, s)), e.fillStyle = n, e.fill("evenodd")), e.beginPath(), a(e, Fl(o, r)), e.fillStyle = i, e.fill(), e.restore();
    }
    inRange(e, r, n) {
      return Bl(this, e, r, n);
    }
    inXRange(e, r) {
      return Bl(this, e, null, r);
    }
    inYRange(e, r) {
      return Bl(this, null, e, r);
    }
    getCenterPoint(e) {
      const { x: r, y: n, base: i, horizontal: o } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], e);
      return {
        x: o ? (r + i) / 2 : r,
        y: o ? n : (n + i) / 2
      };
    }
    getRange(e) {
      return e === "x" ? this.width / 2 : this.height / 2;
    }
  }
  ge(Ls, "id", "bar"), ge(Ls, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  }), ge(Ls, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var v6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement: Qi,
    BarElement: Ls,
    LineElement: Xr,
    PointElement: Ns
  });
  const Ic = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ], ph = /* @__PURE__ */ Ic.map((t10) => t10.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function Q1(t10) {
    return Ic[t10 % Ic.length];
  }
  function G1(t10) {
    return ph[t10 % ph.length];
  }
  function A6(t10, e) {
    return t10.borderColor = Q1(e), t10.backgroundColor = G1(e), ++e;
  }
  function w6(t10, e) {
    return t10.backgroundColor = t10.data.map(() => Q1(e++)), e;
  }
  function x6(t10, e) {
    return t10.backgroundColor = t10.data.map(() => G1(e++)), e;
  }
  function _6(t10) {
    let e = 0;
    return (r, n) => {
      const i = t10.getDatasetMeta(n).controller;
      i instanceof Cn ? e = w6(r, e) : i instanceof lo ? e = x6(r, e) : i && (e = A6(r, e));
    };
  }
  function gh(t10) {
    let e;
    for (e in t10)
      if (t10[e].borderColor || t10[e].backgroundColor)
        return true;
    return false;
  }
  function S6(t10) {
    return t10 && (t10.borderColor || t10.backgroundColor);
  }
  var E6 = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(t10, e, r) {
      if (!r.enabled)
        return;
      const { data: { datasets: n }, options: i } = t10.config, { elements: o } = i;
      if (!r.forceOverride && (gh(n) || S6(i) || o && gh(o)))
        return;
      const s = _6(t10);
      n.forEach(s);
    }
  };
  function k6(t10, e, r, n, i) {
    const o = i.samples || n;
    if (o >= r)
      return t10.slice(e, e + r);
    const s = [], a = (r - 2) / (o - 2);
    let l = 0;
    const c = e + r - 1;
    let u = e, f, d, h, g, p;
    for (s[l++] = t10[u], f = 0; f < o - 2; f++) {
      let y = 0, b = 0, x;
      const S = Math.floor((f + 1) * a) + 1 + e, C = Math.min(Math.floor((f + 2) * a) + 1, r) + e, _ = C - S;
      for (x = S; x < C; x++)
        y += t10[x].x, b += t10[x].y;
      y /= _, b /= _;
      const L = Math.floor(f * a) + 1 + e, F = Math.min(Math.floor((f + 1) * a) + 1, r) + e, { x: V, y: W } = t10[u];
      for (h = g = -1, x = L; x < F; x++)
        g = 0.5 * Math.abs((V - y) * (t10[x].y - W) - (V - t10[x].x) * (b - W)), g > h && (h = g, d = t10[x], p = x);
      s[l++] = d, u = p;
    }
    return s[l++] = t10[c], s;
  }
  function C6(t10, e, r, n) {
    let i = 0, o = 0, s, a, l, c, u, f, d, h, g, p;
    const y = [], b = e + r - 1, x = t10[e].x, C = t10[b].x - x;
    for (s = e; s < e + r; ++s) {
      a = t10[s], l = (a.x - x) / C * n, c = a.y;
      const _ = l | 0;
      if (_ === u)
        c < g ? (g = c, f = s) : c > p && (p = c, d = s), i = (o * i + a.x) / ++o;
      else {
        const L = s - 1;
        if (!Re(f) && !Re(d)) {
          const F = Math.min(f, d), V = Math.max(f, d);
          F !== h && F !== L && y.push({
            ...t10[F],
            x: i
          }), V !== h && V !== L && y.push({
            ...t10[V],
            x: i
          });
        }
        s > 0 && L !== h && y.push(t10[L]), y.push(a), u = _, o = 0, g = p = c, f = d = h = s;
      }
    }
    return y;
  }
  function Z1(t10) {
    if (t10._decimated) {
      const e = t10._data;
      delete t10._decimated, delete t10._data, Object.defineProperty(t10, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: e
      });
    }
  }
  function mh(t10) {
    t10.data.datasets.forEach((e) => {
      Z1(e);
    });
  }
  function T6(t10, e) {
    const r = e.length;
    let n = 0, i;
    const { iScale: o } = t10, { min: s, max: a, minDefined: l, maxDefined: c } = o.getUserBounds();
    return l && (n = ht(Dr(e, o.axis, s).lo, 0, r - 1)), c ? i = ht(Dr(e, o.axis, a).hi + 1, n, r) - n : i = r - n, {
      start: n,
      count: i
    };
  }
  var I6 = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (t10, e, r) => {
      if (!r.enabled) {
        mh(t10);
        return;
      }
      const n = t10.width;
      t10.data.datasets.forEach((i, o) => {
        const { _data: s, indexAxis: a } = i, l = t10.getDatasetMeta(o), c = s || i.data;
        if (Xi([
          a,
          t10.options.indexAxis
        ]) === "y" || !l.controller.supportsDecimation)
          return;
        const u = t10.scales[l.xAxisID];
        if (u.type !== "linear" && u.type !== "time" || t10.options.parsing)
          return;
        let { start: f, count: d } = T6(l, c);
        const h = r.threshold || 4 * n;
        if (d <= h) {
          Z1(i);
          return;
        }
        Re(s) && (i._data = c, delete i.data, Object.defineProperty(i, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(p) {
            this._data = p;
          }
        }));
        let g;
        switch (r.algorithm) {
          case "lttb":
            g = k6(c, f, d, n, r);
            break;
          case "min-max":
            g = C6(c, f, d, n);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${r.algorithm}'`);
        }
        i._decimated = g;
      });
    },
    destroy(t10) {
      mh(t10);
    }
  };
  function O6(t10, e, r) {
    const n = t10.segments, i = t10.points, o = e.points, s = [];
    for (const a of n) {
      let { start: l, end: c } = a;
      c = Fu(l, c, i);
      const u = Oc(r, i[l], i[c], a.loop);
      if (!e.segments) {
        s.push({
          source: a,
          target: u,
          start: i[l],
          end: i[c]
        });
        continue;
      }
      const f = M1(e, u);
      for (const d of f) {
        const h = Oc(r, o[d.start], o[d.end], d.loop), g = D1(a, i, h);
        for (const p of g)
          s.push({
            source: p,
            target: d,
            start: {
              [r]: yh(u, h, "start", Math.max)
            },
            end: {
              [r]: yh(u, h, "end", Math.min)
            }
          });
      }
    }
    return s;
  }
  function Oc(t10, e, r, n) {
    if (n)
      return;
    let i = e[t10], o = r[t10];
    return t10 === "angle" && (i = Lt(i), o = Lt(o)), {
      property: t10,
      start: i,
      end: o
    };
  }
  function P6(t10, e) {
    const { x: r = null, y: n = null } = t10 || {}, i = e.points, o = [];
    return e.segments.forEach(({ start: s, end: a }) => {
      a = Fu(s, a, i);
      const l = i[s], c = i[a];
      n !== null ? (o.push({
        x: l.x,
        y: n
      }), o.push({
        x: c.x,
        y: n
      })) : r !== null && (o.push({
        x: r,
        y: l.y
      }), o.push({
        x: r,
        y: c.y
      }));
    }), o;
  }
  function Fu(t10, e, r) {
    for (; e > t10; e--) {
      const n = r[e];
      if (!isNaN(n.x) && !isNaN(n.y))
        break;
    }
    return e;
  }
  function yh(t10, e, r, n) {
    return t10 && e ? n(t10[r], e[r]) : t10 ? t10[r] : e ? e[r] : 0;
  }
  function $1(t10, e) {
    let r = [], n = false;
    return Ge(t10) ? (n = true, r = t10) : r = P6(t10, e), r.length ? new Xr({
      points: r,
      options: {
        tension: 0
      },
      _loop: n,
      _fullLoop: n
    }) : null;
  }
  function bh(t10) {
    return t10 && t10.fill !== false;
  }
  function R6(t10, e, r) {
    let i = t10[e].fill;
    const o = [
      e
    ];
    let s;
    if (!r)
      return i;
    for (; i !== false && o.indexOf(i) === -1; ) {
      if (!ot(i))
        return i;
      if (s = t10[i], !s)
        return false;
      if (s.visible)
        return i;
      o.push(i), i = s.fill;
    }
    return false;
  }
  function D6(t10, e, r) {
    const n = B6(t10);
    if (Ie(n))
      return isNaN(n.value) ? false : n;
    let i = parseFloat(n);
    return ot(i) && Math.floor(i) === i ? M6(n[0], e, i, r) : [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(n) >= 0 && n;
  }
  function M6(t10, e, r, n) {
    return (t10 === "-" || t10 === "+") && (r = e + r), r === e || r < 0 || r >= n ? false : r;
  }
  function N6(t10, e) {
    let r = null;
    return t10 === "start" ? r = e.bottom : t10 === "end" ? r = e.top : Ie(t10) ? r = e.getPixelForValue(t10.value) : e.getBasePixel && (r = e.getBasePixel()), r;
  }
  function L6(t10, e, r) {
    let n;
    return t10 === "start" ? n = r : t10 === "end" ? n = e.options.reverse ? e.min : e.max : Ie(t10) ? n = t10.value : n = e.getBaseValue(), n;
  }
  function B6(t10) {
    const e = t10.options, r = e.fill;
    let n = ke(r && r.target, r);
    return n === void 0 && (n = !!e.backgroundColor), n === false || n === null ? false : n === true ? "origin" : n;
  }
  function F6(t10) {
    const { scale: e, index: r, line: n } = t10, i = [], o = n.segments, s = n.points, a = j6(e, r);
    a.push($1({
      x: null,
      y: e.bottom
    }, n));
    for (let l = 0; l < o.length; l++) {
      const c = o[l];
      for (let u = c.start; u <= c.end; u++)
        W6(i, s[u], a);
    }
    return new Xr({
      points: i,
      options: {}
    });
  }
  function j6(t10, e) {
    const r = [], n = t10.getMatchingVisibleMetas("line");
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      if (o.index === e)
        break;
      o.hidden || r.unshift(o.dataset);
    }
    return r;
  }
  function W6(t10, e, r) {
    const n = [];
    for (let i = 0; i < r.length; i++) {
      const o = r[i], { first: s, last: a, point: l } = U6(o, e, "x");
      if (!(!l || s && a)) {
        if (s)
          n.unshift(l);
        else if (t10.push(l), !a)
          break;
      }
    }
    t10.push(...n);
  }
  function U6(t10, e, r) {
    const n = t10.interpolate(e, r);
    if (!n)
      return {};
    const i = n[r], o = t10.segments, s = t10.points;
    let a = false, l = false;
    for (let c = 0; c < o.length; c++) {
      const u = o[c], f = s[u.start][r], d = s[u.end][r];
      if (Rr(i, f, d)) {
        a = i === f, l = i === d;
        break;
      }
    }
    return {
      first: a,
      last: l,
      point: n
    };
  }
  class eg {
    constructor(e) {
      this.x = e.x, this.y = e.y, this.radius = e.radius;
    }
    pathSegment(e, r, n) {
      const { x: i, y: o, radius: s } = this;
      return r = r || {
        start: 0,
        end: Ze
      }, e.arc(i, o, s, r.end, r.start, true), !n.bounds;
    }
    interpolate(e) {
      const { x: r, y: n, radius: i } = this, o = e.angle;
      return {
        x: r + Math.cos(o) * i,
        y: n + Math.sin(o) * i,
        angle: o
      };
    }
  }
  function z6(t10) {
    const { chart: e, fill: r, line: n } = t10;
    if (ot(r))
      return V6(e, r);
    if (r === "stack")
      return F6(t10);
    if (r === "shape")
      return true;
    const i = q6(t10);
    return i instanceof eg ? i : $1(i, n);
  }
  function V6(t10, e) {
    const r = t10.getDatasetMeta(e);
    return r && t10.isDatasetVisible(e) ? r.dataset : null;
  }
  function q6(t10) {
    return (t10.scale || {}).getPointPositionForValue ? K6(t10) : H6(t10);
  }
  function H6(t10) {
    const { scale: e = {}, fill: r } = t10, n = N6(r, e);
    if (ot(n)) {
      const i = e.isHorizontal();
      return {
        x: i ? n : null,
        y: i ? null : n
      };
    }
    return null;
  }
  function K6(t10) {
    const { scale: e, fill: r } = t10, n = e.options, i = e.getLabels().length, o = n.reverse ? e.max : e.min, s = L6(r, e, o), a = [];
    if (n.grid.circular) {
      const l = e.getPointPositionForValue(0, o);
      return new eg({
        x: l.x,
        y: l.y,
        radius: e.getDistanceFromCenterForValue(s)
      });
    }
    for (let l = 0; l < i; ++l)
      a.push(e.getPointPositionForValue(l, s));
    return a;
  }
  function jl(t10, e, r) {
    const n = z6(e), { line: i, scale: o, axis: s } = e, a = i.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: f = c } = l || {};
    n && i.points.length && (Da(t10, r), Y6(t10, {
      line: i,
      target: n,
      above: u,
      below: f,
      area: r,
      scale: o,
      axis: s
    }), Ma(t10));
  }
  function Y6(t10, e) {
    const { line: r, target: n, above: i, below: o, area: s, scale: a } = e, l = r._loop ? "angle" : e.axis;
    t10.save(), l === "x" && o !== i && (vh(t10, n, s.top), Ah(t10, {
      line: r,
      target: n,
      color: i,
      scale: a,
      property: l
    }), t10.restore(), t10.save(), vh(t10, n, s.bottom)), Ah(t10, {
      line: r,
      target: n,
      color: o,
      scale: a,
      property: l
    }), t10.restore();
  }
  function vh(t10, e, r) {
    const { segments: n, points: i } = e;
    let o = true, s = false;
    t10.beginPath();
    for (const a of n) {
      const { start: l, end: c } = a, u = i[l], f = i[Fu(l, c, i)];
      o ? (t10.moveTo(u.x, u.y), o = false) : (t10.lineTo(u.x, r), t10.lineTo(u.x, u.y)), s = !!e.pathSegment(t10, a, {
        move: s
      }), s ? t10.closePath() : t10.lineTo(f.x, r);
    }
    t10.lineTo(e.first().x, r), t10.closePath(), t10.clip();
  }
  function Ah(t10, e) {
    const { line: r, target: n, property: i, color: o, scale: s } = e, a = O6(r, n, i);
    for (const { source: l, target: c, start: u, end: f } of a) {
      const { style: { backgroundColor: d = o } = {} } = l, h = n !== true;
      t10.save(), t10.fillStyle = d, X6(t10, s, h && Oc(i, u, f)), t10.beginPath();
      const g = !!r.pathSegment(t10, l);
      let p;
      if (h) {
        g ? t10.closePath() : wh(t10, n, f, i);
        const y = !!n.pathSegment(t10, c, {
          move: g,
          reverse: true
        });
        p = g && y, p || wh(t10, n, u, i);
      }
      t10.closePath(), t10.fill(p ? "evenodd" : "nonzero"), t10.restore();
    }
  }
  function X6(t10, e, r) {
    const { top: n, bottom: i } = e.chart.chartArea, { property: o, start: s, end: a } = r || {};
    o === "x" && (t10.beginPath(), t10.rect(s, n, a - s, i - n), t10.clip());
  }
  function wh(t10, e, r, n) {
    const i = e.interpolate(r, n);
    i && t10.lineTo(i.x, i.y);
  }
  var J6 = {
    id: "filler",
    afterDatasetsUpdate(t10, e, r) {
      const n = (t10.data.datasets || []).length, i = [];
      let o, s, a, l;
      for (s = 0; s < n; ++s)
        o = t10.getDatasetMeta(s), a = o.dataset, l = null, a && a.options && a instanceof Xr && (l = {
          visible: t10.isDatasetVisible(s),
          index: s,
          fill: D6(a, s, n),
          chart: t10,
          axis: o.controller.options.indexAxis,
          scale: o.vScale,
          line: a
        }), o.$filler = l, i.push(l);
      for (s = 0; s < n; ++s)
        l = i[s], !(!l || l.fill === false) && (l.fill = R6(i, s, r.propagate));
    },
    beforeDraw(t10, e, r) {
      const n = r.drawTime === "beforeDraw", i = t10.getSortedVisibleDatasetMetas(), o = t10.chartArea;
      for (let s = i.length - 1; s >= 0; --s) {
        const a = i[s].$filler;
        a && (a.line.updateControlPoints(o, a.axis), n && a.fill && jl(t10.ctx, a, o));
      }
    },
    beforeDatasetsDraw(t10, e, r) {
      if (r.drawTime !== "beforeDatasetsDraw")
        return;
      const n = t10.getSortedVisibleDatasetMetas();
      for (let i = n.length - 1; i >= 0; --i) {
        const o = n[i].$filler;
        bh(o) && jl(t10.ctx, o, t10.chartArea);
      }
    },
    beforeDatasetDraw(t10, e, r) {
      const n = e.meta.$filler;
      !bh(n) || r.drawTime !== "beforeDatasetDraw" || jl(t10.ctx, n, t10.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  const xh = (t10, e) => {
    let { boxHeight: r = e, boxWidth: n = e } = t10;
    return t10.usePointStyle && (r = Math.min(r, e), n = t10.pointStyleWidth || Math.min(n, e)), {
      boxWidth: n,
      boxHeight: r,
      itemHeight: Math.max(e, r)
    };
  }, Q6 = (t10, e) => t10 !== null && e !== null && t10.datasetIndex === e.datasetIndex && t10.index === e.index;
  class _h extends Ur {
    constructor(e) {
      super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
    }
    update(e, r, n) {
      this.maxWidth = e, this.maxHeight = r, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
    }
    buildLabels() {
      const e = this.options.labels || {};
      let r = Je(e.generateLabels, [
        this.chart
      ], this) || [];
      e.filter && (r = r.filter((n) => e.filter(n, this.chart.data))), e.sort && (r = r.sort((n, i) => e.sort(n, i, this.chart.data))), this.options.reverse && r.reverse(), this.legendItems = r;
    }
    fit() {
      const { options: e, ctx: r } = this;
      if (!e.display) {
        this.width = this.height = 0;
        return;
      }
      const n = e.labels, i = ft(n.font), o = i.size, s = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = xh(n, o);
      let c, u;
      r.font = i.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(s, o, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(s, i, a, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight);
    }
    _fitRows(e, r, n, i) {
      const { ctx: o, maxWidth: s, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
        0
      ], u = i + a;
      let f = e;
      o.textAlign = "left", o.textBaseline = "middle";
      let d = -1, h = -u;
      return this.legendItems.forEach((g, p) => {
        const y = n + r / 2 + o.measureText(g.text).width;
        (p === 0 || c[c.length - 1] + y + 2 * a > s) && (f += u, c[c.length - (p > 0 ? 0 : 1)] = 0, h += u, d++), l[p] = {
          left: 0,
          top: h,
          row: d,
          width: y,
          height: i
        }, c[c.length - 1] += y + a;
      }), f;
    }
    _fitCols(e, r, n, i) {
      const { ctx: o, maxHeight: s, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = s - e;
      let f = a, d = 0, h = 0, g = 0, p = 0;
      return this.legendItems.forEach((y, b) => {
        const { itemWidth: x, itemHeight: S } = G6(n, r, o, y, i);
        b > 0 && h + S + 2 * a > u && (f += d + a, c.push({
          width: d,
          height: h
        }), g += d + a, p++, d = h = 0), l[b] = {
          left: g,
          top: h,
          col: p,
          width: x,
          height: S
        }, d = Math.max(d, x), h += S + a;
      }), f += d, c.push({
        width: d,
        height: h
      }), f;
    }
    adjustHitBoxes() {
      if (!this.options.display)
        return;
      const e = this._computeTitleHeight(), { legendHitBoxes: r, options: { align: n, labels: { padding: i }, rtl: o } } = this, s = ai(o, this.left, this.width);
      if (this.isHorizontal()) {
        let a = 0, l = At(n, this.left + i, this.right - this.lineWidths[a]);
        for (const c of r)
          a !== c.row && (a = c.row, l = At(n, this.left + i, this.right - this.lineWidths[a])), c.top += this.top + e + i, c.left = s.leftForLtr(s.x(l), c.width), l += c.width + i;
      } else {
        let a = 0, l = At(n, this.top + e + i, this.bottom - this.columnSizes[a].height);
        for (const c of r)
          c.col !== a && (a = c.col, l = At(n, this.top + e + i, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + i, c.left = s.leftForLtr(s.x(c.left), c.width), l += c.height + i;
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const e = this.ctx;
        Da(e, this), this._draw(), Ma(e);
      }
    }
    _draw() {
      const { options: e, columnSizes: r, lineWidths: n, ctx: i } = this, { align: o, labels: s } = e, a = st.color, l = ai(e.rtl, this.left, this.width), c = ft(s.font), { padding: u } = s, f = c.size, d = f / 2;
      let h;
      this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = 0.5, i.font = c.string;
      const { boxWidth: g, boxHeight: p, itemHeight: y } = xh(s, f), b = function(L, F, V) {
        if (isNaN(g) || g <= 0 || isNaN(p) || p < 0)
          return;
        i.save();
        const W = ke(V.lineWidth, 1);
        if (i.fillStyle = ke(V.fillStyle, a), i.lineCap = ke(V.lineCap, "butt"), i.lineDashOffset = ke(V.lineDashOffset, 0), i.lineJoin = ke(V.lineJoin, "miter"), i.lineWidth = W, i.strokeStyle = ke(V.strokeStyle, a), i.setLineDash(ke(V.lineDash, [])), s.usePointStyle) {
          const X = {
            radius: p * Math.SQRT2 / 2,
            pointStyle: V.pointStyle,
            rotation: V.rotation,
            borderWidth: W
          }, G = l.xPlus(L, g / 2), ie = F + d;
          w1(i, X, G, ie, s.pointStyleWidth && g);
        } else {
          const X = F + Math.max((f - p) / 2, 0), G = l.leftForLtr(L, g), ie = Tn(V.borderRadius);
          i.beginPath(), Object.values(ie).some((P10) => P10 !== 0) ? wo(i, {
            x: G,
            y: X,
            w: g,
            h: p,
            radius: ie
          }) : i.rect(G, X, g, p), i.fill(), W !== 0 && i.stroke();
        }
        i.restore();
      }, x = function(L, F, V) {
        Fn(i, V.text, L, F + y / 2, c, {
          strikethrough: V.hidden,
          textAlign: l.textAlign(V.textAlign)
        });
      }, S = this.isHorizontal(), C = this._computeTitleHeight();
      S ? h = {
        x: At(o, this.left + u, this.right - n[0]),
        y: this.top + u + C,
        line: 0
      } : h = {
        x: this.left + u,
        y: At(o, this.top + C + u, this.bottom - r[0].height),
        line: 0
      }, O1(this.ctx, e.textDirection);
      const _ = y + u;
      this.legendItems.forEach((L, F) => {
        i.strokeStyle = L.fontColor, i.fillStyle = L.fontColor;
        const V = i.measureText(L.text).width, W = l.textAlign(L.textAlign || (L.textAlign = s.textAlign)), X = g + d + V;
        let G = h.x, ie = h.y;
        l.setWidth(this.width), S ? F > 0 && G + X + u > this.right && (ie = h.y += _, h.line++, G = h.x = At(o, this.left + u, this.right - n[h.line])) : F > 0 && ie + _ > this.bottom && (G = h.x = G + r[h.line].width + u, h.line++, ie = h.y = At(o, this.top + C + u, this.bottom - r[h.line].height));
        const P10 = l.x(G);
        if (b(P10, ie, L), G = b2(W, G + g + d, S ? G + X : this.right, e.rtl), x(l.x(G), ie, L), S)
          h.x += X + u;
        else if (typeof L.text != "string") {
          const z10 = c.lineHeight;
          h.y += tg(L, z10) + u;
        } else
          h.y += _;
      }), P1(this.ctx, e.textDirection);
    }
    drawTitle() {
      const e = this.options, r = e.title, n = ft(r.font), i = Et(r.padding);
      if (!r.display)
        return;
      const o = ai(e.rtl, this.left, this.width), s = this.ctx, a = r.position, l = n.size / 2, c = i.top + l;
      let u, f = this.left, d = this.width;
      if (this.isHorizontal())
        d = Math.max(...this.lineWidths), u = this.top + c, f = At(e.align, f, this.right - d);
      else {
        const g = this.columnSizes.reduce((p, y) => Math.max(p, y.height), 0);
        u = c + At(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight());
      }
      const h = At(a, f, f + d);
      s.textAlign = o.textAlign(Ou(a)), s.textBaseline = "middle", s.strokeStyle = r.color, s.fillStyle = r.color, s.font = n.string, Fn(s, r.text, h, u, n);
    }
    _computeTitleHeight() {
      const e = this.options.title, r = ft(e.font), n = Et(e.padding);
      return e.display ? r.lineHeight + n.height : 0;
    }
    _getLegendItemAt(e, r) {
      let n, i, o;
      if (Rr(e, this.left, this.right) && Rr(r, this.top, this.bottom)) {
        for (o = this.legendHitBoxes, n = 0; n < o.length; ++n)
          if (i = o[n], Rr(e, i.left, i.left + i.width) && Rr(r, i.top, i.top + i.height))
            return this.legendItems[n];
      }
      return null;
    }
    handleEvent(e) {
      const r = this.options;
      if (!e5(e.type, r))
        return;
      const n = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const i = this._hoveredItem, o = Q6(i, n);
        i && !o && Je(r.onLeave, [
          e,
          i,
          this
        ], this), this._hoveredItem = n, n && !o && Je(r.onHover, [
          e,
          n,
          this
        ], this);
      } else
        n && Je(r.onClick, [
          e,
          n,
          this
        ], this);
    }
  }
  function G6(t10, e, r, n, i) {
    const o = Z6(n, t10, e, r), s = $6(i, n, e.lineHeight);
    return {
      itemWidth: o,
      itemHeight: s
    };
  }
  function Z6(t10, e, r, n) {
    let i = t10.text;
    return i && typeof i != "string" && (i = i.reduce((o, s) => o.length > s.length ? o : s)), e + r.size / 2 + n.measureText(i).width;
  }
  function $6(t10, e, r) {
    let n = t10;
    return typeof e.text != "string" && (n = tg(e, r)), n;
  }
  function tg(t10, e) {
    const r = t10.text ? t10.text.length : 0;
    return e * r;
  }
  function e5(t10, e) {
    return !!((t10 === "mousemove" || t10 === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t10 === "click" || t10 === "mouseup"));
  }
  var t5 = {
    id: "legend",
    _element: _h,
    start(t10, e, r) {
      const n = t10.legend = new _h({
        ctx: t10.ctx,
        options: r,
        chart: t10
      });
      _t.configure(t10, n, r), _t.addBox(t10, n);
    },
    stop(t10) {
      _t.removeBox(t10, t10.legend), delete t10.legend;
    },
    beforeUpdate(t10, e, r) {
      const n = t10.legend;
      _t.configure(t10, n, r), n.options = r;
    },
    afterUpdate(t10) {
      const e = t10.legend;
      e.buildLabels(), e.adjustHitBoxes();
    },
    afterEvent(t10, e) {
      e.replay || t10.legend.handleEvent(e.event);
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(t10, e, r) {
        const n = e.datasetIndex, i = r.chart;
        i.isDatasetVisible(n) ? (i.hide(n), e.hidden = true) : (i.show(n), e.hidden = false);
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (t10) => t10.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(t10) {
          const e = t10.data.datasets, { labels: { usePointStyle: r, pointStyle: n, textAlign: i, color: o, useBorderRadius: s, borderRadius: a } } = t10.legend.options;
          return t10._getSortedDatasetMetas().map((l) => {
            const c = l.controller.getStyle(r ? 0 : void 0), u = Et(c.borderWidth);
            return {
              text: e[l.index].label,
              fillStyle: c.backgroundColor,
              fontColor: o,
              hidden: !l.visible,
              lineCap: c.borderCapStyle,
              lineDash: c.borderDash,
              lineDashOffset: c.borderDashOffset,
              lineJoin: c.borderJoinStyle,
              lineWidth: (u.width + u.height) / 4,
              strokeStyle: c.borderColor,
              pointStyle: n || c.pointStyle,
              rotation: c.rotation,
              textAlign: i || c.textAlign,
              borderRadius: s && (a || c.borderRadius),
              datasetIndex: l.index
            };
          }, this);
        }
      },
      title: {
        color: (t10) => t10.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (t10) => !t10.startsWith("on"),
      labels: {
        _scriptable: (t10) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(t10)
      }
    }
  };
  class ju extends Ur {
    constructor(e) {
      super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
    }
    update(e, r) {
      const n = this.options;
      if (this.left = 0, this.top = 0, !n.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = e, this.height = this.bottom = r;
      const i = Ge(n.text) ? n.text.length : 1;
      this._padding = Et(n.padding);
      const o = i * ft(n.font).lineHeight + this._padding.height;
      this.isHorizontal() ? this.height = o : this.width = o;
    }
    isHorizontal() {
      const e = this.options.position;
      return e === "top" || e === "bottom";
    }
    _drawArgs(e) {
      const { top: r, left: n, bottom: i, right: o, options: s } = this, a = s.align;
      let l = 0, c, u, f;
      return this.isHorizontal() ? (u = At(a, n, o), f = r + e, c = o - n) : (s.position === "left" ? (u = n + e, f = At(a, i, r), l = $e * -0.5) : (u = o - e, f = At(a, r, i), l = $e * 0.5), c = i - r), {
        titleX: u,
        titleY: f,
        maxWidth: c,
        rotation: l
      };
    }
    draw() {
      const e = this.ctx, r = this.options;
      if (!r.display)
        return;
      const n = ft(r.font), o = n.lineHeight / 2 + this._padding.top, { titleX: s, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(o);
      Fn(e, r.text, 0, 0, n, {
        color: r.color,
        maxWidth: l,
        rotation: c,
        textAlign: Ou(r.align),
        textBaseline: "middle",
        translation: [
          s,
          a
        ]
      });
    }
  }
  function r5(t10, e) {
    const r = new ju({
      ctx: t10.ctx,
      options: e,
      chart: t10
    });
    _t.configure(t10, r, e), _t.addBox(t10, r), t10.titleBlock = r;
  }
  var n5 = {
    id: "title",
    _element: ju,
    start(t10, e, r) {
      r5(t10, r);
    },
    stop(t10) {
      const e = t10.titleBlock;
      _t.removeBox(t10, e), delete t10.titleBlock;
    },
    beforeUpdate(t10, e, r) {
      const n = t10.titleBlock;
      _t.configure(t10, n, r), n.options = r;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  const fs = /* @__PURE__ */ new WeakMap();
  var i5 = {
    id: "subtitle",
    start(t10, e, r) {
      const n = new ju({
        ctx: t10.ctx,
        options: r,
        chart: t10
      });
      _t.configure(t10, n, r), _t.addBox(t10, n), fs.set(t10, n);
    },
    stop(t10) {
      _t.removeBox(t10, fs.get(t10)), fs.delete(t10);
    },
    beforeUpdate(t10, e, r) {
      const n = fs.get(t10);
      _t.configure(t10, n, r), n.options = r;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  const Gi = {
    average(t10) {
      if (!t10.length)
        return false;
      let e, r, n = 0, i = 0, o = 0;
      for (e = 0, r = t10.length; e < r; ++e) {
        const s = t10[e].element;
        if (s && s.hasValue()) {
          const a = s.tooltipPosition();
          n += a.x, i += a.y, ++o;
        }
      }
      return {
        x: n / o,
        y: i / o
      };
    },
    nearest(t10, e) {
      if (!t10.length)
        return false;
      let r = e.x, n = e.y, i = Number.POSITIVE_INFINITY, o, s, a;
      for (o = 0, s = t10.length; o < s; ++o) {
        const l = t10[o].element;
        if (l && l.hasValue()) {
          const c = l.getCenterPoint(), u = xc(e, c);
          u < i && (i = u, a = l);
        }
      }
      if (a) {
        const l = a.tooltipPosition();
        r = l.x, n = l.y;
      }
      return {
        x: r,
        y: n
      };
    }
  };
  function fr(t10, e) {
    return e && (Ge(e) ? Array.prototype.push.apply(t10, e) : t10.push(e)), t10;
  }
  function kr(t10) {
    return (typeof t10 == "string" || t10 instanceof String) && t10.indexOf(`
`) > -1 ? t10.split(`
`) : t10;
  }
  function o5(t10, e) {
    const { element: r, datasetIndex: n, index: i } = e, o = t10.getDatasetMeta(n).controller, { label: s, value: a } = o.getLabelAndValue(i);
    return {
      chart: t10,
      label: s,
      parsed: o.getParsed(i),
      raw: t10.data.datasets[n].data[i],
      formattedValue: a,
      dataset: o.getDataset(),
      dataIndex: i,
      datasetIndex: n,
      element: r
    };
  }
  function Sh(t10, e) {
    const r = t10.chart.ctx, { body: n, footer: i, title: o } = t10, { boxWidth: s, boxHeight: a } = e, l = ft(e.bodyFont), c = ft(e.titleFont), u = ft(e.footerFont), f = o.length, d = i.length, h = n.length, g = Et(e.padding);
    let p = g.height, y = 0, b = n.reduce((C, _) => C + _.before.length + _.lines.length + _.after.length, 0);
    if (b += t10.beforeBody.length + t10.afterBody.length, f && (p += f * c.lineHeight + (f - 1) * e.titleSpacing + e.titleMarginBottom), b) {
      const C = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
      p += h * C + (b - h) * l.lineHeight + (b - 1) * e.bodySpacing;
    }
    d && (p += e.footerMarginTop + d * u.lineHeight + (d - 1) * e.footerSpacing);
    let x = 0;
    const S = function(C) {
      y = Math.max(y, r.measureText(C).width + x);
    };
    return r.save(), r.font = c.string, Ve(t10.title, S), r.font = l.string, Ve(t10.beforeBody.concat(t10.afterBody), S), x = e.displayColors ? s + 2 + e.boxPadding : 0, Ve(n, (C) => {
      Ve(C.before, S), Ve(C.lines, S), Ve(C.after, S);
    }), x = 0, r.font = u.string, Ve(t10.footer, S), r.restore(), y += g.width, {
      width: y,
      height: p
    };
  }
  function s5(t10, e) {
    const { y: r, height: n } = e;
    return r < n / 2 ? "top" : r > t10.height - n / 2 ? "bottom" : "center";
  }
  function a5(t10, e, r, n) {
    const { x: i, width: o } = n, s = r.caretSize + r.caretPadding;
    if (t10 === "left" && i + o + s > e.width || t10 === "right" && i - o - s < 0)
      return true;
  }
  function l5(t10, e, r, n) {
    const { x: i, width: o } = r, { width: s, chartArea: { left: a, right: l } } = t10;
    let c = "center";
    return n === "center" ? c = i <= (a + l) / 2 ? "left" : "right" : i <= o / 2 ? c = "left" : i >= s - o / 2 && (c = "right"), a5(c, t10, e, r) && (c = "center"), c;
  }
  function Eh(t10, e, r) {
    const n = r.yAlign || e.yAlign || s5(t10, r);
    return {
      xAlign: r.xAlign || e.xAlign || l5(t10, e, r, n),
      yAlign: n
    };
  }
  function c5(t10, e) {
    let { x: r, width: n } = t10;
    return e === "right" ? r -= n : e === "center" && (r -= n / 2), r;
  }
  function u5(t10, e, r) {
    let { y: n, height: i } = t10;
    return e === "top" ? n += r : e === "bottom" ? n -= i + r : n -= i / 2, n;
  }
  function kh(t10, e, r, n) {
    const { caretSize: i, caretPadding: o, cornerRadius: s } = t10, { xAlign: a, yAlign: l } = r, c = i + o, { topLeft: u, topRight: f, bottomLeft: d, bottomRight: h } = Tn(s);
    let g = c5(e, a);
    const p = u5(e, l, c);
    return l === "center" ? a === "left" ? g += c : a === "right" && (g -= c) : a === "left" ? g -= Math.max(u, d) + i : a === "right" && (g += Math.max(f, h) + i), {
      x: ht(g, 0, n.width - e.width),
      y: ht(p, 0, n.height - e.height)
    };
  }
  function ds(t10, e, r) {
    const n = Et(r.padding);
    return e === "center" ? t10.x + t10.width / 2 : e === "right" ? t10.x + t10.width - n.right : t10.x + n.left;
  }
  function Ch(t10) {
    return fr([], kr(t10));
  }
  function f5(t10, e, r) {
    return fn(t10, {
      tooltip: e,
      tooltipItems: r,
      type: "tooltip"
    });
  }
  function Th(t10, e) {
    const r = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
    return r ? t10.override(r) : t10;
  }
  const rg = {
    beforeTitle: _r,
    title(t10) {
      if (t10.length > 0) {
        const e = t10[0], r = e.chart.data.labels, n = r ? r.length : 0;
        if (this && this.options && this.options.mode === "dataset")
          return e.dataset.label || "";
        if (e.label)
          return e.label;
        if (n > 0 && e.dataIndex < n)
          return r[e.dataIndex];
      }
      return "";
    },
    afterTitle: _r,
    beforeBody: _r,
    beforeLabel: _r,
    label(t10) {
      if (this && this.options && this.options.mode === "dataset")
        return t10.label + ": " + t10.formattedValue || t10.formattedValue;
      let e = t10.dataset.label || "";
      e && (e += ": ");
      const r = t10.formattedValue;
      return Re(r) || (e += r), e;
    },
    labelColor(t10) {
      const r = t10.chart.getDatasetMeta(t10.datasetIndex).controller.getStyle(t10.dataIndex);
      return {
        borderColor: r.borderColor,
        backgroundColor: r.backgroundColor,
        borderWidth: r.borderWidth,
        borderDash: r.borderDash,
        borderDashOffset: r.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(t10) {
      const r = t10.chart.getDatasetMeta(t10.datasetIndex).controller.getStyle(t10.dataIndex);
      return {
        pointStyle: r.pointStyle,
        rotation: r.rotation
      };
    },
    afterLabel: _r,
    afterBody: _r,
    beforeFooter: _r,
    footer: _r,
    afterFooter: _r
  };
  function Ct(t10, e, r, n) {
    const i = t10[e].call(r, n);
    return typeof i > "u" ? rg[e].call(r, n) : i;
  }
  var uc;
  let Ih = (uc = class extends Ur {
    constructor(e) {
      super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
    }
    initialize(e) {
      this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
    }
    _resolveAnimations() {
      const e = this._cachedAnimations;
      if (e)
        return e;
      const r = this.chart, n = this.options.setContext(this.getContext()), i = n.enabled && r.options.animation && n.animations, o = new N1(this.chart, i);
      return i._cacheable && (this._cachedAnimations = Object.freeze(o)), o;
    }
    getContext() {
      return this.$context || (this.$context = f5(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(e, r) {
      const { callbacks: n } = r, i = Ct(n, "beforeTitle", this, e), o = Ct(n, "title", this, e), s = Ct(n, "afterTitle", this, e);
      let a = [];
      return a = fr(a, kr(i)), a = fr(a, kr(o)), a = fr(a, kr(s)), a;
    }
    getBeforeBody(e, r) {
      return Ch(Ct(r.callbacks, "beforeBody", this, e));
    }
    getBody(e, r) {
      const { callbacks: n } = r, i = [];
      return Ve(e, (o) => {
        const s = {
          before: [],
          lines: [],
          after: []
        }, a = Th(n, o);
        fr(s.before, kr(Ct(a, "beforeLabel", this, o))), fr(s.lines, Ct(a, "label", this, o)), fr(s.after, kr(Ct(a, "afterLabel", this, o))), i.push(s);
      }), i;
    }
    getAfterBody(e, r) {
      return Ch(Ct(r.callbacks, "afterBody", this, e));
    }
    getFooter(e, r) {
      const { callbacks: n } = r, i = Ct(n, "beforeFooter", this, e), o = Ct(n, "footer", this, e), s = Ct(n, "afterFooter", this, e);
      let a = [];
      return a = fr(a, kr(i)), a = fr(a, kr(o)), a = fr(a, kr(s)), a;
    }
    _createItems(e) {
      const r = this._active, n = this.chart.data, i = [], o = [], s = [];
      let a = [], l, c;
      for (l = 0, c = r.length; l < c; ++l)
        a.push(o5(this.chart, r[l]));
      return e.filter && (a = a.filter((u, f, d) => e.filter(u, f, d, n))), e.itemSort && (a = a.sort((u, f) => e.itemSort(u, f, n))), Ve(a, (u) => {
        const f = Th(e.callbacks, u);
        i.push(Ct(f, "labelColor", this, u)), o.push(Ct(f, "labelPointStyle", this, u)), s.push(Ct(f, "labelTextColor", this, u));
      }), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = s, this.dataPoints = a, a;
    }
    update(e, r) {
      const n = this.options.setContext(this.getContext()), i = this._active;
      let o, s = [];
      if (!i.length)
        this.opacity !== 0 && (o = {
          opacity: 0
        });
      else {
        const a = Gi[n.position].call(this, i, this._eventPosition);
        s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
        const l = this._size = Sh(this, n), c = Object.assign({}, a, l), u = Eh(this.chart, n, c), f = kh(n, c, u, this.chart);
        this.xAlign = u.xAlign, this.yAlign = u.yAlign, o = {
          opacity: 1,
          x: f.x,
          y: f.y,
          width: l.width,
          height: l.height,
          caretX: a.x,
          caretY: a.y
        };
      }
      this._tooltipItems = s, this.$context = void 0, o && this._resolveAnimations().update(this, o), e && n.external && n.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay: r
      });
    }
    drawCaret(e, r, n, i) {
      const o = this.getCaretPosition(e, n, i);
      r.lineTo(o.x1, o.y1), r.lineTo(o.x2, o.y2), r.lineTo(o.x3, o.y3);
    }
    getCaretPosition(e, r, n) {
      const { xAlign: i, yAlign: o } = this, { caretSize: s, cornerRadius: a } = n, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: f } = Tn(a), { x: d, y: h } = e, { width: g, height: p } = r;
      let y, b, x, S, C, _;
      return o === "center" ? (C = h + p / 2, i === "left" ? (y = d, b = y - s, S = C + s, _ = C - s) : (y = d + g, b = y + s, S = C - s, _ = C + s), x = y) : (i === "left" ? b = d + Math.max(l, u) + s : i === "right" ? b = d + g - Math.max(c, f) - s : b = this.caretX, o === "top" ? (S = h, C = S - s, y = b - s, x = b + s) : (S = h + p, C = S + s, y = b + s, x = b - s), _ = S), {
        x1: y,
        x2: b,
        x3: x,
        y1: S,
        y2: C,
        y3: _
      };
    }
    drawTitle(e, r, n) {
      const i = this.title, o = i.length;
      let s, a, l;
      if (o) {
        const c = ai(n.rtl, this.x, this.width);
        for (e.x = ds(this, n.titleAlign, n), r.textAlign = c.textAlign(n.titleAlign), r.textBaseline = "middle", s = ft(n.titleFont), a = n.titleSpacing, r.fillStyle = n.titleColor, r.font = s.string, l = 0; l < o; ++l)
          r.fillText(i[l], c.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + a, l + 1 === o && (e.y += n.titleMarginBottom - a);
      }
    }
    _drawColorBox(e, r, n, i, o) {
      const s = this.labelColors[n], a = this.labelPointStyles[n], { boxHeight: l, boxWidth: c } = o, u = ft(o.bodyFont), f = ds(this, "left", o), d = i.x(f), h = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, g = r.y + h;
      if (o.usePointStyle) {
        const p = {
          radius: Math.min(c, l) / 2,
          pointStyle: a.pointStyle,
          rotation: a.rotation,
          borderWidth: 1
        }, y = i.leftForLtr(d, c) + c / 2, b = g + l / 2;
        e.strokeStyle = o.multiKeyBackground, e.fillStyle = o.multiKeyBackground, Sc(e, p, y, b), e.strokeStyle = s.borderColor, e.fillStyle = s.backgroundColor, Sc(e, p, y, b);
      } else {
        e.lineWidth = Ie(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, e.strokeStyle = s.borderColor, e.setLineDash(s.borderDash || []), e.lineDashOffset = s.borderDashOffset || 0;
        const p = i.leftForLtr(d, c), y = i.leftForLtr(i.xPlus(d, 1), c - 2), b = Tn(s.borderRadius);
        Object.values(b).some((x) => x !== 0) ? (e.beginPath(), e.fillStyle = o.multiKeyBackground, wo(e, {
          x: p,
          y: g,
          w: c,
          h: l,
          radius: b
        }), e.fill(), e.stroke(), e.fillStyle = s.backgroundColor, e.beginPath(), wo(e, {
          x: y,
          y: g + 1,
          w: c - 2,
          h: l - 2,
          radius: b
        }), e.fill()) : (e.fillStyle = o.multiKeyBackground, e.fillRect(p, g, c, l), e.strokeRect(p, g, c, l), e.fillStyle = s.backgroundColor, e.fillRect(y, g + 1, c - 2, l - 2));
      }
      e.fillStyle = this.labelTextColors[n];
    }
    drawBody(e, r, n) {
      const { body: i } = this, { bodySpacing: o, bodyAlign: s, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = n, f = ft(n.bodyFont);
      let d = f.lineHeight, h = 0;
      const g = ai(n.rtl, this.x, this.width), p = function(V) {
        r.fillText(V, g.x(e.x + h), e.y + d / 2), e.y += d + o;
      }, y = g.textAlign(s);
      let b, x, S, C, _, L, F;
      for (r.textAlign = s, r.textBaseline = "middle", r.font = f.string, e.x = ds(this, y, n), r.fillStyle = n.bodyColor, Ve(this.beforeBody, p), h = a && y !== "right" ? s === "center" ? c / 2 + u : c + 2 + u : 0, C = 0, L = i.length; C < L; ++C) {
        for (b = i[C], x = this.labelTextColors[C], r.fillStyle = x, Ve(b.before, p), S = b.lines, a && S.length && (this._drawColorBox(r, e, C, g, n), d = Math.max(f.lineHeight, l)), _ = 0, F = S.length; _ < F; ++_)
          p(S[_]), d = f.lineHeight;
        Ve(b.after, p);
      }
      h = 0, d = f.lineHeight, Ve(this.afterBody, p), e.y -= o;
    }
    drawFooter(e, r, n) {
      const i = this.footer, o = i.length;
      let s, a;
      if (o) {
        const l = ai(n.rtl, this.x, this.width);
        for (e.x = ds(this, n.footerAlign, n), e.y += n.footerMarginTop, r.textAlign = l.textAlign(n.footerAlign), r.textBaseline = "middle", s = ft(n.footerFont), r.fillStyle = n.footerColor, r.font = s.string, a = 0; a < o; ++a)
          r.fillText(i[a], l.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + n.footerSpacing;
      }
    }
    drawBackground(e, r, n, i) {
      const { xAlign: o, yAlign: s } = this, { x: a, y: l } = e, { width: c, height: u } = n, { topLeft: f, topRight: d, bottomLeft: h, bottomRight: g } = Tn(i.cornerRadius);
      r.fillStyle = i.backgroundColor, r.strokeStyle = i.borderColor, r.lineWidth = i.borderWidth, r.beginPath(), r.moveTo(a + f, l), s === "top" && this.drawCaret(e, r, n, i), r.lineTo(a + c - d, l), r.quadraticCurveTo(a + c, l, a + c, l + d), s === "center" && o === "right" && this.drawCaret(e, r, n, i), r.lineTo(a + c, l + u - g), r.quadraticCurveTo(a + c, l + u, a + c - g, l + u), s === "bottom" && this.drawCaret(e, r, n, i), r.lineTo(a + h, l + u), r.quadraticCurveTo(a, l + u, a, l + u - h), s === "center" && o === "left" && this.drawCaret(e, r, n, i), r.lineTo(a, l + f), r.quadraticCurveTo(a, l, a + f, l), r.closePath(), r.fill(), i.borderWidth > 0 && r.stroke();
    }
    _updateAnimationTarget(e) {
      const r = this.chart, n = this.$animations, i = n && n.x, o = n && n.y;
      if (i || o) {
        const s = Gi[e.position].call(this, this._active, this._eventPosition);
        if (!s)
          return;
        const a = this._size = Sh(this, e), l = Object.assign({}, s, this._size), c = Eh(r, e, l), u = kh(e, l, c, r);
        (i._to !== u.x || o._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, u));
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(e) {
      const r = this.options.setContext(this.getContext());
      let n = this.opacity;
      if (!n)
        return;
      this._updateAnimationTarget(r);
      const i = {
        width: this.width,
        height: this.height
      }, o = {
        x: this.x,
        y: this.y
      };
      n = Math.abs(n) < 1e-3 ? 0 : n;
      const s = Et(r.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      r.enabled && a && (e.save(), e.globalAlpha = n, this.drawBackground(o, e, i, r), O1(e, r.textDirection), o.y += s.top, this.drawTitle(o, e, r), this.drawBody(o, e, r), this.drawFooter(o, e, r), P1(e, r.textDirection), e.restore());
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(e, r) {
      const n = this._active, i = e.map(({ datasetIndex: a, index: l }) => {
        const c = this.chart.getDatasetMeta(a);
        if (!c)
          throw new Error("Cannot find a dataset at index " + a);
        return {
          datasetIndex: a,
          element: c.data[l],
          index: l
        };
      }), o = !na(n, i), s = this._positionChanged(i, r);
      (o || s) && (this._active = i, this._eventPosition = r, this._ignoreReplayEvents = true, this.update(true));
    }
    handleEvent(e, r, n = true) {
      if (r && this._ignoreReplayEvents)
        return false;
      this._ignoreReplayEvents = false;
      const i = this.options, o = this._active || [], s = this._getActiveElements(e, o, r, n), a = this._positionChanged(s, e), l = r || !na(s, o) || a;
      return l && (this._active = s, (i.enabled || i.external) && (this._eventPosition = {
        x: e.x,
        y: e.y
      }, this.update(true, r))), l;
    }
    _getActiveElements(e, r, n, i) {
      const o = this.options;
      if (e.type === "mouseout")
        return [];
      if (!i)
        return r;
      const s = this.chart.getElementsAtEventForMode(e, o.mode, o, n);
      return o.reverse && s.reverse(), s;
    }
    _positionChanged(e, r) {
      const { caretX: n, caretY: i, options: o } = this, s = Gi[o.position].call(this, e, r);
      return s !== false && (n !== s.x || i !== s.y);
    }
  }, ge(uc, "positioners", Gi), uc);
  var d5 = {
    id: "tooltip",
    _element: Ih,
    positioners: Gi,
    afterInit(t10, e, r) {
      r && (t10.tooltip = new Ih({
        chart: t10,
        options: r
      }));
    },
    beforeUpdate(t10, e, r) {
      t10.tooltip && t10.tooltip.initialize(r);
    },
    reset(t10, e, r) {
      t10.tooltip && t10.tooltip.initialize(r);
    },
    afterDraw(t10) {
      const e = t10.tooltip;
      if (e && e._willRender()) {
        const r = {
          tooltip: e
        };
        if (t10.notifyPlugins("beforeTooltipDraw", {
          ...r,
          cancelable: true
        }) === false)
          return;
        e.draw(t10.ctx), t10.notifyPlugins("afterTooltipDraw", r);
      }
    },
    afterEvent(t10, e) {
      if (t10.tooltip) {
        const r = e.replay;
        t10.tooltip.handleEvent(e.event, r, e.inChartArea) && (e.changed = true);
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (t10, e) => e.bodyFont.size,
      boxWidth: (t10, e) => e.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: rg
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (t10) => t10 !== "filter" && t10 !== "itemSort" && t10 !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  }, h5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: E6,
    Decimation: I6,
    Filler: J6,
    Legend: t5,
    SubTitle: i5,
    Title: n5,
    Tooltip: d5
  });
  const p5 = (t10, e, r, n) => (typeof e == "string" ? (r = t10.push(e) - 1, n.unshift({
    index: r,
    label: e
  })) : isNaN(e) && (r = null), r);
  function g5(t10, e, r, n) {
    const i = t10.indexOf(e);
    if (i === -1)
      return p5(t10, e, r, n);
    const o = t10.lastIndexOf(e);
    return i !== o ? r : i;
  }
  const m5 = (t10, e) => t10 === null ? null : ht(Math.round(t10), 0, e);
  function Oh(t10) {
    const e = this.getLabels();
    return t10 >= 0 && t10 < e.length ? e[t10] : t10;
  }
  class Pc extends Vn {
    constructor(e) {
      super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
    }
    init(e) {
      const r = this._addedLabels;
      if (r.length) {
        const n = this.getLabels();
        for (const { index: i, label: o } of r)
          n[i] === o && n.splice(i, 1);
        this._addedLabels = [];
      }
      super.init(e);
    }
    parse(e, r) {
      if (Re(e))
        return null;
      const n = this.getLabels();
      return r = isFinite(r) && n[r] === e ? r : g5(n, e, ke(r, e), this._addedLabels), m5(r, n.length - 1);
    }
    determineDataLimits() {
      const { minDefined: e, maxDefined: r } = this.getUserBounds();
      let { min: n, max: i } = this.getMinMax(true);
      this.options.bounds === "ticks" && (e || (n = 0), r || (i = this.getLabels().length - 1)), this.min = n, this.max = i;
    }
    buildTicks() {
      const e = this.min, r = this.max, n = this.options.offset, i = [];
      let o = this.getLabels();
      o = e === 0 && r === o.length - 1 ? o : o.slice(e, r + 1), this._valueRange = Math.max(o.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
      for (let s = e; s <= r; s++)
        i.push({
          value: s
        });
      return i;
    }
    getLabelForValue(e) {
      return Oh.call(this, e);
    }
    configure() {
      super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
    }
    getPixelForValue(e) {
      return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
    }
    getPixelForTick(e) {
      const r = this.ticks;
      return e < 0 || e > r.length - 1 ? null : this.getPixelForValue(r[e].value);
    }
    getValueForPixel(e) {
      return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  }
  ge(Pc, "id", "category"), ge(Pc, "defaults", {
    ticks: {
      callback: Oh
    }
  });
  function y5(t10, e) {
    const r = [], { bounds: i, step: o, min: s, max: a, precision: l, count: c, maxTicks: u, maxDigits: f, includeBounds: d } = t10, h = o || 1, g = u - 1, { min: p, max: y } = e, b = !Re(s), x = !Re(a), S = !Re(c), C = (y - p) / (f + 1);
    let _ = _d((y - p) / g / h) * h, L, F, V, W;
    if (_ < 1e-14 && !b && !x)
      return [
        {
          value: p
        },
        {
          value: y
        }
      ];
    W = Math.ceil(y / _) - Math.floor(p / _), W > g && (_ = _d(W * _ / g / h) * h), Re(l) || (L = Math.pow(10, l), _ = Math.ceil(_ * L) / L), i === "ticks" ? (F = Math.floor(p / _) * _, V = Math.ceil(y / _) * _) : (F = p, V = y), b && x && o && f2((a - s) / o, _ / 1e3) ? (W = Math.round(Math.min((a - s) / _, u)), _ = (a - s) / W, F = s, V = a) : S ? (F = b ? s : F, V = x ? a : V, W = c - 1, _ = (V - F) / W) : (W = (V - F) / _, oo(W, Math.round(W), _ / 1e3) ? W = Math.round(W) : W = Math.ceil(W));
    const X = Math.max(Sd(_), Sd(F));
    L = Math.pow(10, Re(l) ? X : l), F = Math.round(F * L) / L, V = Math.round(V * L) / L;
    let G = 0;
    for (b && (d && F !== s ? (r.push({
      value: s
    }), F < s && G++, oo(Math.round((F + G * _) * L) / L, s, Ph(s, C, t10)) && G++) : F < s && G++); G < W; ++G) {
      const ie = Math.round((F + G * _) * L) / L;
      if (x && ie > a)
        break;
      r.push({
        value: ie
      });
    }
    return x && d && V !== a ? r.length && oo(r[r.length - 1].value, a, Ph(a, C, t10)) ? r[r.length - 1].value = a : r.push({
      value: a
    }) : (!x || V === a) && r.push({
      value: V
    }), r;
  }
  function Ph(t10, e, { horizontal: r, minRotation: n }) {
    const i = sr(n), o = (r ? Math.sin(i) : Math.cos(i)) || 1e-3, s = 0.75 * e * ("" + t10).length;
    return Math.min(e / o, s);
  }
  class ua extends Vn {
    constructor(e) {
      super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
    }
    parse(e, r) {
      return Re(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
    }
    handleTickRangeOptions() {
      const { beginAtZero: e } = this.options, { minDefined: r, maxDefined: n } = this.getUserBounds();
      let { min: i, max: o } = this;
      const s = (l) => i = r ? i : l, a = (l) => o = n ? o : l;
      if (e) {
        const l = vr(i), c = vr(o);
        l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && s(0);
      }
      if (i === o) {
        let l = o === 0 ? 1 : Math.abs(o * 0.05);
        a(o + l), e || s(i - l);
      }
      this.min = i, this.max = o;
    }
    getTickLimit() {
      const e = this.options.ticks;
      let { maxTicksLimit: r, stepSize: n } = e, i;
      return n ? (i = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), r = r || 11), r && (i = Math.min(r, i)), i;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const e = this.options, r = e.ticks;
      let n = this.getTickLimit();
      n = Math.max(2, n);
      const i = {
        maxTicks: n,
        bounds: e.bounds,
        min: e.min,
        max: e.max,
        precision: r.precision,
        step: r.stepSize,
        count: r.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: r.minRotation || 0,
        includeBounds: r.includeBounds !== false
      }, o = this._range || this, s = y5(i, o);
      return e.bounds === "ticks" && d1(s, this, "value"), e.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
    }
    configure() {
      const e = this.ticks;
      let r = this.min, n = this.max;
      if (super.configure(), this.options.offset && e.length) {
        const i = (n - r) / Math.max(e.length - 1, 1) / 2;
        r -= i, n += i;
      }
      this._startValue = r, this._endValue = n, this._valueRange = n - r;
    }
    getLabelForValue(e) {
      return jo(e, this.chart.options.locale, this.options.ticks.format);
    }
  }
  class Rc extends ua {
    determineDataLimits() {
      const { min: e, max: r } = this.getMinMax(true);
      this.min = ot(e) ? e : 0, this.max = ot(r) ? r : 1, this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const e = this.isHorizontal(), r = e ? this.width : this.height, n = sr(this.options.ticks.minRotation), i = (e ? Math.sin(n) : Math.cos(n)) || 1e-3, o = this._resolveTickFontOptions(0);
      return Math.ceil(r / Math.min(40, o.lineHeight / i));
    }
    getPixelForValue(e) {
      return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
    }
    getValueForPixel(e) {
      return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
    }
  }
  ge(Rc, "id", "linear"), ge(Rc, "defaults", {
    ticks: {
      callback: Ra.formatters.numeric
    }
  });
  const _o = (t10) => Math.floor(Yr(t10)), vn = (t10, e) => Math.pow(10, _o(t10) + e);
  function Rh(t10) {
    return t10 / Math.pow(10, _o(t10)) === 1;
  }
  function Dh(t10, e, r) {
    const n = Math.pow(10, r), i = Math.floor(t10 / n);
    return Math.ceil(e / n) - i;
  }
  function b5(t10, e) {
    const r = e - t10;
    let n = _o(r);
    for (; Dh(t10, e, n) > 10; )
      n++;
    for (; Dh(t10, e, n) < 10; )
      n--;
    return Math.min(n, _o(t10));
  }
  function v5(t10, { min: e, max: r }) {
    e = Nt(t10.min, e);
    const n = [], i = _o(e);
    let o = b5(e, r), s = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
    const a = Math.pow(10, o), l = i > o ? Math.pow(10, i) : 0, c = Math.round((e - l) * s) / s, u = Math.floor((e - l) / a / 10) * a * 10;
    let f = Math.floor((c - u) / Math.pow(10, o)), d = Nt(t10.min, Math.round((l + u + f * Math.pow(10, o)) * s) / s);
    for (; d < r; )
      n.push({
        value: d,
        major: Rh(d),
        significand: f
      }), f >= 10 ? f = f < 15 ? 15 : 20 : f++, f >= 20 && (o++, f = 2, s = o >= 0 ? 1 : s), d = Math.round((l + u + f * Math.pow(10, o)) * s) / s;
    const h = Nt(t10.max, d);
    return n.push({
      value: h,
      major: Rh(h),
      significand: f
    }), n;
  }
  class Dc extends Vn {
    constructor(e) {
      super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
    }
    parse(e, r) {
      const n = ua.prototype.parse.apply(this, [
        e,
        r
      ]);
      if (n === 0) {
        this._zero = true;
        return;
      }
      return ot(n) && n > 0 ? n : null;
    }
    determineDataLimits() {
      const { min: e, max: r } = this.getMinMax(true);
      this.min = ot(e) ? Math.max(0, e) : null, this.max = ot(r) ? Math.max(0, r) : null, this.options.beginAtZero && (this._zero = true), this._zero && this.min !== this._suggestedMin && !ot(this._userMin) && (this.min = e === vn(this.min, 0) ? vn(this.min, -1) : vn(this.min, 0)), this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined: e, maxDefined: r } = this.getUserBounds();
      let n = this.min, i = this.max;
      const o = (a) => n = e ? n : a, s = (a) => i = r ? i : a;
      n === i && (n <= 0 ? (o(1), s(10)) : (o(vn(n, -1)), s(vn(i, 1)))), n <= 0 && o(vn(i, -1)), i <= 0 && s(vn(n, 1)), this.min = n, this.max = i;
    }
    buildTicks() {
      const e = this.options, r = {
        min: this._userMin,
        max: this._userMax
      }, n = v5(r, this);
      return e.bounds === "ticks" && d1(n, this, "value"), e.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;
    }
    getLabelForValue(e) {
      return e === void 0 ? "0" : jo(e, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const e = this.min;
      super.configure(), this._startValue = Yr(e), this._valueRange = Yr(this.max) - Yr(e);
    }
    getPixelForValue(e) {
      return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Yr(e) - this._startValue) / this._valueRange);
    }
    getValueForPixel(e) {
      const r = this.getDecimalForPixel(e);
      return Math.pow(10, this._startValue + r * this._valueRange);
    }
  }
  ge(Dc, "id", "logarithmic"), ge(Dc, "defaults", {
    ticks: {
      callback: Ra.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function Mc(t10) {
    const e = t10.ticks;
    if (e.display && t10.display) {
      const r = Et(e.backdropPadding);
      return ke(e.font && e.font.size, st.font.size) + r.height;
    }
    return 0;
  }
  function A5(t10, e, r) {
    return r = Ge(r) ? r : [
      r
    ], {
      w: T2(t10, e.string, r),
      h: r.length * e.lineHeight
    };
  }
  function Mh(t10, e, r, n, i) {
    return t10 === n || t10 === i ? {
      start: e - r / 2,
      end: e + r / 2
    } : t10 < n || t10 > i ? {
      start: e - r,
      end: e
    } : {
      start: e,
      end: e + r
    };
  }
  function w5(t10) {
    const e = {
      l: t10.left + t10._padding.left,
      r: t10.right - t10._padding.right,
      t: t10.top + t10._padding.top,
      b: t10.bottom - t10._padding.bottom
    }, r = Object.assign({}, e), n = [], i = [], o = t10._pointLabels.length, s = t10.options.pointLabels, a = s.centerPointLabels ? $e / o : 0;
    for (let l = 0; l < o; l++) {
      const c = s.setContext(t10.getPointLabelContext(l));
      i[l] = c.padding;
      const u = t10.getPointPosition(l, t10.drawingArea + i[l], a), f = ft(c.font), d = A5(t10.ctx, f, t10._pointLabels[l]);
      n[l] = d;
      const h = Lt(t10.getIndexAngle(l) + a), g = Math.round(Tu(h)), p = Mh(g, u.x, d.w, 0, 180), y = Mh(g, u.y, d.h, 90, 270);
      x5(r, e, h, p, y);
    }
    t10.setCenterPoint(e.l - r.l, r.r - e.r, e.t - r.t, r.b - e.b), t10._pointLabelItems = E5(t10, n, i);
  }
  function x5(t10, e, r, n, i) {
    const o = Math.abs(Math.sin(r)), s = Math.abs(Math.cos(r));
    let a = 0, l = 0;
    n.start < e.l ? (a = (e.l - n.start) / o, t10.l = Math.min(t10.l, e.l - a)) : n.end > e.r && (a = (n.end - e.r) / o, t10.r = Math.max(t10.r, e.r + a)), i.start < e.t ? (l = (e.t - i.start) / s, t10.t = Math.min(t10.t, e.t - l)) : i.end > e.b && (l = (i.end - e.b) / s, t10.b = Math.max(t10.b, e.b + l));
  }
  function _5(t10, e, r) {
    const n = t10.drawingArea, { extra: i, additionalAngle: o, padding: s, size: a } = r, l = t10.getPointPosition(e, n + i + s, o), c = Math.round(Tu(Lt(l.angle + at))), u = T5(l.y, a.h, c), f = k5(c), d = C5(l.x, a.w, f);
    return {
      visible: true,
      x: l.x,
      y: u,
      textAlign: f,
      left: d,
      top: u,
      right: d + a.w,
      bottom: u + a.h
    };
  }
  function S5(t10, e) {
    if (!e)
      return true;
    const { left: r, top: n, right: i, bottom: o } = t10;
    return !(Mr({
      x: r,
      y: n
    }, e) || Mr({
      x: r,
      y: o
    }, e) || Mr({
      x: i,
      y: n
    }, e) || Mr({
      x: i,
      y: o
    }, e));
  }
  function E5(t10, e, r) {
    const n = [], i = t10._pointLabels.length, o = t10.options, { centerPointLabels: s, display: a } = o.pointLabels, l = {
      extra: Mc(o) / 2,
      additionalAngle: s ? $e / i : 0
    };
    let c;
    for (let u = 0; u < i; u++) {
      l.padding = r[u], l.size = e[u];
      const f = _5(t10, u, l);
      n.push(f), a === "auto" && (f.visible = S5(f, c), f.visible && (c = f));
    }
    return n;
  }
  function k5(t10) {
    return t10 === 0 || t10 === 180 ? "center" : t10 < 180 ? "left" : "right";
  }
  function C5(t10, e, r) {
    return r === "right" ? t10 -= e : r === "center" && (t10 -= e / 2), t10;
  }
  function T5(t10, e, r) {
    return r === 90 || r === 270 ? t10 -= e / 2 : (r > 270 || r < 90) && (t10 -= e), t10;
  }
  function I5(t10, e, r) {
    const { left: n, top: i, right: o, bottom: s } = r, { backdropColor: a } = e;
    if (!Re(a)) {
      const l = Tn(e.borderRadius), c = Et(e.backdropPadding);
      t10.fillStyle = a;
      const u = n - c.left, f = i - c.top, d = o - n + c.width, h = s - i + c.height;
      Object.values(l).some((g) => g !== 0) ? (t10.beginPath(), wo(t10, {
        x: u,
        y: f,
        w: d,
        h,
        radius: l
      }), t10.fill()) : t10.fillRect(u, f, d, h);
    }
  }
  function O5(t10, e) {
    const { ctx: r, options: { pointLabels: n } } = t10;
    for (let i = e - 1; i >= 0; i--) {
      const o = t10._pointLabelItems[i];
      if (!o.visible)
        continue;
      const s = n.setContext(t10.getPointLabelContext(i));
      I5(r, s, o);
      const a = ft(s.font), { x: l, y: c, textAlign: u } = o;
      Fn(r, t10._pointLabels[i], l, c + a.lineHeight / 2, a, {
        color: s.color,
        textAlign: u,
        textBaseline: "middle"
      });
    }
  }
  function ng(t10, e, r, n) {
    const { ctx: i } = t10;
    if (r)
      i.arc(t10.xCenter, t10.yCenter, e, 0, Ze);
    else {
      let o = t10.getPointPosition(0, e);
      i.moveTo(o.x, o.y);
      for (let s = 1; s < n; s++)
        o = t10.getPointPosition(s, e), i.lineTo(o.x, o.y);
    }
  }
  function P5(t10, e, r, n, i) {
    const o = t10.ctx, s = e.circular, { color: a, lineWidth: l } = e;
    !s && !n || !a || !l || r < 0 || (o.save(), o.strokeStyle = a, o.lineWidth = l, o.setLineDash(i.dash), o.lineDashOffset = i.dashOffset, o.beginPath(), ng(t10, r, s, n), o.closePath(), o.stroke(), o.restore());
  }
  function R5(t10, e, r) {
    return fn(t10, {
      label: r,
      index: e,
      type: "pointLabel"
    });
  }
  class Zi extends ua {
    constructor(e) {
      super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
    }
    setDimensions() {
      const e = this._padding = Et(Mc(this.options) / 2), r = this.width = this.maxWidth - e.width, n = this.height = this.maxHeight - e.height;
      this.xCenter = Math.floor(this.left + r / 2 + e.left), this.yCenter = Math.floor(this.top + n / 2 + e.top), this.drawingArea = Math.floor(Math.min(r, n) / 2);
    }
    determineDataLimits() {
      const { min: e, max: r } = this.getMinMax(false);
      this.min = ot(e) && !isNaN(e) ? e : 0, this.max = ot(r) && !isNaN(r) ? r : 0, this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / Mc(this.options));
    }
    generateTickLabels(e) {
      ua.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((r, n) => {
        const i = Je(this.options.pointLabels.callback, [
          r,
          n
        ], this);
        return i || i === 0 ? i : "";
      }).filter((r, n) => this.chart.getDataVisibility(n));
    }
    fit() {
      const e = this.options;
      e.display && e.pointLabels.display ? w5(this) : this.setCenterPoint(0, 0, 0, 0);
    }
    setCenterPoint(e, r, n, i) {
      this.xCenter += Math.floor((e - r) / 2), this.yCenter += Math.floor((n - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, r, n, i));
    }
    getIndexAngle(e) {
      const r = Ze / (this._pointLabels.length || 1), n = this.options.startAngle || 0;
      return Lt(e * r + sr(n));
    }
    getDistanceFromCenterForValue(e) {
      if (Re(e))
        return NaN;
      const r = this.drawingArea / (this.max - this.min);
      return this.options.reverse ? (this.max - e) * r : (e - this.min) * r;
    }
    getValueForDistanceFromCenter(e) {
      if (Re(e))
        return NaN;
      const r = e / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - r : this.min + r;
    }
    getPointLabelContext(e) {
      const r = this._pointLabels || [];
      if (e >= 0 && e < r.length) {
        const n = r[e];
        return R5(this.getContext(), e, n);
      }
    }
    getPointPosition(e, r, n = 0) {
      const i = this.getIndexAngle(e) - at + n;
      return {
        x: Math.cos(i) * r + this.xCenter,
        y: Math.sin(i) * r + this.yCenter,
        angle: i
      };
    }
    getPointPositionForValue(e, r) {
      return this.getPointPosition(e, this.getDistanceFromCenterForValue(r));
    }
    getBasePosition(e) {
      return this.getPointPositionForValue(e || 0, this.getBaseValue());
    }
    getPointLabelPosition(e) {
      const { left: r, top: n, right: i, bottom: o } = this._pointLabelItems[e];
      return {
        left: r,
        top: n,
        right: i,
        bottom: o
      };
    }
    drawBackground() {
      const { backgroundColor: e, grid: { circular: r } } = this.options;
      if (e) {
        const n = this.ctx;
        n.save(), n.beginPath(), ng(this, this.getDistanceFromCenterForValue(this._endValue), r, this._pointLabels.length), n.closePath(), n.fillStyle = e, n.fill(), n.restore();
      }
    }
    drawGrid() {
      const e = this.ctx, r = this.options, { angleLines: n, grid: i, border: o } = r, s = this._pointLabels.length;
      let a, l, c;
      if (r.pointLabels.display && O5(this, s), i.display && this.ticks.forEach((u, f) => {
        if (f !== 0) {
          l = this.getDistanceFromCenterForValue(u.value);
          const d = this.getContext(f), h = i.setContext(d), g = o.setContext(d);
          P5(this, h, l, s, g);
        }
      }), n.display) {
        for (e.save(), a = s - 1; a >= 0; a--) {
          const u = n.setContext(this.getPointLabelContext(a)), { color: f, lineWidth: d } = u;
          !d || !f || (e.lineWidth = d, e.strokeStyle = f, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(r.ticks.reverse ? this.min : this.max), c = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(c.x, c.y), e.stroke());
        }
        e.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const e = this.ctx, r = this.options, n = r.ticks;
      if (!n.display)
        return;
      const i = this.getIndexAngle(0);
      let o, s;
      e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(i), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => {
        if (l === 0 && !r.reverse)
          return;
        const c = n.setContext(this.getContext(l)), u = ft(c.font);
        if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
          e.font = u.string, s = e.measureText(a.label).width, e.fillStyle = c.backdropColor;
          const f = Et(c.backdropPadding);
          e.fillRect(-s / 2 - f.left, -o - u.size / 2 - f.top, s + f.width, u.size + f.height);
        }
        Fn(e, a.label, 0, -o, u, {
          color: c.color,
          strokeColor: c.textStrokeColor,
          strokeWidth: c.textStrokeWidth
        });
      }), e.restore();
    }
    drawTitle() {
    }
  }
  ge(Zi, "id", "radialLinear"), ge(Zi, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ra.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(e) {
        return e;
      },
      padding: 5,
      centerPointLabels: false
    }
  }), ge(Zi, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  }), ge(Zi, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  const La = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  }, Ot = /* @__PURE__ */ Object.keys(La);
  function Nh(t10, e) {
    return t10 - e;
  }
  function Lh(t10, e) {
    if (Re(e))
      return null;
    const r = t10._adapter, { parser: n, round: i, isoWeekday: o } = t10._parseOpts;
    let s = e;
    return typeof n == "function" && (s = n(s)), ot(s) || (s = typeof n == "string" ? r.parse(s, n) : r.parse(s)), s === null ? null : (i && (s = i === "week" && (pi(o) || o === true) ? r.startOf(s, "isoWeek", o) : r.startOf(s, i)), +s);
  }
  function Bh(t10, e, r, n) {
    const i = Ot.length;
    for (let o = Ot.indexOf(t10); o < i - 1; ++o) {
      const s = La[Ot[o]], a = s.steps ? s.steps : Number.MAX_SAFE_INTEGER;
      if (s.common && Math.ceil((r - e) / (a * s.size)) <= n)
        return Ot[o];
    }
    return Ot[i - 1];
  }
  function D5(t10, e, r, n, i) {
    for (let o = Ot.length - 1; o >= Ot.indexOf(r); o--) {
      const s = Ot[o];
      if (La[s].common && t10._adapter.diff(i, n, s) >= e - 1)
        return s;
    }
    return Ot[r ? Ot.indexOf(r) : 0];
  }
  function M5(t10) {
    for (let e = Ot.indexOf(t10) + 1, r = Ot.length; e < r; ++e)
      if (La[Ot[e]].common)
        return Ot[e];
  }
  function Fh(t10, e, r) {
    if (!r)
      t10[e] = true;
    else if (r.length) {
      const { lo: n, hi: i } = Iu(r, e), o = r[n] >= e ? r[n] : r[i];
      t10[o] = true;
    }
  }
  function N5(t10, e, r, n) {
    const i = t10._adapter, o = +i.startOf(e[0].value, n), s = e[e.length - 1].value;
    let a, l;
    for (a = o; a <= s; a = +i.add(a, 1, n))
      l = r[a], l >= 0 && (e[l].major = true);
    return e;
  }
  function jh(t10, e, r) {
    const n = [], i = {}, o = e.length;
    let s, a;
    for (s = 0; s < o; ++s)
      a = e[s], i[a] = s, n.push({
        value: a,
        major: false
      });
    return o === 0 || !r ? n : N5(t10, n, i, r);
  }
  class So extends Vn {
    constructor(e) {
      super(e), this._cache = {
        data: [],
        labels: [],
        all: []
      }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
    }
    init(e, r = {}) {
      const n = e.time || (e.time = {}), i = this._adapter = new qv._date(e.adapters.date);
      i.init(r), io(n.displayFormats, i.formats()), this._parseOpts = {
        parser: n.parser,
        round: n.round,
        isoWeekday: n.isoWeekday
      }, super.init(e), this._normalized = r.normalized;
    }
    parse(e, r) {
      return e === void 0 ? null : Lh(this, e);
    }
    beforeLayout() {
      super.beforeLayout(), this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const e = this.options, r = this._adapter, n = e.time.unit || "day";
      let { min: i, max: o, minDefined: s, maxDefined: a } = this.getUserBounds();
      function l(c) {
        !s && !isNaN(c.min) && (i = Math.min(i, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));
      }
      (!s || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(false))), i = ot(i) && !isNaN(i) ? i : +r.startOf(Date.now(), n), o = ot(o) && !isNaN(o) ? o : +r.endOf(Date.now(), n) + 1, this.min = Math.min(i, o - 1), this.max = Math.max(i + 1, o);
    }
    _getLabelBounds() {
      const e = this.getLabelTimestamps();
      let r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
      return e.length && (r = e[0], n = e[e.length - 1]), {
        min: r,
        max: n
      };
    }
    buildTicks() {
      const e = this.options, r = e.time, n = e.ticks, i = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
      e.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]);
      const o = this.min, s = this.max, a = g2(i, o, s);
      return this._unit = r.unit || (n.autoSkip ? Bh(r.minUnit, this.min, this.max, this._getLabelCapacity(o)) : D5(this, a.length, r.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : M5(this._unit), this.initOffsets(i), e.reverse && a.reverse(), jh(this, a, this._majorUnit);
    }
    afterAutoSkip() {
      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
    }
    initOffsets(e = []) {
      let r = 0, n = 0, i, o;
      this.options.offset && e.length && (i = this.getDecimalForValue(e[0]), e.length === 1 ? r = 1 - i : r = (this.getDecimalForValue(e[1]) - i) / 2, o = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? n = o : n = (o - this.getDecimalForValue(e[e.length - 2])) / 2);
      const s = e.length < 3 ? 0.5 : 0.25;
      r = ht(r, 0, s), n = ht(n, 0, s), this._offsets = {
        start: r,
        end: n,
        factor: 1 / (r + 1 + n)
      };
    }
    _generate() {
      const e = this._adapter, r = this.min, n = this.max, i = this.options, o = i.time, s = o.unit || Bh(o.minUnit, r, n, this._getLabelCapacity(r)), a = ke(i.ticks.stepSize, 1), l = s === "week" ? o.isoWeekday : false, c = pi(l) || l === true, u = {};
      let f = r, d, h;
      if (c && (f = +e.startOf(f, "isoWeek", l)), f = +e.startOf(f, c ? "day" : s), e.diff(n, r, s) > 1e5 * a)
        throw new Error(r + " and " + n + " are too far apart with stepSize of " + a + " " + s);
      const g = i.ticks.source === "data" && this.getDataTimestamps();
      for (d = f, h = 0; d < n; d = +e.add(d, a, s), h++)
        Fh(u, d, g);
      return (d === n || i.bounds === "ticks" || h === 1) && Fh(u, d, g), Object.keys(u).sort(Nh).map((p) => +p);
    }
    getLabelForValue(e) {
      const r = this._adapter, n = this.options.time;
      return n.tooltipFormat ? r.format(e, n.tooltipFormat) : r.format(e, n.displayFormats.datetime);
    }
    format(e, r) {
      const i = this.options.time.displayFormats, o = this._unit, s = r || i[o];
      return this._adapter.format(e, s);
    }
    _tickFormatFunction(e, r, n, i) {
      const o = this.options, s = o.ticks.callback;
      if (s)
        return Je(s, [
          e,
          r,
          n
        ], this);
      const a = o.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], f = c && a[c], d = n[r], h = c && f && d && d.major;
      return this._adapter.format(e, i || (h ? f : u));
    }
    generateTickLabels(e) {
      let r, n, i;
      for (r = 0, n = e.length; r < n; ++r)
        i = e[r], i.label = this._tickFormatFunction(i.value, r, e);
    }
    getDecimalForValue(e) {
      return e === null ? NaN : (e - this.min) / (this.max - this.min);
    }
    getPixelForValue(e) {
      const r = this._offsets, n = this.getDecimalForValue(e);
      return this.getPixelForDecimal((r.start + n) * r.factor);
    }
    getValueForPixel(e) {
      const r = this._offsets, n = this.getDecimalForPixel(e) / r.factor - r.end;
      return this.min + n * (this.max - this.min);
    }
    _getLabelSize(e) {
      const r = this.options.ticks, n = this.ctx.measureText(e).width, i = sr(this.isHorizontal() ? r.maxRotation : r.minRotation), o = Math.cos(i), s = Math.sin(i), a = this._resolveTickFontOptions(0).size;
      return {
        w: n * o + a * s,
        h: n * s + a * o
      };
    }
    _getLabelCapacity(e) {
      const r = this.options.time, n = r.displayFormats, i = n[r.unit] || n.millisecond, o = this._tickFormatFunction(e, 0, jh(this, [
        e
      ], this._majorUnit), i), s = this._getLabelSize(o), a = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
      return a > 0 ? a : 1;
    }
    getDataTimestamps() {
      let e = this._cache.data || [], r, n;
      if (e.length)
        return e;
      const i = this.getMatchingVisibleMetas();
      if (this._normalized && i.length)
        return this._cache.data = i[0].controller.getAllParsedValues(this);
      for (r = 0, n = i.length; r < n; ++r)
        e = e.concat(i[r].controller.getAllParsedValues(this));
      return this._cache.data = this.normalize(e);
    }
    getLabelTimestamps() {
      const e = this._cache.labels || [];
      let r, n;
      if (e.length)
        return e;
      const i = this.getLabels();
      for (r = 0, n = i.length; r < n; ++r)
        e.push(Lh(this, i[r]));
      return this._cache.labels = this._normalized ? e : this.normalize(e);
    }
    normalize(e) {
      return g1(e.sort(Nh));
    }
  }
  ge(So, "id", "time"), ge(So, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function hs(t10, e, r) {
    let n = 0, i = t10.length - 1, o, s, a, l;
    r ? (e >= t10[n].pos && e <= t10[i].pos && ({ lo: n, hi: i } = Dr(t10, "pos", e)), { pos: o, time: a } = t10[n], { pos: s, time: l } = t10[i]) : (e >= t10[n].time && e <= t10[i].time && ({ lo: n, hi: i } = Dr(t10, "time", e)), { time: o, pos: a } = t10[n], { time: s, pos: l } = t10[i]);
    const c = s - o;
    return c ? a + (l - a) * (e - o) / c : a;
  }
  class Nc extends So {
    constructor(e) {
      super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
    }
    initOffsets() {
      const e = this._getTimestampsForTable(), r = this._table = this.buildLookupTable(e);
      this._minPos = hs(r, this.min), this._tableRange = hs(r, this.max) - this._minPos, super.initOffsets(e);
    }
    buildLookupTable(e) {
      const { min: r, max: n } = this, i = [], o = [];
      let s, a, l, c, u;
      for (s = 0, a = e.length; s < a; ++s)
        c = e[s], c >= r && c <= n && i.push(c);
      if (i.length < 2)
        return [
          {
            time: r,
            pos: 0
          },
          {
            time: n,
            pos: 1
          }
        ];
      for (s = 0, a = i.length; s < a; ++s)
        u = i[s + 1], l = i[s - 1], c = i[s], Math.round((u + l) / 2) !== c && o.push({
          time: c,
          pos: s / (a - 1)
        });
      return o;
    }
    _generate() {
      const e = this.min, r = this.max;
      let n = super.getDataTimestamps();
      return (!n.includes(e) || !n.length) && n.splice(0, 0, e), (!n.includes(r) || n.length === 1) && n.push(r), n.sort((i, o) => i - o);
    }
    _getTimestampsForTable() {
      let e = this._cache.all || [];
      if (e.length)
        return e;
      const r = this.getDataTimestamps(), n = this.getLabelTimestamps();
      return r.length && n.length ? e = this.normalize(r.concat(n)) : e = r.length ? r : n, e = this._cache.all = e, e;
    }
    getDecimalForValue(e) {
      return (hs(this._table, e) - this._minPos) / this._tableRange;
    }
    getValueForPixel(e) {
      const r = this._offsets, n = this.getDecimalForPixel(e) / r.factor - r.end;
      return hs(this._table, n * this._tableRange + this._minPos, true);
    }
  }
  ge(Nc, "id", "timeseries"), ge(Nc, "defaults", So.defaults);
  var L5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale: Pc,
    LinearScale: Rc,
    LogarithmicScale: Dc,
    RadialLinearScale: Zi,
    TimeScale: So,
    TimeSeriesScale: Nc
  });
  const B5 = [
    Vv,
    v6,
    h5,
    L5
  ];
  Tr.register(...B5);
  class F5 {
    constructor(e, r, n) {
      ge(this, "getConfiguration");
      this.myChart = void 0, this.getConfiguration = r, this.resetBot = n, this.startTime = e, this.elapsedTimeDiv = null;
    }
    createOverlay() {
      const e = document.createElement("div");
      e.style.display = "flex", e.style.position = "fixed", e.style.top = "0%", e.style.right = "0%", e.style.width = "450px", e.style.height = "150px", e.style.zIndex = "1000", e.style.backgroundColor = "rgba(0,0,0,0.7)";
      const r = document.createElement("div");
      r.id = "overlay", r.style.top = "0%", r.style.right = "0%", r.style.width = "75%", r.style.height = "150px", r.style.backgroundColor = "rgba(0,0,0,0.7)";
      const n = document.createElement("div");
      n.style.display = "flex", n.style.flexDirection = "column", n.style.width = "25%", n.style.height = "150px", n.style.justifyContent = "strech", n.style.alignItems = "strech", n.style.backgroundColor = "rgba(0,0,0,0.7)";
      const i = document.createElement("canvas");
      i.id = "overlayChart", i.width = "100%", i.height = "100%", this.elapsedTimeDiv = document.createElement("div"), this.elapsedTimeDiv.style.position = "absolute", this.elapsedTimeDiv.style.bottom = "5px", this.elapsedTimeDiv.style.left = "26%", this.elapsedTimeDiv.style.color = "gray", this.elapsedTimeDiv.style.fontSize = "12px", this.elapsedTimeDiv.innerText = "Elapsed Time: 0s";
      const o = document.createElement("button");
      o.innerText = "Reset", o.style.width = "100%", o.style.height = "50%", o.style.color = "gray", o.style.backgroundColor = "rgba(0,0,0,0.7)", n.appendChild(o), o.addEventListener("click", this.resetBot.bind(this));
      const s = document.createElement("button");
      return s.innerText = "Download", s.style.width = "100%", s.style.height = "50%", s.addEventListener("click", this.downloadConfiguration.bind(this)), s.style.backgroundColor = "rgba(0,0,0,0.7)", s.style.color = "gray", n.appendChild(s), e.appendChild(n), e.appendChild(r), r.appendChild(i), r.appendChild(this.elapsedTimeDiv), document.body.appendChild(e), { overlay: r, chartCanvas: i };
    }
    setConfigurationForBot(e) {
      this.getConfiguration = e, console.log("CONFIGURATION SET", this.getConfiguration());
    }
    downloadConfiguration() {
      console.log("DOWNLOADING CONF", this.getConfiguration());
      const e = this.getConfiguration();
      console.log("CONFIGURATIOn", e);
      const r = JSON.stringify(e, null, 2);
      console.log("jsonStr", r);
      const n = new Blob([r], { type: "application/json" }), i = URL.createObjectURL(n), o = document.createElement("a");
      o.href = i, o.download = "chartConfiguration.json", document.body.appendChild(o), o.click(), document.body.removeChild(o);
    }
    showOverlayChart() {
      const { overlay: e, chartCanvas: r } = this.createOverlay();
      setInterval(this.updateElapsedTime.bind(this), 1e3);
      const n = r.getContext("2d");
      this.myChart = new Tr(n, {
        type: "line",
        data: {
          labels: [],
          // Empty array, we will populate it dynamically
          datasets: [
            {
              label: "Average Rewards",
              data: [],
              // Empty array, we will populate it dynamically
              borderColor: "rgba(75, 192, 192, 1)",
              borderWidth: 0.6,
              fill: false,
              pointRadius: 0,
              // This will remove the points
              pointHitRadius: 0
              // This will remove the points
            },
            {
              label: "Individual Rewards",
              data: [],
              // Empty array for individual data points
              borderColor: "rgba(255, 24, 12, 1)",
              // borderWidth: 2,
              fill: true,
              pointRadius: 0.1,
              // Add points
              // pointHitRadius: 1,
              showLine: false,
              animation: {
                // Disable animation for this dataset
                duration: 0
              }
            }
          ]
        },
        options: {
          scales: {
            x: {
              type: "linear",
              // To handle numerical data on x-axis
              position: "bottom",
              title: {
                display: true,
                text: "Number of Iterations"
              }
            },
            y: {
              title: {
                display: true,
                text: "Total Reward"
              }
            }
          }
        }
      });
    }
    updateChart(e, r, n) {
      this.myChart.data.labels.push(e), this.myChart.data.datasets[0].data.push(n / e), r !== 0 && this.myChart.data.datasets[1].data.push(r), this.myChart.update();
    }
    reset() {
      this.startTime = (/* @__PURE__ */ new Date()).getTime(), this.myChart.data.labels = [], this.myChart.data.datasets[0].data = [], this.myChart.update();
    }
    updateElapsedTime() {
      const r = (/* @__PURE__ */ new Date()).getTime() - this.startTime, n = Math.floor(r / 1e3), i = Math.floor(n / 3600), o = Math.floor(n % 3600 / 60), s = n % 60, a = String(i).padStart(2, "0"), l = String(o).padStart(2, "0"), c = String(s).padStart(2, "0"), u = `${a}:${l}:${c}`;
      this.elapsedTimeDiv.innerText = `Elapsed Time: ${u}`;
    }
  }
  function Wh(t10) {
    try {
      var e = window[t10], r = "__storage_test__";
      return e.setItem(r, r), e.removeItem(r), true;
    } catch {
      return false;
    }
  }
  class ig {
    constructor(e) {
      if (!e || !e.player)
        throw new Error(
          "botParams is undefined, did you forget to pass botParams to base Bot class like: super(params);"
        );
      this._player = e.player, this._player.setState("__bot", true), this._player.bot = this, this._id = void 0;
    }
    get id() {
      return this._player.id;
    }
    get player() {
      return this._player;
    }
    getProfile() {
      return this.player.getProfile();
    }
    getState(e) {
      return this.player.getState(e);
    }
    setState(e, r, n) {
      this.player.setState(e, r, n);
    }
    onQuit(e) {
      return this.player.onQuit(e);
    }
    kick() {
      return this.player.kick();
    }
  }
  class j5 extends ig {
    constructor(r) {
      super(r);
      ge(this, "agent");
      ge(this, "totalIteration", 0);
      ge(this, "totalReward", 0);
      ge(this, "numberOfStates", 0);
      ge(this, "numberOfActions", 0);
      ge(this, "showChart", false);
      ge(this, "overlayChart");
      ge(this, "startTime", (/* @__PURE__ */ new Date()).getTime());
      if (!r.numberOfActions)
        throw new Error("Please Define Number of Actions for DQN Bot");
      if (!r.numberOfStates)
        throw new Error("Please Define Number of States for DQN Bot");
      this.numberOfActions = r.numberOfActions, this.numberOfStates = r.numberOfStates;
      const n = {
        getNumStates: () => this.numberOfStates,
        getMaxNumActions: () => this.numberOfActions
      };
      this.agent = new s1.DQNAgent(n, r.specifications), (!r.hasOwnProperty("retrieveFromLocalStorage") || r.retrieveFromLocalStorage) && (window.addEventListener("beforeunload", () => {
        this.saveModelToLocalStorage();
      }), this.loadModelFromLocalStorage()), r.weights && r.weights.modelWeights && this.setWeights(r.weights), this.overlayChart = new F5(
        this.startTime,
        this.getDownloadableConfiguration.bind(this),
        this.resetBot.bind(this)
      );
    }
    resetBot() {
      this.agent.reset(), this.totalIteration = 0, this.totalReward = 0, this.startTime = (/* @__PURE__ */ new Date()).getTime(), this.overlayChart.reset();
    }
    act(r) {
      if (r.length !== this.numberOfStates)
        throw new Error(
          `State provided for action ${r.length} does not match the number of states ${this.numberOfStates} provided while initialization`
        );
      const n = this.getValidStates(r);
      return this.agent.act(n);
    }
    getValidStates(r) {
      const n = [];
      for (let i = 0; i < r.length; i++) {
        const o = r[i];
        if (typeof o == "boolean")
          n.push(o ? 1 : 0);
        else if (typeof o == "number" && !isNaN(o))
          n.push(o);
        else
          throw new Error(
            `Invalid element at index ${i}: ${o}. Bot only expects Number/Boolean`
          );
      }
      return n;
    }
    learn(r) {
      this.totalIteration += 1, this.totalReward += r, this.showChart && this.overlayChart.updateChart(
        this.totalIteration,
        r,
        this.totalReward
      ), this.agent.learn(r);
    }
    getCurrentModelStateAsJSON() {
      const r = this.agent.toJSON();
      return JSON.stringify(r);
    }
    setCurrentModelState(r) {
      const n = JSON.parse(r);
      this.agent.fromJSON(n);
    }
    saveModelToLocalStorage() {
      try {
        if (Wh("localStorage")) {
          const r = this.getCurrentModelStateAsJSON();
          localStorage.setItem(
            this.numberOfStates + "_" + this.numberOfActions,
            r
          );
        }
      } catch (r) {
        console.error(r);
      }
    }
    loadModelFromLocalStorage() {
      try {
        if (Wh("localStorage")) {
          const r = localStorage.getItem(
            this.numberOfStates + "_" + this.numberOfActions
          );
          r && this.setCurrentModelState(r);
        }
      } catch (r) {
        console.error(r);
      }
    }
    getDownloadableConfiguration() {
      return {
        numberOfActions: this.numberOfActions,
        numberOfStates: this.numberOfStates,
        modelWeights: this.getCurrentModelStateAsJSON(),
        type: "dqn",
        iterations: this.totalIteration,
        reward: this.totalReward,
        startTime: this.startTime
      };
    }
    setWeights(r) {
      if (!r)
        throw new Error("Weights not given");
      this.setCurrentModelState(r.modelWeights), this.totalIteration = r.iterations ? r.iterations : 0, this.totalReward = r.reward ? r.reward : 0, this.startTime = r.startTime ? r.startTime : (/* @__PURE__ */ new Date()).getTime();
    }
    displayChart() {
      this.overlayChart.showOverlayChart(), this.showChart = true;
    }
  }
  const Wl = 20;
  class QE extends j5 {
    constructor(r) {
      var n = 0;
      let i = r.joystickOptions;
      i.type === "dpad" ? n += 4 : i.type === "angular" && (n += Math.floor(360 / Wl)), i.buttons && (n += i.buttons.length), r.numberOfActions = n;
      super(r);
      ge(this, "joystick");
      this.joystick = i, this.numberOfActions = n;
    }
    getAction(r) {
      var n = this.act(r);
      let i = {};
      if (this.joystick.type === "dpad") {
        var o = void 0, s = void 0;
        n === 0 && (o = "left"), n === 1 && (o = "right"), n === 2 && (s = "up"), n === 3 && (s = "down"), o && (i.x = o), s && (i.y = s);
      }
      this.joystick.type === "angular" && (i = n * Wl * (Math.PI / 180));
      var a = this.joystick.type === "dpad" ? 4 : Math.floor(360 / Wl), l = {};
      const c = this.joystick.buttons;
      if (c.length > 0)
        for (let u = 0; u < c.length; u++)
          u === n - a ? l[c[u].id] = true : l[c[u].id] = false;
      return {
        joystickType: this.joystick.type,
        finalDirection: i,
        buttonSelection: l
      };
    }
    setDQNBotState(r) {
      var { joystickType: n, finalDirection: i, buttonSelection: o } = this.getAction(r);
      this.player.setState("ctr-joystick", false), n === "angular" && !isNaN(i) && (this.player.setState("ctr-angle", i), this.player.setState("ctr-joystick", true)), n === "dpad" && Object.keys(i).length !== 0 && (this.player.setState("ctr-dpad", i), this.player.setState("ctr-joystick", true));
      for (var s in o)
        this.player.setState("ctr-" + s, false), this.player.setState("ctr-" + s, o[s]);
    }
    setDQNBotReward(r) {
      this.learn(r);
    }
  }
  const Uh = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ];
  function W5() {
    return new Promise((t10, e) => {
      we().connection.once("sync", () => {
        setTimeout(() => {
          t10();
        }, 1e3);
      });
    });
  }
  let ji = [], zh = false, ir, tr;
  async function U5() {
    var t10;
    if (!zh) {
      if (tr = we(), ir = (t10 = tr.sdkOptions) == null ? void 0 : t10.botOptions, !ir)
        throw new Error("Please Define Bot Options");
      if (!ir.botClass)
        throw new Error("Please Define Bot Instance");
      await W5(), zh = true, tr.on("joined", (e) => {
        !tr.isHost && e.isBot() && og(e);
      });
    }
  }
  function og(t10) {
    return ir.botParams = ir.botParams || {}, ir.botParams.player = t10, new ir.botClass(ir.botParams);
  }
  function z5(t10) {
    let e = "";
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = r.length;
    for (let i = 0; i < t10; ++i)
      e += r.charAt(Math.floor(Math.random() * n));
    return e;
  }
  function V5(t10) {
    return t10 && t10.length > 0 ? t10[Math.floor(Math.random() * t10.length)] : Pa(Oa(z5(10)));
  }
  async function q5() {
    if (!tr || !tr.isConnected)
      throw new Error("Create or join a room before adding bots");
    const t10 = tr.sdkOptions || {};
    if (!t10.spectator && t10.maxPlayersPerRoom && Object.values(tr.connection.playerStates).filter((i) => !i.playerIsSpectator).length >= t10.maxPlayersPerRoom)
      throw new Error("Room's players limit has reached.");
    if (t10.spectator && t10.maxSpectatorsPerRoom && Object.values(tr.connection.playerStates).filter((i) => i.playerIsSpectator).length >= t10.maxSpectatorsPerRoom)
      throw new Error("Room's spectators limit has reached.");
    const e = tr.connection.addProxyPlayer();
    e.setState("profile", {
      name: "Bot " + (ji.length + 1),
      photo: V5(t10.avatars),
      color: Uh[ji.length % Uh.length]
    });
    let r = og(e);
    if (!(r instanceof ig))
      throw tr.connection.removeProxyPlayer(e.id), new Error("Bot Class Should Be Instance of Bot");
    ir.trainingMode && r.displayChart();
    let n;
    return ir.botParams.joystickOptions ? n = new Ac(e, ir.botParams.joystickOptions) : n = new Ac(e), ji.push({ player: e, joystick: n, bot: r }), e.on("quit", () => {
      const i = ji.findIndex((o) => e.id == o.player.id);
      ji.splice(i, 1);
    }), r;
  }
  const K5 = "0.0.94", Wu = {
    version: K5
  };
  async function GE(t10) {
    const e = ta(10);
    return await C3("_turns", {
      id: e,
      player: {
        id: Ln().id,
        profile: Ln().getProfile()
      },
      data: t10
    }), e;
  }
  async function ZE() {
    return await i1("_turns") || [];
  }
  async function $E() {
    await k3("_turns", void 0);
  }
  async function ek() {
    const t10 = await i1("_turns"), e = (t10 == null ? void 0 : t10.filter((n) => {
      var o;
      return (typeof n.player == "string" ? n.player : (o = n.player) == null ? void 0 : o.id) === Ln().id;
    })) || [];
    return e[e.length - 1] || void 0;
  }
  const sg = `/*!
 * Bootstrap Grid Only (grid and responsive utilities extracted from Bootstrap 4.1.3)
 * GitHub: https://github.com/dmhendricks/bootstrap-grid-css
 * Bootstrap License: MIT (https://github.com/twbs/bootstrap/blob/v4-dev/LICENSE)
 * Credits: Twitter, Inc. & The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 */@-ms-viewport{width:device-width}html{-webkit-box-sizing:border-box;box-sizing:border-box;-ms-overflow-style:scrollbar}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}.bootstrap-wrapper .clearfix:after{display:block;clear:both;content:""}.bootstrap-wrapper .visible{visibility:visible!important}.bootstrap-wrapper .invisible{visibility:hidden!important}.bootstrap-wrapper .hidden-xs-up{display:none!important}@media (max-width: 575.98px){.bootstrap-wrapper .hidden-xs-down{display:none!important}}@media (min-width: 576px){.bootstrap-wrapper .hidden-sm-up{display:none!important}}@media (max-width: 767.98px){.bootstrap-wrapper .hidden-sm-down{display:none!important}}@media (min-width: 768px){.bootstrap-wrapper .hidden-md-up{display:none!important}}@media (max-width: 991.98px){.bootstrap-wrapper .hidden-md-down{display:none!important}}@media (min-width: 992px){.bootstrap-wrapper .hidden-lg-up{display:none!important}}@media (max-width: 1199.98px){.bootstrap-wrapper .hidden-lg-down{display:none!important}}@media (min-width: 1200px){.bootstrap-wrapper .hidden-xl-up{display:none!important}}.bootstrap-wrapper .hidden-xl-down,.bootstrap-wrapper .visible-print-block{display:none!important}@media print{.bootstrap-wrapper .visible-print-block{display:block!important}}.bootstrap-wrapper .visible-print-inline{display:none!important}@media print{.bootstrap-wrapper .visible-print-inline{display:inline!important}}.bootstrap-wrapper .visible-print-inline-block{display:none!important}@media print{.bootstrap-wrapper .visible-print-inline-block{display:inline-block!important}}@media print{.bootstrap-wrapper .hidden-print{display:none!important}}.bootstrap-wrapper .container{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width: 576px){.bootstrap-wrapper .container{max-width:540px}}@media (min-width: 768px){.bootstrap-wrapper .container{max-width:720px}}@media (min-width: 992px){.bootstrap-wrapper .container{max-width:960px}}@media (min-width: 1200px){.bootstrap-wrapper .container{max-width:1140px}}.bootstrap-wrapper .container-fluid{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.bootstrap-wrapper .row{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-15px;margin-left:-15px}.bootstrap-wrapper .no-gutters{margin-right:0;margin-left:0}.bootstrap-wrapper .no-gutters>.col,.bootstrap-wrapper .no-gutters>[class*=col-]{padding-right:0;padding-left:0}.bootstrap-wrapper .col-1,.bootstrap-wrapper .col-2,.bootstrap-wrapper .col-3,.bootstrap-wrapper .col-4,.bootstrap-wrapper .col-5,.bootstrap-wrapper .col-6,.bootstrap-wrapper .col-7,.bootstrap-wrapper .col-8,.bootstrap-wrapper .col-9,.bootstrap-wrapper .col-10,.bootstrap-wrapper .col-11,.bootstrap-wrapper .col-12,.bootstrap-wrapper .col,.bootstrap-wrapper .col-auto,.bootstrap-wrapper .col-sm-1,.bootstrap-wrapper .col-sm-2,.bootstrap-wrapper .col-sm-3,.bootstrap-wrapper .col-sm-4,.bootstrap-wrapper .col-sm-5,.bootstrap-wrapper .col-sm-6,.bootstrap-wrapper .col-sm-7,.bootstrap-wrapper .col-sm-8,.bootstrap-wrapper .col-sm-9,.bootstrap-wrapper .col-sm-10,.bootstrap-wrapper .col-sm-11,.bootstrap-wrapper .col-sm-12,.bootstrap-wrapper .col-sm,.bootstrap-wrapper .col-sm-auto,.bootstrap-wrapper .col-md-1,.bootstrap-wrapper .col-md-2,.bootstrap-wrapper .col-md-3,.bootstrap-wrapper .col-md-4,.bootstrap-wrapper .col-md-5,.bootstrap-wrapper .col-md-6,.bootstrap-wrapper .col-md-7,.bootstrap-wrapper .col-md-8,.bootstrap-wrapper .col-md-9,.bootstrap-wrapper .col-md-10,.bootstrap-wrapper .col-md-11,.bootstrap-wrapper .col-md-12,.bootstrap-wrapper .col-md,.bootstrap-wrapper .col-md-auto,.bootstrap-wrapper .col-lg-1,.bootstrap-wrapper .col-lg-2,.bootstrap-wrapper .col-lg-3,.bootstrap-wrapper .col-lg-4,.bootstrap-wrapper .col-lg-5,.bootstrap-wrapper .col-lg-6,.bootstrap-wrapper .col-lg-7,.bootstrap-wrapper .col-lg-8,.bootstrap-wrapper .col-lg-9,.bootstrap-wrapper .col-lg-10,.bootstrap-wrapper .col-lg-11,.bootstrap-wrapper .col-lg-12,.bootstrap-wrapper .col-lg,.bootstrap-wrapper .col-lg-auto,.bootstrap-wrapper .col-xl-1,.bootstrap-wrapper .col-xl-2,.bootstrap-wrapper .col-xl-3,.bootstrap-wrapper .col-xl-4,.bootstrap-wrapper .col-xl-5,.bootstrap-wrapper .col-xl-6,.bootstrap-wrapper .col-xl-7,.bootstrap-wrapper .col-xl-8,.bootstrap-wrapper .col-xl-9,.bootstrap-wrapper .col-xl-10,.bootstrap-wrapper .col-xl-11,.bootstrap-wrapper .col-xl-12,.bootstrap-wrapper .col-xl,.bootstrap-wrapper .col-xl-auto{position:relative;width:100%;padding-right:15px;padding-left:15px}.bootstrap-wrapper .col{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-3{margin-left:25%}.bootstrap-wrapper .offset-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-6{margin-left:50%}.bootstrap-wrapper .offset-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-9{margin-left:75%}.bootstrap-wrapper .offset-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-11{margin-left:91.6666666667%}@media (min-width: 576px){.bootstrap-wrapper .col-sm{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-sm-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-sm-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-sm-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-sm-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-sm-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-sm-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-sm-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-sm-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-sm-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-sm-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-sm-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-sm-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-sm-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-sm-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-sm-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-sm-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-sm-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-sm-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-sm-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-sm-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-sm-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-sm-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-sm-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-sm-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-sm-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-sm-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-sm-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-sm-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-sm-0{margin-left:0}.bootstrap-wrapper .offset-sm-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-sm-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-sm-3{margin-left:25%}.bootstrap-wrapper .offset-sm-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-sm-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-sm-6{margin-left:50%}.bootstrap-wrapper .offset-sm-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-sm-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-sm-9{margin-left:75%}.bootstrap-wrapper .offset-sm-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-sm-11{margin-left:91.6666666667%}}@media (min-width: 768px){.bootstrap-wrapper .col-md{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-md-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-md-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-md-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-md-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-md-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-md-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-md-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-md-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-md-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-md-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-md-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-md-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-md-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-md-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-md-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-md-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-md-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-md-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-md-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-md-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-md-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-md-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-md-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-md-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-md-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-md-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-md-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-md-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-md-0{margin-left:0}.bootstrap-wrapper .offset-md-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-md-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-md-3{margin-left:25%}.bootstrap-wrapper .offset-md-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-md-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-md-6{margin-left:50%}.bootstrap-wrapper .offset-md-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-md-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-md-9{margin-left:75%}.bootstrap-wrapper .offset-md-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-md-11{margin-left:91.6666666667%}}@media (min-width: 992px){.bootstrap-wrapper .col-lg{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-lg-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-lg-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-lg-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-lg-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-lg-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-lg-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-lg-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-lg-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-lg-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-lg-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-lg-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-lg-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-lg-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-lg-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-lg-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-lg-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-lg-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-lg-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-lg-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-lg-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-lg-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-lg-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-lg-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-lg-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-lg-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-lg-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-lg-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-lg-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-lg-0{margin-left:0}.bootstrap-wrapper .offset-lg-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-lg-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-lg-3{margin-left:25%}.bootstrap-wrapper .offset-lg-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-lg-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-lg-6{margin-left:50%}.bootstrap-wrapper .offset-lg-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-lg-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-lg-9{margin-left:75%}.bootstrap-wrapper .offset-lg-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-lg-11{margin-left:91.6666666667%}}@media (min-width: 1200px){.bootstrap-wrapper .col-xl{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-xl-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-xl-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-xl-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-xl-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-xl-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-xl-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-xl-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-xl-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-xl-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-xl-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-xl-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-xl-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-xl-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-xl-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-xl-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-xl-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-xl-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-xl-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-xl-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-xl-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-xl-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-xl-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-xl-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-xl-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-xl-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-xl-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-xl-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-xl-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-xl-0{margin-left:0}.bootstrap-wrapper .offset-xl-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-xl-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-xl-3{margin-left:25%}.bootstrap-wrapper .offset-xl-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-xl-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-xl-6{margin-left:50%}.bootstrap-wrapper .offset-xl-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-xl-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-xl-9{margin-left:75%}.bootstrap-wrapper .offset-xl-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-xl-11{margin-left:91.6666666667%}}.bootstrap-wrapper .img-fluid{max-width:100%;height:auto}
`, ag = `:root{--bg-surface-base: #121316;--bg-surface-light2: #272729}.bootstrap-wrapper{font-family:Russo One,sans-serif}.modal-container{position:absolute;top:0;left:0;right:0;bottom:0;z-index:100}.modal-container.fullscreen #popup{background-image:linear-gradient(to bottom,var(--bg-surface-light2) 25%,var(--bg-surface-base) 75%)!important;border-radius:0;height:100vh;width:100vw;padding-top:1rem}.modal-container .popupcontent>span{font-size:1.3rem;margin-bottom:40px;display:block;text-align:center;padding:0px 6rem;max-width:50rem}.modal-container .popupcontent>span.error{color:#bf0000}.modal-container.fullscreen #overlay.show{opacity:1!important;border-radius:0}.modal-container .react-code-input input:first-child{border-color:#ffb0cc;color:#ffb0cc}.modal-container .react-code-input input:nth-child(2){border-color:#fff27a;color:#fff27a}.modal-container .react-code-input input:nth-child(3){border-color:#6bdcff;color:#6bdcff}.modal-container .react-code-input input:nth-child(4){border-color:#ff7f56;color:#ff7f56}.modal-container.fullscreen .popupcontent{width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;row-gap:1rem}.full-room-container{background-image:linear-gradient(to bottom,var(--bg-surface-light2) 25%,var(--bg-surface-base) 75%);position:absolute;top:0;left:0;right:0;bottom:0;z-index:101}.button-bot{position:relative;top:60px;width:70px;min-width:70px;height:50px;border:none;border-radius:14px;border:2px solid #000;padding:0rem;font-size:1.5rem;font-weight:400;font-family:Russo One,sans-serif;background:#fff;background-color:#fff;cursor:pointer;color:#000;backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);box-shadow:0 7px #00000040}.button-black{cursor:pointer;font-weight:bolder;border:none;color:#000;min-width:80px;height:65px;font-size:1.2rem;background:#fff;backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:2px solid #000;box-shadow:0 7px #00000040;border-radius:20px}.button-black.disabled{color:#fff;background:transparent;border:1px solid #fff;cursor:not-allowed;width:100%}.button-black.btn-icon{background-repeat:no-repeat;background-position-y:center;background-position-x:1rem;background-size:1.75rem}.btn-invite{min-width:200px}.airplay-btn{margin-right:.5rem}.launch-btn{width:100%}.close-btn{width:100%;background:#000;cursor:pointer;font-weight:bolder;border:none;color:#fff;min-width:80px;height:60px;font-size:1rem;border-radius:14px}.close-btn.white{background:#fff;color:#000}.airplay-icon{width:30px;height:30px;object-fit:contain;margin-top:8px}.player-avatar-strip{display:flex}.player-avatar-strip:not(.mobile){margin-bottom:2.2rem;flex-wrap:wrap;row-gap:.5rem}.player-avatar-strip.mobile{overflow-x:auto;max-width:100%;padding-bottom:.4rem}.player-avatar-strip.mobile>div:first-child{margin-left:auto}.player-avatar-strip.mobile>div:last-child{margin-right:auto}.player-avatar-strip .player-score-container{display:flex;flex-direction:row;align-items:center;margin:0rem .3rem;border-radius:2rem;padding:.2rem;position:relative}.player-avatar-strip .player-score-container .player-remove{position:absolute;top:-.1rem;right:-1rem;width:1.5rem;height:1.5rem;border-radius:50%;color:#fff;display:flex;align-items:center;justify-content:center;font-size:1.2rem;cursor:pointer}.player-avatar-strip .player-score-container>span{color:#fff;font-family:Lilita One;font-style:normal;font-weight:400;font-size:2rem;margin:0rem 1rem}.player-avatar-strip .avatar-holder{background-color:#fffc;background-size:23px;background-position:center;background-repeat:no-repeat;width:3.5rem;height:3.5rem;border-radius:50%;margin:.1rem;border:.15rem solid transparent}.player-avatar-strip .avatar-holder.empty{background-color:#0003!important}.player-avatar-strip.mobile .avatar-holder{width:2.5rem;height:2.5rem}.player-avatar-strip.mobile .player-score-container>span{font-size:1.5rem;margin:0rem .7rem}.room-code-sticker{font-family:Russo One,sans-serif;position:absolute;top:calc(20px + env(safe-area-inset-top));right:0;background-color:#fff;color:#000;padding:1.45rem 1.513rem;border-radius:1.1rem;z-index:4;display:flex;flex-direction:column;align-items:center;margin:0rem 3rem;width:11.1rem;text-align:center}.room-code-sticker .qr-code{height:auto;margin:0 auto;width:100%}.room-code-sticker .room-code{margin-top:.62rem;font-size:.89rem;display:flex;flex-direction:column;align-items:center}.room-code-sticker .room-code b{font-size:1.5rem;margin:0;font-weight:400;display:block;white-space:nowrap}.room-code-sticker{width:15.8rem!important;border-radius:2.2rem!important}.room-code-sticker .room-code b{font-size:2.8rem!important;line-height:normal;font-weight:700}.room-code-sticker .room-code span{font-size:1.6rem!important;line-height:normal;display:none}.player-avatar-strip .player-score-container{padding:.1rem!important}.player-avatar-strip .avatar-holder{border-width:0px;width:3rem!important;height:3rem!important;position:relative}.player-avatar-strip .avatar-holder .badge-gamepad{display:block;background-color:#703eff;width:2rem;background-repeat:no-repeat;background-position:center;background-size:70%;border-radius:100%;position:absolute;height:1.7rem;top:1.7rem;right:-.7rem}@-webkit-keyframes playroom-anim-dash{0%{transform:translate(-100%)}to{transform:translate(100%)}}@keyframes playroom-anim-dash{0%{transform:translate(-100%)}to{transform:translate(100%)}}.bootstrap-wrapper .playroom .steps-container{display:flex;height:10px;width:100%;gap:14px}.bootstrap-wrapper .playroom .step-item{flex:1 1 0;width:0;background:#dfdfdf;border-radius:15px}.bootstrap-wrapper .playroom .step-item.active{background:#00bc8b}.bootstrap-wrapper .playroom .step-item.loading{position:relative;overflow:hidden;z-index:0}.bootstrap-wrapper .playroom .step-item.loading:before,.bootstrap-wrapper .playroom .step-item.loading:after,.bootstrap-wrapper .playroom .step-item.loading span{display:flex;position:absolute;transform:translate(-100%);height:100%;width:100%;border-radius:15px}.bootstrap-wrapper .playroom .step-item.loading span{-webkit-animation:playroom-anim-dash 1.618s infinite cubic-bezier(.4,0,1,1);animation:playroom-anim-dash 1.618s infinite cubic-bezier(.4,0,1,1);background-color:#00bc8b;z-index:2}.bootstrap-wrapper .playroom .step-item.loading span:before{content:"";display:inline-block;position:absolute;left:0;width:10px;height:10px;border-radius:50%;background-color:#dfdfdf}.bootstrap-wrapper .playroom .step-item.loading:before{content:"";-webkit-animation:playroom-anim-dash 1.618s infinite cubic-bezier(.2,0,1,1);animation:playroom-anim-dash 1.618s infinite cubic-bezier(.2,0,1,1);background-color:#9eddcc;z-index:1}.bootstrap-wrapper .playroom .step-item.loading:after{content:"";-webkit-animation:playroom-anim-dash 1.618s infinite linear;animation:playroom-anim-dash 1.618s infinite linear;background-color:#cbf4e9;z-index:0}
`, lg = `@import"https://fonts.googleapis.com/css2?family=Russo+One&display=swap";.platform{position:fixed;top:50%;max-width:500px;right:0;z-index:3;transform:translate(-50%,-50%);background-size:contain;width:90vw;left:50%;background-position:50% 55%;display:flex;flex-direction:column;align-items:center;justify-content:center}.back-dark-gradient{background:#5f33ff;background-repeat:no-repeat;background-attachment:fixed}.platform .avatar-container{width:100%;height:100%;display:block;background-size:contain;background-repeat:no-repeat;position:absolute;top:0}.full-avatar-container{width:80px;height:100px;display:block;background-size:contain;background-repeat:no-repeat;position:relative;z-index:2}.player-shadow{display:block;position:absolute;bottom:-45%;left:0;width:100%;height:100%;background-size:100%;background-repeat:no-repeat;background-position:center}.platform .avatar-photo{width:14rem;height:14rem;display:block;background-size:contain;background-repeat:no-repeat;position:relative;border-radius:50%;border:4px solid red;background-color:#0006;backdrop-filter:blur(20px)}.platform .avatar-photo.no-photo{background-size:25%;background-position:center}.platform .color-tray{z-index:3;display:block}.platform .color-tray .color{width:1.8rem;height:1.8rem;display:inline-block;border-radius:50%;margin:3.5px;vertical-align:middle}.platform .input-name{background:#fff;border:4px solid #fff;border-radius:1.8rem;padding:14px 0;font-size:1.2rem;margin:-30px 20px 20px;text-align:center;color:#000;font-weight:700;z-index:1;position:relative;width:14rem}.platform .profilecontainer{text-align:center;padding:40px 20px;background:linear-gradient(0deg,#18191b,#18191b),linear-gradient(0deg,#38393c,#38393c);border:1px solid #38393c;box-shadow:0 2px #ffffff40 inset;border-radius:20.75px;width:100%}.platform .party-hr{font-family:Russo One,sans-serif;font-weight:700;font-size:.85rem;display:flex;align-items:center;text-align:center;color:#fff;margin:2rem 0}.platform .party-hr:before,.platform .party-hr:after{content:"";flex:1;border-bottom:1px solid #38393c}.platform .party-hr:not(:empty):before{margin-right:1.25em}.platform .party-hr:not(:empty):after{margin-left:1.25em}.platform .input-name:focus{outline:none}.platform .color-tray .color.active{width:2.6rem;height:2.6rem}.platform #btn-launchjoin{margin-top:2rem}.button-crop{background-color:#fff;color:#000;width:auto;margin-top:20px}.platform .refresh-button{position:absolute;top:10px;right:10px;color:#000;cursor:pointer;background:#18191b;padding:10px;z-index:1;border-radius:50%;line-height:0;border:1px solid rgba(255,255,255,.3)}.room-code-sticker{width:16.8rem!important;margin:1.1rem 0px}.toast-container{animation:fadeIn .2s,slideIn .2s cubic-bezier(.4,-.05,0,1);transform:translate(-50%) scale(.9)}.sdk-version{margin-top:2rem;color:#fff;font-size:1rem}@keyframes slideIn{0%{transform:translate(-50%) translateY(400px) scale(.9);animation-timing-function:ease-out}to{transform:translate(-50%) translateY(0) scale(.9);animation-timing-function:ease-in}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.airplay-instruction-modal{position:absolute;top:0;left:0;bottom:0;right:0;z-index:101}.airplay-instruction-toast{max-width:500px;width:100%;position:absolute;bottom:.7rem;left:50%;transform:translate(-50%) scale(.9);display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:4.5rem}.airplay-instruction-container{font-family:Russo One,sans-serif;display:flex;flex-direction:column;align-items:center;margin:1rem 0rem;background:#fff;border:2px solid #000000;box-shadow:0 12px #00000040;border-radius:20px;width:95%;padding:1rem}.airplay-instruction-container .close-icon{background-color:#ff3666;height:4rem;width:4rem;transform:scale(.7);border-radius:50%;position:absolute;top:1.5rem;right:1rem;padding:1rem;cursor:pointer;text-align:center;flex-direction:column;align-items:center;justify-content:center}.airplay-instruction-container .airplay-icon{width:4rem;height:4rem;object-fit:contain}.airplay-instruction-container .airplay-instruction-title{font-weight:bolder;font-size:1.6rem;line-height:normal;margin:0rem;font-family:Open Sans,sans-serif}
`, tw = `.sw_background-node{position:absolute;top:0;left:0;width:100%;height:100%}.sw_parent-container{position:absolute;display:flex;justify-content:center;align-items:center}.sw_parent-container>.sw_container{position:absolute;opacity:0;transition:opacity;transition-duration:.3s}
`, rw = `.ad-wrapper{position:fixed;inset:0;display:flex;justify-content:center;align-items:center;height:100vh;width:100vw;font-family:Poppins,sans-serif;z-index:999999}.ad-content{display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:100%;position:relative}.ad-video{width:100%;height:100%;object-fit:cover}.ad-loading{position:fixed;top:0;bottom:0;left:0;right:0;display:flex;align-items:center;justify-content:center;width:100vw;height:100vh;background-color:#000c;z-index:99999}.loading-spinner{width:88px;height:88px;border:4px solid transparent;border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}.skip-button-container{width:100%;height:100%;display:flex;justify-content:flex-end;padding:1rem}.skip-button{width:68px;height:28px;display:flex;align-items:center;justify-content:space-between;padding:.3rem .4rem .3rem .6rem;background-color:#212121cc;border-radius:.5rem;cursor:pointer;transition:opacity .2s;border:none;pointer-events:auto}.skip-button.disabled{opacity:.5;pointer-events:none}.skip-button.active{opacity:1}.skip-text{color:#fff;font-weight:700;font-size:12px}.skip-icon{width:12px;height:12px;object-fit:contain}.top-left-overlay-container{width:100%;height:100%;display:flex;justify-content:flex-start;align-items:flex-start;padding:1rem}.top-left-overlay{width:90px;height:28px;display:flex;align-items:center;justify-content:space-between;padding:.3rem .4rem .3rem .6rem;background-color:#212121cc;border-radius:.5rem;cursor:pointer;transition:opacity .2s;border:none}.overlay-title{font-weight:700}.overlay-title,.overlay-time{color:#fff;font-size:12px}.bottom-left-overlay-container{width:100%;height:100%;display:flex;justify-content:flex-start;align-items:flex-end;padding:1rem}.bottom-left-overlay{background-color:#212121cc;display:flex;flex-direction:column;gap:6px;width:320px;height:140px;border-radius:12px;padding:10px}.action-button{width:max-content;display:flex;align-items:center;gap:.4rem;padding:10px;background-color:#3330ff;border-radius:6px;cursor:pointer;height:36px;border:none;max-width:100%;margin-top:7px;color:#fff;pointer-events:auto}.action-icon{width:auto;height:20px;object-fit:contain}.action-text{font-size:12px;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ad-body{display:flex;align-items:center;gap:6px}.ad-thumbnail{height:100%;width:90px;object-fit:contain}.ad-description{display:flex;flex-direction:column;gap:.25rem;width:200px}.ad-title{color:#fff;font-size:16px;font-weight:700;margin:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ad-subtitle{color:#fff;margin-top:0;margin-bottom:0;font-size:10px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.header-container{display:flex;flex-direction:row;align-items:center;gap:.5rem}.header-image{width:20px;height:20px;object-fit:contain}.header-text{color:#fff;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;margin:0;font-weight:lighter}
`;
  function nw() {
    return bc.getUrlHashParameter("preview") === "phone";
  }
  function iw() {
    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.NativeMethods)
      return true;
  }
  function ow() {
    return !!(iw() || nw() || localStorage && ct.get("DEV"));
  }
  function sw() {
    return !!(ow() || aw || lw);
  }
  var aw = typeof window < "u" && /(android)/i.test(navigator.userAgent), lw = function() {
    if (typeof window > "u")
      return false;
    var t10 = function() {
      var i = new Audio();
      return i.volume = 0.5, i.volume === 1;
    }, e = /iPhone|iPod/.test(navigator.userAgent), r = navigator.userAgent.includes("Macintosh"), n = navigator.maxTouchPoints >= 1;
    return e || r && (n || t10());
  }(), Lc = {}, cw = {
    get exports() {
      return Lc;
    },
    set exports(t10) {
      Lc = t10;
    }
  }, Ul = {};
  /**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Vh;
  function uw() {
    if (Vh)
      return Ul;
    Vh = 1;
    var t10 = U;
    function e(f, d) {
      return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : e, n = t10.useState, i = t10.useEffect, o = t10.useLayoutEffect, s = t10.useDebugValue;
    function a(f, d) {
      var h = d(), g = n({ inst: { value: h, getSnapshot: d } }), p = g[0].inst, y = g[1];
      return o(function() {
        p.value = h, p.getSnapshot = d, l(p) && y({ inst: p });
      }, [f, h, d]), i(function() {
        return l(p) && y({ inst: p }), f(function() {
          l(p) && y({ inst: p });
        });
      }, [f]), s(h), h;
    }
    function l(f) {
      var d = f.getSnapshot;
      f = f.value;
      try {
        var h = d();
        return !r(f, h);
      } catch {
        return true;
      }
    }
    function c(f, d) {
      return d();
    }
    var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
    return Ul.useSyncExternalStore = t10.useSyncExternalStore !== void 0 ? t10.useSyncExternalStore : u, Ul;
  }
  var zl = {};
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var qh;
  function fw() {
    return qh || (qh = 1, define_process_env_default.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t10 = U, e = t10.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function r(S) {
        {
          for (var C = arguments.length, _ = new Array(C > 1 ? C - 1 : 0), L = 1; L < C; L++)
            _[L - 1] = arguments[L];
          n("error", S, _);
        }
      }
      function n(S, C, _) {
        {
          var L = e.ReactDebugCurrentFrame, F = L.getStackAddendum();
          F !== "" && (C += "%s", _ = _.concat([F]));
          var V = _.map(function(W) {
            return String(W);
          });
          V.unshift("Warning: " + C), Function.prototype.apply.call(console[S], console, V);
        }
      }
      function i(S, C) {
        return S === C && (S !== 0 || 1 / S === 1 / C) || S !== S && C !== C;
      }
      var o = typeof Object.is == "function" ? Object.is : i, s = t10.useState, a = t10.useEffect, l = t10.useLayoutEffect, c = t10.useDebugValue, u = false, f = false;
      function d(S, C, _) {
        u || t10.startTransition !== void 0 && (u = true, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var L = C();
        if (!f) {
          var F = C();
          o(L, F) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), f = true);
        }
        var V = s({
          inst: {
            value: L,
            getSnapshot: C
          }
        }), W = V[0].inst, X = V[1];
        return l(function() {
          W.value = L, W.getSnapshot = C, h(W) && X({
            inst: W
          });
        }, [S, L, C]), a(function() {
          h(W) && X({
            inst: W
          });
          var G = function() {
            h(W) && X({
              inst: W
            });
          };
          return S(G);
        }, [S]), c(L), L;
      }
      function h(S) {
        var C = S.getSnapshot, _ = S.value;
        try {
          var L = C();
          return !o(_, L);
        } catch {
          return true;
        }
      }
      function g(S, C, _) {
        return C();
      }
      var p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", y = !p, b = y ? g : d, x = t10.useSyncExternalStore !== void 0 ? t10.useSyncExternalStore : b;
      zl.useSyncExternalStore = x, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }()), zl;
  }
  (function(t10) {
    define_process_env_default.NODE_ENV === "production" ? t10.exports = uw() : t10.exports = fw();
  })(cw);
  const Qr = () => {
  }, Tt = (
    /*#__NOINLINE__*/
    Qr()
  ), Vl = Object, De = (t10) => t10 === Tt, Nr = (t10) => typeof t10 == "function", ln$1 = (t10, e) => ({
    ...t10,
    ...e
  }), dw = (t10) => Nr(t10.then), ps = /* @__PURE__ */ new WeakMap();
  let hw = 0;
  const Eo = (t10) => {
    const e = typeof t10, r = t10 && t10.constructor, n = r == Date;
    let i, o;
    if (Vl(t10) === t10 && !n && r != RegExp) {
      if (i = ps.get(t10), i)
        return i;
      if (i = ++hw + "~", ps.set(t10, i), r == Array) {
        for (i = "@", o = 0; o < t10.length; o++)
          i += Eo(t10[o]) + ",";
        ps.set(t10, i);
      }
      if (r == Vl) {
        i = "#";
        const s = Vl.keys(t10).sort();
        for (; !De(o = s.pop()); )
          De(t10[o]) || (i += o + ":" + Eo(t10[o]) + ",");
        ps.set(t10, i);
      }
    } else
      i = n ? t10.toJSON() : e == "symbol" ? t10.toString() : e == "string" ? JSON.stringify(t10) : "" + t10;
    return i;
  }, Or = /* @__PURE__ */ new WeakMap(), ql = {}, gs = {}, Uu = "undefined", Ba = typeof window != Uu, Bc = typeof document != Uu, pw = () => Ba && typeof window.requestAnimationFrame != Uu, cg = (t10, e) => {
    const r = Or.get(t10);
    return [
      // Getter
      () => !De(e) && t10.get(e) || ql,
      // Setter
      (n) => {
        if (!De(e)) {
          const i = t10.get(e);
          e in gs || (gs[e] = i), r[5](e, ln$1(i, n), i || ql);
        }
      },
      // Subscriber
      r[6],
      // Get server cache snapshot
      () => !De(e) && e in gs ? gs[e] : !De(e) && t10.get(e) || ql
    ];
  };
  let Fc = true;
  const gw = () => Fc, [jc, Wc] = Ba && window.addEventListener ? [
    window.addEventListener.bind(window),
    window.removeEventListener.bind(window)
  ] : [
    Qr,
    Qr
  ], mw = () => {
    const t10 = Bc && document.visibilityState;
    return De(t10) || t10 !== "hidden";
  }, yw = (t10) => (Bc && document.addEventListener("visibilitychange", t10), jc("focus", t10), () => {
    Bc && document.removeEventListener("visibilitychange", t10), Wc("focus", t10);
  }), bw = (t10) => {
    const e = () => {
      Fc = true, t10();
    }, r = () => {
      Fc = false;
    };
    return jc("online", e), jc("offline", r), () => {
      Wc("online", e), Wc("offline", r);
    };
  }, vw = {
    isOnline: gw,
    isVisible: mw
  }, Aw = {
    initFocus: yw,
    initReconnect: bw
  }, Hh = !U.useId, ko = !Ba || "Deno" in window, ww = (t10) => pw() ? window.requestAnimationFrame(t10) : setTimeout(t10, 1), Hl = ko ? reactExports.useEffect : reactExports.useLayoutEffect, Kl = typeof navigator < "u" && navigator.connection, Kh = !ko && Kl && ([
    "slow-2g",
    "2g"
  ].includes(Kl.effectiveType) || Kl.saveData), zu = (t10) => {
    if (Nr(t10))
      try {
        t10 = t10();
      } catch {
        t10 = "";
      }
    const e = t10;
    return t10 = typeof t10 == "string" ? t10 : (Array.isArray(t10) ? t10.length : t10) ? Eo(t10) : "", [
      t10,
      e
    ];
  };
  let xw = 0;
  const Uc = () => ++xw, ug = 0, fg = 1, dg = 2, _w = 3;
  var Wi = {
    __proto__: null,
    ERROR_REVALIDATE_EVENT: _w,
    FOCUS_EVENT: ug,
    MUTATE_EVENT: dg,
    RECONNECT_EVENT: fg
  };
  async function hg(...t10) {
    const [e, r, n, i] = t10, o = ln$1({
      populateCache: true,
      throwOnError: true
    }, typeof i == "boolean" ? {
      revalidate: i
    } : i || {});
    let s = o.populateCache;
    const a = o.rollbackOnError;
    let l = o.optimisticData;
    const c = o.revalidate !== false, u = (h) => typeof a == "function" ? a(h) : a !== false, f = o.throwOnError;
    if (Nr(r)) {
      const h = r, g = [], p = e.keys();
      for (const y of p)
        !/^\$(inf|sub)\$/.test(y) && h(e.get(y)._k) && g.push(y);
      return Promise.all(g.map(d));
    }
    return d(r);
    async function d(h) {
      const [g] = zu(h);
      if (!g)
        return;
      const [p, y] = cg(e, g), [b, x, S, C] = Or.get(e), _ = () => {
        const z10 = b[g];
        return c && (delete S[g], delete C[g], z10 && z10[0]) ? z10[0](dg).then(() => p().data) : p().data;
      };
      if (t10.length < 3)
        return _();
      let L = n, F;
      const V = Uc();
      x[g] = [
        V,
        0
      ];
      const W = !De(l), X = p(), G = X.data, ie = X._c, P10 = De(ie) ? G : ie;
      if (W && (l = Nr(l) ? l(P10, G) : l, y({
        data: l,
        _c: P10
      })), Nr(L))
        try {
          L = L(P10);
        } catch (z10) {
          F = z10;
        }
      if (L && dw(L))
        if (L = await L.catch((z10) => {
          F = z10;
        }), V !== x[g][0]) {
          if (F)
            throw F;
          return L;
        } else
          F && W && u(F) && (s = true, y({
            data: P10,
            _c: Tt
          }));
      if (s && !F)
        if (Nr(s)) {
          const z10 = s(L, P10);
          y({
            data: z10,
            error: Tt,
            _c: Tt
          });
        } else
          y({
            data: L,
            error: Tt,
            _c: Tt
          });
      if (x[g][1] = Uc(), Promise.resolve(_()).then(() => {
        y({
          _c: Tt
        });
      }), F) {
        if (f)
          throw F;
        return;
      }
      return L;
    }
  }
  const Yh = (t10, e) => {
    for (const r in t10)
      t10[r][0] && t10[r][0](e);
  }, Sw = (t10, e) => {
    if (!Or.has(t10)) {
      const r = ln$1(Aw, e), n = {}, i = hg.bind(Tt, t10);
      let o = Qr;
      const s = {}, a = (u, f) => {
        const d = s[u] || [];
        return s[u] = d, d.push(f), () => d.splice(d.indexOf(f), 1);
      }, l = (u, f, d) => {
        t10.set(u, f);
        const h = s[u];
        if (h)
          for (const g of h)
            g(f, d);
      }, c = () => {
        if (!Or.has(t10) && (Or.set(t10, [
          n,
          {},
          {},
          {},
          i,
          l,
          a
        ]), !ko)) {
          const u = r.initFocus(setTimeout.bind(Tt, Yh.bind(Tt, n, ug))), f = r.initReconnect(setTimeout.bind(Tt, Yh.bind(Tt, n, fg)));
          o = () => {
            u && u(), f && f(), Or.delete(t10);
          };
        }
      };
      return c(), [
        t10,
        i,
        c,
        o
      ];
    }
    return [
      t10,
      Or.get(t10)[4]
    ];
  }, Ew = (t10, e, r, n, i) => {
    const o = r.errorRetryCount, s = i.retryCount, a = ~~((Math.random() + 0.5) * (1 << (s < 8 ? s : 8))) * r.errorRetryInterval;
    !De(o) && s > o || setTimeout(n, a, i);
  }, kw = (t10, e) => Eo(t10) == Eo(e), [pg, Cw] = Sw(/* @__PURE__ */ new Map()), Tw = ln$1(
    {
      // events
      onLoadingSlow: Qr,
      onSuccess: Qr,
      onError: Qr,
      onErrorRetry: Ew,
      onDiscarded: Qr,
      // switches
      revalidateOnFocus: true,
      revalidateOnReconnect: true,
      revalidateIfStale: true,
      shouldRetryOnError: true,
      // timeouts
      errorRetryInterval: Kh ? 1e4 : 5e3,
      focusThrottleInterval: 5 * 1e3,
      dedupingInterval: 2 * 1e3,
      loadingTimeout: Kh ? 5e3 : 3e3,
      // providers
      compare: kw,
      isPaused: () => false,
      cache: pg,
      mutate: Cw,
      fallback: {}
    },
    // use web preset by default
    vw
  ), Iw = (t10, e) => {
    const r = ln$1(t10, e);
    if (e) {
      const { use: n, fallback: i } = t10, { use: o, fallback: s } = e;
      n && o && (r.use = n.concat(o)), i && s && (r.fallback = ln$1(i, s));
    }
    return r;
  }, Ow = reactExports.createContext({}), Pw = "$inf$", gg = Ba && window.__SWR_DEVTOOLS_USE__, Rw = gg ? window.__SWR_DEVTOOLS_USE__ : [], Dw = () => {
    gg && (window.__SWR_DEVTOOLS_REACT__ = U);
  }, Mw = (t10) => Nr(t10[1]) ? [
    t10[0],
    t10[1],
    t10[2] || {}
  ] : [
    t10[0],
    null,
    (t10[1] === null ? t10[2] : t10[1]) || {}
  ], Nw = () => ln$1(Tw, reactExports.useContext(Ow)), Lw = (t10) => (e, r, n) => t10(e, r && ((...o) => {
    const [s] = zu(e), [, , , a] = Or.get(pg);
    if (s.startsWith(Pw))
      return r(...o);
    const l = a[s];
    return De(l) ? r(...o) : (delete a[s], l);
  }), n), Bw = Rw.concat(Lw), Fw = (t10) => function(...r) {
    const n = Nw(), [i, o, s] = Mw(r), a = Iw(n, s);
    let l = t10;
    const { use: c } = a, u = (c || []).concat(Bw);
    for (let f = u.length; f--; )
      l = u[f](l);
    return l(i, o || a.fetcher || null, a);
  }, jw = (t10, e, r) => {
    const n = e[t10] || (e[t10] = []);
    return n.push(r), () => {
      const i = n.indexOf(r);
      i >= 0 && (n[i] = n[n.length - 1], n.pop());
    };
  };
  Dw();
  const Xh = U.use || ((t10) => {
    if (t10.status === "pending")
      throw t10;
    if (t10.status === "fulfilled")
      return t10.value;
    throw t10.status === "rejected" ? t10.reason : (t10.status = "pending", t10.then((e) => {
      t10.status = "fulfilled", t10.value = e;
    }, (e) => {
      t10.status = "rejected", t10.reason = e;
    }), t10);
  }), Yl = {
    dedupe: true
  }, Ww = (t10, e, r) => {
    const { cache: n, compare: i, suspense: o, fallbackData: s, revalidateOnMount: a, revalidateIfStale: l, refreshInterval: c, refreshWhenHidden: u, refreshWhenOffline: f, keepPreviousData: d } = r, [h, g, p, y] = Or.get(n), [b, x] = zu(t10), S = reactExports.useRef(false), C = reactExports.useRef(false), _ = reactExports.useRef(b), L = reactExports.useRef(e), F = reactExports.useRef(r), V = () => F.current, W = () => V().isVisible() && V().isOnline(), [X, G, ie, P10] = cg(n, b), z10 = reactExports.useRef({}).current, B = De(s) ? r.fallback[b] : s, O = (k, ee) => {
      for (const re in z10) {
        const ye = re;
        if (ye === "data") {
          if (!i(k[ye], ee[ye]) && (!De(k[ye]) || !i(pe, ee[ye])))
            return false;
        } else if (ee[ye] !== k[ye])
          return false;
      }
      return true;
    }, q = reactExports.useMemo(() => {
      const k = (() => !b || !e ? false : De(a) ? V().isPaused() || o ? false : De(l) ? true : l : a)(), ee = (D) => {
        const Q = ln$1(D);
        return delete Q._k, k ? {
          isValidating: true,
          isLoading: true,
          ...Q
        } : Q;
      }, re = X(), ye = P10(), I = ee(re), v = re === ye ? I : ee(ye);
      let w = I;
      return [
        () => {
          const D = ee(X());
          return O(D, w) ? (w.data = D.data, w.isLoading = D.isLoading, w.isValidating = D.isValidating, w.error = D.error, w) : (w = D, D);
        },
        () => v
      ];
    }, [
      n,
      b
    ]), te = Lc.useSyncExternalStore(reactExports.useCallback(
      (k) => ie(b, (ee, re) => {
        O(re, ee) || k();
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        n,
        b
      ]
    ), q[0], q[1]), Y = !S.current, K = h[b] && h[b].length > 0, $ = te.data, se = De($) ? B : $, he = te.error, de = reactExports.useRef(se), pe = d ? De($) ? de.current : $ : se, j = (() => K && !De(he) ? false : Y && !De(a) ? a : V().isPaused() ? false : o ? De(se) ? false : l : De(se) || l)(), H = !!(b && e && Y && j), Z = De(te.isValidating) ? H : te.isValidating, oe = De(te.isLoading) ? H : te.isLoading, ue = reactExports.useCallback(
      async (k) => {
        const ee = L.current;
        if (!b || !ee || C.current || V().isPaused())
          return false;
        let re, ye, I = true;
        const v = k || {}, w = !p[b] || !v.dedupe, D = () => Hh ? !C.current && b === _.current && S.current : b === _.current, Q = {
          isValidating: false,
          isLoading: false
        }, ae = () => {
          G(Q);
        }, fe = () => {
          const ve = p[b];
          ve && ve[1] === ye && delete p[b];
        }, Ae = {
          isValidating: true
        };
        De(X().data) && (Ae.isLoading = true);
        try {
          if (w && (G(Ae), r.loadingTimeout && De(X().data) && setTimeout(() => {
            I && D() && V().onLoadingSlow(b, r);
          }, r.loadingTimeout), p[b] = [
            ee(x),
            Uc()
          ]), [re, ye] = p[b], re = await re, w && setTimeout(fe, r.dedupingInterval), !p[b] || p[b][1] !== ye)
            return w && D() && V().onDiscarded(b), false;
          Q.error = Tt;
          const ve = g[b];
          if (!De(ve) && // case 1
          (ye <= ve[0] || // case 2
          ye <= ve[1] || // case 3
          ve[1] === 0))
            return ae(), w && D() && V().onDiscarded(b), false;
          const be = X().data;
          Q.data = i(be, re) ? be : re, w && D() && V().onSuccess(re, b, r);
        } catch (ve) {
          fe();
          const be = V(), { shouldRetryOnError: Pe } = be;
          be.isPaused() || (Q.error = ve, w && D() && (be.onError(ve, b, be), (Pe === true || Nr(Pe) && Pe(ve)) && W() && be.onErrorRetry(ve, b, be, (E) => {
            const m = h[b];
            m && m[0] && m[0](Wi.ERROR_REVALIDATE_EVENT, E);
          }, {
            retryCount: (v.retryCount || 0) + 1,
            dedupe: true
          })));
        }
        return I = false, ae(), true;
      },
      // `setState` is immutable, and `eventsCallback`, `fnArg`, and
      // `keyValidating` are depending on `key`, so we can exclude them from
      // the deps array.
      //
      // FIXME:
      // `fn` and `config` might be changed during the lifecycle,
      // but they might be changed every render like this.
      // `useSWR('key', () => fetch('/api/'), { suspense: true })`
      // So we omit the values from the deps array
      // even though it might cause unexpected behaviors.
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        b,
        n
      ]
    ), R = reactExports.useCallback(
      // Use callback to make sure `keyRef.current` returns latest result every time
      (...k) => hg(n, _.current, ...k),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    if (Hl(() => {
      L.current = e, F.current = r, De($) || (de.current = $);
    }), Hl(() => {
      if (!b)
        return;
      const k = ue.bind(Tt, Yl);
      let ee = 0;
      const ye = jw(b, h, (I, v = {}) => {
        if (I == Wi.FOCUS_EVENT) {
          const w = Date.now();
          V().revalidateOnFocus && w > ee && W() && (ee = w + V().focusThrottleInterval, k());
        } else if (I == Wi.RECONNECT_EVENT)
          V().revalidateOnReconnect && W() && k();
        else {
          if (I == Wi.MUTATE_EVENT)
            return ue();
          if (I == Wi.ERROR_REVALIDATE_EVENT)
            return ue(v);
        }
      });
      return C.current = false, _.current = b, S.current = true, G({
        _k: x
      }), j && (De(se) || ko ? k() : ww(k)), () => {
        C.current = true, ye();
      };
    }, [
      b
    ]), Hl(() => {
      let k;
      function ee() {
        const ye = Nr(c) ? c(X().data) : c;
        ye && k !== -1 && (k = setTimeout(re, ye));
      }
      function re() {
        !X().error && (u || V().isVisible()) && (f || V().isOnline()) ? ue(Yl).then(ee) : ee();
      }
      return ee(), () => {
        k && (clearTimeout(k), k = -1);
      };
    }, [
      c,
      u,
      f,
      b
    ]), reactExports.useDebugValue(pe), o && De(se) && b) {
      if (!Hh && ko)
        throw new Error("Fallback data is required when using suspense in SSR.");
      L.current = e, F.current = r, C.current = false;
      const k = y[b];
      if (!De(k)) {
        const ee = R(k);
        Xh(ee);
      }
      if (De(he)) {
        const ee = ue(Yl);
        De(pe) || (ee.status = "fulfilled", ee.value = true), Xh(ee);
      } else
        throw he;
    }
    return {
      mutate: R,
      get data() {
        return z10.data = true, pe;
      },
      get error() {
        return z10.error = true, he;
      },
      get isValidating() {
        return z10.isValidating = true, Z;
      },
      get isLoading() {
        return z10.isLoading = true, oe;
      }
    };
  }, Uw = Fw(Ww);
  function ki({
    middle: t10,
    center: e,
    bottom: r,
    right: n,
    visible: i,
    children: o,
    flag: s,
    style: a,
    containerClassName: l
  }) {
    return i ? /* @__PURE__ */ U.createElement(
      "div",
      {
        style: a,
        className: [
          "toast-container",
          r ? "bottom" : "",
          n ? "right" : "",
          s ? " with-flag" : "",
          l || ""
        ].join(" ")
      },
      o
    ) : null;
  }
  var N = {}, Jh = {
    get exports() {
      return N;
    },
    set exports(t10) {
      N = t10;
    }
  }, fa = {}, zw = {
    get exports() {
      return fa;
    },
    set exports(t10) {
      fa = t10;
    }
  }, Be = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Qh;
  function Vw() {
    if (Qh)
      return Be;
    Qh = 1;
    var t10 = typeof Symbol == "function" && Symbol.for, e = t10 ? Symbol.for("react.element") : 60103, r = t10 ? Symbol.for("react.portal") : 60106, n = t10 ? Symbol.for("react.fragment") : 60107, i = t10 ? Symbol.for("react.strict_mode") : 60108, o = t10 ? Symbol.for("react.profiler") : 60114, s = t10 ? Symbol.for("react.provider") : 60109, a = t10 ? Symbol.for("react.context") : 60110, l = t10 ? Symbol.for("react.async_mode") : 60111, c = t10 ? Symbol.for("react.concurrent_mode") : 60111, u = t10 ? Symbol.for("react.forward_ref") : 60112, f = t10 ? Symbol.for("react.suspense") : 60113, d = t10 ? Symbol.for("react.suspense_list") : 60120, h = t10 ? Symbol.for("react.memo") : 60115, g = t10 ? Symbol.for("react.lazy") : 60116, p = t10 ? Symbol.for("react.block") : 60121, y = t10 ? Symbol.for("react.fundamental") : 60117, b = t10 ? Symbol.for("react.responder") : 60118, x = t10 ? Symbol.for("react.scope") : 60119;
    function S(_) {
      if (typeof _ == "object" && _ !== null) {
        var L = _.$$typeof;
        switch (L) {
          case e:
            switch (_ = _.type, _) {
              case l:
              case c:
              case n:
              case o:
              case i:
              case f:
                return _;
              default:
                switch (_ = _ && _.$$typeof, _) {
                  case a:
                  case u:
                  case g:
                  case h:
                  case s:
                    return _;
                  default:
                    return L;
                }
            }
          case r:
            return L;
        }
      }
    }
    function C(_) {
      return S(_) === c;
    }
    return Be.AsyncMode = l, Be.ConcurrentMode = c, Be.ContextConsumer = a, Be.ContextProvider = s, Be.Element = e, Be.ForwardRef = u, Be.Fragment = n, Be.Lazy = g, Be.Memo = h, Be.Portal = r, Be.Profiler = o, Be.StrictMode = i, Be.Suspense = f, Be.isAsyncMode = function(_) {
      return C(_) || S(_) === l;
    }, Be.isConcurrentMode = C, Be.isContextConsumer = function(_) {
      return S(_) === a;
    }, Be.isContextProvider = function(_) {
      return S(_) === s;
    }, Be.isElement = function(_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === e;
    }, Be.isForwardRef = function(_) {
      return S(_) === u;
    }, Be.isFragment = function(_) {
      return S(_) === n;
    }, Be.isLazy = function(_) {
      return S(_) === g;
    }, Be.isMemo = function(_) {
      return S(_) === h;
    }, Be.isPortal = function(_) {
      return S(_) === r;
    }, Be.isProfiler = function(_) {
      return S(_) === o;
    }, Be.isStrictMode = function(_) {
      return S(_) === i;
    }, Be.isSuspense = function(_) {
      return S(_) === f;
    }, Be.isValidElementType = function(_) {
      return typeof _ == "string" || typeof _ == "function" || _ === n || _ === c || _ === o || _ === i || _ === f || _ === d || typeof _ == "object" && _ !== null && (_.$$typeof === g || _.$$typeof === h || _.$$typeof === s || _.$$typeof === a || _.$$typeof === u || _.$$typeof === y || _.$$typeof === b || _.$$typeof === x || _.$$typeof === p);
    }, Be.typeOf = S, Be;
  }
  var Fe = {};
  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Gh;
  function qw() {
    return Gh || (Gh = 1, define_process_env_default.NODE_ENV !== "production" && function() {
      var t10 = typeof Symbol == "function" && Symbol.for, e = t10 ? Symbol.for("react.element") : 60103, r = t10 ? Symbol.for("react.portal") : 60106, n = t10 ? Symbol.for("react.fragment") : 60107, i = t10 ? Symbol.for("react.strict_mode") : 60108, o = t10 ? Symbol.for("react.profiler") : 60114, s = t10 ? Symbol.for("react.provider") : 60109, a = t10 ? Symbol.for("react.context") : 60110, l = t10 ? Symbol.for("react.async_mode") : 60111, c = t10 ? Symbol.for("react.concurrent_mode") : 60111, u = t10 ? Symbol.for("react.forward_ref") : 60112, f = t10 ? Symbol.for("react.suspense") : 60113, d = t10 ? Symbol.for("react.suspense_list") : 60120, h = t10 ? Symbol.for("react.memo") : 60115, g = t10 ? Symbol.for("react.lazy") : 60116, p = t10 ? Symbol.for("react.block") : 60121, y = t10 ? Symbol.for("react.fundamental") : 60117, b = t10 ? Symbol.for("react.responder") : 60118, x = t10 ? Symbol.for("react.scope") : 60119;
      function S(k) {
        return typeof k == "string" || typeof k == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        k === n || k === c || k === o || k === i || k === f || k === d || typeof k == "object" && k !== null && (k.$$typeof === g || k.$$typeof === h || k.$$typeof === s || k.$$typeof === a || k.$$typeof === u || k.$$typeof === y || k.$$typeof === b || k.$$typeof === x || k.$$typeof === p);
      }
      function C(k) {
        if (typeof k == "object" && k !== null) {
          var ee = k.$$typeof;
          switch (ee) {
            case e:
              var re = k.type;
              switch (re) {
                case l:
                case c:
                case n:
                case o:
                case i:
                case f:
                  return re;
                default:
                  var ye = re && re.$$typeof;
                  switch (ye) {
                    case a:
                    case u:
                    case g:
                    case h:
                    case s:
                      return ye;
                    default:
                      return ee;
                  }
              }
            case r:
              return ee;
          }
        }
      }
      var _ = l, L = c, F = a, V = s, W = e, X = u, G = n, ie = g, P10 = h, z10 = r, B = o, O = i, q = f, te = false;
      function Y(k) {
        return te || (te = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), K(k) || C(k) === l;
      }
      function K(k) {
        return C(k) === c;
      }
      function $(k) {
        return C(k) === a;
      }
      function se(k) {
        return C(k) === s;
      }
      function he(k) {
        return typeof k == "object" && k !== null && k.$$typeof === e;
      }
      function de(k) {
        return C(k) === u;
      }
      function pe(k) {
        return C(k) === n;
      }
      function j(k) {
        return C(k) === g;
      }
      function H(k) {
        return C(k) === h;
      }
      function Z(k) {
        return C(k) === r;
      }
      function oe(k) {
        return C(k) === o;
      }
      function ue(k) {
        return C(k) === i;
      }
      function R(k) {
        return C(k) === f;
      }
      Fe.AsyncMode = _, Fe.ConcurrentMode = L, Fe.ContextConsumer = F, Fe.ContextProvider = V, Fe.Element = W, Fe.ForwardRef = X, Fe.Fragment = G, Fe.Lazy = ie, Fe.Memo = P10, Fe.Portal = z10, Fe.Profiler = B, Fe.StrictMode = O, Fe.Suspense = q, Fe.isAsyncMode = Y, Fe.isConcurrentMode = K, Fe.isContextConsumer = $, Fe.isContextProvider = se, Fe.isElement = he, Fe.isForwardRef = de, Fe.isFragment = pe, Fe.isLazy = j, Fe.isMemo = H, Fe.isPortal = Z, Fe.isProfiler = oe, Fe.isStrictMode = ue, Fe.isSuspense = R, Fe.isValidElementType = S, Fe.typeOf = C;
    }()), Fe;
  }
  var Zh;
  function mg() {
    return Zh || (Zh = 1, function(t10) {
      define_process_env_default.NODE_ENV === "production" ? t10.exports = Vw() : t10.exports = qw();
    }(zw)), fa;
  }
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var Xl, $h;
  function Hw() {
    if ($h)
      return Xl;
    $h = 1;
    var t10 = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
    function n(o) {
      if (o == null)
        throw new TypeError("Object.assign cannot be called with null or undefined");
      return Object(o);
    }
    function i() {
      try {
        if (!Object.assign)
          return false;
        var o = new String("abc");
        if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
          return false;
        for (var s = {}, a = 0; a < 10; a++)
          s["_" + String.fromCharCode(a)] = a;
        var l = Object.getOwnPropertyNames(s).map(function(u) {
          return s[u];
        });
        if (l.join("") !== "0123456789")
          return false;
        var c = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(u) {
          c[u] = u;
        }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
      } catch {
        return false;
      }
    }
    return Xl = i() ? Object.assign : function(o, s) {
      for (var a, l = n(o), c, u = 1; u < arguments.length; u++) {
        a = Object(arguments[u]);
        for (var f in a)
          e.call(a, f) && (l[f] = a[f]);
        if (t10) {
          c = t10(a);
          for (var d = 0; d < c.length; d++)
            r.call(a, c[d]) && (l[c[d]] = a[c[d]]);
        }
      }
      return l;
    }, Xl;
  }
  var Jl, ep;
  function Vu() {
    if (ep)
      return Jl;
    ep = 1;
    var t10 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return Jl = t10, Jl;
  }
  var Ql, tp;
  function yg() {
    return tp || (tp = 1, Ql = Function.call.bind(Object.prototype.hasOwnProperty)), Ql;
  }
  var Gl, rp;
  function Kw() {
    if (rp)
      return Gl;
    rp = 1;
    var t10 = function() {
    };
    if (define_process_env_default.NODE_ENV !== "production") {
      var e = Vu(), r = {}, n = yg();
      t10 = function(o) {
        var s = "Warning: " + o;
        typeof console < "u" && console.error(s);
        try {
          throw new Error(s);
        } catch {
        }
      };
    }
    function i(o, s, a, l, c) {
      if (define_process_env_default.NODE_ENV !== "production") {
        for (var u in o)
          if (n(o, u)) {
            var f;
            try {
              if (typeof o[u] != "function") {
                var d = Error(
                  (l || "React class") + ": " + a + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                throw d.name = "Invariant Violation", d;
              }
              f = o[u](s, u, l, a, null, e);
            } catch (g) {
              f = g;
            }
            if (f && !(f instanceof Error) && t10(
              (l || "React class") + ": type specification of " + a + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            ), f instanceof Error && !(f.message in r)) {
              r[f.message] = true;
              var h = c ? c() : "";
              t10(
                "Failed " + a + " type: " + f.message + (h ?? "")
              );
            }
          }
      }
    }
    return i.resetWarningCache = function() {
      define_process_env_default.NODE_ENV !== "production" && (r = {});
    }, Gl = i, Gl;
  }
  var Zl, np;
  function Yw() {
    if (np)
      return Zl;
    np = 1;
    var t10 = mg(), e = Hw(), r = Vu(), n = yg(), i = Kw(), o = function() {
    };
    define_process_env_default.NODE_ENV !== "production" && (o = function(a) {
      var l = "Warning: " + a;
      typeof console < "u" && console.error(l);
      try {
        throw new Error(l);
      } catch {
      }
    });
    function s() {
      return null;
    }
    return Zl = function(a, l) {
      var c = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
      function f(K) {
        var $ = K && (c && K[c] || K[u]);
        if (typeof $ == "function")
          return $;
      }
      var d = "<<anonymous>>", h = {
        array: b("array"),
        bigint: b("bigint"),
        bool: b("boolean"),
        func: b("function"),
        number: b("number"),
        object: b("object"),
        string: b("string"),
        symbol: b("symbol"),
        any: x(),
        arrayOf: S,
        element: C(),
        elementType: _(),
        instanceOf: L,
        node: X(),
        objectOf: V,
        oneOf: F,
        oneOfType: W,
        shape: ie,
        exact: P10
      };
      function g(K, $) {
        return K === $ ? K !== 0 || 1 / K === 1 / $ : K !== K && $ !== $;
      }
      function p(K, $) {
        this.message = K, this.data = $ && typeof $ == "object" ? $ : {}, this.stack = "";
      }
      p.prototype = Error.prototype;
      function y(K) {
        if (define_process_env_default.NODE_ENV !== "production")
          var $ = {}, se = 0;
        function he(pe, j, H, Z, oe, ue, R) {
          if (Z = Z || d, ue = ue || H, R !== r) {
            if (l) {
              var k = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              throw k.name = "Invariant Violation", k;
            } else if (define_process_env_default.NODE_ENV !== "production" && typeof console < "u") {
              var ee = Z + ":" + H;
              !$[ee] && // Avoid spamming the console because they are often not actionable except for lib authors
              se < 3 && (o(
                "You are manually calling a React.PropTypes validation function for the `" + ue + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              ), $[ee] = true, se++);
            }
          }
          return j[H] == null ? pe ? j[H] === null ? new p("The " + oe + " `" + ue + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new p("The " + oe + " `" + ue + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : K(j, H, Z, oe, ue);
        }
        var de = he.bind(null, false);
        return de.isRequired = he.bind(null, true), de;
      }
      function b(K) {
        function $(se, he, de, pe, j, H) {
          var Z = se[he], oe = O(Z);
          if (oe !== K) {
            var ue = q(Z);
            return new p(
              "Invalid " + pe + " `" + j + "` of type " + ("`" + ue + "` supplied to `" + de + "`, expected ") + ("`" + K + "`."),
              { expectedType: K }
            );
          }
          return null;
        }
        return y($);
      }
      function x() {
        return y(s);
      }
      function S(K) {
        function $(se, he, de, pe, j) {
          if (typeof K != "function")
            return new p("Property `" + j + "` of component `" + de + "` has invalid PropType notation inside arrayOf.");
          var H = se[he];
          if (!Array.isArray(H)) {
            var Z = O(H);
            return new p("Invalid " + pe + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + de + "`, expected an array."));
          }
          for (var oe = 0; oe < H.length; oe++) {
            var ue = K(H, oe, de, pe, j + "[" + oe + "]", r);
            if (ue instanceof Error)
              return ue;
          }
          return null;
        }
        return y($);
      }
      function C() {
        function K($, se, he, de, pe) {
          var j = $[se];
          if (!a(j)) {
            var H = O(j);
            return new p("Invalid " + de + " `" + pe + "` of type " + ("`" + H + "` supplied to `" + he + "`, expected a single ReactElement."));
          }
          return null;
        }
        return y(K);
      }
      function _() {
        function K($, se, he, de, pe) {
          var j = $[se];
          if (!t10.isValidElementType(j)) {
            var H = O(j);
            return new p("Invalid " + de + " `" + pe + "` of type " + ("`" + H + "` supplied to `" + he + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return y(K);
      }
      function L(K) {
        function $(se, he, de, pe, j) {
          if (!(se[he] instanceof K)) {
            var H = K.name || d, Z = Y(se[he]);
            return new p("Invalid " + pe + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + de + "`, expected ") + ("instance of `" + H + "`."));
          }
          return null;
        }
        return y($);
      }
      function F(K) {
        if (!Array.isArray(K))
          return define_process_env_default.NODE_ENV !== "production" && (arguments.length > 1 ? o(
            "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
          ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
        function $(se, he, de, pe, j) {
          for (var H = se[he], Z = 0; Z < K.length; Z++)
            if (g(H, K[Z]))
              return null;
          var oe = JSON.stringify(K, function(R, k) {
            var ee = q(k);
            return ee === "symbol" ? String(k) : k;
          });
          return new p("Invalid " + pe + " `" + j + "` of value `" + String(H) + "` " + ("supplied to `" + de + "`, expected one of " + oe + "."));
        }
        return y($);
      }
      function V(K) {
        function $(se, he, de, pe, j) {
          if (typeof K != "function")
            return new p("Property `" + j + "` of component `" + de + "` has invalid PropType notation inside objectOf.");
          var H = se[he], Z = O(H);
          if (Z !== "object")
            return new p("Invalid " + pe + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + de + "`, expected an object."));
          for (var oe in H)
            if (n(H, oe)) {
              var ue = K(H, oe, de, pe, j + "." + oe, r);
              if (ue instanceof Error)
                return ue;
            }
          return null;
        }
        return y($);
      }
      function W(K) {
        if (!Array.isArray(K))
          return define_process_env_default.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
        for (var $ = 0; $ < K.length; $++) {
          var se = K[$];
          if (typeof se != "function")
            return o(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(se) + " at index " + $ + "."
            ), s;
        }
        function he(de, pe, j, H, Z) {
          for (var oe = [], ue = 0; ue < K.length; ue++) {
            var R = K[ue], k = R(de, pe, j, H, Z, r);
            if (k == null)
              return null;
            k.data && n(k.data, "expectedType") && oe.push(k.data.expectedType);
          }
          var ee = oe.length > 0 ? ", expected one of type [" + oe.join(", ") + "]" : "";
          return new p("Invalid " + H + " `" + Z + "` supplied to " + ("`" + j + "`" + ee + "."));
        }
        return y(he);
      }
      function X() {
        function K($, se, he, de, pe) {
          return z10($[se]) ? null : new p("Invalid " + de + " `" + pe + "` supplied to " + ("`" + he + "`, expected a ReactNode."));
        }
        return y(K);
      }
      function G(K, $, se, he, de) {
        return new p(
          (K || "React class") + ": " + $ + " type `" + se + "." + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + de + "`."
        );
      }
      function ie(K) {
        function $(se, he, de, pe, j) {
          var H = se[he], Z = O(H);
          if (Z !== "object")
            return new p("Invalid " + pe + " `" + j + "` of type `" + Z + "` " + ("supplied to `" + de + "`, expected `object`."));
          for (var oe in K) {
            var ue = K[oe];
            if (typeof ue != "function")
              return G(de, pe, j, oe, q(ue));
            var R = ue(H, oe, de, pe, j + "." + oe, r);
            if (R)
              return R;
          }
          return null;
        }
        return y($);
      }
      function P10(K) {
        function $(se, he, de, pe, j) {
          var H = se[he], Z = O(H);
          if (Z !== "object")
            return new p("Invalid " + pe + " `" + j + "` of type `" + Z + "` " + ("supplied to `" + de + "`, expected `object`."));
          var oe = e({}, se[he], K);
          for (var ue in oe) {
            var R = K[ue];
            if (n(K, ue) && typeof R != "function")
              return G(de, pe, j, ue, q(R));
            if (!R)
              return new p(
                "Invalid " + pe + " `" + j + "` key `" + ue + "` supplied to `" + de + "`.\nBad object: " + JSON.stringify(se[he], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(K), null, "  ")
              );
            var k = R(H, ue, de, pe, j + "." + ue, r);
            if (k)
              return k;
          }
          return null;
        }
        return y($);
      }
      function z10(K) {
        switch (typeof K) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !K;
          case "object":
            if (Array.isArray(K))
              return K.every(z10);
            if (K === null || a(K))
              return true;
            var $ = f(K);
            if ($) {
              var se = $.call(K), he;
              if ($ !== K.entries) {
                for (; !(he = se.next()).done; )
                  if (!z10(he.value))
                    return false;
              } else
                for (; !(he = se.next()).done; ) {
                  var de = he.value;
                  if (de && !z10(de[1]))
                    return false;
                }
            } else
              return false;
            return true;
          default:
            return false;
        }
      }
      function B(K, $) {
        return K === "symbol" ? true : $ ? $["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && $ instanceof Symbol : false;
      }
      function O(K) {
        var $ = typeof K;
        return Array.isArray(K) ? "array" : K instanceof RegExp ? "object" : B($, K) ? "symbol" : $;
      }
      function q(K) {
        if (typeof K > "u" || K === null)
          return "" + K;
        var $ = O(K);
        if ($ === "object") {
          if (K instanceof Date)
            return "date";
          if (K instanceof RegExp)
            return "regexp";
        }
        return $;
      }
      function te(K) {
        var $ = q(K);
        switch ($) {
          case "array":
          case "object":
            return "an " + $;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + $;
          default:
            return $;
        }
      }
      function Y(K) {
        return !K.constructor || !K.constructor.name ? d : K.constructor.name;
      }
      return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
    }, Zl;
  }
  var $l, ip;
  function Xw() {
    if (ip)
      return $l;
    ip = 1;
    var t10 = Vu();
    function e() {
    }
    function r() {
    }
    return r.resetWarningCache = e, $l = function() {
      function n(s, a, l, c, u, f) {
        if (f !== t10) {
          var d = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw d.name = "Invariant Violation", d;
        }
      }
      n.isRequired = n;
      function i() {
        return n;
      }
      var o = {
        array: n,
        bigint: n,
        bool: n,
        func: n,
        number: n,
        object: n,
        string: n,
        symbol: n,
        any: n,
        arrayOf: i,
        element: n,
        elementType: n,
        instanceOf: i,
        node: n,
        objectOf: i,
        oneOf: i,
        oneOfType: i,
        shape: i,
        exact: i,
        checkPropTypes: r,
        resetWarningCache: e
      };
      return o.PropTypes = o, o;
    }, $l;
  }
  if (define_process_env_default.NODE_ENV !== "production") {
    var Jw = mg(), Qw = true;
    Jh.exports = Yw()(Jw.isElement, Qw);
  } else
    Jh.exports = Xw()();
  var Gw = !!(typeof window < "u" && window.document && window.document.createElement), Zw = /* @__PURE__ */ function() {
    function t10(e, r) {
      for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
      }
    }
    return function(e, r, n) {
      return r && t10(e.prototype, r), n && t10(e, n), e;
    };
  }();
  function $w(t10, e) {
    if (!(t10 instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function e4(t10, e) {
    if (!t10)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t10;
  }
  function t4(t10, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t10.prototype = Object.create(e && e.prototype, { constructor: { value: t10, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t10, e) : t10.__proto__ = e);
  }
  var bg = function(t10) {
    t4(e, t10);
    function e() {
      return $w(this, e), e4(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
    }
    return Zw(e, [{
      key: "componentWillUnmount",
      value: function() {
        this.defaultNode && document.body.removeChild(this.defaultNode), this.defaultNode = null;
      }
    }, {
      key: "render",
      value: function() {
        return Gw ? (!this.props.node && !this.defaultNode && (this.defaultNode = document.createElement("div"), document.body.appendChild(this.defaultNode)), yr.createPortal(this.props.children, this.props.node || this.defaultNode)) : null;
      }
    }]), e;
  }(U.Component);
  bg.propTypes = {
    children: N.node.isRequired,
    node: N.any
  };
  const r4 = bg;
  var n4 = /* @__PURE__ */ function() {
    function t10(e, r) {
      for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
      }
    }
    return function(e, r, n) {
      return r && t10(e.prototype, r), n && t10(e, n), e;
    };
  }();
  function i4(t10, e) {
    if (!(t10 instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function o4(t10, e) {
    if (!t10)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t10;
  }
  function s4(t10, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t10.prototype = Object.create(e && e.prototype, { constructor: { value: t10, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t10, e) : t10.__proto__ = e);
  }
  var vg = function(t10) {
    s4(e, t10);
    function e() {
      return i4(this, e), o4(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
    }
    return n4(e, [{
      key: "componentDidMount",
      value: function() {
        this.renderPortal();
      }
    }, {
      key: "componentDidUpdate",
      value: function(n) {
        this.renderPortal();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        yr.unmountComponentAtNode(this.defaultNode || this.props.node), this.defaultNode && document.body.removeChild(this.defaultNode), this.defaultNode = null, this.portal = null;
      }
    }, {
      key: "renderPortal",
      value: function(n) {
        !this.props.node && !this.defaultNode && (this.defaultNode = document.createElement("div"), document.body.appendChild(this.defaultNode));
        var i = this.props.children;
        typeof this.props.children.type == "function" && (i = U.cloneElement(this.props.children)), this.portal = yr.unstable_renderSubtreeIntoContainer(this, i, this.props.node || this.defaultNode);
      }
    }, {
      key: "render",
      value: function() {
        return null;
      }
    }]), e;
  }(U.Component);
  const a4 = vg;
  vg.propTypes = {
    children: N.node.isRequired,
    node: N.any
  };
  var zc = void 0;
  yr.createPortal ? zc = r4 : zc = a4;
  const Ag = zc, wg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAgKADAAQAAAABAAAAgAAAAAC7tGl0AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgoZXuEHAAArZ0lEQVR4Ae19aaxl2XXWvm+sqlfz0FVd3dWTbYzt2B1wTBIBDgpBSgiCIKYQQXAifhhFIJBCTJAwIUjgH5GQkILgR/4RKVKEhPiBlERWjGkIKAbHbmxntONuu+exurqq3sz61rTX2nuf816V2+62q069d/YavvWttYdz7rnnnndr8dhjj+2Xu9sdOwJLd2zP73acR+DuArjDF8LdBXB3AdzhI3CHd//uGeDuArjDR+AO7/7dM8DdBXCHj8Ad3v27Z4C7C+AOH4E7vPt3zwB3F8AdPgJ3ePfvngHuLoA7fATu8O7fPQPcXQB3+Ajc4d1f+Vbv/6IsCn5kg3CLz78QXCJuMc5SvsXbb5kFkCaaJ22/7O/vlz36t7+HyRP9UPPBa0ZWzWIBZvpHLVYS/tn2rbAwvokXgEwFTStP9O7+LrV7PDc8TUtLZXlpmX5X/HeJ9SWazGX6pVbRaLBYsFywWPaIa29vt4Bzd29HZLScQxYTLwZw6AKppxlZFkz9TbD7plgAdtTZZPNk6WQv0USvLK+WtdUjZZ1+0a6urJdVsmHyMeky2cSCo3i/HsE2PzT3tOnxTA3y0IqQRUHtLi0GLIidve2ys7NVtnY3y/bOZtnauVl2drdooeww1hYD8slmuYRbjW+p5i27AOSUi3mQCeCjm8YTk3pk7Wg5ur7Bv+trx8rayhrbF7QYdB598nguMaU8p3SG4AnGHEBYwCMToo3PjuMWZWVptRT6XStHSlmTSeWXF10UWAyb29fLzZ3rvij26WxBK47OMvUsISnaRJ7xTRHecgsARw8me3cXp9y9skQ6jupjR46XjaMnaNKP04Svl+VlKZ3PBnt06qYZ3tvZ4UHkIW7GGQsgbTb50U6yqxoAXc4ItY08q0trZXX9SNlYP0X10mLd3eZFcHP79XJz+1rZ3L1BZ5Bt5qAXJe4P4n3hRbI3QX7LLAAc8Xs0kTt0eoV8hI7s48dOleNHT9GkH6PT+hofTVgcjMNkY5JwQPKsQZCjU3SdSmpUkuFlPRvT4ggTzwEaLGZPxqRwyXWDXHsAv0TXF0fXaKGunuAFvE39wWK4sX2V2539LaqSzguEC8Uj9E3Z3uQFIAOK11cc7XjtPn3iXDm5cZaO+A1+bccgyRkBR7kc4T7RmPA0Qaa4WQaVzH7EKQSOduLd5YJh1EBNcKmii0IdeNdBK5RxmOjVpfWyRmeI42tnyvbeFi2C18rrW6+WzZ1r/A4FCwG4N2t7ExYAdRfzRqOPK2xsx+i0foYm/sTGGTrdr7MNV+O7u3JqhwFDhIHicQ6zIJOoBmrc5aZoRF6ml50qbvIYcrNcDT2m+oxR6GRB8J4WNVCwy2LAy8V5XgybdAF5feuVcn3nFb64hF8uHiXeOL/e7Td0AfBpngZld2eXr85P0YSfOXmBT/V4y4ZTOybdp5EHTrQ4cSLnCVDNJ451N8ok+GASgbtcMIwaqAkuV+x6wLhqXaM4mkwyy6UmRVL/ZFuU9eVjZf3osXJi73y5vv0qnRVeLlt7N9j9jXx5+IYsAEw8jvhteguFq3hM+tmT9/BFHVY+3mbt6AUcj0AdSx942NuJ9wlyPAluNDwzuuJui+HWrRzvmmGM1B1Oh6r4h+vTVBVefeLCOIhES51Jlhcr5eTahbKxcobOBrQQtl+mC8fXGbREPieXsDd8/3VfAJjgHboyRotJP3fqIl/Rix03b/b5oo9P8iTz+OggobeTk85ODI+CuxgdK+NUvFozLxklj8VI2x7tsFYcJZQfA0sLTHKwwap0BSd69BnXPrjGwXgcXz1bji6fLDd2rpZr2y/SGeE6jQ2uEXBfIXSQY9+Y3ddtAaBDfHeOTnsnNk6XC6cvyxFPZwN7bce1AA+ETVLoIxaGb4OBbgc5wm2WnEEFbiJwiheJPZhElyXA1YCbX4gakRvPgTHgC11aCBgRnA2O0ELA9cG1nRfoGmGT3jVgqhiJrG/Y9oYvAHud36H38bhhc/Hs/eXU8bNUOk71ttq1KzaSoRWR9mozV9WrD6NQJ0eUFl8xldAx7JQd25LDuAdxjtNpdx1cFseS90M1NGqToFo/HwrUH7r4xcsDbRsrZ2khnOCzwfXdl+hsQddOb/Dbxzd0AWDycbpHkRfP3FfOn76X3tqtkk3u00sXU/+5ozIINCA6kD6erlcfB9DOB04Fhnqg+aPB6V047FHrLEFg0XXL59WFHGpzLGV1OfvaenCdQDe6y6nVS3xGeG37ubK5d43fLbxRLwtvyALA0Y3icZGHGzeXzl2h0/1Jvqrf3pHXf3Q1DppPujt8zBwY8QyLA3eYiSd8DLECWt7MXYM8VgO6uAqV3nmAdwHUtIkjTbxifdIrrNbM/Px5Jt2BPlrOrj1QXt95uby++zx//vBGXCR+zQsARz1u26K9dO7Bcp4u8vABzA5NPDZeHHFgWPbe1876AOQjJA0aY3TIImeIhQhSd3sqFxjCsB5023Gatkvc1y/pfeK9hhgajExMY0z/MJYby2fL+uJYubqLs8FVvTYQztvZfw0LAOUUPupxf/7y+Yfo6D/Jb+l2+S2dvqZxB6xz1DH5qbW67gL70sCpQggjChi2DnlhbGOYQkNiUDR5XMiXeRQdm0wwPM0LJAZxN7RGJwh9Ez/2GE2+DU73D5cXa+X0yv0F1wXX9p6Hh/y4tZw5yHDgdlsLAEc7LlZ26E7e2ZMXy6WzV/i2rR31Ui4KRv7aYS8vCGmigXafKK6qwE3dMX2PiWDUEHnJ17oDAYuux9g2SGmagFy/xncJvYRYmKBSblLkR4homrEQ8NYR28bSubK6OEJng2fKTqF3CnS9EJgZc9DulhcAn/Lpxg1KuXzuIX5fv0e3bXHVD5uMh/YiN14bH5fqQ4F50MTB+w4TDU6nwuGO9sDgBG09uSaKCEEsui5Crl+GXKsxRVra13iNNY9zwkDRSbdA9lgEXweslmPlzPID5bW9Z8vNfXpJ4DOBQw4UbmkBYPJxlY8Pbe4//wjdwj3Nr/98M4cnX6umxut3UzRKhxyDMqnHrAdj1dVIjbvdFI3S3zp4DurifCidMNZU44SRy1Ox+mKoFe82F2LN1chSVSU59snmZqIPDhfpRhK/ZVwqJxf30tSvlev7L/KBaGdhLXqyOfQCwOTjKn/jyMly34VH6Ombo36hB3a7ceO1sTCYVAdwEBemUJaxk0EIQBJdC0I7WCkuxjCp0HNFzqE213MQm6PPa5M43nOIg0KhKmaSZoIlru0HeFNf2MDZeKdRIRc+dKILxMV5XgTX9p8hHXcXD74uONQCwKkdk39q41y57/zDdJW/wpOPRYGZkYK0QNZbo3XIMGE9azA3dScdpZcWdeuqnltQlchiPJiEhjpMRI3T6gK2+pwTIDcHq9uEhQ8Im1mMEzaHi2BucVZ/7XW0GYpincdEzAOidst6Ocn3YV6jRUBPVxy4CA5cADz59Nzb2ROXyr3nHqAq9G0ftd4BLYgLj8UF2cBsCvaqq5Ea7gp9KohPCJdo8PhTQrrgxNtL2zw3RkN+zGWjwjxsVGrIKY4NjACFx5lQsYKRPJEsxHK8+FAvDg48r4inhPboRhg/l0g2O1Mqo6WqtTKPe6UuSVyNJA3rhZ2emVih64IT5b5yrTxNSwIPoEyfCQ5cANs0+edPXS6XzlzhzvCzbph8lEO7dtLZLONgAMEq3hsjUIOF2AAdo49K8QkhflfobuISPVhx8+ZNHliEaPIBNxclENu7SbNYMmFhKoEKMLiDOVhVdEtYKZj8tbV1rnNra4sXwfqR9bK5tckLmc+aYHUOZ3GbuwNvtUHCFuKguSrXBSt0PXBi/3J5bYFFQOM28Q5hdgHg+bZ7Tt9Pv/fxfXzJIqezduJrAbUarskLsyLVkBvuDzjBjuf9fuuz/6d88n/+erl69dVy/tyF8j1/6vvKO972zoJBlc7H0ypXI2by2iY1tYkU5nWJkOoHAZmVVegcH+OrERIeYsHkP/Pc0+UTj/1a+cpTT5K+Vr7j0e8s3/HHvov6tczPQmAROHelQErN5RLrrLnJBcFXlbCqUGO3kbEIrtEi2Ck3hotgYgHgan+LJ//CqfvpSp/u5dM/fpvXjFRVKav8aCdCw3XxboiBEV4M4CoN2K98/L+Wv/PhvyYEYf+ff/FXy3d+4E/ymWApz39AEU+Tz5zVLLXU2hUhZq2mtZmuoEbFTRo8zfSHT3yx/ODf/J5y/fo1RUjz0Z/8WPmRv/KhsqDC+SWClzoPhzFFhceDHZ5Oa4bRbUEhWzITP18I7i+Xjf1LvAh2F/2ZwB5g51zYYZIx+edPXi4XTuHIl2fewW6nZwyc/ZpQdSJxvwps0BgkIbOYaOIpELF79JqPo+dLX/6iT/4jD769PHD/Q+Xb3vUoosqH/9GHyrPPPkMDvaafLAoPfJZfakRe8WnDft05FnG8AY469J/ZpEbxxSDm5BiL36drlaVyc/NG+Xe/8G948t/zzkfL5Yv3l0cefEd5+Mrby8/+3D8pn378U/zhGNdKocjnvCBlm5jgYp8IWa3INpw9YIZD8uCezXI5vk9vE/fXyYNPGvXoISmdAfiCjx5cPHviIh39V/i2LgYGdmwg9A0JoEQb1GgkOblZV0tyIG6fL/o+/4XHOQUm/4tf/n2Wj6wfLQ+T/iXSYbt4z71MXCl6TrY4gAT5YT7eqU97IXa3KSx1GDXWcOEgAw0N7szh0fWnnv1q+eX/8h9p4q+Uz/3OZxz8rj/yXpaxAN5PLwf8EkBkNg1O2wisus3oxuNu9XRwyiIPnCyXY3QmeH3p6bK3wAd0cmHoC4CPfHp+/eTRc+Xi6Qf4NGWT76Q6AlWXosTs1jzYauayAwSRNQ5FQt/niyX4rt+4joY2vOugR8a25QFSbgkHKpzkeIuNylwEOSWHwCo2TLvjNaIJYHfAAJUg5IOOydzelg/A7PE2vGvBE8/bW2Lf3Lwpt3ERQL/7dC1gXQiCmJqcqJ1Nya5W0EFsN7aLB9cEy2W1bOxdLNeWnya8PIXELwFYkfizJzzPfu+Zh5gNq0aGGCzotAwaaudsYma7pYePf1EI4xAjsazDbBgjMhzpyHH/ZbzVLOXkiVP8mrpxdKPcc4FWrr6mXjh/j+Sk6wXJ4alEUKPlYTLOgdxWD1nNZmIKAFZ+rW4EcDzibFMOqLgVfubU2XLfpSvluRef5rPACl3M8h+1HDvGEQ9eeZg+M1mR+rFkkMTqNclMHEEKapZGoGwHuNaDEN84Xn21eMpG1x54oIReBo7tXlA4XrrIgYcy11aOlMtn6SYPPcyBJ3d4TbfJUQh5ZCBY8uJQpPbF/W7jGK5ZQIFX+OgPKug98+bmZvm2dz9a/u6P/kT53T/4Qtna3iyv37hWvvr0E+WlV14oH/2pf0WvqW9nnFxJK6cmsglilTKhHp90GwzYxMW1eweCzeOFQPsDQt0aXj570hnqNC2Aj/7Uxxj01LNPcv1H6G8CPvv5/1ve9573l+/+wAf5zIp7A1KF1mIqWq3O+8JstuPE2iezacsumnj+N/bBiptDK3vHytHdc4Skey0/9uM//jM4fV0++7ZyZHWDJj9+qFOJZFC4Qq5RJQGwgtS0RQfJoqrR9YjTODLh6hh/AfT+Rz9QTtFg/vff+HUwlgvn7ik/85GPlb/+l/8Wf+qIlwR5hl7ZlZ7BKldWsrqNEaTHAHUnE0UnPXIERxDBjAPn4QfeVt737j9efv9Lv1teeJE+s9+6WT70wx8uP/0Pf7ZcuucSvY2lv3wKf8OoFUkC4msoxU3FjO1wz/l6LxYrrHJBSNch/+2Tn9i/dPqhcnrjHnqtxWsVALJx0rrj6rwQFTi9GzXOdRLkxyhZN/ZukMmBRYAbP6ji2eefKTfoWmBj40S55/xFvilkD590sZwzDIbXoCmbAIXXujCQIYYdqgfWUH8QNRBHLc5MeDfz0ssvllevvsx9Qe2rq6t65opvvCRBl9eqIkdbktQ1ZZfAoXfUF4IvPvOpz+/LRV99eyAFeUQtwqvRFK7TYLh8a3EoOeWDri9BdkcNiwJHDja5gmZRdpQuddjrgJ22WhjjG5X9IcQ5ObT2XMmimxOLgfbOQQnw8fgaTThu/GBRbG3Tn5BTH/BWMSDb0pRcmJzPMyA09bR6GDznQ9YhY1l85Xde2cfrvl30eYGE9xAVmMSNqV5UZz9NYVApci5OIBxnMAwcJt4C4+cAUljokgVxprSrnAFjhSYTkGQQm3oCwMWmI9WuBJxRzmTyWo8/GJU/EXd2D1Iwh4b+BLPUNAhQ0zBqzse5JAFiV1CcTD4Z2xXGRJoi1KBmBBiTSa7DV3Fixr6OH3k1nO15xy8By6itviIxPnW4pke08lVSlqrKyaNaYxAaPCOxFl6RjnPB+4drlGWvndhDPOfV5EMzfOSorDXCjEMvBww9QkD+1ruC26/YPJkKDnQH1yREhiZfcKuikcFRO6nG3AQScsiP5pHCvBazxniW1SDwwIcAIawIJWFzY1W1WhmkAYGWAQkVnJoTmSvEOSbr8bCut8498Mz7LCt3Y1hMWXEzC/3kcV0RRLKrbdHR4bhgVJEbN4vQDRaZU4cVX8Nc4m6ylkwUnXSCqT7i9a7ogmHSGqKxmbDj1wS9XdjHdiRJFVnqcb1CpZiJOPNOJrTu0EuA9NdHxpPXWPK1bterzwJTHIyOVQTrYqzY6lOPGDQWSg2rxmrTeEJ1nBqchqpSWHmUIBgtn8Z6J8yeoKpQk8yIhWVoN1cfYSSpXuaSGIhDX8DM+duXopXWUMdhUDzXq/SxdoHGCq0c6Y9jRag5FMbxDkojydYmIKvTnGBPg9GlIEOwCZ6DINJWnaOcjKgQjuCdgjsXG1JFIUbEoVeJhj5laOexEusYdMUIgj8LqJ3zTLXrbnLBuUdxcHouFkSrWA13Okd7YA2rvmqz9GSRHzNIyzZGV7uq1cog97PdnS5IP6pKeFWoSWZmEmNvt7CJ6eOAad+Ep9beDay76KQ2rMaq5ZbOAGhpJz9srL3T9JHHcWoMPhZdF6GrgcypU4qvYS5xLawlE0UnXcoHeMQrdt2HuCBy33UnXU/OwNDZ4aPIriCxgyzVpGZJchs+o53Kh1okqWXqWu+CcuCTCasH0byNSGpOBymWmsoqNtdZdX/IFGyGqUEsVVUSkJ5MCGNbY1XVrbVwScQ63bGrALabCjt/SifofrGpPY2b2dAyUeqpeDXBwBP8k95xXyWS95OLUDFSlhYR4vQMAIsmbzB1/MgRfCy6LkLF1qypS463cQoGVJBUUuRHySonpFneQSCoF5Rgl/7Ofo+eaqbbjUrIaXQnpiV6sHIJD8KE2+LioaypRqVgW6rIuVEKtqF3zidhFDiMrJyjejRWXLSfwdDbQPUGUO3kwb6KrVklKhKKjy11p52gJkB5qJJeedmnag0O4U0xTqM5d+jLHo9uvlBOv/q5srr9ClHkW7Nguklf1/LyyfeUzZWT9KnZln5m76MUs2viad/Qo0VJ4xVmXtLmjug5H4ikuzPcYcD5baBlr+OnwbFxPhEqVqPJnDocY2tVlkqLdJUEJgilqW+CF15NQYJLHMSam3C6pw9Bl9fLmatfKJe/+m/LYvsJOh3g28gcxHFYECf3r5dzLz1anrzv75WrR6+UZfqev326q+ebkreR7FdjGgcLnPMpZm5imXOYVILFRftZTHCquPjDz7ykw6eW3ARCcsiPdcl93mGNBcDFdnLcoaiW080J6ITVmgPdzoJrFEfPwtAj5cc2ny2PPPXP6TNbmtByjlr65BP3mQENt2wLPTWz2Hmi7Ky9s/zeg/+4bK8cK8v8TZ9ytgjMqFQ2MvoYmM1aDZjzT/qIg33DpJ6aUdwPyxnajjtx0Y2gNgH7HSRCM4c8aIlY8TXMJS6li0e3MkRKJtuIF06GD4LELuGKYsXs8iTMopzZ/Gwp6y8Sz0M0wfR1bPjwc4dQu/TLYOOgr3Vdua+sbH2+nLn22+XpM3+CPjvHS0ECeUyqFxQB1vksBWCDvpibKQ7yI1HIZbFou7wdTgzY+0sAm+qO+VINEpPJ3cZw9EoFabIqvmwjHJlTwYGiigxybrez4BqomM+Byry0v13Wll8o5Sh92TNAu/RAJCbffrdJxoKwTR+HW996kfDyZY/mQnyq1x0kzPmAO8A/tyg03EigdtuwLsopmwiuqjW9C4DtlieoCeAEKQuVlXTNTLZUcMCIyAAFS8P2unNfb2ILdwYSfRJfdui7e/EAXKHn5OsCoHcCmPwl+kWLX2z8kkB/8k5f5uivD9QJ9TLEd2qc8DLs4IklkiG5maf9SNDlTlyiJFMoHu+H+glSdCJ2m0aHWWVXykCK/HgqFhToUBcEJirtg91FFlwTSFWtKEnjdn4BoP4tlWsrj9CXLW2UBT793KVur9Ahv0MzvUyLAAtgiVpMPF0aLOjqvyyfL68dfZBqwfjQL57gjRvnSCMUvdp/BmW7ahw57dYhIMAEpsuccKIkk1eRreEMQAjyJeKAZTFMOvjE5sxG0Nfc8nqw9Y8Bkajh5kzsH+ZE5gqpPExLT77Sg5BX9+8vF4+8nV7zvkITf1RO+duYfIIvMPkQ5M+sFzdfKTeOfHd5bf0SrQ+8C9DJ1xxpjGo2luaO9jkfgoXekzTMona5FW5etMkkjmwNKcI1QAgLAI4Po8uuAOV0pCcTgtSQCnYbsxImR7nGgmttCZHc0ihh5hWGJZrjbfr6Vfq+vaX3ltPrXy7727jSJy9eEvDLE0yLgNno7ED/8cOrJ7697ND/BbBG3/ePJZT6kbOxNje5HJu7kxicewLjfovqcGLozFKZRXH3MsbeBQASPCzWXaUJGAQ08yeJCJMKDjEuNoFsr07hsZLcDrMoTbjjUVCCWwgOYLqYe2nrXeX06Y+XxQpN6BZdEC7RH5vQFT4d+HSvAI/F0cKg7+HbP3KlvLzxTjr6cTew6U/NRvgum3vZM+MHUKJpP0Ez6E3AerTnrEIgVDFYPDPw4Qyg4aFoDkqRpMiPgi0G5gT0Qqs1B7qdBdeYMJRAuviyLaQnR46uNVlV+/R+f3lpq1y9cW956cafL2dP/aeyWN6Q0z9uCy/haWj6w8m9m/TS8EJ55thHyo2VU3QnsLkJZNSTxWjGYUHWE5AoYIDretNhOoRWFXhVzKFZsyB5Ioh9FdCohCWL/Fhc6EONY6eqbm0Gi+3V6XwNTHJi71iHsm9sl4BhCF3hLS12ypPPfRf9p08nytmNT9HfGLxcdreukoe+f2DlONnPluc3PlieX/6j9N6f7geEO4AHHu3dANV6vZ7pom1JDIJgEgbnqSj3sUkBGZe1GIqltPi933zOEX19BHGvhrLerMKAEZH2nS3W6qiEi0qXF+nJGGi1IOM9jA/RC3pMm75D48g2/R9DL5d//x/+dnnfe/9G+b4/88Pl1Zv0jR7LR+nuGB5Bp9cNgk+wcm72DQtit9bKJGLo9g174qpKlYygsaharVWyCGubjPwGiCe5DjgFY6D518KoZTPClQI59Fca9YAIhupWnII1nvMpzog4FOFuVxYycD3MGnZu15rMpakkJvpwMUA3e5dv0nP6q+XazVPl53/p8fLbT62Wm4szVNlSWd2nlwGuQftjnKFlDxcbjCpqaunlJEa4vZsWxByimMkxwWci0xPAsFHScrxpMrpdrwEkDQjTpjqCfetEMnQ2QrOtOhpV6Yi5QjwFC+QYupRoyjcRxfWYbw/XBItdegnYKu97x6Vy5hj9jRz/Z074v4vwZ9P9xrHDpIIVF+0nMZY9cCfswO/QAOxSBJ/jraZpn80P3QcYgDhJsHciA1I6hjjOBcsTsOIbpdVZGo8hhQ2HSFPdug9/kr5U/uCr+I8g8UYAOt04kpOE1zscH/eGmmqXgzf4zZpwoiST4eIoKCDjsuZhJAzHwgDNwNMlsG6eJBC7LYCCG1ZW686AgyNbApv8iqeSG152KO/IZYmnfGIfepUaw0RfSTM44HkAp0M9XmrQLqSGGaql42r8FUlSAJMYtOxLMYbLaIewufqqpG8DUznBW0WSqiKi6y40dqQX33By4ZMfr9MFDktViUvomNdFC1KDNJ3X48HKRzUgCcYe8RlnaB067gwju4o9CG5Rkinwm99qyrisxbAuZ3LmuJE2fiKISQieI0RlW3b0YyL+3k7EZMzRWrHyTvtQzsCrpqHPqIeFwEnBfJOIosGD3/YlADA44BtsXd6EEyWZEkfwqFgtVUohqnR5I6jpb2bKWn8jqOmsw1lwTcajqpRelCZ3LYscCW6eSbsAJqJ0ToaMGjgZyX54ES3vFCBIGPZVJKkqFcBSw59woiSTRwerisGSsnuICk3G6maCg1iy34LlRhB62fhZdZsIjUocbpEjyFit1dVQUeZA6ER3FNx5A0nnS7QBGOwQOY7caLk02uHbSOXbRiSO91p3E24M2ZzSBY6M4lg3ESyFNZrjOCojo0/Csn9OS7EYAzLQGaCGsOSqC4M84guhDbeQZyNpFDb0aKpb9lkCKqRWa8batlfy+P6BpdUFfa3bzfLSqy/Qlzm8wF/exH8lTUTyLRohvmVPyURJJg9trKRmS9Y8jITZHnFYja2SMfQW87TM+CSci+LJ5DizkJ3EageF+NxeWcVHDj+lRp/bOUH1aCp0tuvwnE8ZOBe4K6NLzKh53UgCYvANJPhSx8e/8Gl2/cIv/nx56ukny/GNk/SZUWWTqqqu3Vc6KVD2MQNktVpDLaUNdaqjCROrZG1cSqlEypRZTEPbbuIbMeNzTqlOizYVBcsmwegBd8Lt8MJmv7GD7GLe8YKAS8rB3jdNxbnAHX0GIozlNFNs3RdozQ8fvowKX4r1yd/4ePn7P/1j5c/+6R/g7/H5lz/3T/k7CFdW8M6YMvNjYSxClV8VrLI+hQPRhRrGBZhvFDXNKKEWWzkrS/UxNu2Ed4wQ6+Lz/+Mp1CqbC1BFqU7FsAvEExsFDH1qHHrnfJoGkze1Mee0m8PwFS34xq5PP/6b5Ud/4ofY9uc++IPln/3kv6bv9H2i/MiH/wLbvv97/1L5yD/4F+X0ydP8nUS4PvCxYES7C4m9H4YJPjNpOxwHw3BYja1SApgyaOfYM1t+IoipCCA/PfHs5A6Saq6Bx8bUllmfCxauQ0kGCOadcFezSlQ7pnKbvq/nB773h8pf/P6/Wr79ve8vR+l7CN9Nk/2rv/y/y2P/6xPlt/7fp+iraewJ0WHlWonxeldChTV7MLI4x9gOfM/SWyr/HPN03OJzjz1FXgGMDzIinoqfWRDDcpxn6A19mfYzxWRBQsHRnqvSQoIPX4uDL6XGYsC3euKiD9/qjRbfTSg4bppdJu3LyH4LFuvYJ0NffVXK0ab17fRY2bz2MbBI3PizAPbPEI8mXiufjDqEfzIW5fajjSp9E3raax53BAH8mGR8edON66/T2z96XEw/88fXuOKDAFwj9Lm8eGbLKbIW0ukQR0uQm/70LL2lRotvjBhbLbYd4/pZACPIPYpnWxuqlIofeud8taLJgZK0SmL40IqH9hMQ94cY/i/XyFG/dUwqx5c3Ao9vJms/EDL+mqZKgdrF4ViYNwxwz9JbLAztLK8VGQNUnouTBUBFDVOTccKjgz7hnYuTnkzych1hkAb90Vo5ycjdczOpQPk9Pv2Vz6hyvgscbwV3KQJRk3nE55CmPz1Lb/HYYaXVO7n6GTJXleQcvwTMLAjwDmm1D0Of1TvFy5zYTQ+EeGg/DenrSlhnsGpCG4AkBk0xvcWCD+pvxZkU22neiVHW4NuNQ3iOrS8BbJ/oDvmGHucaeqXYqVjvCgNU6xtJMY3pMkuAs0NIJk8RrCoGy2SU8GWkU4ozxfbI3lLjxTeNmPNM+6ZGAHn5w6BuEOFRvlv2IZa2/kJK7OwD+Uy94vICamCQuroSX2IIUZLdDQRLYezoLTVq7BOS7JvTPH/Il/GGGFvNi+rnEXNe8dWPg42V7JO0HDPple7MnsaZ3DJ1rZQ0jRlmliDi8uiOVwwOZGjQPHYUOM9K3kAURKXqLTHHsD8OmIudi5yPM3pD6UUgzBOkipzwMp/MuVFaCmk5buySWIcTaALX5U44UZIpcrpMAoEqrkoRYnKXszqEyPQDtABTcZK5Y8qxc3FAzvWn+qok7Lf3EqCVzZ7mZ84EtVwqp63IuFtHwlWlShrITbCSGDTyZi1HTfhg5jvC1V8lY+gt5kHOae+0Zz4O7POxln+MEmt+CVDkbLkzE8tx42xWi5R8EIej2z7OVlajvB9mmi9qyOohmczNTJ01y1bbIbO652OnI+fj4qLokY2FFvXBLwEol+KmC1Jfw10HwUpikmgOcsOeuERJphBp7DD162ouatrXEvXI3lJLEt8YMbZKbDMGlVCluVhApvIO4sK9jvF9AEtOsXNlzb4EOMegAPV13AkqSjIZp3Y2qhmXNceR0OXMTkbANGYYW4VijvnrEZer7DM0ljDpsXf1PoD0gn3zXSHihttCa0lzmIa94xJDZ+YkwUpi0MibtVzThM/NLgxYqi9yiiy+MWJsrRzNOFQHSXOxt5AzTToS9Lx1AdD5s3dLVZ5yCsDU5DzIL3SRVC2eISKSjxXlz2myFgmme0So8HrRM/SWyiu+acS0BwM0550dQI0cxzfWNPGNr3aEJX4mcArC5U45MYZMQftJzKDDCTvwe4EKzI16E4lHQBgyGhwDc9sTP8kOB22WRLS8H1alkLk4QMTfoxpLmvQap0mapsbqU8HZf6jXdhRWeRJB192EEyWZPDpYSQwaIbLmISp0ORNAY3MTEHPcc8zzcUgwjZj2xKge1VhuY+Ijg78EzE167QiFxug0hANHMh1yILsUiSRkRCnTPgaGo732wSjmYg9ivt3YubhcYY8MltuY9MyuY0Cfis6/CyAcp20GUsO56YYq1GmrJZlicJjAPsVc1LQvnuKRqkf2llqS+MaIsVViu1GolCzNxxq4RzWWNPGNz0i8rf4qwamacvkZwOMcQsAcGSBNhzucGDozMwQriUHzzCGRi01Gt7PAJHNM2TcIbuqIiOnY2ZpqYZEsyMI7Zg/WNOkID77AJmL1VclAZOm47EaQYrhDfaQxUOrgDGJM3pnZ2VhJzZaseUISUs7ogNycNnqW3lIp5phvN46Lqik6SXjH7I01TVbjOzSvxiWuGMzfEgYDASdyDIcpYUVJJs8RrCQGTXI6LguCy2hHNJMOe0ZmzeNYmGXumNrYOea2ijbW9J6jsaTJanxGwq34xgiyJp4YmCPSn4ZlWAbmURZfg9DwYCUxaL0/JiR5uNiAYZLMlDUHQRhsk8yE7ZkqwVwcUPOxxtOjGkuarMZnJN5Wf5XMSZbEZXa0PRrW7hogdTnFVKVKoLAtWEkMGgGyZhHWppxmtDYc8T1Lb7EwaeeY52JvNw5ZK2+VrKrG4pPV2A3ubfVXyZxkcR6zWdujzWP/Zw4vgK67KU6UZHKWYFUxWAiVNQsT69jHmDDp0DMya8ZZ2zn2udi5uL6Kmi/7+gyNpZusxp+Ia00Iy0jSOi4Lzkizctt87X39OLiLEUNnZpZgJTFo5M1aSs7eCT+bs29Oy7yCzPiImPag3mnvtEfYxT9GNdY0WY0vlspyz+uWxBMDZzg5ZuznB0IqjaepJpcCgYrBQqiseRh7pn0SVv1VMobeYh7LOY2Y8sxNOtin4qpvGtF4fMIae+2EStVfpZpvfLRnZEfZHO3ZL7F6DSDKmC5YSQwa8WUtJ4B3ws/m6quSMfQW80g7xXy7cWCdixXfNKLx+KQfjneMUs7EBSS2Jp8YdU++YYyBQizh6kuA+b0NQBKDRoiseQh7pn1v1vt21Ddd1bQnRvWo3lIHfuCLgxSqyUjVJicwoxPlIY52xwf+5l2AJsiNxk0nF8+En83ZN6d5kS7c3tE+FeW0YRKqzSSJxjjlWuEPljCQEhl8Ygj77BtqHR/CMzIQinjYie+4hZcWQEigYrDMFjA7yLNX8qg9Z5He2H6WeTZ2PnI+Z80uUkVXyTC3erQPGKQf3cRYhnEEew876QB3/JnXzwDNfFFkBnJi3U0OMkJQXAgN4iynUE8yHxB7u3HIKhXmOqUa85mWB3McIdjqq5KxkKWblOAzcdQeduI7/r4Kq4E+DYyZkhIdNEwTPjYHH4lBU47eUsnFN0aMrRI7WdEhcgIylbfJeZjB1IzgbKLdw/k6LnNPR9kNG0P2rcYOuQe8jhNfehcwIh9QVFhePU3nZyOJ44DBqlkaaS4O0Lm81Vclo28sPlBfI2fisVwHcZL/sEc7qFKOph/Jn33Q8jUAwLTNDvHspEs0kwx3s8yceRjGnlx8xh3ON0Y11oMG0xNLXBPNlTIk8XhQ9UeTy8Q2GQdQyNbhgs/4HDPwAUN+vwaAPjs9sxM/kQCkvM0xT8fORaXBsDSpFd4xe7D6IFlw8JkptVO8ZO+4LHCGk2Nm/Lc96cg9wRtyztwHsPhKUqVDdIwhc1PYswmr2Ke8k53SfPOVBdZusoLPSLzNvqqp1HFZYEWaxdswCW5Lwhz3gNdrGPiIl74JH3vPABW/6QzAXsZUIGxzGsf4TpAZb86x1bzIMo2Y9kh89VfJmHtLPVIHPgvTasYItfqgexAJ4whGzL6uAxFiO+7gYzLaJUzvhwVfdzMaWUPnBRBO8wawXKm4alRplCKCejbzzkdOx8V6elRvOWiwrB7jHTAQhKxp0GuUxUVLlefigArZOv7gM0LHDHxgI79AxG9wQ9N/jWEAOgOESW9K0XQWZtljK74xYmyV6Lk4IA6OHaOaOOs5J218bIu7qaWocYnL4g7gnD3iQ2zHHXyWKmHEj300x9O8MWQMaTGA4v8/GLYQ6Pgi2jsAAAAASUVORK5CYII=", xg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAnCAYAAACMo1E1AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAE3SURBVHgB7ZdtbcMwEIbfDEEhBEIhbAwGwUOyMCiFQhiDlUHHwINQBtez+qFWipvz6w+1kh/p5B/JvXlkKckZ6HQ6r8GwdIOIrHUJ9T8Mww4ZaNZKl0+tg2b9IAcN28g9XmsEgfZ9l8oKYU7mSQ6dEbtmgUEbfyWOtwo+ELuwRioLciZBg1jgHalo02QI9jFBo1joXyGV0KS1Nz5gJMQCDiyMYBMxUnAjNhxKkSDYVqywoEMtMgUdakMKOrTiLOiNYhNaIvbPhUjOD76yWDtBUqy+YKZYPcEEMW+8Z0QJEsTCcEoPC1XFbnrqC0p8TI+KEYJ7MMjyJDwrRghGx/Q38Hzp8W4bu6jXDrp8aP3hMdQkPDE7NpOztIP0mO5zxAyCE1i0eZTTi7HT2gpzUrrPK5bV6XSeiSNPs80hxEV9awAAAABJRU5ErkJggg==", l4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAAdCAYAAAD7En+mAAAACXBIWXMAABCcAAAQnAEmzTo0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAK1SURBVHgB1ZmBddowEIbPLFA2qEagE2AmKBuETBA6AWwQOgHNBE0mgE4AnUDuBPUGf3WWnMqOZJ8wJPC9dxgL3UknS6ezyEgIgNxcvhrhqzIypo/jaKQw8mJkn2VZQUMxDq6M/MV1szWi6BSM4sSIxm2xSnXyAbfLAYGnmwWc5FFZ021TGPli1m5ZFzQchQ04O5LBAYEN5fQ+lK5N5aQPDlKzN6X8uCFbk9qfGgl6Q1i3+roW6i1Djj4KlRcB3QUuh6YAkA0u7xbVNjiqn4q5LEnGMVC2p8vxO1L+i/phJyu/Rq4gJzklvS+fI+VTkvHAH7Wjd3S98H7e2B/dvZKp09jUzzOniEglfnpP1Jyuz37Ydvo8ReZ+58imi4rS2ZNN7djmnWeDywt3n3v9++6u01YffL7VGVAwCODUtIpeo3Fq6rgO2NDS/pn7TaTutto7oz8OpKPhGCpgYxmpuwzUHUfq7kYd/fxDw0kKXJG3kFJqu72kfEYdhqRRrYskG7CZmdTGVKj/+uO4Yyqt4DbcxA6zTWkC4qONTBJsrHwnEV/PmzrqcvahOvpeeN9n7SkGu7b8HFnRMOpZNvbav6f/UXdLzTZK6j4IuK8+kRY0VNsKbHS8JCrQXkpEV3Uweqbr5aU9g9z9nmRURy0jp7hPUFTCshBF5jDfZ0KdT5Fyaex4atwhvp+2eWxbgj2zkTBv6e0EOjxFVUtPulQOQdchX6tb2IGZQ+7kJtCedK1p2FdBbnMJ+SuaijnKIf2A86MR2aZwuXfZ7tdOnP/EQKMnZ4b8xEDKmiTAPtkfGM5PCBMO2GWgMQyernNKBXZaaaTDDS4oEdjZdOoA86AqGoJzeCdojOtwsBj0d4XnsEb/gHIAzftsZpSAc2DipHaG06+C7MZ89mMW2NxXuTZrCiNH095RaucfEDTBOCTCWakAAAAASUVORK5CYII=";
  function c4({
    playerState: t10,
    key: e,
    style: r,
    noDefault: n,
    defaultImage: i
  }) {
    var o = t10 ? t10.getState("profile") : false, s = t10 ? t10.getState("__gamepad") : false;
    return r = r || {}, o && (r.borderColor = o.color), o && o.photo ? (r.backgroundImage = `url(${o.photo})`, r.backgroundSize = "contain") : n || (i === "color" && o ? r.background = o.color : r.backgroundImage = `url(${i || wg})`, r.backgroundSize = i ? "cover" : "contain"), /* @__PURE__ */ U.createElement(
      "div",
      {
        key: e || (t10 ? t10.id : ""),
        className: "avatar-holder",
        style: r
      },
      s && /* @__PURE__ */ U.createElement(
        "div",
        {
          className: "badge-gamepad",
          style: { backgroundImage: `url(${l4})` }
        }
      )
    );
  }
  function _g({
    centered: t10,
    bottom: e,
    showNames: r,
    showScores: n,
    onPlayerKick: i,
    showEmptySlots: o = 0,
    mobileMode: s,
    initialScore: a = 0,
    style: l = {}
  }) {
    const c = Ei(true), u = _u(), f = o - c.length;
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        className: "player-avatar-strip" + (s ? " mobile" : ""),
        style: l
      },
      c.map((d) => {
        var p, y, b, x;
        const h = w3() ? false : d.id === Ln().id, g = ((p = d.getState("profile")) == null ? void 0 : p.points) || ((y = d.getState("profile")) == null ? void 0 : y.score) || 0;
        return /* @__PURE__ */ U.createElement(
          "div",
          {
            key: d.id,
            className: "player-score-container",
            style: { backgroundColor: (b = d.getState("profile")) == null ? void 0 : b.color }
          },
          /* @__PURE__ */ U.createElement(c4, { playerState: d }),
          s && !h && u && /* @__PURE__ */ U.createElement(
            "span",
            {
              className: "player-remove",
              onClick: () => i(d)
            },
            /* @__PURE__ */ U.createElement(
              "svg",
              {
                width: "20",
                height: "20",
                viewBox: "0 0 20 20",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              },
              /* @__PURE__ */ U.createElement("circle", { cx: "10.2441", cy: "9.75", r: "9.75", fill: "white" }),
              /* @__PURE__ */ U.createElement(
                "rect",
                {
                  x: "15.2549",
                  y: "7.75",
                  width: "4",
                  height: "10",
                  rx: "2",
                  transform: "rotate(90 15.2549 7.75)",
                  fill: "black"
                }
              )
            )
          ),
          r && /* @__PURE__ */ U.createElement("span", null, (x = d.getState("profile")) == null ? void 0 : x.name),
          n && /* @__PURE__ */ U.createElement("span", null, a + g)
        );
      }),
      f > 0 && [...Array(f)].map((d, h) => /* @__PURE__ */ U.createElement(
        "div",
        {
          key: "empty" + h,
          className: "player-score-container",
          style: { backgroundColor: "#000000" }
        },
        /* @__PURE__ */ U.createElement("div", { className: "avatar-holder empty" })
      ))
    );
  }
  function dn(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  function xe() {
    return xe = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, xe.apply(this, arguments);
  }
  function Sg(t10) {
    var e, r, n = "";
    if (typeof t10 == "string" || typeof t10 == "number")
      n += t10;
    else if (typeof t10 == "object")
      if (Array.isArray(t10))
        for (e = 0; e < t10.length; e++)
          t10[e] && (r = Sg(t10[e])) && (n && (n += " "), n += r);
      else
        for (e in t10)
          t10[e] && (n && (n += " "), n += e);
    return n;
  }
  function $i() {
    for (var t10, e, r = 0, n = ""; r < arguments.length; )
      (t10 = arguments[r++]) && (e = Sg(t10)) && (n && (n += " "), n += e);
    return n;
  }
  function qu(t10, e) {
    return define_process_env_default.NODE_ENV === "production" ? () => null : function(...n) {
      return t10(...n) || e(...n);
    };
  }
  function rn() {
    return rn = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, rn.apply(this, arguments);
  }
  function ei(t10) {
    return t10 !== null && typeof t10 == "object" && t10.constructor === Object;
  }
  function Eg(t10) {
    if (!ei(t10))
      return t10;
    const e = {};
    return Object.keys(t10).forEach((r) => {
      e[r] = Eg(t10[r]);
    }), e;
  }
  function Lr(t10, e, r = {
    clone: true
  }) {
    const n = r.clone ? rn({}, t10) : t10;
    return ei(t10) && ei(e) && Object.keys(e).forEach((i) => {
      i !== "__proto__" && (ei(e[i]) && i in t10 && ei(t10[i]) ? n[i] = Lr(t10[i], e[i], r) : r.clone ? n[i] = ei(e[i]) ? Eg(e[i]) : e[i] : n[i] = e[i]);
    }), n;
  }
  function u4(t10) {
    const {
      prototype: e = {}
    } = t10;
    return !!e.isReactComponent;
  }
  function kg(t10, e, r, n, i) {
    const o = t10[e], s = i || e;
    if (o == null || // When server-side rendering React doesn't warn either.
    // This is not an accurate check for SSR.
    // This is only in place for Emotion compat.
    // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
    typeof window > "u")
      return null;
    let a;
    const l = o.type;
    return typeof l == "function" && !u4(l) && (a = "Did you accidentally use a plain function component for an element instead?"), a !== void 0 ? new Error(`Invalid ${n} \`${s}\` supplied to \`${r}\`. Expected an element that can hold a ref. ${a} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
  }
  const Cg = qu(N.element, kg);
  Cg.isRequired = qu(N.element.isRequired, kg);
  const Tg = Cg, f4 = "exact-prop: ";
  function d4(t10) {
    return define_process_env_default.NODE_ENV === "production" ? t10 : rn({}, t10, {
      [f4]: (e) => {
        const r = Object.keys(e).filter((n) => !t10.hasOwnProperty(n));
        return r.length > 0 ? new Error(`The following props are not supported: ${r.map((n) => `\`${n}\``).join(", ")}. Please remove them.`) : null;
      }
    });
  }
  function yi(t10) {
    let e = "https://mui.com/production-error/?code=" + t10;
    for (let r = 1; r < arguments.length; r += 1)
      e += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified MUI error #" + t10 + "; visit " + e + " for the full message.";
  }
  var da = {}, h4 = {
    get exports() {
      return da;
    },
    set exports(t10) {
      da = t10;
    }
  }, je = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var op;
  function p4() {
    if (op)
      return je;
    op = 1;
    var t10 = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), g;
    g = Symbol.for("react.module.reference");
    function p(y) {
      if (typeof y == "object" && y !== null) {
        var b = y.$$typeof;
        switch (b) {
          case t10:
            switch (y = y.type, y) {
              case r:
              case i:
              case n:
              case c:
              case u:
                return y;
              default:
                switch (y = y && y.$$typeof, y) {
                  case a:
                  case s:
                  case l:
                  case d:
                  case f:
                  case o:
                    return y;
                  default:
                    return b;
                }
            }
          case e:
            return b;
        }
      }
    }
    return je.ContextConsumer = s, je.ContextProvider = o, je.Element = t10, je.ForwardRef = l, je.Fragment = r, je.Lazy = d, je.Memo = f, je.Portal = e, je.Profiler = i, je.StrictMode = n, je.Suspense = c, je.SuspenseList = u, je.isAsyncMode = function() {
      return false;
    }, je.isConcurrentMode = function() {
      return false;
    }, je.isContextConsumer = function(y) {
      return p(y) === s;
    }, je.isContextProvider = function(y) {
      return p(y) === o;
    }, je.isElement = function(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t10;
    }, je.isForwardRef = function(y) {
      return p(y) === l;
    }, je.isFragment = function(y) {
      return p(y) === r;
    }, je.isLazy = function(y) {
      return p(y) === d;
    }, je.isMemo = function(y) {
      return p(y) === f;
    }, je.isPortal = function(y) {
      return p(y) === e;
    }, je.isProfiler = function(y) {
      return p(y) === i;
    }, je.isStrictMode = function(y) {
      return p(y) === n;
    }, je.isSuspense = function(y) {
      return p(y) === c;
    }, je.isSuspenseList = function(y) {
      return p(y) === u;
    }, je.isValidElementType = function(y) {
      return typeof y == "string" || typeof y == "function" || y === r || y === i || y === n || y === c || y === u || y === h || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === f || y.$$typeof === o || y.$$typeof === s || y.$$typeof === l || y.$$typeof === g || y.getModuleId !== void 0);
    }, je.typeOf = p, je;
  }
  var We = {};
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var sp;
  function g4() {
    return sp || (sp = 1, define_process_env_default.NODE_ENV !== "production" && function() {
      var t10 = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), g = false, p = false, y = false, b = false, x = false, S;
      S = Symbol.for("react.module.reference");
      function C(re) {
        return !!(typeof re == "string" || typeof re == "function" || re === r || re === i || x || re === n || re === c || re === u || b || re === h || g || p || y || typeof re == "object" && re !== null && (re.$$typeof === d || re.$$typeof === f || re.$$typeof === o || re.$$typeof === s || re.$$typeof === l || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        re.$$typeof === S || re.getModuleId !== void 0));
      }
      function _(re) {
        if (typeof re == "object" && re !== null) {
          var ye = re.$$typeof;
          switch (ye) {
            case t10:
              var I = re.type;
              switch (I) {
                case r:
                case i:
                case n:
                case c:
                case u:
                  return I;
                default:
                  var v = I && I.$$typeof;
                  switch (v) {
                    case a:
                    case s:
                    case l:
                    case d:
                    case f:
                    case o:
                      return v;
                    default:
                      return ye;
                  }
              }
            case e:
              return ye;
          }
        }
      }
      var L = s, F = o, V = t10, W = l, X = r, G = d, ie = f, P10 = e, z10 = i, B = n, O = c, q = u, te = false, Y = false;
      function K(re) {
        return te || (te = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
      }
      function $(re) {
        return Y || (Y = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
      }
      function se(re) {
        return _(re) === s;
      }
      function he(re) {
        return _(re) === o;
      }
      function de(re) {
        return typeof re == "object" && re !== null && re.$$typeof === t10;
      }
      function pe(re) {
        return _(re) === l;
      }
      function j(re) {
        return _(re) === r;
      }
      function H(re) {
        return _(re) === d;
      }
      function Z(re) {
        return _(re) === f;
      }
      function oe(re) {
        return _(re) === e;
      }
      function ue(re) {
        return _(re) === i;
      }
      function R(re) {
        return _(re) === n;
      }
      function k(re) {
        return _(re) === c;
      }
      function ee(re) {
        return _(re) === u;
      }
      We.ContextConsumer = L, We.ContextProvider = F, We.Element = V, We.ForwardRef = W, We.Fragment = X, We.Lazy = G, We.Memo = ie, We.Portal = P10, We.Profiler = z10, We.StrictMode = B, We.Suspense = O, We.SuspenseList = q, We.isAsyncMode = K, We.isConcurrentMode = $, We.isContextConsumer = se, We.isContextProvider = he, We.isElement = de, We.isForwardRef = pe, We.isFragment = j, We.isLazy = H, We.isMemo = Z, We.isPortal = oe, We.isProfiler = ue, We.isStrictMode = R, We.isSuspense = k, We.isSuspenseList = ee, We.isValidElementType = C, We.typeOf = _;
    }()), We;
  }
  (function(t10) {
    define_process_env_default.NODE_ENV === "production" ? t10.exports = p4() : t10.exports = g4();
  })(h4);
  const m4 = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
  function y4(t10) {
    const e = `${t10}`.match(m4);
    return e && e[1] || "";
  }
  function Ig(t10, e = "") {
    return t10.displayName || t10.name || y4(t10) || e;
  }
  function ap(t10, e, r) {
    const n = Ig(e);
    return t10.displayName || (n !== "" ? `${r}(${n})` : r);
  }
  function b4(t10) {
    if (t10 != null) {
      if (typeof t10 == "string")
        return t10;
      if (typeof t10 == "function")
        return Ig(t10, "Component");
      if (typeof t10 == "object")
        switch (t10.$$typeof) {
          case da.ForwardRef:
            return ap(t10, t10.render, "ForwardRef");
          case da.Memo:
            return ap(t10, t10.type, "memo");
          default:
            return;
        }
    }
  }
  function Co(t10, e, r, n, i) {
    if (define_process_env_default.NODE_ENV === "production")
      return null;
    const o = t10[e], s = i || e;
    return o == null ? null : o && o.nodeType !== 1 ? new Error(`Invalid ${n} \`${s}\` supplied to \`${r}\`. Expected an HTMLElement.`) : null;
  }
  const v4$1 = N.oneOfType([N.func, N.object]), Og = v4$1;
  function Jt(t10) {
    if (typeof t10 != "string")
      throw new Error(define_process_env_default.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : yi(7));
    return t10.charAt(0).toUpperCase() + t10.slice(1);
  }
  function A4(...t10) {
    return t10.reduce((e, r) => r == null ? e : function(...i) {
      e.apply(this, i), r.apply(this, i);
    }, () => {
    });
  }
  function w4(t10, e = 166) {
    let r;
    function n(...i) {
      const o = () => {
        t10.apply(this, i);
      };
      clearTimeout(r), r = setTimeout(o, e);
    }
    return n.clear = () => {
      clearTimeout(r);
    }, n;
  }
  function x4(t10, e) {
    return define_process_env_default.NODE_ENV === "production" ? () => null : (r, n, i, o, s) => {
      const a = i || "<<anonymous>>", l = s || n;
      return typeof r[n] < "u" ? new Error(`The ${o} \`${l}\` of \`${a}\` is deprecated. ${e}`) : null;
    };
  }
  function _4(t10, e) {
    return /* @__PURE__ */ reactExports.isValidElement(t10) && e.indexOf(t10.type.muiName) !== -1;
  }
  function ha(t10) {
    return t10 && t10.ownerDocument || document;
  }
  function S4(t10) {
    return ha(t10).defaultView || window;
  }
  function E4(t10, e) {
    if (define_process_env_default.NODE_ENV === "production")
      return () => null;
    const r = e ? rn({}, e.propTypes) : null;
    return (i) => (o, s, a, l, c, ...u) => {
      const f = c || s, d = r == null ? void 0 : r[f];
      if (d) {
        const h = d(o, s, a, l, c, ...u);
        if (h)
          return h;
      }
      return typeof o[s] < "u" && !o[i] ? new Error(`The prop \`${f}\` of \`${t10}\` can only be used together with the \`${i}\` prop.`) : null;
    };
  }
  function pa(t10, e) {
    typeof t10 == "function" ? t10(e) : t10 && (t10.current = e);
  }
  const k4 = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect, bi = k4;
  let lp = 0;
  function C4(t10) {
    const [e, r] = reactExports.useState(t10), n = t10 || e;
    return reactExports.useEffect(() => {
      e == null && (lp += 1, r(`mui-${lp}`));
    }, [e]), n;
  }
  const cp = reactExports.useId;
  function Pg(t10) {
    if (cp !== void 0) {
      const e = cp();
      return t10 ?? e;
    }
    return C4(t10);
  }
  function T4(t10, e, r, n, i) {
    if (define_process_env_default.NODE_ENV === "production")
      return null;
    const o = i || e;
    return typeof t10[e] < "u" ? new Error(`The prop \`${o}\` is not supported. Please remove it.`) : null;
  }
  function Rg({
    controlled: t10,
    default: e,
    name: r,
    state: n = "value"
  }) {
    const {
      current: i
    } = reactExports.useRef(t10 !== void 0), [o, s] = reactExports.useState(e), a = i ? t10 : o;
    if (define_process_env_default.NODE_ENV !== "production") {
      reactExports.useEffect(() => {
        i !== (t10 !== void 0) && console.error([`MUI: A component is changing the ${i ? "" : "un"}controlled ${n} state of ${r} to be ${i ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
      }, [n, r, t10]);
      const {
        current: c
      } = reactExports.useRef(e);
      reactExports.useEffect(() => {
        !i && c !== e && console.error([`MUI: A component is changing the default ${n} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
      }, [JSON.stringify(e)]);
    }
    const l = reactExports.useCallback((c) => {
      i || s(c);
    }, []);
    return [a, l];
  }
  function Dg(t10) {
    const e = reactExports.useRef(t10);
    return bi(() => {
      e.current = t10;
    }), reactExports.useCallback((...r) => (
      // @ts-expect-error hide `this`
      // tslint:disable-next-line:ban-comma-operator
      (0, e.current)(...r)
    ), []);
  }
  function jn(...t10) {
    return reactExports.useMemo(() => t10.every((e) => e == null) ? null : (e) => {
      t10.forEach((r) => {
        pa(r, e);
      });
    }, t10);
  }
  let Fa = true, Vc = false, up;
  const I4 = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    "datetime-local": true
  };
  function O4(t10) {
    const {
      type: e,
      tagName: r
    } = t10;
    return !!(r === "INPUT" && I4[e] && !t10.readOnly || r === "TEXTAREA" && !t10.readOnly || t10.isContentEditable);
  }
  function P4(t10) {
    t10.metaKey || t10.altKey || t10.ctrlKey || (Fa = true);
  }
  function ec() {
    Fa = false;
  }
  function R4() {
    this.visibilityState === "hidden" && Vc && (Fa = true);
  }
  function D4(t10) {
    t10.addEventListener("keydown", P4, true), t10.addEventListener("mousedown", ec, true), t10.addEventListener("pointerdown", ec, true), t10.addEventListener("touchstart", ec, true), t10.addEventListener("visibilitychange", R4, true);
  }
  function M4(t10) {
    const {
      target: e
    } = t10;
    try {
      return e.matches(":focus-visible");
    } catch {
    }
    return Fa || O4(e);
  }
  function Mg() {
    const t10 = reactExports.useCallback((i) => {
      i != null && D4(i.ownerDocument);
    }, []), e = reactExports.useRef(false);
    function r() {
      return e.current ? (Vc = true, window.clearTimeout(up), up = window.setTimeout(() => {
        Vc = false;
      }, 100), e.current = false, true) : false;
    }
    function n(i) {
      return M4(i) ? (e.current = true, true) : false;
    }
    return {
      isFocusVisibleRef: e,
      onFocus: n,
      onBlur: r,
      ref: t10
    };
  }
  function Ng(t10, e) {
    const r = rn({}, e);
    return Object.keys(t10).forEach((n) => {
      if (n.toString().match(/^(components|slots)$/))
        r[n] = rn({}, t10[n], r[n]);
      else if (n.toString().match(/^(componentsProps|slotProps)$/)) {
        const i = t10[n] || {}, o = e[n];
        r[n] = {}, !o || !Object.keys(o) ? r[n] = i : !i || !Object.keys(i) ? r[n] = o : (r[n] = rn({}, o), Object.keys(i).forEach((s) => {
          r[n][s] = Ng(i[s], o[s]);
        }));
      } else
        r[n] === void 0 && (r[n] = t10[n]);
    }), r;
  }
  function Hu(t10, e, r = void 0) {
    const n = {};
    return Object.keys(t10).forEach(
      // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
      // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
      (i) => {
        n[i] = t10[i].reduce((o, s) => {
          if (s) {
            const a = e(s);
            a !== "" && o.push(a), r && r[s] && o.push(r[s]);
          }
          return o;
        }, []).join(" ");
      }
    ), n;
  }
  const fp = (t10) => t10, N4 = () => {
    let t10 = fp;
    return {
      configure(e) {
        t10 = e;
      },
      generate(e) {
        return t10(e);
      },
      reset() {
        t10 = fp;
      }
    };
  }, L4 = N4(), Lg = L4, B4 = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    readOnly: "readOnly",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    required: "required",
    selected: "selected"
  };
  function Uo(t10, e, r = "Mui") {
    const n = B4[e];
    return n ? `${r}-${n}` : `${Lg.generate(t10)}-${e}`;
  }
  function Ku(t10, e, r = "Mui") {
    const n = {};
    return e.forEach((i) => {
      n[i] = Uo(t10, i, r);
    }), n;
  }
  function kt() {
    return kt = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, kt.apply(this, arguments);
  }
  function F4(t10) {
    return typeof t10 == "string";
  }
  function eo(t10, e, r) {
    return t10 === void 0 || F4(t10) ? e : kt({}, e, {
      ownerState: kt({}, e.ownerState, r)
    });
  }
  const j4 = {
    disableDefaultClasses: false
  }, W4 = /* @__PURE__ */ reactExports.createContext(j4);
  function U4(t10) {
    const {
      disableDefaultClasses: e
    } = reactExports.useContext(W4);
    return (r) => e ? "" : t10(r);
  }
  function z4(t10, e = []) {
    if (t10 === void 0)
      return {};
    const r = {};
    return Object.keys(t10).filter((n) => n.match(/^on[A-Z]/) && typeof t10[n] == "function" && !e.includes(n)).forEach((n) => {
      r[n] = t10[n];
    }), r;
  }
  function V4(t10, e) {
    return typeof t10 == "function" ? t10(e) : t10;
  }
  function Yu(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  function Bg(t10) {
    var e, r, n = "";
    if (typeof t10 == "string" || typeof t10 == "number")
      n += t10;
    else if (typeof t10 == "object")
      if (Array.isArray(t10))
        for (e = 0; e < t10.length; e++)
          t10[e] && (r = Bg(t10[e])) && (n && (n += " "), n += r);
      else
        for (e in t10)
          t10[e] && (n && (n += " "), n += e);
    return n;
  }
  function dp() {
    for (var t10, e, r = 0, n = ""; r < arguments.length; )
      (t10 = arguments[r++]) && (e = Bg(t10)) && (n && (n += " "), n += e);
    return n;
  }
  function hp(t10) {
    if (t10 === void 0)
      return {};
    const e = {};
    return Object.keys(t10).filter((r) => !(r.match(/^on[A-Z]/) && typeof t10[r] == "function")).forEach((r) => {
      e[r] = t10[r];
    }), e;
  }
  function q4(t10) {
    const {
      getSlotProps: e,
      additionalProps: r,
      externalSlotProps: n,
      externalForwardedProps: i,
      className: o
    } = t10;
    if (!e) {
      const h = dp(i == null ? void 0 : i.className, n == null ? void 0 : n.className, o, r == null ? void 0 : r.className), g = kt({}, r == null ? void 0 : r.style, i == null ? void 0 : i.style, n == null ? void 0 : n.style), p = kt({}, r, i, n);
      return h.length > 0 && (p.className = h), Object.keys(g).length > 0 && (p.style = g), {
        props: p,
        internalRef: void 0
      };
    }
    const s = z4(kt({}, i, n)), a = hp(n), l = hp(i), c = e(s), u = dp(c == null ? void 0 : c.className, r == null ? void 0 : r.className, o, i == null ? void 0 : i.className, n == null ? void 0 : n.className), f = kt({}, c == null ? void 0 : c.style, r == null ? void 0 : r.style, i == null ? void 0 : i.style, n == null ? void 0 : n.style), d = kt({}, c, r, l, a);
    return u.length > 0 && (d.className = u), Object.keys(f).length > 0 && (d.style = f), {
      props: d,
      internalRef: c.ref
    };
  }
  const H4 = ["elementType", "externalSlotProps", "ownerState"];
  function K4(t10) {
    var e;
    const {
      elementType: r,
      externalSlotProps: n,
      ownerState: i
    } = t10, o = Yu(t10, H4), s = V4(n, i), {
      props: a,
      internalRef: l
    } = q4(kt({}, o, {
      externalSlotProps: s
    })), c = jn(l, s == null ? void 0 : s.ref, (e = t10.additionalProps) == null ? void 0 : e.ref);
    return eo(r, kt({}, a, {
      ref: c
    }), i);
  }
  var Pt = "top", Qt = "bottom", Gt = "right", Rt = "left", ja = "auto", zo = [Pt, Qt, Gt, Rt], vi = "start", To = "end", Y4 = "clippingParents", Fg = "viewport", Ui = "popper", X4 = "reference", pp = /* @__PURE__ */ zo.reduce(function(t10, e) {
    return t10.concat([e + "-" + vi, e + "-" + To]);
  }, []), jg = /* @__PURE__ */ [].concat(zo, [ja]).reduce(function(t10, e) {
    return t10.concat([e, e + "-" + vi, e + "-" + To]);
  }, []), J4 = "beforeRead", Q4 = "read", G4 = "afterRead", Z4 = "beforeMain", $4 = "main", ex = "afterMain", tx = "beforeWrite", rx = "write", nx = "afterWrite", qc = [J4, Q4, G4, Z4, $4, ex, tx, rx, nx];
  function wr(t10) {
    return t10 ? (t10.nodeName || "").toLowerCase() : null;
  }
  function Wt(t10) {
    if (t10 == null)
      return window;
    if (t10.toString() !== "[object Window]") {
      var e = t10.ownerDocument;
      return e && e.defaultView || window;
    }
    return t10;
  }
  function Wn(t10) {
    var e = Wt(t10).Element;
    return t10 instanceof e || t10 instanceof Element;
  }
  function Ft(t10) {
    var e = Wt(t10).HTMLElement;
    return t10 instanceof e || t10 instanceof HTMLElement;
  }
  function Xu(t10) {
    if (typeof ShadowRoot > "u")
      return false;
    var e = Wt(t10).ShadowRoot;
    return t10 instanceof e || t10 instanceof ShadowRoot;
  }
  function ix(t10) {
    var e = t10.state;
    Object.keys(e.elements).forEach(function(r) {
      var n = e.styles[r] || {}, i = e.attributes[r] || {}, o = e.elements[r];
      !Ft(o) || !wr(o) || (Object.assign(o.style, n), Object.keys(i).forEach(function(s) {
        var a = i[s];
        a === false ? o.removeAttribute(s) : o.setAttribute(s, a === true ? "" : a);
      }));
    });
  }
  function ox(t10) {
    var e = t10.state, r = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(e.elements.popper.style, r.popper), e.styles = r, e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow), function() {
      Object.keys(e.elements).forEach(function(n) {
        var i = e.elements[n], o = e.attributes[n] || {}, s = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]), a = s.reduce(function(l, c) {
          return l[c] = "", l;
        }, {});
        !Ft(i) || !wr(i) || (Object.assign(i.style, a), Object.keys(o).forEach(function(l) {
          i.removeAttribute(l);
        }));
      });
    };
  }
  const sx = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: ix,
    effect: ox,
    requires: ["computeStyles"]
  };
  function cr(t10) {
    return t10.split("-")[0];
  }
  var On = Math.max, ga = Math.min, Ai = Math.round;
  function Hc() {
    var t10 = navigator.userAgentData;
    return t10 != null && t10.brands && Array.isArray(t10.brands) ? t10.brands.map(function(e) {
      return e.brand + "/" + e.version;
    }).join(" ") : navigator.userAgent;
  }
  function Wg() {
    return !/^((?!chrome|android).)*safari/i.test(Hc());
  }
  function wi(t10, e, r) {
    e === void 0 && (e = false), r === void 0 && (r = false);
    var n = t10.getBoundingClientRect(), i = 1, o = 1;
    e && Ft(t10) && (i = t10.offsetWidth > 0 && Ai(n.width) / t10.offsetWidth || 1, o = t10.offsetHeight > 0 && Ai(n.height) / t10.offsetHeight || 1);
    var s = Wn(t10) ? Wt(t10) : window, a = s.visualViewport, l = !Wg() && r, c = (n.left + (l && a ? a.offsetLeft : 0)) / i, u = (n.top + (l && a ? a.offsetTop : 0)) / o, f = n.width / i, d = n.height / o;
    return {
      width: f,
      height: d,
      top: u,
      right: c + f,
      bottom: u + d,
      left: c,
      x: c,
      y: u
    };
  }
  function Ju(t10) {
    var e = wi(t10), r = t10.offsetWidth, n = t10.offsetHeight;
    return Math.abs(e.width - r) <= 1 && (r = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
      x: t10.offsetLeft,
      y: t10.offsetTop,
      width: r,
      height: n
    };
  }
  function Ug(t10, e) {
    var r = e.getRootNode && e.getRootNode();
    if (t10.contains(e))
      return true;
    if (r && Xu(r)) {
      var n = e;
      do {
        if (n && t10.isSameNode(n))
          return true;
        n = n.parentNode || n.host;
      } while (n);
    }
    return false;
  }
  function ur(t10) {
    return Wt(t10).getComputedStyle(t10);
  }
  function ax(t10) {
    return ["table", "td", "th"].indexOf(wr(t10)) >= 0;
  }
  function hn(t10) {
    return ((Wn(t10) ? t10.ownerDocument : (
      // $FlowFixMe[prop-missing]
      t10.document
    )) || window.document).documentElement;
  }
  function Wa(t10) {
    return wr(t10) === "html" ? t10 : (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      t10.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      t10.parentNode || // DOM Element detected
      (Xu(t10) ? t10.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      hn(t10)
    );
  }
  function gp(t10) {
    return !Ft(t10) || // https://github.com/popperjs/popper-core/issues/837
    ur(t10).position === "fixed" ? null : t10.offsetParent;
  }
  function lx(t10) {
    var e = /firefox/i.test(Hc()), r = /Trident/i.test(Hc());
    if (r && Ft(t10)) {
      var n = ur(t10);
      if (n.position === "fixed")
        return null;
    }
    var i = Wa(t10);
    for (Xu(i) && (i = i.host); Ft(i) && ["html", "body"].indexOf(wr(i)) < 0; ) {
      var o = ur(i);
      if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
        return i;
      i = i.parentNode;
    }
    return null;
  }
  function Vo(t10) {
    for (var e = Wt(t10), r = gp(t10); r && ax(r) && ur(r).position === "static"; )
      r = gp(r);
    return r && (wr(r) === "html" || wr(r) === "body" && ur(r).position === "static") ? e : r || lx(t10) || e;
  }
  function Qu(t10) {
    return ["top", "bottom"].indexOf(t10) >= 0 ? "x" : "y";
  }
  function co(t10, e, r) {
    return On(t10, ga(e, r));
  }
  function cx(t10, e, r) {
    var n = co(t10, e, r);
    return n > r ? r : n;
  }
  function zg() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function Vg(t10) {
    return Object.assign({}, zg(), t10);
  }
  function qg(t10, e) {
    return e.reduce(function(r, n) {
      return r[n] = t10, r;
    }, {});
  }
  var ux = function(e, r) {
    return e = typeof e == "function" ? e(Object.assign({}, r.rects, {
      placement: r.placement
    })) : e, Vg(typeof e != "number" ? e : qg(e, zo));
  };
  function fx(t10) {
    var e, r = t10.state, n = t10.name, i = t10.options, o = r.elements.arrow, s = r.modifiersData.popperOffsets, a = cr(r.placement), l = Qu(a), c = [Rt, Gt].indexOf(a) >= 0, u = c ? "height" : "width";
    if (!(!o || !s)) {
      var f = ux(i.padding, r), d = Ju(o), h = l === "y" ? Pt : Rt, g = l === "y" ? Qt : Gt, p = r.rects.reference[u] + r.rects.reference[l] - s[l] - r.rects.popper[u], y = s[l] - r.rects.reference[l], b = Vo(o), x = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, S = p / 2 - y / 2, C = f[h], _ = x - d[u] - f[g], L = x / 2 - d[u] / 2 + S, F = co(C, L, _), V = l;
      r.modifiersData[n] = (e = {}, e[V] = F, e.centerOffset = F - L, e);
    }
  }
  function dx(t10) {
    var e = t10.state, r = t10.options, n = r.element, i = n === void 0 ? "[data-popper-arrow]" : n;
    if (i != null && !(typeof i == "string" && (i = e.elements.popper.querySelector(i), !i))) {
      if (define_process_env_default.NODE_ENV !== "production" && (Ft(i) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Ug(e.elements.popper, i)) {
        define_process_env_default.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
        return;
      }
      e.elements.arrow = i;
    }
  }
  const hx = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: fx,
    effect: dx,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function xi(t10) {
    return t10.split("-")[1];
  }
  var px = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function gx(t10, e) {
    var r = t10.x, n = t10.y, i = e.devicePixelRatio || 1;
    return {
      x: Ai(r * i) / i || 0,
      y: Ai(n * i) / i || 0
    };
  }
  function mp(t10) {
    var e, r = t10.popper, n = t10.popperRect, i = t10.placement, o = t10.variation, s = t10.offsets, a = t10.position, l = t10.gpuAcceleration, c = t10.adaptive, u = t10.roundOffsets, f = t10.isFixed, d = s.x, h = d === void 0 ? 0 : d, g = s.y, p = g === void 0 ? 0 : g, y = typeof u == "function" ? u({
      x: h,
      y: p
    }) : {
      x: h,
      y: p
    };
    h = y.x, p = y.y;
    var b = s.hasOwnProperty("x"), x = s.hasOwnProperty("y"), S = Rt, C = Pt, _ = window;
    if (c) {
      var L = Vo(r), F = "clientHeight", V = "clientWidth";
      if (L === Wt(r) && (L = hn(r), ur(L).position !== "static" && a === "absolute" && (F = "scrollHeight", V = "scrollWidth")), L = L, i === Pt || (i === Rt || i === Gt) && o === To) {
        C = Qt;
        var W = f && L === _ && _.visualViewport ? _.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          L[F]
        );
        p -= W - n.height, p *= l ? 1 : -1;
      }
      if (i === Rt || (i === Pt || i === Qt) && o === To) {
        S = Gt;
        var X = f && L === _ && _.visualViewport ? _.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          L[V]
        );
        h -= X - n.width, h *= l ? 1 : -1;
      }
    }
    var G = Object.assign({
      position: a
    }, c && px), ie = u === true ? gx({
      x: h,
      y: p
    }, Wt(r)) : {
      x: h,
      y: p
    };
    if (h = ie.x, p = ie.y, l) {
      var P10;
      return Object.assign({}, G, (P10 = {}, P10[C] = x ? "0" : "", P10[S] = b ? "0" : "", P10.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + p + "px)" : "translate3d(" + h + "px, " + p + "px, 0)", P10));
    }
    return Object.assign({}, G, (e = {}, e[C] = x ? p + "px" : "", e[S] = b ? h + "px" : "", e.transform = "", e));
  }
  function mx(t10) {
    var e = t10.state, r = t10.options, n = r.gpuAcceleration, i = n === void 0 ? true : n, o = r.adaptive, s = o === void 0 ? true : o, a = r.roundOffsets, l = a === void 0 ? true : a;
    if (define_process_env_default.NODE_ENV !== "production") {
      var c = ur(e.elements.popper).transitionProperty || "";
      s && ["transform", "top", "right", "bottom", "left"].some(function(f) {
        return c.indexOf(f) >= 0;
      }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
    var u = {
      placement: cr(e.placement),
      variation: xi(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: i,
      isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, mp(Object.assign({}, u, {
      offsets: e.modifiersData.popperOffsets,
      position: e.options.strategy,
      adaptive: s,
      roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, mp(Object.assign({}, u, {
      offsets: e.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement
    });
  }
  const yx = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: mx,
    data: {}
  };
  var ms = {
    passive: true
  };
  function bx(t10) {
    var e = t10.state, r = t10.instance, n = t10.options, i = n.scroll, o = i === void 0 ? true : i, s = n.resize, a = s === void 0 ? true : s, l = Wt(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return o && c.forEach(function(u) {
      u.addEventListener("scroll", r.update, ms);
    }), a && l.addEventListener("resize", r.update, ms), function() {
      o && c.forEach(function(u) {
        u.removeEventListener("scroll", r.update, ms);
      }), a && l.removeEventListener("resize", r.update, ms);
    };
  }
  const vx = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function() {
    },
    effect: bx,
    data: {}
  };
  var Ax = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Bs(t10) {
    return t10.replace(/left|right|bottom|top/g, function(e) {
      return Ax[e];
    });
  }
  var wx = {
    start: "end",
    end: "start"
  };
  function yp(t10) {
    return t10.replace(/start|end/g, function(e) {
      return wx[e];
    });
  }
  function Gu(t10) {
    var e = Wt(t10), r = e.pageXOffset, n = e.pageYOffset;
    return {
      scrollLeft: r,
      scrollTop: n
    };
  }
  function Zu(t10) {
    return wi(hn(t10)).left + Gu(t10).scrollLeft;
  }
  function xx(t10, e) {
    var r = Wt(t10), n = hn(t10), i = r.visualViewport, o = n.clientWidth, s = n.clientHeight, a = 0, l = 0;
    if (i) {
      o = i.width, s = i.height;
      var c = Wg();
      (c || !c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
    }
    return {
      width: o,
      height: s,
      x: a + Zu(t10),
      y: l
    };
  }
  function _x(t10) {
    var e, r = hn(t10), n = Gu(t10), i = (e = t10.ownerDocument) == null ? void 0 : e.body, o = On(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = On(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -n.scrollLeft + Zu(t10), l = -n.scrollTop;
    return ur(i || r).direction === "rtl" && (a += On(r.clientWidth, i ? i.clientWidth : 0) - o), {
      width: o,
      height: s,
      x: a,
      y: l
    };
  }
  function $u(t10) {
    var e = ur(t10), r = e.overflow, n = e.overflowX, i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(r + i + n);
  }
  function Hg(t10) {
    return ["html", "body", "#document"].indexOf(wr(t10)) >= 0 ? t10.ownerDocument.body : Ft(t10) && $u(t10) ? t10 : Hg(Wa(t10));
  }
  function uo(t10, e) {
    var r;
    e === void 0 && (e = []);
    var n = Hg(t10), i = n === ((r = t10.ownerDocument) == null ? void 0 : r.body), o = Wt(n), s = i ? [o].concat(o.visualViewport || [], $u(n) ? n : []) : n, a = e.concat(s);
    return i ? a : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      a.concat(uo(Wa(s)))
    );
  }
  function Kc(t10) {
    return Object.assign({}, t10, {
      left: t10.x,
      top: t10.y,
      right: t10.x + t10.width,
      bottom: t10.y + t10.height
    });
  }
  function Sx(t10, e) {
    var r = wi(t10, false, e === "fixed");
    return r.top = r.top + t10.clientTop, r.left = r.left + t10.clientLeft, r.bottom = r.top + t10.clientHeight, r.right = r.left + t10.clientWidth, r.width = t10.clientWidth, r.height = t10.clientHeight, r.x = r.left, r.y = r.top, r;
  }
  function bp(t10, e, r) {
    return e === Fg ? Kc(xx(t10, r)) : Wn(e) ? Sx(e, r) : Kc(_x(hn(t10)));
  }
  function Ex(t10) {
    var e = uo(Wa(t10)), r = ["absolute", "fixed"].indexOf(ur(t10).position) >= 0, n = r && Ft(t10) ? Vo(t10) : t10;
    return Wn(n) ? e.filter(function(i) {
      return Wn(i) && Ug(i, n) && wr(i) !== "body";
    }) : [];
  }
  function kx(t10, e, r, n) {
    var i = e === "clippingParents" ? Ex(t10) : [].concat(e), o = [].concat(i, [r]), s = o[0], a = o.reduce(function(l, c) {
      var u = bp(t10, c, n);
      return l.top = On(u.top, l.top), l.right = ga(u.right, l.right), l.bottom = ga(u.bottom, l.bottom), l.left = On(u.left, l.left), l;
    }, bp(t10, s, n));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function Kg(t10) {
    var e = t10.reference, r = t10.element, n = t10.placement, i = n ? cr(n) : null, o = n ? xi(n) : null, s = e.x + e.width / 2 - r.width / 2, a = e.y + e.height / 2 - r.height / 2, l;
    switch (i) {
      case Pt:
        l = {
          x: s,
          y: e.y - r.height
        };
        break;
      case Qt:
        l = {
          x: s,
          y: e.y + e.height
        };
        break;
      case Gt:
        l = {
          x: e.x + e.width,
          y: a
        };
        break;
      case Rt:
        l = {
          x: e.x - r.width,
          y: a
        };
        break;
      default:
        l = {
          x: e.x,
          y: e.y
        };
    }
    var c = i ? Qu(i) : null;
    if (c != null) {
      var u = c === "y" ? "height" : "width";
      switch (o) {
        case vi:
          l[c] = l[c] - (e[u] / 2 - r[u] / 2);
          break;
        case To:
          l[c] = l[c] + (e[u] / 2 - r[u] / 2);
          break;
      }
    }
    return l;
  }
  function Io(t10, e) {
    e === void 0 && (e = {});
    var r = e, n = r.placement, i = n === void 0 ? t10.placement : n, o = r.strategy, s = o === void 0 ? t10.strategy : o, a = r.boundary, l = a === void 0 ? Y4 : a, c = r.rootBoundary, u = c === void 0 ? Fg : c, f = r.elementContext, d = f === void 0 ? Ui : f, h = r.altBoundary, g = h === void 0 ? false : h, p = r.padding, y = p === void 0 ? 0 : p, b = Vg(typeof y != "number" ? y : qg(y, zo)), x = d === Ui ? X4 : Ui, S = t10.rects.popper, C = t10.elements[g ? x : d], _ = kx(Wn(C) ? C : C.contextElement || hn(t10.elements.popper), l, u, s), L = wi(t10.elements.reference), F = Kg({
      reference: L,
      element: S,
      placement: i
    }), V = Kc(Object.assign({}, S, F)), W = d === Ui ? V : L, X = {
      top: _.top - W.top + b.top,
      bottom: W.bottom - _.bottom + b.bottom,
      left: _.left - W.left + b.left,
      right: W.right - _.right + b.right
    }, G = t10.modifiersData.offset;
    if (d === Ui && G) {
      var ie = G[i];
      Object.keys(X).forEach(function(P10) {
        var z10 = [Gt, Qt].indexOf(P10) >= 0 ? 1 : -1, B = [Pt, Qt].indexOf(P10) >= 0 ? "y" : "x";
        X[P10] += ie[B] * z10;
      });
    }
    return X;
  }
  function Cx(t10, e) {
    e === void 0 && (e = {});
    var r = e, n = r.placement, i = r.boundary, o = r.rootBoundary, s = r.padding, a = r.flipVariations, l = r.allowedAutoPlacements, c = l === void 0 ? jg : l, u = xi(n), f = u ? a ? pp : pp.filter(function(g) {
      return xi(g) === u;
    }) : zo, d = f.filter(function(g) {
      return c.indexOf(g) >= 0;
    });
    d.length === 0 && (d = f, define_process_env_default.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
    var h = d.reduce(function(g, p) {
      return g[p] = Io(t10, {
        placement: p,
        boundary: i,
        rootBoundary: o,
        padding: s
      })[cr(p)], g;
    }, {});
    return Object.keys(h).sort(function(g, p) {
      return h[g] - h[p];
    });
  }
  function Tx(t10) {
    if (cr(t10) === ja)
      return [];
    var e = Bs(t10);
    return [yp(t10), e, yp(e)];
  }
  function Ix(t10) {
    var e = t10.state, r = t10.options, n = t10.name;
    if (!e.modifiersData[n]._skip) {
      for (var i = r.mainAxis, o = i === void 0 ? true : i, s = r.altAxis, a = s === void 0 ? true : s, l = r.fallbackPlacements, c = r.padding, u = r.boundary, f = r.rootBoundary, d = r.altBoundary, h = r.flipVariations, g = h === void 0 ? true : h, p = r.allowedAutoPlacements, y = e.options.placement, b = cr(y), x = b === y, S = l || (x || !g ? [Bs(y)] : Tx(y)), C = [y].concat(S).reduce(function(de, pe) {
        return de.concat(cr(pe) === ja ? Cx(e, {
          placement: pe,
          boundary: u,
          rootBoundary: f,
          padding: c,
          flipVariations: g,
          allowedAutoPlacements: p
        }) : pe);
      }, []), _ = e.rects.reference, L = e.rects.popper, F = /* @__PURE__ */ new Map(), V = true, W = C[0], X = 0; X < C.length; X++) {
        var G = C[X], ie = cr(G), P10 = xi(G) === vi, z10 = [Pt, Qt].indexOf(ie) >= 0, B = z10 ? "width" : "height", O = Io(e, {
          placement: G,
          boundary: u,
          rootBoundary: f,
          altBoundary: d,
          padding: c
        }), q = z10 ? P10 ? Gt : Rt : P10 ? Qt : Pt;
        _[B] > L[B] && (q = Bs(q));
        var te = Bs(q), Y = [];
        if (o && Y.push(O[ie] <= 0), a && Y.push(O[q] <= 0, O[te] <= 0), Y.every(function(de) {
          return de;
        })) {
          W = G, V = false;
          break;
        }
        F.set(G, Y);
      }
      if (V)
        for (var K = g ? 3 : 1, $ = function(pe) {
          var j = C.find(function(H) {
            var Z = F.get(H);
            if (Z)
              return Z.slice(0, pe).every(function(oe) {
                return oe;
              });
          });
          if (j)
            return W = j, "break";
        }, se = K; se > 0; se--) {
          var he = $(se);
          if (he === "break")
            break;
        }
      e.placement !== W && (e.modifiersData[n]._skip = true, e.placement = W, e.reset = true);
    }
  }
  const Ox = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: Ix,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function vp(t10, e, r) {
    return r === void 0 && (r = {
      x: 0,
      y: 0
    }), {
      top: t10.top - e.height - r.y,
      right: t10.right - e.width + r.x,
      bottom: t10.bottom - e.height + r.y,
      left: t10.left - e.width - r.x
    };
  }
  function Ap(t10) {
    return [Pt, Gt, Qt, Rt].some(function(e) {
      return t10[e] >= 0;
    });
  }
  function Px(t10) {
    var e = t10.state, r = t10.name, n = e.rects.reference, i = e.rects.popper, o = e.modifiersData.preventOverflow, s = Io(e, {
      elementContext: "reference"
    }), a = Io(e, {
      altBoundary: true
    }), l = vp(s, n), c = vp(a, i, o), u = Ap(l), f = Ap(c);
    e.modifiersData[r] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: c,
      isReferenceHidden: u,
      hasPopperEscaped: f
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": u,
      "data-popper-escaped": f
    });
  }
  const Rx = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: Px
  };
  function Dx(t10, e, r) {
    var n = cr(t10), i = [Rt, Pt].indexOf(n) >= 0 ? -1 : 1, o = typeof r == "function" ? r(Object.assign({}, e, {
      placement: t10
    })) : r, s = o[0], a = o[1];
    return s = s || 0, a = (a || 0) * i, [Rt, Gt].indexOf(n) >= 0 ? {
      x: a,
      y: s
    } : {
      x: s,
      y: a
    };
  }
  function Mx(t10) {
    var e = t10.state, r = t10.options, n = t10.name, i = r.offset, o = i === void 0 ? [0, 0] : i, s = jg.reduce(function(u, f) {
      return u[f] = Dx(f, e.rects, o), u;
    }, {}), a = s[e.placement], l = a.x, c = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = s;
  }
  const Nx = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: Mx
  };
  function Lx(t10) {
    var e = t10.state, r = t10.name;
    e.modifiersData[r] = Kg({
      reference: e.rects.reference,
      element: e.rects.popper,
      placement: e.placement
    });
  }
  const Bx = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: Lx,
    data: {}
  };
  function Fx(t10) {
    return t10 === "x" ? "y" : "x";
  }
  function jx(t10) {
    var e = t10.state, r = t10.options, n = t10.name, i = r.mainAxis, o = i === void 0 ? true : i, s = r.altAxis, a = s === void 0 ? false : s, l = r.boundary, c = r.rootBoundary, u = r.altBoundary, f = r.padding, d = r.tether, h = d === void 0 ? true : d, g = r.tetherOffset, p = g === void 0 ? 0 : g, y = Io(e, {
      boundary: l,
      rootBoundary: c,
      padding: f,
      altBoundary: u
    }), b = cr(e.placement), x = xi(e.placement), S = !x, C = Qu(b), _ = Fx(C), L = e.modifiersData.popperOffsets, F = e.rects.reference, V = e.rects.popper, W = typeof p == "function" ? p(Object.assign({}, e.rects, {
      placement: e.placement
    })) : p, X = typeof W == "number" ? {
      mainAxis: W,
      altAxis: W
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, W), G = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, ie = {
      x: 0,
      y: 0
    };
    if (L) {
      if (o) {
        var P10, z10 = C === "y" ? Pt : Rt, B = C === "y" ? Qt : Gt, O = C === "y" ? "height" : "width", q = L[C], te = q + y[z10], Y = q - y[B], K = h ? -V[O] / 2 : 0, $ = x === vi ? F[O] : V[O], se = x === vi ? -V[O] : -F[O], he = e.elements.arrow, de = h && he ? Ju(he) : {
          width: 0,
          height: 0
        }, pe = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : zg(), j = pe[z10], H = pe[B], Z = co(0, F[O], de[O]), oe = S ? F[O] / 2 - K - Z - j - X.mainAxis : $ - Z - j - X.mainAxis, ue = S ? -F[O] / 2 + K + Z + H + X.mainAxis : se + Z + H + X.mainAxis, R = e.elements.arrow && Vo(e.elements.arrow), k = R ? C === "y" ? R.clientTop || 0 : R.clientLeft || 0 : 0, ee = (P10 = G == null ? void 0 : G[C]) != null ? P10 : 0, re = q + oe - ee - k, ye = q + ue - ee, I = co(h ? ga(te, re) : te, q, h ? On(Y, ye) : Y);
        L[C] = I, ie[C] = I - q;
      }
      if (a) {
        var v, w = C === "x" ? Pt : Rt, D = C === "x" ? Qt : Gt, Q = L[_], ae = _ === "y" ? "height" : "width", fe = Q + y[w], Ae = Q - y[D], ve = [Pt, Rt].indexOf(b) !== -1, be = (v = G == null ? void 0 : G[_]) != null ? v : 0, Pe = ve ? fe : Q - F[ae] - V[ae] - be + X.altAxis, E = ve ? Q + F[ae] + V[ae] - be - X.altAxis : Ae, m = h && ve ? cx(Pe, Q, E) : co(h ? Pe : fe, Q, h ? E : Ae);
        L[_] = m, ie[_] = m - Q;
      }
      e.modifiersData[n] = ie;
    }
  }
  const Wx = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: jx,
    requiresIfExists: ["offset"]
  };
  function Ux(t10) {
    return {
      scrollLeft: t10.scrollLeft,
      scrollTop: t10.scrollTop
    };
  }
  function zx(t10) {
    return t10 === Wt(t10) || !Ft(t10) ? Gu(t10) : Ux(t10);
  }
  function Vx(t10) {
    var e = t10.getBoundingClientRect(), r = Ai(e.width) / t10.offsetWidth || 1, n = Ai(e.height) / t10.offsetHeight || 1;
    return r !== 1 || n !== 1;
  }
  function qx(t10, e, r) {
    r === void 0 && (r = false);
    var n = Ft(e), i = Ft(e) && Vx(e), o = hn(e), s = wi(t10, i, r), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, l = {
      x: 0,
      y: 0
    };
    return (n || !n && !r) && ((wr(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    $u(o)) && (a = zx(e)), Ft(e) ? (l = wi(e, true), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = Zu(o))), {
      x: s.left + a.scrollLeft - l.x,
      y: s.top + a.scrollTop - l.y,
      width: s.width,
      height: s.height
    };
  }
  function Hx(t10) {
    var e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];
    t10.forEach(function(o) {
      e.set(o.name, o);
    });
    function i(o) {
      r.add(o.name);
      var s = [].concat(o.requires || [], o.requiresIfExists || []);
      s.forEach(function(a) {
        if (!r.has(a)) {
          var l = e.get(a);
          l && i(l);
        }
      }), n.push(o);
    }
    return t10.forEach(function(o) {
      r.has(o.name) || i(o);
    }), n;
  }
  function Kx(t10) {
    var e = Hx(t10);
    return qc.reduce(function(r, n) {
      return r.concat(e.filter(function(i) {
        return i.phase === n;
      }));
    }, []);
  }
  function Yx(t10) {
    var e;
    return function() {
      return e || (e = new Promise(function(r) {
        Promise.resolve().then(function() {
          e = void 0, r(t10());
        });
      })), e;
    };
  }
  function Vr(t10) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      r[n - 1] = arguments[n];
    return [].concat(r).reduce(function(i, o) {
      return i.replace(/%s/, o);
    }, t10);
  }
  var An = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', Xx = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', wp = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function Jx(t10) {
    t10.forEach(function(e) {
      [].concat(Object.keys(e), wp).filter(function(r, n, i) {
        return i.indexOf(r) === n;
      }).forEach(function(r) {
        switch (r) {
          case "name":
            typeof e.name != "string" && console.error(Vr(An, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
            break;
          case "enabled":
            typeof e.enabled != "boolean" && console.error(Vr(An, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
            break;
          case "phase":
            qc.indexOf(e.phase) < 0 && console.error(Vr(An, e.name, '"phase"', "either " + qc.join(", "), '"' + String(e.phase) + '"'));
            break;
          case "fn":
            typeof e.fn != "function" && console.error(Vr(An, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
            break;
          case "effect":
            e.effect != null && typeof e.effect != "function" && console.error(Vr(An, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
            break;
          case "requires":
            e.requires != null && !Array.isArray(e.requires) && console.error(Vr(An, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
            break;
          case "requiresIfExists":
            Array.isArray(e.requiresIfExists) || console.error(Vr(An, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + wp.map(function(n) {
              return '"' + n + '"';
            }).join(", ") + '; but "' + r + '" was provided.');
        }
        e.requires && e.requires.forEach(function(n) {
          t10.find(function(i) {
            return i.name === n;
          }) == null && console.error(Vr(Xx, String(e.name), n, n));
        });
      });
    });
  }
  function Qx(t10, e) {
    var r = /* @__PURE__ */ new Set();
    return t10.filter(function(n) {
      var i = e(n);
      if (!r.has(i))
        return r.add(i), true;
    });
  }
  function Gx(t10) {
    var e = t10.reduce(function(r, n) {
      var i = r[n.name];
      return r[n.name] = i ? Object.assign({}, i, n, {
        options: Object.assign({}, i.options, n.options),
        data: Object.assign({}, i.data, n.data)
      }) : n, r;
    }, {});
    return Object.keys(e).map(function(r) {
      return e[r];
    });
  }
  var xp = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Zx = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", _p = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Sp() {
    for (var t10 = arguments.length, e = new Array(t10), r = 0; r < t10; r++)
      e[r] = arguments[r];
    return !e.some(function(n) {
      return !(n && typeof n.getBoundingClientRect == "function");
    });
  }
  function $x(t10) {
    t10 === void 0 && (t10 = {});
    var e = t10, r = e.defaultModifiers, n = r === void 0 ? [] : r, i = e.defaultOptions, o = i === void 0 ? _p : i;
    return function(a, l, c) {
      c === void 0 && (c = o);
      var u = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, _p, o),
        modifiersData: {},
        elements: {
          reference: a,
          popper: l
        },
        attributes: {},
        styles: {}
      }, f = [], d = false, h = {
        state: u,
        setOptions: function(b) {
          var x = typeof b == "function" ? b(u.options) : b;
          p(), u.options = Object.assign({}, o, u.options, x), u.scrollParents = {
            reference: Wn(a) ? uo(a) : a.contextElement ? uo(a.contextElement) : [],
            popper: uo(l)
          };
          var S = Kx(Gx([].concat(n, u.options.modifiers)));
          if (u.orderedModifiers = S.filter(function(G) {
            return G.enabled;
          }), define_process_env_default.NODE_ENV !== "production") {
            var C = Qx([].concat(S, u.options.modifiers), function(G) {
              var ie = G.name;
              return ie;
            });
            if (Jx(C), cr(u.options.placement) === ja) {
              var _ = u.orderedModifiers.find(function(G) {
                var ie = G.name;
                return ie === "flip";
              });
              _ || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
            var L = ur(l), F = L.marginTop, V = L.marginRight, W = L.marginBottom, X = L.marginLeft;
            [F, V, W, X].some(function(G) {
              return parseFloat(G);
            }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
          return g(), h.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function() {
          if (!d) {
            var b = u.elements, x = b.reference, S = b.popper;
            if (!Sp(x, S)) {
              define_process_env_default.NODE_ENV !== "production" && console.error(xp);
              return;
            }
            u.rects = {
              reference: qx(x, Vo(S), u.options.strategy === "fixed"),
              popper: Ju(S)
            }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(G) {
              return u.modifiersData[G.name] = Object.assign({}, G.data);
            });
            for (var C = 0, _ = 0; _ < u.orderedModifiers.length; _++) {
              if (define_process_env_default.NODE_ENV !== "production" && (C += 1, C > 100)) {
                console.error(Zx);
                break;
              }
              if (u.reset === true) {
                u.reset = false, _ = -1;
                continue;
              }
              var L = u.orderedModifiers[_], F = L.fn, V = L.options, W = V === void 0 ? {} : V, X = L.name;
              typeof F == "function" && (u = F({
                state: u,
                options: W,
                name: X,
                instance: h
              }) || u);
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: Yx(function() {
          return new Promise(function(y) {
            h.forceUpdate(), y(u);
          });
        }),
        destroy: function() {
          p(), d = true;
        }
      };
      if (!Sp(a, l))
        return define_process_env_default.NODE_ENV !== "production" && console.error(xp), h;
      h.setOptions(c).then(function(y) {
        !d && c.onFirstUpdate && c.onFirstUpdate(y);
      });
      function g() {
        u.orderedModifiers.forEach(function(y) {
          var b = y.name, x = y.options, S = x === void 0 ? {} : x, C = y.effect;
          if (typeof C == "function") {
            var _ = C({
              state: u,
              name: b,
              instance: h,
              options: S
            }), L = function() {
            };
            f.push(_ || L);
          }
        });
      }
      function p() {
        f.forEach(function(y) {
          return y();
        }), f = [];
      }
      return h;
    };
  }
  var e9 = [vx, Bx, yx, sx, Nx, Ox, Wx, hx, Rx], t9 = /* @__PURE__ */ $x({
    defaultModifiers: e9
  });
  function r9(t10) {
    return typeof t10 == "function" ? t10() : t10;
  }
  const ma = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const {
      children: n,
      container: i,
      disablePortal: o = false
    } = e, [s, a] = reactExports.useState(null), l = jn(/* @__PURE__ */ reactExports.isValidElement(n) ? n.ref : null, r);
    if (bi(() => {
      o || a(r9(i) || document.body);
    }, [i, o]), bi(() => {
      if (s && !o)
        return pa(r, s), () => {
          pa(r, null);
        };
    }, [r, s, o]), o) {
      if (/* @__PURE__ */ reactExports.isValidElement(n)) {
        const c = {
          ref: l
        };
        return /* @__PURE__ */ reactExports.cloneElement(n, c);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: n
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: s && /* @__PURE__ */ reactDomExports.createPortal(n, s)
    });
  });
  define_process_env_default.NODE_ENV !== "production" && (ma.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * The children to render into the `container`.
     */
    children: N.node,
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: N.oneOfType([Co, N.func]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: N.bool
  });
  define_process_env_default.NODE_ENV !== "production" && (ma["propTypes"] = d4(ma.propTypes));
  const n9 = ma;
  function i9(t10) {
    return Uo("MuiPopper", t10);
  }
  Ku("MuiPopper", ["root"]);
  const o9 = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], s9 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
  function a9(t10, e) {
    if (e === "ltr")
      return t10;
    switch (t10) {
      case "bottom-end":
        return "bottom-start";
      case "bottom-start":
        return "bottom-end";
      case "top-end":
        return "top-start";
      case "top-start":
        return "top-end";
      default:
        return t10;
    }
  }
  function ya(t10) {
    return typeof t10 == "function" ? t10() : t10;
  }
  function Ua(t10) {
    return t10.nodeType !== void 0;
  }
  function l9(t10) {
    return !Ua(t10);
  }
  const c9 = () => Hu({
    root: ["root"]
  }, U4(i9)), u9 = {}, f9 = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    var n;
    const {
      anchorEl: i,
      children: o,
      direction: s,
      disablePortal: a,
      modifiers: l,
      open: c,
      placement: u,
      popperOptions: f,
      popperRef: d,
      slotProps: h = {},
      slots: g = {},
      TransitionProps: p
      // @ts-ignore internal logic
      // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    } = e, y = Yu(e, o9), b = reactExports.useRef(null), x = jn(b, r), S = reactExports.useRef(null), C = jn(S, d), _ = reactExports.useRef(C);
    bi(() => {
      _.current = C;
    }, [C]), reactExports.useImperativeHandle(d, () => S.current, []);
    const L = a9(u, s), [F, V] = reactExports.useState(L), [W, X] = reactExports.useState(ya(i));
    reactExports.useEffect(() => {
      S.current && S.current.forceUpdate();
    }), reactExports.useEffect(() => {
      i && X(ya(i));
    }, [i]), bi(() => {
      if (!W || !c)
        return;
      const B = (te) => {
        V(te.placement);
      };
      if (define_process_env_default.NODE_ENV !== "production" && W && Ua(W) && W.nodeType === 1) {
        const te = W.getBoundingClientRect();
        define_process_env_default.NODE_ENV !== "test" && te.top === 0 && te.left === 0 && te.right === 0 && te.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      }
      let O = [{
        name: "preventOverflow",
        options: {
          altBoundary: a
        }
      }, {
        name: "flip",
        options: {
          altBoundary: a
        }
      }, {
        name: "onUpdate",
        enabled: true,
        phase: "afterWrite",
        fn: ({
          state: te
        }) => {
          B(te);
        }
      }];
      l != null && (O = O.concat(l)), f && f.modifiers != null && (O = O.concat(f.modifiers));
      const q = t9(W, b.current, kt({
        placement: L
      }, f, {
        modifiers: O
      }));
      return _.current(q), () => {
        q.destroy(), _.current(null);
      };
    }, [W, a, l, c, f, L]);
    const G = {
      placement: F
    };
    p !== null && (G.TransitionProps = p);
    const ie = c9(), P10 = (n = g.root) != null ? n : "div", z10 = K4({
      elementType: P10,
      externalSlotProps: h.root,
      externalForwardedProps: y,
      additionalProps: {
        role: "tooltip",
        ref: x
      },
      ownerState: e,
      className: ie.root
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(P10, kt({}, z10, {
      children: typeof o == "function" ? o(G) : o
    }));
  }), Yg = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const {
      anchorEl: n,
      children: i,
      container: o,
      direction: s = "ltr",
      disablePortal: a = false,
      keepMounted: l = false,
      modifiers: c,
      open: u,
      placement: f = "bottom",
      popperOptions: d = u9,
      popperRef: h,
      style: g,
      transition: p = false,
      slotProps: y = {},
      slots: b = {}
    } = e, x = Yu(e, s9), [S, C] = reactExports.useState(true), _ = () => {
      C(false);
    }, L = () => {
      C(true);
    };
    if (!l && !u && (!p || S))
      return null;
    let F;
    if (o)
      F = o;
    else if (n) {
      const X = ya(n);
      F = X && Ua(X) ? ha(X).body : ha(null).body;
    }
    const V = !u && l && (!p || S) ? "none" : void 0, W = p ? {
      in: u,
      onEnter: _,
      onExited: L
    } : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(n9, {
      disablePortal: a,
      container: F,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(f9, kt({
        anchorEl: n,
        direction: s,
        disablePortal: a,
        modifiers: c,
        ref: r,
        open: p ? !S : u,
        placement: f,
        popperOptions: d,
        popperRef: h,
        slotProps: y,
        slots: b
      }, x, {
        style: kt({
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: "fixed",
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display: V
        }, g),
        TransitionProps: W,
        children: i
      }))
    });
  });
  define_process_env_default.NODE_ENV !== "production" && (Yg.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: qu(N.oneOfType([Co, N.object, N.func]), (t10) => {
      if (t10.open) {
        const e = ya(t10.anchorEl);
        if (e && Ua(e) && e.nodeType === 1) {
          const r = e.getBoundingClientRect();
          if (define_process_env_default.NODE_ENV !== "test" && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)
            return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
        } else if (!e || typeof e.getBoundingClientRect != "function" || l9(e) && e.contextElement != null && e.contextElement.nodeType !== 1)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
      }
      return null;
    }),
    /**
     * Popper render function or node.
     */
    children: N.oneOfType([N.node, N.func]),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: N.oneOfType([Co, N.func]),
    /**
     * Direction of the text.
     * @default 'ltr'
     */
    direction: N.oneOf(["ltr", "rtl"]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: N.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     * @default false
     */
    keepMounted: N.bool,
    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
     */
    modifiers: N.arrayOf(N.shape({
      data: N.object,
      effect: N.func,
      enabled: N.bool,
      fn: N.func,
      name: N.any,
      options: N.object,
      phase: N.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
      requires: N.arrayOf(N.string),
      requiresIfExists: N.arrayOf(N.string)
    })),
    /**
     * If `true`, the component is shown.
     */
    open: N.bool.isRequired,
    /**
     * Popper placement.
     * @default 'bottom'
     */
    placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
     * @default {}
     */
    popperOptions: N.shape({
      modifiers: N.array,
      onFirstUpdate: N.func,
      placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      strategy: N.oneOf(["absolute", "fixed"])
    }),
    /**
     * A ref that points to the used popper instance.
     */
    popperRef: Og,
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    slotProps: N.shape({
      root: N.oneOfType([N.func, N.object])
    }),
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: N.shape({
      root: N.elementType
    }),
    /**
     * Help supporting a react-transition-group/Transition component.
     * @default false
     */
    transition: N.bool
  });
  const d9 = Yg;
  function Yc() {
    return Yc = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, Yc.apply(this, arguments);
  }
  function h9(t10) {
    var e = /* @__PURE__ */ Object.create(null);
    return function(r) {
      return e[r] === void 0 && (e[r] = t10(r)), e[r];
    };
  }
  var p9 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, g9 = /* @__PURE__ */ h9(
    function(t10) {
      return p9.test(t10) || t10.charCodeAt(0) === 111 && t10.charCodeAt(1) === 110 && t10.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );
  function m9(t10) {
    if (t10.sheet)
      return t10.sheet;
    for (var e = 0; e < document.styleSheets.length; e++)
      if (document.styleSheets[e].ownerNode === t10)
        return document.styleSheets[e];
  }
  function y9(t10) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", t10.key), t10.nonce !== void 0 && e.setAttribute("nonce", t10.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
  }
  var b9 = /* @__PURE__ */ function() {
    function t10(r) {
      var n = this;
      this._insertTag = function(i) {
        var o;
        n.tags.length === 0 ? n.insertionPoint ? o = n.insertionPoint.nextSibling : n.prepend ? o = n.container.firstChild : o = n.before : o = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(i, o), n.tags.push(i);
      }, this.isSpeedy = r.speedy === void 0 ? define_process_env_default.NODE_ENV === "production" : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
    }
    var e = t10.prototype;
    return e.hydrate = function(n) {
      n.forEach(this._insertTag);
    }, e.insert = function(n) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(y9(this));
      var i = this.tags[this.tags.length - 1];
      if (define_process_env_default.NODE_ENV !== "production") {
        var o = n.charCodeAt(0) === 64 && n.charCodeAt(1) === 105;
        o && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + n + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !o;
      }
      if (this.isSpeedy) {
        var s = m9(i);
        try {
          s.insertRule(n, s.cssRules.length);
        } catch (a) {
          define_process_env_default.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(n) && console.error('There was a problem inserting the following rule: "' + n + '"', a);
        }
      } else
        i.appendChild(document.createTextNode(n));
      this.ctr++;
    }, e.flush = function() {
      this.tags.forEach(function(n) {
        return n.parentNode && n.parentNode.removeChild(n);
      }), this.tags = [], this.ctr = 0, define_process_env_default.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = false);
    }, t10;
  }(), vt = "-ms-", ba = "-moz-", Ne = "-webkit-", ef = "comm", tf = "rule", rf = "decl", v9 = "@import", Xg = "@keyframes", A9 = "@layer", w9 = Math.abs, za = String.fromCharCode, x9 = Object.assign;
  function _9(t10, e) {
    return mt(t10, 0) ^ 45 ? (((e << 2 ^ mt(t10, 0)) << 2 ^ mt(t10, 1)) << 2 ^ mt(t10, 2)) << 2 ^ mt(t10, 3) : 0;
  }
  function Jg(t10) {
    return t10.trim();
  }
  function S9(t10, e) {
    return (t10 = e.exec(t10)) ? t10[0] : t10;
  }
  function Le(t10, e, r) {
    return t10.replace(e, r);
  }
  function Xc(t10, e) {
    return t10.indexOf(e);
  }
  function mt(t10, e) {
    return t10.charCodeAt(e) | 0;
  }
  function Oo(t10, e, r) {
    return t10.slice(e, r);
  }
  function hr(t10) {
    return t10.length;
  }
  function nf(t10) {
    return t10.length;
  }
  function ys(t10, e) {
    return e.push(t10), t10;
  }
  function E9(t10, e) {
    return t10.map(e).join("");
  }
  var Va = 1, _i = 1, Qg = 0, Dt = 0, ut = 0, Ci = "";
  function qa(t10, e, r, n, i, o, s) {
    return { value: t10, root: e, parent: r, type: n, props: i, children: o, line: Va, column: _i, length: s, return: "" };
  }
  function zi(t10, e) {
    return x9(qa("", null, null, "", null, null, 0), t10, { length: -t10.length }, e);
  }
  function k9() {
    return ut;
  }
  function C9() {
    return ut = Dt > 0 ? mt(Ci, --Dt) : 0, _i--, ut === 10 && (_i = 1, Va--), ut;
  }
  function jt() {
    return ut = Dt < Qg ? mt(Ci, Dt++) : 0, _i++, ut === 10 && (_i = 1, Va++), ut;
  }
  function Ar() {
    return mt(Ci, Dt);
  }
  function Fs() {
    return Dt;
  }
  function qo(t10, e) {
    return Oo(Ci, t10, e);
  }
  function Po(t10) {
    switch (t10) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function Gg(t10) {
    return Va = _i = 1, Qg = hr(Ci = t10), Dt = 0, [];
  }
  function Zg(t10) {
    return Ci = "", t10;
  }
  function js(t10) {
    return Jg(qo(Dt - 1, Jc(t10 === 91 ? t10 + 2 : t10 === 40 ? t10 + 1 : t10)));
  }
  function T9(t10) {
    for (; (ut = Ar()) && ut < 33; )
      jt();
    return Po(t10) > 2 || Po(ut) > 3 ? "" : " ";
  }
  function I9(t10, e) {
    for (; --e && jt() && !(ut < 48 || ut > 102 || ut > 57 && ut < 65 || ut > 70 && ut < 97); )
      ;
    return qo(t10, Fs() + (e < 6 && Ar() == 32 && jt() == 32));
  }
  function Jc(t10) {
    for (; jt(); )
      switch (ut) {
        case t10:
          return Dt;
        case 34:
        case 39:
          t10 !== 34 && t10 !== 39 && Jc(ut);
          break;
        case 40:
          t10 === 41 && Jc(t10);
          break;
        case 92:
          jt();
          break;
      }
    return Dt;
  }
  function O9(t10, e) {
    for (; jt() && t10 + ut !== 47 + 10; )
      if (t10 + ut === 42 + 42 && Ar() === 47)
        break;
    return "/*" + qo(e, Dt - 1) + "*" + za(t10 === 47 ? t10 : jt());
  }
  function P9(t10) {
    for (; !Po(Ar()); )
      jt();
    return qo(t10, Dt);
  }
  function R9(t10) {
    return Zg(Ws("", null, null, null, [""], t10 = Gg(t10), 0, [0], t10));
  }
  function Ws(t10, e, r, n, i, o, s, a, l) {
    for (var c = 0, u = 0, f = s, d = 0, h = 0, g = 0, p = 1, y = 1, b = 1, x = 0, S = "", C = i, _ = o, L = n, F = S; y; )
      switch (g = x, x = jt()) {
        case 40:
          if (g != 108 && mt(F, f - 1) == 58) {
            Xc(F += Le(js(x), "&", "&\f"), "&\f") != -1 && (b = -1);
            break;
          }
        case 34:
        case 39:
        case 91:
          F += js(x);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          F += T9(g);
          break;
        case 92:
          F += I9(Fs() - 1, 7);
          continue;
        case 47:
          switch (Ar()) {
            case 42:
            case 47:
              ys(D9(O9(jt(), Fs()), e, r), l);
              break;
            default:
              F += "/";
          }
          break;
        case 123 * p:
          a[c++] = hr(F) * b;
        case 125 * p:
        case 59:
        case 0:
          switch (x) {
            case 0:
            case 125:
              y = 0;
            case 59 + u:
              b == -1 && (F = Le(F, /\f/g, "")), h > 0 && hr(F) - f && ys(h > 32 ? kp(F + ";", n, r, f - 1) : kp(Le(F, " ", "") + ";", n, r, f - 2), l);
              break;
            case 59:
              F += ";";
            default:
              if (ys(L = Ep(F, e, r, c, u, i, a, S, C = [], _ = [], f), o), x === 123)
                if (u === 0)
                  Ws(F, e, L, L, C, o, f, a, _);
                else
                  switch (d === 99 && mt(F, 3) === 110 ? 100 : d) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      Ws(t10, L, L, n && ys(Ep(t10, L, L, 0, 0, i, a, S, i, C = [], f), _), i, _, f, a, n ? C : _);
                      break;
                    default:
                      Ws(F, L, L, L, [""], _, 0, a, _);
                  }
          }
          c = u = h = 0, p = b = 1, S = F = "", f = s;
          break;
        case 58:
          f = 1 + hr(F), h = g;
        default:
          if (p < 1) {
            if (x == 123)
              --p;
            else if (x == 125 && p++ == 0 && C9() == 125)
              continue;
          }
          switch (F += za(x), x * p) {
            case 38:
              b = u > 0 ? 1 : (F += "\f", -1);
              break;
            case 44:
              a[c++] = (hr(F) - 1) * b, b = 1;
              break;
            case 64:
              Ar() === 45 && (F += js(jt())), d = Ar(), u = f = hr(S = F += P9(Fs())), x++;
              break;
            case 45:
              g === 45 && hr(F) == 2 && (p = 0);
          }
      }
    return o;
  }
  function Ep(t10, e, r, n, i, o, s, a, l, c, u) {
    for (var f = i - 1, d = i === 0 ? o : [""], h = nf(d), g = 0, p = 0, y = 0; g < n; ++g)
      for (var b = 0, x = Oo(t10, f + 1, f = w9(p = s[g])), S = t10; b < h; ++b)
        (S = Jg(p > 0 ? d[b] + " " + x : Le(x, /&\f/g, d[b]))) && (l[y++] = S);
    return qa(t10, e, r, i === 0 ? tf : a, l, c, u);
  }
  function D9(t10, e, r) {
    return qa(t10, e, r, ef, za(k9()), Oo(t10, 2, -2), 0);
  }
  function kp(t10, e, r, n) {
    return qa(t10, e, r, rf, Oo(t10, 0, n), Oo(t10, n + 1, -1), n);
  }
  function li(t10, e) {
    for (var r = "", n = nf(t10), i = 0; i < n; i++)
      r += e(t10[i], i, t10, e) || "";
    return r;
  }
  function M9(t10, e, r, n) {
    switch (t10.type) {
      case A9:
        if (t10.children.length)
          break;
      case v9:
      case rf:
        return t10.return = t10.return || t10.value;
      case ef:
        return "";
      case Xg:
        return t10.return = t10.value + "{" + li(t10.children, n) + "}";
      case tf:
        t10.value = t10.props.join(",");
    }
    return hr(r = li(t10.children, n)) ? t10.return = t10.value + "{" + r + "}" : "";
  }
  function N9(t10) {
    var e = nf(t10);
    return function(r, n, i, o) {
      for (var s = "", a = 0; a < e; a++)
        s += t10[a](r, n, i, o) || "";
      return s;
    };
  }
  function L9(t10) {
    return function(e) {
      e.root || (e = e.return) && t10(e);
    };
  }
  var B9 = function(e, r, n) {
    for (var i = 0, o = 0; i = o, o = Ar(), i === 38 && o === 12 && (r[n] = 1), !Po(o); )
      jt();
    return qo(e, Dt);
  }, F9 = function(e, r) {
    var n = -1, i = 44;
    do
      switch (Po(i)) {
        case 0:
          i === 38 && Ar() === 12 && (r[n] = 1), e[n] += B9(Dt - 1, r, n);
          break;
        case 2:
          e[n] += js(i);
          break;
        case 4:
          if (i === 44) {
            e[++n] = Ar() === 58 ? "&\f" : "", r[n] = e[n].length;
            break;
          }
        default:
          e[n] += za(i);
      }
    while (i = jt());
    return e;
  }, j9 = function(e, r) {
    return Zg(F9(Gg(e), r));
  }, Cp = /* @__PURE__ */ new WeakMap(), W9 = function(e) {
    if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    e.length < 1)) {
      for (var r = e.value, n = e.parent, i = e.column === n.column && e.line === n.line; n.type !== "rule"; )
        if (n = n.parent, !n)
          return;
      if (!(e.props.length === 1 && r.charCodeAt(0) !== 58 && !Cp.get(n)) && !i) {
        Cp.set(e, true);
        for (var o = [], s = j9(r, o), a = n.props, l = 0, c = 0; l < s.length; l++)
          for (var u = 0; u < a.length; u++, c++)
            e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l];
      }
    }
  }, U9 = function(e) {
    if (e.type === "decl") {
      var r = e.value;
      r.charCodeAt(0) === 108 && // charcode for b
      r.charCodeAt(2) === 98 && (e.return = "", e.value = "");
    }
  }, z9 = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", V9 = function(e) {
    return e.type === "comm" && e.children.indexOf(z9) > -1;
  }, q9 = function(e) {
    return function(r, n, i) {
      if (!(r.type !== "rule" || e.compat)) {
        var o = r.value.match(/(:first|:nth|:nth-last)-child/g);
        if (o) {
          for (var s = !!r.parent, a = s ? r.parent.children : (
            // globalThis rule at the root level
            i
          ), l = a.length - 1; l >= 0; l--) {
            var c = a[l];
            if (c.line < r.line)
              break;
            if (c.column < r.column) {
              if (V9(c))
                return;
              break;
            }
          }
          o.forEach(function(u) {
            console.error('The pseudo class "' + u + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + u.split("-child")[0] + '-of-type".');
          });
        }
      }
    };
  }, $g = function(e) {
    return e.type.charCodeAt(1) === 105 && e.type.charCodeAt(0) === 64;
  }, H9 = function(e, r) {
    for (var n = e - 1; n >= 0; n--)
      if (!$g(r[n]))
        return true;
    return false;
  }, Tp = function(e) {
    e.type = "", e.value = "", e.return = "", e.children = "", e.props = "";
  }, K9 = function(e, r, n) {
    $g(e) && (e.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within globalThis styles."), Tp(e)) : H9(r, n) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), Tp(e)));
  };
  function em(t10, e) {
    switch (_9(t10, e)) {
      case 5103:
        return Ne + "print-" + t10 + t10;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return Ne + t10 + t10;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return Ne + t10 + ba + t10 + vt + t10 + t10;
      case 6828:
      case 4268:
        return Ne + t10 + vt + t10 + t10;
      case 6165:
        return Ne + t10 + vt + "flex-" + t10 + t10;
      case 5187:
        return Ne + t10 + Le(t10, /(\w+).+(:[^]+)/, Ne + "box-$1$2" + vt + "flex-$1$2") + t10;
      case 5443:
        return Ne + t10 + vt + "flex-item-" + Le(t10, /flex-|-self/, "") + t10;
      case 4675:
        return Ne + t10 + vt + "flex-line-pack" + Le(t10, /align-content|flex-|-self/, "") + t10;
      case 5548:
        return Ne + t10 + vt + Le(t10, "shrink", "negative") + t10;
      case 5292:
        return Ne + t10 + vt + Le(t10, "basis", "preferred-size") + t10;
      case 6060:
        return Ne + "box-" + Le(t10, "-grow", "") + Ne + t10 + vt + Le(t10, "grow", "positive") + t10;
      case 4554:
        return Ne + Le(t10, /([^-])(transform)/g, "$1" + Ne + "$2") + t10;
      case 6187:
        return Le(Le(Le(t10, /(zoom-|grab)/, Ne + "$1"), /(image-set)/, Ne + "$1"), t10, "") + t10;
      case 5495:
      case 3959:
        return Le(t10, /(image-set\([^]*)/, Ne + "$1$`$1");
      case 4968:
        return Le(Le(t10, /(.+:)(flex-)?(.*)/, Ne + "box-pack:$3" + vt + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Ne + t10 + t10;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Le(t10, /(.+)-inline(.+)/, Ne + "$1$2") + t10;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (hr(t10) - 1 - e > 6)
          switch (mt(t10, e + 1)) {
            case 109:
              if (mt(t10, e + 4) !== 45)
                break;
            case 102:
              return Le(t10, /(.+:)(.+)-([^]+)/, "$1" + Ne + "$2-$3$1" + ba + (mt(t10, e + 3) == 108 ? "$3" : "$2-$3")) + t10;
            case 115:
              return ~Xc(t10, "stretch") ? em(Le(t10, "stretch", "fill-available"), e) + t10 : t10;
          }
        break;
      case 4949:
        if (mt(t10, e + 1) !== 115)
          break;
      case 6444:
        switch (mt(t10, hr(t10) - 3 - (~Xc(t10, "!important") && 10))) {
          case 107:
            return Le(t10, ":", ":" + Ne) + t10;
          case 101:
            return Le(t10, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Ne + (mt(t10, 14) === 45 ? "inline-" : "") + "box$3$1" + Ne + "$2$3$1" + vt + "$2box$3") + t10;
        }
        break;
      case 5936:
        switch (mt(t10, e + 11)) {
          case 114:
            return Ne + t10 + vt + Le(t10, /[svh]\w+-[tblr]{2}/, "tb") + t10;
          case 108:
            return Ne + t10 + vt + Le(t10, /[svh]\w+-[tblr]{2}/, "tb-rl") + t10;
          case 45:
            return Ne + t10 + vt + Le(t10, /[svh]\w+-[tblr]{2}/, "lr") + t10;
        }
        return Ne + t10 + vt + t10 + t10;
    }
    return t10;
  }
  var Y9 = function(e, r, n, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case rf:
          e.return = em(e.value, e.length);
          break;
        case Xg:
          return li([zi(e, {
            value: Le(e.value, "@", "@" + Ne)
          })], i);
        case tf:
          if (e.length)
            return E9(e.props, function(o) {
              switch (S9(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return li([zi(e, {
                    props: [Le(o, /:(read-\w+)/, ":" + ba + "$1")]
                  })], i);
                case "::placeholder":
                  return li([zi(e, {
                    props: [Le(o, /:(plac\w+)/, ":" + Ne + "input-$1")]
                  }), zi(e, {
                    props: [Le(o, /:(plac\w+)/, ":" + ba + "$1")]
                  }), zi(e, {
                    props: [Le(o, /:(plac\w+)/, vt + "input-$1")]
                  })], i);
              }
              return "";
            });
      }
  }, X9 = [Y9], J9 = function(e) {
    var r = e.key;
    if (define_process_env_default.NODE_ENV !== "production" && !r)
      throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
    if (r === "css") {
      var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(n, function(p) {
        var y = p.getAttribute("data-emotion");
        y.indexOf(" ") !== -1 && (document.head.appendChild(p), p.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || X9;
    if (define_process_env_default.NODE_ENV !== "production" && /[^a-z-]/.test(r))
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + r + '" was passed');
    var o = {}, s, a = [];
    s = e.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
      function(p) {
        for (var y = p.getAttribute("data-emotion").split(" "), b = 1; b < y.length; b++)
          o[y[b]] = true;
        a.push(p);
      }
    );
    var l, c = [W9, U9];
    define_process_env_default.NODE_ENV !== "production" && c.push(q9({
      get compat() {
        return g.compat;
      }
    }), K9);
    {
      var u, f = [M9, define_process_env_default.NODE_ENV !== "production" ? function(p) {
        p.root || (p.return ? u.insert(p.return) : p.value && p.type !== ef && u.insert(p.value + "{}"));
      } : L9(function(p) {
        u.insert(p);
      })], d = N9(c.concat(i, f)), h = function(y) {
        return li(R9(y), d);
      };
      l = function(y, b, x, S) {
        u = x, define_process_env_default.NODE_ENV !== "production" && b.map !== void 0 && (u = {
          insert: function(_) {
            x.insert(_ + b.map);
          }
        }), h(y ? y + "{" + b.styles + "}" : b.styles), S && (g.inserted[b.name] = true);
      };
    }
    var g = {
      key: r,
      sheet: new b9({
        key: r,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: l
    };
    return g.sheet.hydrate(a), g;
  }, Q9 = true;
  function tm(t10, e, r) {
    var n = "";
    return r.split(" ").forEach(function(i) {
      t10[i] !== void 0 ? e.push(t10[i] + ";") : n += i + " ";
    }), n;
  }
  var of = function(e, r, n) {
    var i = e.key + "-" + r.name;
    (n === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is globalThis or not
    // also, note that this check will be dead code eliminated in the browser
    Q9 === false) && e.registered[i] === void 0 && (e.registered[i] = r.styles);
  }, rm = function(e, r, n) {
    of(e, r, n);
    var i = e.key + "-" + r.name;
    if (e.inserted[r.name] === void 0) {
      var o = r;
      do
        e.insert(r === o ? "." + i : "", o, e.sheet, true), o = o.next;
      while (o !== void 0);
    }
  };
  function G9(t10) {
    for (var e = 0, r, n = 0, i = t10.length; i >= 4; ++n, i -= 4)
      r = t10.charCodeAt(n) & 255 | (t10.charCodeAt(++n) & 255) << 8 | (t10.charCodeAt(++n) & 255) << 16 | (t10.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
      (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
      r >>> 24, e = /* Math.imul(k, m): */
      (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
      case 3:
        e ^= (t10.charCodeAt(n + 2) & 255) << 16;
      case 2:
        e ^= (t10.charCodeAt(n + 1) & 255) << 8;
      case 1:
        e ^= t10.charCodeAt(n) & 255, e = /* Math.imul(h, m): */
        (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    }
    return e ^= e >>> 13, e = /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
  }
  var Z9 = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  function $9(t10) {
    var e = /* @__PURE__ */ Object.create(null);
    return function(r) {
      return e[r] === void 0 && (e[r] = t10(r)), e[r];
    };
  }
  var Ip = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, e_ = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", t_ = /[A-Z]|^ms/g, nm = /_EMO_([^_]+?)_([^]*?)_EMO_/g, sf = function(e) {
    return e.charCodeAt(1) === 45;
  }, Op = function(e) {
    return e != null && typeof e != "boolean";
  }, tc = /* @__PURE__ */ $9(function(t10) {
    return sf(t10) ? t10 : t10.replace(t_, "-$&").toLowerCase();
  }), va = function(e, r) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof r == "string")
          return r.replace(nm, function(n, i, o) {
            return nr = {
              name: i,
              styles: o,
              next: nr
            }, i;
          });
    }
    return Z9[e] !== 1 && !sf(e) && typeof r == "number" && r !== 0 ? r + "px" : r;
  };
  if (define_process_env_default.NODE_ENV !== "production") {
    var r_ = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, n_ = ["normal", "none", "initial", "inherit", "unset"], i_ = va, o_ = /^-ms-/, s_ = /-(.)/g, Pp = {};
    va = function(e, r) {
      if (e === "content" && (typeof r != "string" || n_.indexOf(r) === -1 && !r_.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'")))
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + r + "\"'`");
      var n = i_(e, r);
      return n !== "" && !sf(e) && e.indexOf("-") !== -1 && Pp[e] === void 0 && (Pp[e] = true, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + e.replace(o_, "ms-").replace(s_, function(i, o) {
        return o.toUpperCase();
      }) + "?")), n;
    };
  }
  var im = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function Ro(t10, e, r) {
    if (r == null)
      return "";
    if (r.__emotion_styles !== void 0) {
      if (define_process_env_default.NODE_ENV !== "production" && r.toString() === "NO_COMPONENT_SELECTOR")
        throw new Error(im);
      return r;
    }
    switch (typeof r) {
      case "boolean":
        return "";
      case "object": {
        if (r.anim === 1)
          return nr = {
            name: r.name,
            styles: r.styles,
            next: nr
          }, r.name;
        if (r.styles !== void 0) {
          var n = r.next;
          if (n !== void 0)
            for (; n !== void 0; )
              nr = {
                name: n.name,
                styles: n.styles,
                next: nr
              }, n = n.next;
          var i = r.styles + ";";
          return define_process_env_default.NODE_ENV !== "production" && r.map !== void 0 && (i += r.map), i;
        }
        return a_(t10, e, r);
      }
      case "function": {
        if (t10 !== void 0) {
          var o = nr, s = r(t10);
          return nr = o, Ro(t10, e, s);
        } else
          define_process_env_default.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
        break;
      }
      case "string":
        if (define_process_env_default.NODE_ENV !== "production") {
          var a = [], l = r.replace(nm, function(u, f, d) {
            var h = "animation" + a.length;
            return a.push("const " + h + " = keyframes`" + d.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + h + "}";
          });
          a.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(a, ["`" + l + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + l + "`"));
        }
        break;
    }
    if (e == null)
      return r;
    var c = e[r];
    return c !== void 0 ? c : r;
  }
  function a_(t10, e, r) {
    var n = "";
    if (Array.isArray(r))
      for (var i = 0; i < r.length; i++)
        n += Ro(t10, e, r[i]) + ";";
    else
      for (var o in r) {
        var s = r[o];
        if (typeof s != "object")
          e != null && e[s] !== void 0 ? n += o + "{" + e[s] + "}" : Op(s) && (n += tc(o) + ":" + va(o, s) + ";");
        else {
          if (o === "NO_COMPONENT_SELECTOR" && define_process_env_default.NODE_ENV !== "production")
            throw new Error(im);
          if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
            for (var a = 0; a < s.length; a++)
              Op(s[a]) && (n += tc(o) + ":" + va(o, s[a]) + ";");
          else {
            var l = Ro(t10, e, s);
            switch (o) {
              case "animation":
              case "animationName": {
                n += tc(o) + ":" + l + ";";
                break;
              }
              default:
                define_process_env_default.NODE_ENV !== "production" && o === "undefined" && console.error(e_), n += o + "{" + l + "}";
            }
          }
        }
      }
    return n;
  }
  var Rp = /label:\s*([^\s;\n{]+)\s*(;|$)/g, om;
  define_process_env_default.NODE_ENV !== "production" && (om = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
  var nr, Qc = function(e, r, n) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
      return e[0];
    var i = true, o = "";
    nr = void 0;
    var s = e[0];
    s == null || s.raw === void 0 ? (i = false, o += Ro(n, r, s)) : (define_process_env_default.NODE_ENV !== "production" && s[0] === void 0 && console.error(Ip), o += s[0]);
    for (var a = 1; a < e.length; a++)
      o += Ro(n, r, e[a]), i && (define_process_env_default.NODE_ENV !== "production" && s[a] === void 0 && console.error(Ip), o += s[a]);
    var l;
    define_process_env_default.NODE_ENV !== "production" && (o = o.replace(om, function(d) {
      return l = d, "";
    })), Rp.lastIndex = 0;
    for (var c = "", u; (u = Rp.exec(o)) !== null; )
      c += "-" + // $FlowFixMe we know it's not null
      u[1];
    var f = G9(o) + c;
    return define_process_env_default.NODE_ENV !== "production" ? {
      name: f,
      styles: o,
      map: l,
      next: nr,
      toString: function() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    } : {
      name: f,
      styles: o,
      next: nr
    };
  }, l_ = function(e) {
    return e();
  }, c_ = reactExports.useInsertionEffect ? reactExports.useInsertionEffect : false, sm = c_ || l_, u_ = {}.hasOwnProperty, af = /* @__PURE__ */ reactExports.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement < "u" ? /* @__PURE__ */ J9({
      key: "css"
    }) : null
  );
  define_process_env_default.NODE_ENV !== "production" && (af.displayName = "EmotionCacheContext");
  af.Provider;
  var am = function(e) {
    return /* @__PURE__ */ reactExports.forwardRef(function(r, n) {
      var i = reactExports.useContext(af);
      return e(r, i, n);
    });
  }, Ha = /* @__PURE__ */ reactExports.createContext({});
  define_process_env_default.NODE_ENV !== "production" && (Ha.displayName = "EmotionThemeContext");
  var Dp = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Mp = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", f_ = function(e) {
    var r = e.cache, n = e.serialized, i = e.isStringTag;
    return of(r, n, i), sm(function() {
      return rm(r, n, i);
    }), null;
  }, d_ = /* @__PURE__ */ am(function(t10, e, r) {
    var n = t10.css;
    typeof n == "string" && e.registered[n] !== void 0 && (n = e.registered[n]);
    var i = t10[Dp], o = [n], s = "";
    typeof t10.className == "string" ? s = tm(e.registered, o, t10.className) : t10.className != null && (s = t10.className + " ");
    var a = Qc(o, void 0, reactExports.useContext(Ha));
    if (define_process_env_default.NODE_ENV !== "production" && a.name.indexOf("-") === -1) {
      var l = t10[Mp];
      l && (a = Qc([a, "label:" + l + ";"]));
    }
    s += e.key + "-" + a.name;
    var c = {};
    for (var u in t10)
      u_.call(t10, u) && u !== "css" && u !== Dp && (define_process_env_default.NODE_ENV === "production" || u !== Mp) && (c[u] = t10[u]);
    return c.ref = r, c.className = s, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(f_, {
      cache: e,
      serialized: a,
      isStringTag: typeof i == "string"
    }), /* @__PURE__ */ reactExports.createElement(i, c));
  });
  define_process_env_default.NODE_ENV !== "production" && (d_.displayName = "EmotionCssPropInternal");
  var h_ = g9, p_ = function(e) {
    return e !== "theme";
  }, Np = function(e) {
    return typeof e == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96 ? h_ : p_;
  }, Lp = function(e, r, n) {
    var i;
    if (r) {
      var o = r.shouldForwardProp;
      i = e.__emotion_forwardProp && o ? function(s) {
        return e.__emotion_forwardProp(s) && o(s);
      } : o;
    }
    return typeof i != "function" && n && (i = e.__emotion_forwardProp), i;
  }, Bp = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, g_ = function(e) {
    var r = e.cache, n = e.serialized, i = e.isStringTag;
    return of(r, n, i), sm(function() {
      return rm(r, n, i);
    }), null;
  }, m_ = function t(e, r) {
    if (define_process_env_default.NODE_ENV !== "production" && e === void 0)
      throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
    var n = e.__emotion_real === e, i = n && e.__emotion_base || e, o, s;
    r !== void 0 && (o = r.label, s = r.target);
    var a = Lp(e, r, n), l = a || Np(i), c = !l("as");
    return function() {
      var u = arguments, f = n && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (o !== void 0 && f.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
        f.push.apply(f, u);
      else {
        define_process_env_default.NODE_ENV !== "production" && u[0][0] === void 0 && console.error(Bp), f.push(u[0][0]);
        for (var d = u.length, h = 1; h < d; h++)
          define_process_env_default.NODE_ENV !== "production" && u[0][h] === void 0 && console.error(Bp), f.push(u[h], u[0][h]);
      }
      var g = am(function(p, y, b) {
        var x = c && p.as || i, S = "", C = [], _ = p;
        if (p.theme == null) {
          _ = {};
          for (var L in p)
            _[L] = p[L];
          _.theme = reactExports.useContext(Ha);
        }
        typeof p.className == "string" ? S = tm(y.registered, C, p.className) : p.className != null && (S = p.className + " ");
        var F = Qc(f.concat(C), y.registered, _);
        S += y.key + "-" + F.name, s !== void 0 && (S += " " + s);
        var V = c && a === void 0 ? Np(x) : l, W = {};
        for (var X in p)
          c && X === "as" || // $FlowFixMe
          V(X) && (W[X] = p[X]);
        return W.className = S, W.ref = b, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(g_, {
          cache: y,
          serialized: F,
          isStringTag: typeof x == "string"
        }), /* @__PURE__ */ reactExports.createElement(x, W));
      });
      return g.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", g.defaultProps = e.defaultProps, g.__emotion_real = g, g.__emotion_base = i, g.__emotion_styles = f, g.__emotion_forwardProp = a, Object.defineProperty(g, "toString", {
        value: function() {
          return s === void 0 && define_process_env_default.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + s;
        }
      }), g.withComponent = function(p, y) {
        return t(p, Yc({}, r, y, {
          shouldForwardProp: Lp(g, y, true)
        })).apply(void 0, f);
      }, g;
    };
  };
  const y_ = m_;
  var b_ = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], Gc = y_.bind();
  b_.forEach(function(t10) {
    Gc[t10] = Gc(t10);
  });
  const v_ = Gc;
  /**
   * @mui/styled-engine v5.12.3
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function A_(t10, e) {
    const r = v_(t10, e);
    return define_process_env_default.NODE_ENV !== "production" ? (...n) => {
      const i = typeof t10 == "string" ? `"${t10}"` : "component";
      return n.length === 0 ? console.error([`MUI: Seems like you called \`styled(${i})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : n.some((o) => o === void 0) && console.error(`MUI: the styled(${i})(...args) API requires all its args to be defined.`), r(...n);
    } : r;
  }
  const w_ = (t10, e) => {
    Array.isArray(t10.__emotion_styles) && (t10.__emotion_styles = e(t10.__emotion_styles));
  };
  function gt() {
    return gt = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, gt.apply(this, arguments);
  }
  function Ka(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  const x_ = ["values", "unit", "step"], __ = (t10) => {
    const e = Object.keys(t10).map((r) => ({
      key: r,
      val: t10[r]
    })) || [];
    return e.sort((r, n) => r.val - n.val), e.reduce((r, n) => gt({}, r, {
      [n.key]: n.val
    }), {});
  };
  function S_(t10) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: e = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: r = "px",
      step: n = 5
    } = t10, i = Ka(t10, x_), o = __(e), s = Object.keys(o);
    function a(d) {
      return `@media (min-width:${typeof e[d] == "number" ? e[d] : d}${r})`;
    }
    function l(d) {
      return `@media (max-width:${(typeof e[d] == "number" ? e[d] : d) - n / 100}${r})`;
    }
    function c(d, h) {
      const g = s.indexOf(h);
      return `@media (min-width:${typeof e[d] == "number" ? e[d] : d}${r}) and (max-width:${(g !== -1 && typeof e[s[g]] == "number" ? e[s[g]] : h) - n / 100}${r})`;
    }
    function u(d) {
      return s.indexOf(d) + 1 < s.length ? c(d, s[s.indexOf(d) + 1]) : a(d);
    }
    function f(d) {
      const h = s.indexOf(d);
      return h === 0 ? a(s[1]) : h === s.length - 1 ? l(s[h]) : c(d, s[s.indexOf(d) + 1]).replace("@media", "@media not all and");
    }
    return gt({
      keys: s,
      values: o,
      up: a,
      down: l,
      between: c,
      only: u,
      not: f,
      unit: r
    }, i);
  }
  const E_ = {
    borderRadius: 4
  }, k_ = E_, C_ = define_process_env_default.NODE_ENV !== "production" ? N.oneOfType([N.number, N.string, N.object, N.array]) : {}, pn = C_;
  function fo(t10, e) {
    return e ? Lr(t10, e, {
      clone: false
      // No need to clone deep, it's way faster.
    }) : t10;
  }
  const lf = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  }, Fp = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (t10) => `@media (min-width:${lf[t10]}px)`
  };
  function jr(t10, e, r) {
    const n = t10.theme || {};
    if (Array.isArray(e)) {
      const o = n.breakpoints || Fp;
      return e.reduce((s, a, l) => (s[o.up(o.keys[l])] = r(e[l]), s), {});
    }
    if (typeof e == "object") {
      const o = n.breakpoints || Fp;
      return Object.keys(e).reduce((s, a) => {
        if (Object.keys(o.values || lf).indexOf(a) !== -1) {
          const l = o.up(a);
          s[l] = r(e[a], a);
        } else {
          const l = a;
          s[l] = e[l];
        }
        return s;
      }, {});
    }
    return r(e);
  }
  function T_(t10 = {}) {
    var e;
    return ((e = t10.keys) == null ? void 0 : e.reduce((n, i) => {
      const o = t10.up(i);
      return n[o] = {}, n;
    }, {})) || {};
  }
  function I_(t10, e) {
    return t10.reduce((r, n) => {
      const i = r[n];
      return (!i || Object.keys(i).length === 0) && delete r[n], r;
    }, e);
  }
  function Ya(t10, e, r = true) {
    if (!e || typeof e != "string")
      return null;
    if (t10 && t10.vars && r) {
      const n = `vars.${e}`.split(".").reduce((i, o) => i && i[o] ? i[o] : null, t10);
      if (n != null)
        return n;
    }
    return e.split(".").reduce((n, i) => n && n[i] != null ? n[i] : null, t10);
  }
  function Aa(t10, e, r, n = r) {
    let i;
    return typeof t10 == "function" ? i = t10(r) : Array.isArray(t10) ? i = t10[r] || n : i = Ya(t10, r) || n, e && (i = e(i, n, t10)), i;
  }
  function Ue(t10) {
    const {
      prop: e,
      cssProperty: r = t10.prop,
      themeKey: n,
      transform: i
    } = t10, o = (s) => {
      if (s[e] == null)
        return null;
      const a = s[e], l = s.theme, c = Ya(l, n) || {};
      return jr(s, a, (f) => {
        let d = Aa(c, i, f);
        return f === d && typeof f == "string" && (d = Aa(c, i, `${e}${f === "default" ? "" : Jt(f)}`, f)), r === false ? d : {
          [r]: d
        };
      });
    };
    return o.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
      [e]: pn
    } : {}, o.filterProps = [e], o;
  }
  function O_(t10) {
    const e = {};
    return (r) => (e[r] === void 0 && (e[r] = t10(r)), e[r]);
  }
  const P_ = {
    m: "margin",
    p: "padding"
  }, R_ = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  }, jp = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  }, D_ = O_((t10) => {
    if (t10.length > 2)
      if (jp[t10])
        t10 = jp[t10];
      else
        return [t10];
    const [e, r] = t10.split(""), n = P_[e], i = R_[r] || "";
    return Array.isArray(i) ? i.map((o) => n + o) : [n + i];
  }), Xa = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Ja = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], M_ = [...Xa, ...Ja];
  function Ho(t10, e, r, n) {
    var i;
    const o = (i = Ya(t10, e, false)) != null ? i : r;
    return typeof o == "number" ? (s) => typeof s == "string" ? s : (define_process_env_default.NODE_ENV !== "production" && typeof s != "number" && console.error(`MUI: Expected ${n} argument to be a number or a string, got ${s}.`), o * s) : Array.isArray(o) ? (s) => typeof s == "string" ? s : (define_process_env_default.NODE_ENV !== "production" && (Number.isInteger(s) ? s > o.length - 1 && console.error([`MUI: The value provided (${s}) overflows.`, `The supported values are: ${JSON.stringify(o)}.`, `${s} > ${o.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${e}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${e}\` as a number.`].join(`
`))), o[s]) : typeof o == "function" ? o : (define_process_env_default.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${e}\` value (${o}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
    });
  }
  function lm(t10) {
    return Ho(t10, "spacing", 8, "spacing");
  }
  function Ko(t10, e) {
    if (typeof e == "string" || e == null)
      return e;
    const r = Math.abs(e), n = t10(r);
    return e >= 0 ? n : typeof n == "number" ? -n : `-${n}`;
  }
  function N_(t10, e) {
    return (r) => t10.reduce((n, i) => (n[i] = Ko(e, r), n), {});
  }
  function L_(t10, e, r, n) {
    if (e.indexOf(r) === -1)
      return null;
    const i = D_(r), o = N_(i, n), s = t10[r];
    return jr(t10, s, o);
  }
  function cm(t10, e) {
    const r = lm(t10.theme);
    return Object.keys(t10).map((n) => L_(t10, e, n, r)).reduce(fo, {});
  }
  function nt(t10) {
    return cm(t10, Xa);
  }
  nt.propTypes = define_process_env_default.NODE_ENV !== "production" ? Xa.reduce((t10, e) => (t10[e] = pn, t10), {}) : {};
  nt.filterProps = Xa;
  function it(t10) {
    return cm(t10, Ja);
  }
  it.propTypes = define_process_env_default.NODE_ENV !== "production" ? Ja.reduce((t10, e) => (t10[e] = pn, t10), {}) : {};
  it.filterProps = Ja;
  define_process_env_default.NODE_ENV !== "production" && M_.reduce((t10, e) => (t10[e] = pn, t10), {});
  function B_(t10 = 8) {
    if (t10.mui)
      return t10;
    const e = lm({
      spacing: t10
    }), r = (...n) => (define_process_env_default.NODE_ENV !== "production" && (n.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${n.length}`)), (n.length === 0 ? [1] : n).map((o) => {
      const s = e(o);
      return typeof s == "number" ? `${s}px` : s;
    }).join(" "));
    return r.mui = true, r;
  }
  function Qa(...t10) {
    const e = t10.reduce((n, i) => (i.filterProps.forEach((o) => {
      n[o] = i;
    }), n), {}), r = (n) => Object.keys(n).reduce((i, o) => e[o] ? fo(i, e[o](n)) : i, {});
    return r.propTypes = define_process_env_default.NODE_ENV !== "production" ? t10.reduce((n, i) => Object.assign(n, i.propTypes), {}) : {}, r.filterProps = t10.reduce((n, i) => n.concat(i.filterProps), []), r;
  }
  function gr(t10) {
    return typeof t10 != "number" ? t10 : `${t10}px solid`;
  }
  const F_ = Ue({
    prop: "border",
    themeKey: "borders",
    transform: gr
  }), j_ = Ue({
    prop: "borderTop",
    themeKey: "borders",
    transform: gr
  }), W_ = Ue({
    prop: "borderRight",
    themeKey: "borders",
    transform: gr
  }), U_ = Ue({
    prop: "borderBottom",
    themeKey: "borders",
    transform: gr
  }), z_ = Ue({
    prop: "borderLeft",
    themeKey: "borders",
    transform: gr
  }), V_ = Ue({
    prop: "borderColor",
    themeKey: "palette"
  }), q_ = Ue({
    prop: "borderTopColor",
    themeKey: "palette"
  }), H_ = Ue({
    prop: "borderRightColor",
    themeKey: "palette"
  }), K_ = Ue({
    prop: "borderBottomColor",
    themeKey: "palette"
  }), Y_ = Ue({
    prop: "borderLeftColor",
    themeKey: "palette"
  }), Ga = (t10) => {
    if (t10.borderRadius !== void 0 && t10.borderRadius !== null) {
      const e = Ho(t10.theme, "shape.borderRadius", 4, "borderRadius"), r = (n) => ({
        borderRadius: Ko(e, n)
      });
      return jr(t10, t10.borderRadius, r);
    }
    return null;
  };
  Ga.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    borderRadius: pn
  } : {};
  Ga.filterProps = ["borderRadius"];
  Qa(F_, j_, W_, U_, z_, V_, q_, H_, K_, Y_, Ga);
  const Za = (t10) => {
    if (t10.gap !== void 0 && t10.gap !== null) {
      const e = Ho(t10.theme, "spacing", 8, "gap"), r = (n) => ({
        gap: Ko(e, n)
      });
      return jr(t10, t10.gap, r);
    }
    return null;
  };
  Za.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    gap: pn
  } : {};
  Za.filterProps = ["gap"];
  const $a = (t10) => {
    if (t10.columnGap !== void 0 && t10.columnGap !== null) {
      const e = Ho(t10.theme, "spacing", 8, "columnGap"), r = (n) => ({
        columnGap: Ko(e, n)
      });
      return jr(t10, t10.columnGap, r);
    }
    return null;
  };
  $a.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    columnGap: pn
  } : {};
  $a.filterProps = ["columnGap"];
  const el = (t10) => {
    if (t10.rowGap !== void 0 && t10.rowGap !== null) {
      const e = Ho(t10.theme, "spacing", 8, "rowGap"), r = (n) => ({
        rowGap: Ko(e, n)
      });
      return jr(t10, t10.rowGap, r);
    }
    return null;
  };
  el.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    rowGap: pn
  } : {};
  el.filterProps = ["rowGap"];
  const X_ = Ue({
    prop: "gridColumn"
  }), J_ = Ue({
    prop: "gridRow"
  }), Q_ = Ue({
    prop: "gridAutoFlow"
  }), G_ = Ue({
    prop: "gridAutoColumns"
  }), Z_ = Ue({
    prop: "gridAutoRows"
  }), $_ = Ue({
    prop: "gridTemplateColumns"
  }), e8 = Ue({
    prop: "gridTemplateRows"
  }), t8 = Ue({
    prop: "gridTemplateAreas"
  }), r8 = Ue({
    prop: "gridArea"
  });
  Qa(Za, $a, el, X_, J_, Q_, G_, Z_, $_, e8, t8, r8);
  function ci(t10, e) {
    return e === "grey" ? e : t10;
  }
  const n8 = Ue({
    prop: "color",
    themeKey: "palette",
    transform: ci
  }), i8 = Ue({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: ci
  }), o8 = Ue({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: ci
  });
  Qa(n8, i8, o8);
  function Bt(t10) {
    return t10 <= 1 && t10 !== 0 ? `${t10 * 100}%` : t10;
  }
  const s8 = Ue({
    prop: "width",
    transform: Bt
  }), cf = (t10) => {
    if (t10.maxWidth !== void 0 && t10.maxWidth !== null) {
      const e = (r) => {
        var n, i, o;
        return {
          maxWidth: ((n = t10.theme) == null || (i = n.breakpoints) == null || (o = i.values) == null ? void 0 : o[r]) || lf[r] || Bt(r)
        };
      };
      return jr(t10, t10.maxWidth, e);
    }
    return null;
  };
  cf.filterProps = ["maxWidth"];
  const a8 = Ue({
    prop: "minWidth",
    transform: Bt
  }), l8 = Ue({
    prop: "height",
    transform: Bt
  }), c8 = Ue({
    prop: "maxHeight",
    transform: Bt
  }), u8 = Ue({
    prop: "minHeight",
    transform: Bt
  });
  Ue({
    prop: "size",
    cssProperty: "width",
    transform: Bt
  });
  Ue({
    prop: "size",
    cssProperty: "height",
    transform: Bt
  });
  const f8 = Ue({
    prop: "boxSizing"
  });
  Qa(s8, cf, a8, l8, c8, u8, f8);
  const d8 = {
    // borders
    border: {
      themeKey: "borders",
      transform: gr
    },
    borderTop: {
      themeKey: "borders",
      transform: gr
    },
    borderRight: {
      themeKey: "borders",
      transform: gr
    },
    borderBottom: {
      themeKey: "borders",
      transform: gr
    },
    borderLeft: {
      themeKey: "borders",
      transform: gr
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: Ga
    },
    // palette
    color: {
      themeKey: "palette",
      transform: ci
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: ci
    },
    backgroundColor: {
      themeKey: "palette",
      transform: ci
    },
    // spacing
    p: {
      style: it
    },
    pt: {
      style: it
    },
    pr: {
      style: it
    },
    pb: {
      style: it
    },
    pl: {
      style: it
    },
    px: {
      style: it
    },
    py: {
      style: it
    },
    padding: {
      style: it
    },
    paddingTop: {
      style: it
    },
    paddingRight: {
      style: it
    },
    paddingBottom: {
      style: it
    },
    paddingLeft: {
      style: it
    },
    paddingX: {
      style: it
    },
    paddingY: {
      style: it
    },
    paddingInline: {
      style: it
    },
    paddingInlineStart: {
      style: it
    },
    paddingInlineEnd: {
      style: it
    },
    paddingBlock: {
      style: it
    },
    paddingBlockStart: {
      style: it
    },
    paddingBlockEnd: {
      style: it
    },
    m: {
      style: nt
    },
    mt: {
      style: nt
    },
    mr: {
      style: nt
    },
    mb: {
      style: nt
    },
    ml: {
      style: nt
    },
    mx: {
      style: nt
    },
    my: {
      style: nt
    },
    margin: {
      style: nt
    },
    marginTop: {
      style: nt
    },
    marginRight: {
      style: nt
    },
    marginBottom: {
      style: nt
    },
    marginLeft: {
      style: nt
    },
    marginX: {
      style: nt
    },
    marginY: {
      style: nt
    },
    marginInline: {
      style: nt
    },
    marginInlineStart: {
      style: nt
    },
    marginInlineEnd: {
      style: nt
    },
    marginBlock: {
      style: nt
    },
    marginBlockStart: {
      style: nt
    },
    marginBlockEnd: {
      style: nt
    },
    // display
    displayPrint: {
      cssProperty: false,
      transform: (t10) => ({
        "@media print": {
          display: t10
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: Za
    },
    rowGap: {
      style: el
    },
    columnGap: {
      style: $a
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: Bt
    },
    maxWidth: {
      style: cf
    },
    minWidth: {
      transform: Bt
    },
    height: {
      transform: Bt
    },
    maxHeight: {
      transform: Bt
    },
    minHeight: {
      transform: Bt
    },
    boxSizing: {},
    // typography
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: false,
      themeKey: "typography"
    }
  }, uf = d8;
  function h8(...t10) {
    const e = t10.reduce((n, i) => n.concat(Object.keys(i)), []), r = new Set(e);
    return t10.every((n) => r.size === Object.keys(n).length);
  }
  function p8(t10, e) {
    return typeof t10 == "function" ? t10(e) : t10;
  }
  function g8() {
    function t10(r, n, i, o) {
      const s = {
        [r]: n,
        theme: i
      }, a = o[r];
      if (!a)
        return {
          [r]: n
        };
      const {
        cssProperty: l = r,
        themeKey: c,
        transform: u,
        style: f
      } = a;
      if (n == null)
        return null;
      if (c === "typography" && n === "inherit")
        return {
          [r]: n
        };
      const d = Ya(i, c) || {};
      return f ? f(s) : jr(s, n, (g) => {
        let p = Aa(d, u, g);
        return g === p && typeof g == "string" && (p = Aa(d, u, `${r}${g === "default" ? "" : Jt(g)}`, g)), l === false ? p : {
          [l]: p
        };
      });
    }
    function e(r) {
      var n;
      const {
        sx: i,
        theme: o = {}
      } = r || {};
      if (!i)
        return null;
      const s = (n = o.unstable_sxConfig) != null ? n : uf;
      function a(l) {
        let c = l;
        if (typeof l == "function")
          c = l(o);
        else if (typeof l != "object")
          return l;
        if (!c)
          return null;
        const u = T_(o.breakpoints), f = Object.keys(u);
        let d = u;
        return Object.keys(c).forEach((h) => {
          const g = p8(c[h], o);
          if (g != null)
            if (typeof g == "object")
              if (s[h])
                d = fo(d, t10(h, g, o, s));
              else {
                const p = jr({
                  theme: o
                }, g, (y) => ({
                  [h]: y
                }));
                h8(p, g) ? d[h] = e({
                  sx: g,
                  theme: o
                }) : d = fo(d, p);
              }
            else
              d = fo(d, t10(h, g, o, s));
        }), I_(f, d);
      }
      return Array.isArray(i) ? i.map(a) : a(i);
    }
    return e;
  }
  const um = g8();
  um.filterProps = ["sx"];
  const ff = um, m8 = ["breakpoints", "palette", "spacing", "shape"];
  function df(t10 = {}, ...e) {
    const {
      breakpoints: r = {},
      palette: n = {},
      spacing: i,
      shape: o = {}
    } = t10, s = Ka(t10, m8), a = S_(r), l = B_(i);
    let c = Lr({
      breakpoints: a,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: gt({
        mode: "light"
      }, n),
      spacing: l,
      shape: gt({}, k_, o)
    }, s);
    return c = e.reduce((u, f) => Lr(u, f), c), c.unstable_sxConfig = gt({}, uf, s == null ? void 0 : s.unstable_sxConfig), c.unstable_sx = function(f) {
      return ff({
        sx: f,
        theme: this
      });
    }, c;
  }
  function y8(t10) {
    return Object.keys(t10).length === 0;
  }
  function fm(t10 = null) {
    const e = reactExports.useContext(Ha);
    return !e || y8(e) ? t10 : e;
  }
  const b8 = df();
  function dm(t10 = b8) {
    return fm(t10);
  }
  const v8 = ["variant"];
  function Wp(t10) {
    return t10.length === 0;
  }
  function hm(t10) {
    const {
      variant: e
    } = t10, r = Ka(t10, v8);
    let n = e || "";
    return Object.keys(r).sort().forEach((i) => {
      i === "color" ? n += Wp(n) ? t10[i] : Jt(t10[i]) : n += `${Wp(n) ? i : Jt(i)}${Jt(t10[i].toString())}`;
    }), n;
  }
  const A8 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function w8(t10) {
    return Object.keys(t10).length === 0;
  }
  function x8(t10) {
    return typeof t10 == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    t10.charCodeAt(0) > 96;
  }
  const _8 = (t10, e) => e.components && e.components[t10] && e.components[t10].styleOverrides ? e.components[t10].styleOverrides : null, S8 = (t10, e) => {
    let r = [];
    e && e.components && e.components[t10] && e.components[t10].variants && (r = e.components[t10].variants);
    const n = {};
    return r.forEach((i) => {
      const o = hm(i.props);
      n[o] = i.style;
    }), n;
  }, E8 = (t10, e, r, n) => {
    var i, o;
    const {
      ownerState: s = {}
    } = t10, a = [], l = r == null || (i = r.components) == null || (o = i[n]) == null ? void 0 : o.variants;
    return l && l.forEach((c) => {
      let u = true;
      Object.keys(c.props).forEach((f) => {
        s[f] !== c.props[f] && t10[f] !== c.props[f] && (u = false);
      }), u && a.push(e[hm(c.props)]);
    }), a;
  };
  function Us(t10) {
    return t10 !== "ownerState" && t10 !== "theme" && t10 !== "sx" && t10 !== "as";
  }
  const k8 = df(), C8 = (t10) => t10.charAt(0).toLowerCase() + t10.slice(1);
  function Vi({
    defaultTheme: t10,
    theme: e,
    themeId: r
  }) {
    return w8(e) ? t10 : e[r] || e;
  }
  function T8(t10 = {}) {
    const {
      themeId: e,
      defaultTheme: r = k8,
      rootShouldForwardProp: n = Us,
      slotShouldForwardProp: i = Us
    } = t10, o = (s) => ff(gt({}, s, {
      theme: Vi(gt({}, s, {
        defaultTheme: r,
        themeId: e
      }))
    }));
    return o.__mui_systemSx = true, (s, a = {}) => {
      w_(s, (C) => C.filter((_) => !(_ != null && _.__mui_systemSx)));
      const {
        name: l,
        slot: c,
        skipVariantsResolver: u,
        skipSx: f,
        overridesResolver: d
      } = a, h = Ka(a, A8), g = u !== void 0 ? u : c && c !== "Root" || false, p = f || false;
      let y;
      define_process_env_default.NODE_ENV !== "production" && l && (y = `${l}-${C8(c || "Root")}`);
      let b = Us;
      c === "Root" ? b = n : c ? b = i : x8(s) && (b = void 0);
      const x = A_(s, gt({
        shouldForwardProp: b,
        label: y
      }, h)), S = (C, ..._) => {
        const L = _ ? _.map((X) => typeof X == "function" && X.__emotion_real !== X ? (G) => X(gt({}, G, {
          theme: Vi(gt({}, G, {
            defaultTheme: r,
            themeId: e
          }))
        })) : X) : [];
        let F = C;
        l && d && L.push((X) => {
          const G = Vi(gt({}, X, {
            defaultTheme: r,
            themeId: e
          })), ie = _8(l, G);
          if (ie) {
            const P10 = {};
            return Object.entries(ie).forEach(([z10, B]) => {
              P10[z10] = typeof B == "function" ? B(gt({}, X, {
                theme: G
              })) : B;
            }), d(X, P10);
          }
          return null;
        }), l && !g && L.push((X) => {
          const G = Vi(gt({}, X, {
            defaultTheme: r,
            themeId: e
          }));
          return E8(X, S8(l, G), G, l);
        }), p || L.push(o);
        const V = L.length - _.length;
        if (Array.isArray(C) && V > 0) {
          const X = new Array(V).fill("");
          F = [...C, ...X], F.raw = [...C.raw, ...X];
        } else
          typeof C == "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
          // component stays as a function. This condition makes sure that we do not interpolate functions
          // which are basically components used as a selectors.
          C.__emotion_real !== C && (F = (X) => C(gt({}, X, {
            theme: Vi(gt({}, X, {
              defaultTheme: r,
              themeId: e
            }))
          })));
        const W = x(F, ...L);
        if (define_process_env_default.NODE_ENV !== "production") {
          let X;
          l && (X = `${l}${c || ""}`), X === void 0 && (X = `Styled(${b4(s)})`), W.displayName = X;
        }
        return s.muiName && (W.muiName = s.muiName), W;
      };
      return x.withConfig && (S.withConfig = x.withConfig), S;
    };
  }
  function I8(t10) {
    const {
      theme: e,
      name: r,
      props: n
    } = t10;
    return !e || !e.components || !e.components[r] || !e.components[r].defaultProps ? n : Ng(e.components[r].defaultProps, n);
  }
  function O8({
    props: t10,
    name: e,
    defaultTheme: r,
    themeId: n
  }) {
    let i = dm(r);
    return i = i[n] || i, I8({
      theme: i,
      name: e,
      props: t10
    });
  }
  function hf(t10, e = 0, r = 1) {
    return define_process_env_default.NODE_ENV !== "production" && (t10 < e || t10 > r) && console.error(`MUI: The value provided ${t10} is out of range [${e}, ${r}].`), Math.min(Math.max(e, t10), r);
  }
  function P8(t10) {
    t10 = t10.slice(1);
    const e = new RegExp(`.{1,${t10.length >= 6 ? 2 : 1}}`, "g");
    let r = t10.match(e);
    return r && r[0].length === 1 && (r = r.map((n) => n + n)), r ? `rgb${r.length === 4 ? "a" : ""}(${r.map((n, i) => i < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
  }
  function Un(t10) {
    if (t10.type)
      return t10;
    if (t10.charAt(0) === "#")
      return Un(P8(t10));
    const e = t10.indexOf("("), r = t10.substring(0, e);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(r) === -1)
      throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: Unsupported \`${t10}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : yi(9, t10));
    let n = t10.substring(e + 1, t10.length - 1), i;
    if (r === "color") {
      if (n = n.split(" "), i = n.shift(), n.length === 4 && n[3].charAt(0) === "/" && (n[3] = n[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1)
        throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: unsupported \`${i}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : yi(10, i));
    } else
      n = n.split(",");
    return n = n.map((o) => parseFloat(o)), {
      type: r,
      values: n,
      colorSpace: i
    };
  }
  function tl(t10) {
    const {
      type: e,
      colorSpace: r
    } = t10;
    let {
      values: n
    } = t10;
    return e.indexOf("rgb") !== -1 ? n = n.map((i, o) => o < 3 ? parseInt(i, 10) : i) : e.indexOf("hsl") !== -1 && (n[1] = `${n[1]}%`, n[2] = `${n[2]}%`), e.indexOf("color") !== -1 ? n = `${r} ${n.join(" ")}` : n = `${n.join(", ")}`, `${e}(${n})`;
  }
  function R8(t10) {
    t10 = Un(t10);
    const {
      values: e
    } = t10, r = e[0], n = e[1] / 100, i = e[2] / 100, o = n * Math.min(i, 1 - i), s = (c, u = (c + r / 30) % 12) => i - o * Math.max(Math.min(u - 3, 9 - u, 1), -1);
    let a = "rgb";
    const l = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];
    return t10.type === "hsla" && (a += "a", l.push(e[3])), tl({
      type: a,
      values: l
    });
  }
  function Up(t10) {
    t10 = Un(t10);
    let e = t10.type === "hsl" || t10.type === "hsla" ? Un(R8(t10)).values : t10.values;
    return e = e.map((r) => (t10.type !== "color" && (r /= 255), r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4)), Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3));
  }
  function zp(t10, e) {
    const r = Up(t10), n = Up(e);
    return (Math.max(r, n) + 0.05) / (Math.min(r, n) + 0.05);
  }
  function pm(t10, e) {
    return t10 = Un(t10), e = hf(e), (t10.type === "rgb" || t10.type === "hsl") && (t10.type += "a"), t10.type === "color" ? t10.values[3] = `/${e}` : t10.values[3] = e, tl(t10);
  }
  function D8(t10, e) {
    if (t10 = Un(t10), e = hf(e), t10.type.indexOf("hsl") !== -1)
      t10.values[2] *= 1 - e;
    else if (t10.type.indexOf("rgb") !== -1 || t10.type.indexOf("color") !== -1)
      for (let r = 0; r < 3; r += 1)
        t10.values[r] *= 1 - e;
    return tl(t10);
  }
  function M8(t10, e) {
    if (t10 = Un(t10), e = hf(e), t10.type.indexOf("hsl") !== -1)
      t10.values[2] += (100 - t10.values[2]) * e;
    else if (t10.type.indexOf("rgb") !== -1)
      for (let r = 0; r < 3; r += 1)
        t10.values[r] += (255 - t10.values[r]) * e;
    else if (t10.type.indexOf("color") !== -1)
      for (let r = 0; r < 3; r += 1)
        t10.values[r] += (1 - t10.values[r]) * e;
    return tl(t10);
  }
  function N8(t10, e) {
    return xe({
      toolbar: {
        minHeight: 56,
        [t10.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [t10.up("sm")]: {
          minHeight: 64
        }
      }
    }, e);
  }
  const L8 = {
    black: "#000",
    white: "#fff"
  }, Do = L8, B8 = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  }, F8 = B8, j8 = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
  }, Yn = j8, W8 = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
  }, Xn = W8, U8 = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
  }, qi = U8, z8 = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
  }, Jn = z8, V8 = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
  }, Qn = V8, q8 = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
  }, Gn = q8, H8 = ["mode", "contrastThreshold", "tonalOffset"], Vp = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Do.white,
      default: Do.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  }, rc = {
    text: {
      primary: Do.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Do.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
  function qp(t10, e, r, n) {
    const i = n.light || n, o = n.dark || n * 1.5;
    t10[e] || (t10.hasOwnProperty(r) ? t10[e] = t10[r] : e === "light" ? t10.light = M8(t10.main, i) : e === "dark" && (t10.dark = D8(t10.main, o)));
  }
  function K8(t10 = "light") {
    return t10 === "dark" ? {
      main: Jn[200],
      light: Jn[50],
      dark: Jn[400]
    } : {
      main: Jn[700],
      light: Jn[400],
      dark: Jn[800]
    };
  }
  function Y8(t10 = "light") {
    return t10 === "dark" ? {
      main: Yn[200],
      light: Yn[50],
      dark: Yn[400]
    } : {
      main: Yn[500],
      light: Yn[300],
      dark: Yn[700]
    };
  }
  function X8(t10 = "light") {
    return t10 === "dark" ? {
      main: Xn[500],
      light: Xn[300],
      dark: Xn[700]
    } : {
      main: Xn[700],
      light: Xn[400],
      dark: Xn[800]
    };
  }
  function J8(t10 = "light") {
    return t10 === "dark" ? {
      main: Qn[400],
      light: Qn[300],
      dark: Qn[700]
    } : {
      main: Qn[700],
      light: Qn[500],
      dark: Qn[900]
    };
  }
  function Q8(t10 = "light") {
    return t10 === "dark" ? {
      main: Gn[400],
      light: Gn[300],
      dark: Gn[700]
    } : {
      main: Gn[800],
      light: Gn[500],
      dark: Gn[900]
    };
  }
  function G8(t10 = "light") {
    return t10 === "dark" ? {
      main: qi[400],
      light: qi[300],
      dark: qi[700]
    } : {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: qi[500],
      dark: qi[900]
    };
  }
  function Z8(t10) {
    const {
      mode: e = "light",
      contrastThreshold: r = 3,
      tonalOffset: n = 0.2
    } = t10, i = dn(t10, H8), o = t10.primary || K8(e), s = t10.secondary || Y8(e), a = t10.error || X8(e), l = t10.info || J8(e), c = t10.success || Q8(e), u = t10.warning || G8(e);
    function f(p) {
      const y = zp(p, rc.text.primary) >= r ? rc.text.primary : Vp.text.primary;
      if (define_process_env_default.NODE_ENV !== "production") {
        const b = zp(p, y);
        b < 3 && console.error([`MUI: The contrast ratio of ${b}:1 for ${y} on ${p}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
      }
      return y;
    }
    const d = ({
      color: p,
      name: y,
      mainShade: b = 500,
      lightShade: x = 300,
      darkShade: S = 700
    }) => {
      if (p = xe({}, p), !p.main && p[b] && (p.main = p[b]), !p.hasOwnProperty("main"))
        throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${b}\` property.` : yi(11, y ? ` (${y})` : "", b));
      if (typeof p.main != "string")
        throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(p.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : yi(12, y ? ` (${y})` : "", JSON.stringify(p.main)));
      return qp(p, "light", x, n), qp(p, "dark", S, n), p.contrastText || (p.contrastText = f(p.main)), p;
    }, h = {
      dark: rc,
      light: Vp
    };
    return define_process_env_default.NODE_ENV !== "production" && (h[e] || console.error(`MUI: The palette mode \`${e}\` is not supported.`)), Lr(xe({
      // A collection of common colors.
      common: xe({}, Do),
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode: e,
      // The colors used to represent primary interface elements for a user.
      primary: d({
        color: o,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: d({
        color: s,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: d({
        color: a,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: d({
        color: u,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: d({
        color: l,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: d({
        color: c,
        name: "success"
      }),
      // The grey colors.
      grey: F8,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: r,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: f,
      // Generate a rich color object.
      augmentColor: d,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: n
    }, h[e]), i);
  }
  const $8 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
  function e7(t10) {
    return Math.round(t10 * 1e5) / 1e5;
  }
  const Hp = {
    textTransform: "uppercase"
  }, Kp = '"Roboto", "Helvetica", "Arial", sans-serif';
  function t7(t10, e) {
    const r = typeof e == "function" ? e(t10) : e, {
      fontFamily: n = Kp,
      // The default font size of the Material Specification.
      fontSize: i = 14,
      // px
      fontWeightLight: o = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: l = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize: c = 16,
      // Apply the CSS properties to all the variants.
      allVariants: u,
      pxToRem: f
    } = r, d = dn(r, $8);
    define_process_env_default.NODE_ENV !== "production" && (typeof i != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof c != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
    const h = i / 14, g = f || ((b) => `${b / c * h}rem`), p = (b, x, S, C, _) => xe({
      fontFamily: n,
      fontWeight: b,
      fontSize: g(x),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight: S
    }, n === Kp ? {
      letterSpacing: `${e7(C / x)}em`
    } : {}, _, u), y = {
      h1: p(o, 96, 1.167, -1.5),
      h2: p(o, 60, 1.2, -0.5),
      h3: p(s, 48, 1.167, 0),
      h4: p(s, 34, 1.235, 0.25),
      h5: p(s, 24, 1.334, 0),
      h6: p(a, 20, 1.6, 0.15),
      subtitle1: p(s, 16, 1.75, 0.15),
      subtitle2: p(a, 14, 1.57, 0.1),
      body1: p(s, 16, 1.5, 0.15),
      body2: p(s, 14, 1.43, 0.15),
      button: p(a, 14, 1.75, 0.4, Hp),
      caption: p(s, 12, 1.66, 0.4),
      overline: p(s, 12, 2.66, 1, Hp),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return Lr(xe({
      htmlFontSize: c,
      pxToRem: g,
      fontFamily: n,
      fontSize: i,
      fontWeightLight: o,
      fontWeightRegular: s,
      fontWeightMedium: a,
      fontWeightBold: l
    }, y), d, {
      clone: false
      // No need to clone deep
    });
  }
  const r7 = 0.2, n7 = 0.14, i7 = 0.12;
  function tt(...t10) {
    return [`${t10[0]}px ${t10[1]}px ${t10[2]}px ${t10[3]}px rgba(0,0,0,${r7})`, `${t10[4]}px ${t10[5]}px ${t10[6]}px ${t10[7]}px rgba(0,0,0,${n7})`, `${t10[8]}px ${t10[9]}px ${t10[10]}px ${t10[11]}px rgba(0,0,0,${i7})`].join(",");
  }
  const o7 = ["none", tt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), tt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), tt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), tt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), tt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), tt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), tt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), tt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), tt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), tt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), tt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), tt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), tt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), tt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), tt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), tt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), tt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), tt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), tt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), tt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), tt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), tt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), tt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), tt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], s7 = o7, a7 = ["duration", "easing", "delay"], l7 = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  }, c7 = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function Yp(t10) {
    return `${Math.round(t10)}ms`;
  }
  function u7(t10) {
    if (!t10)
      return 0;
    const e = t10 / 36;
    return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
  }
  function f7(t10) {
    const e = xe({}, l7, t10.easing), r = xe({}, c7, t10.duration);
    return xe({
      getAutoHeightDuration: u7,
      create: (i = ["all"], o = {}) => {
        const {
          duration: s = r.standard,
          easing: a = e.easeInOut,
          delay: l = 0
        } = o, c = dn(o, a7);
        if (define_process_env_default.NODE_ENV !== "production") {
          const u = (d) => typeof d == "string", f = (d) => !isNaN(parseFloat(d));
          !u(i) && !Array.isArray(i) && console.error('MUI: Argument "props" must be a string or Array.'), !f(s) && !u(s) && console.error(`MUI: Argument "duration" must be a number or a string but found ${s}.`), u(a) || console.error('MUI: Argument "easing" must be a string.'), !f(l) && !u(l) && console.error('MUI: Argument "delay" must be a number or a string.'), Object.keys(c).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(c).join(",")}].`);
        }
        return (Array.isArray(i) ? i : [i]).map((u) => `${u} ${typeof s == "string" ? s : Yp(s)} ${a} ${typeof l == "string" ? l : Yp(l)}`).join(",");
      }
    }, t10, {
      easing: e,
      duration: r
    });
  }
  const d7 = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  }, h7 = d7, p7 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
  function g7(t10 = {}, ...e) {
    const {
      mixins: r = {},
      palette: n = {},
      transitions: i = {},
      typography: o = {}
    } = t10, s = dn(t10, p7);
    if (t10.vars)
      throw new Error(define_process_env_default.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : yi(18));
    const a = Z8(n), l = df(t10);
    let c = Lr(l, {
      mixins: N8(l.breakpoints, r),
      palette: a,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: s7.slice(),
      typography: t7(a, o),
      transitions: f7(i),
      zIndex: xe({}, h7)
    });
    if (c = Lr(c, s), c = e.reduce((u, f) => Lr(u, f), c), define_process_env_default.NODE_ENV !== "production") {
      const u = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], f = (d, h) => {
        let g;
        for (g in d) {
          const p = d[g];
          if (u.indexOf(g) !== -1 && Object.keys(p).length > 0) {
            if (define_process_env_default.NODE_ENV !== "production") {
              const y = Uo("", g);
              console.error([`MUI: The \`${h}\` component increases the CSS specificity of the \`${g}\` internal state.`, "You can not override it like this: ", JSON.stringify(d, null, 2), "", `Instead, you need to use the '&.${y}' syntax:`, JSON.stringify({
                root: {
                  [`&.${y}`]: p
                }
              }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
            }
            d[g] = {};
          }
        }
      };
      Object.keys(c.components).forEach((d) => {
        const h = c.components[d].styleOverrides;
        h && d.indexOf("Mui") === 0 && f(h, d);
      });
    }
    return c.unstable_sxConfig = xe({}, uf, s == null ? void 0 : s.unstable_sxConfig), c.unstable_sx = function(f) {
      return ff({
        sx: f,
        theme: this
      });
    }, c;
  }
  const m7 = g7(), pf = m7, gf = "$$material", y7 = (t10) => Us(t10) && t10 !== "classes", b7 = T8({
    themeId: gf,
    defaultTheme: pf,
    rootShouldForwardProp: y7
  }), Yo = b7;
  function mf({
    props: t10,
    name: e
  }) {
    return O8({
      props: t10,
      name: e,
      defaultTheme: pf,
      themeId: gf
    });
  }
  function v7(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  function A7(t10, e) {
    t10.prototype = Object.create(e.prototype), t10.prototype.constructor = t10, t10.__proto__ = e;
  }
  const Xp = {
    disabled: false
  };
  var w7 = define_process_env_default.NODE_ENV !== "production" ? N.oneOfType([N.number, N.shape({
    enter: N.number,
    exit: N.number,
    appear: N.number
  }).isRequired]) : null;
  define_process_env_default.NODE_ENV !== "production" && N.oneOfType([N.string, N.shape({
    enter: N.string,
    exit: N.string,
    active: N.string
  }), N.shape({
    enter: N.string,
    enterDone: N.string,
    enterActive: N.string,
    exit: N.string,
    exitDone: N.string,
    exitActive: N.string
  })]);
  const gm = U.createContext(null);
  var x7 = function(e) {
    return e.scrollTop;
  }, to = "unmounted", En = "exited", kn = "entering", ti = "entered", Zc = "exiting", zr = /* @__PURE__ */ function(t10) {
    A7(e, t10);
    function e(n, i) {
      var o;
      o = t10.call(this, n, i) || this;
      var s = i, a = s && !s.isMounting ? n.enter : n.appear, l;
      return o.appearStatus = null, n.in ? a ? (l = En, o.appearStatus = kn) : l = ti : n.unmountOnExit || n.mountOnEnter ? l = to : l = En, o.state = {
        status: l
      }, o.nextCallback = null, o;
    }
    e.getDerivedStateFromProps = function(i, o) {
      var s = i.in;
      return s && o.status === to ? {
        status: En
      } : null;
    };
    var r = e.prototype;
    return r.componentDidMount = function() {
      this.updateStatus(true, this.appearStatus);
    }, r.componentDidUpdate = function(i) {
      var o = null;
      if (i !== this.props) {
        var s = this.state.status;
        this.props.in ? s !== kn && s !== ti && (o = kn) : (s === kn || s === ti) && (o = Zc);
      }
      this.updateStatus(false, o);
    }, r.componentWillUnmount = function() {
      this.cancelNextCallback();
    }, r.getTimeouts = function() {
      var i = this.props.timeout, o, s, a;
      return o = s = a = i, i != null && typeof i != "number" && (o = i.exit, s = i.enter, a = i.appear !== void 0 ? i.appear : s), {
        exit: o,
        enter: s,
        appear: a
      };
    }, r.updateStatus = function(i, o) {
      if (i === void 0 && (i = false), o !== null)
        if (this.cancelNextCallback(), o === kn) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var s = this.props.nodeRef ? this.props.nodeRef.current : yr.findDOMNode(this);
            s && x7(s);
          }
          this.performEnter(i);
        } else
          this.performExit();
      else
        this.props.unmountOnExit && this.state.status === En && this.setState({
          status: to
        });
    }, r.performEnter = function(i) {
      var o = this, s = this.props.enter, a = this.context ? this.context.isMounting : i, l = this.props.nodeRef ? [a] : [yr.findDOMNode(this), a], c = l[0], u = l[1], f = this.getTimeouts(), d = a ? f.appear : f.enter;
      if (!i && !s || Xp.disabled) {
        this.safeSetState({
          status: ti
        }, function() {
          o.props.onEntered(c);
        });
        return;
      }
      this.props.onEnter(c, u), this.safeSetState({
        status: kn
      }, function() {
        o.props.onEntering(c, u), o.onTransitionEnd(d, function() {
          o.safeSetState({
            status: ti
          }, function() {
            o.props.onEntered(c, u);
          });
        });
      });
    }, r.performExit = function() {
      var i = this, o = this.props.exit, s = this.getTimeouts(), a = this.props.nodeRef ? void 0 : yr.findDOMNode(this);
      if (!o || Xp.disabled) {
        this.safeSetState({
          status: En
        }, function() {
          i.props.onExited(a);
        });
        return;
      }
      this.props.onExit(a), this.safeSetState({
        status: Zc
      }, function() {
        i.props.onExiting(a), i.onTransitionEnd(s.exit, function() {
          i.safeSetState({
            status: En
          }, function() {
            i.props.onExited(a);
          });
        });
      });
    }, r.cancelNextCallback = function() {
      this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
    }, r.safeSetState = function(i, o) {
      o = this.setNextCallback(o), this.setState(i, o);
    }, r.setNextCallback = function(i) {
      var o = this, s = true;
      return this.nextCallback = function(a) {
        s && (s = false, o.nextCallback = null, i(a));
      }, this.nextCallback.cancel = function() {
        s = false;
      }, this.nextCallback;
    }, r.onTransitionEnd = function(i, o) {
      this.setNextCallback(o);
      var s = this.props.nodeRef ? this.props.nodeRef.current : yr.findDOMNode(this), a = i == null && !this.props.addEndListener;
      if (!s || a) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var l = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], c = l[0], u = l[1];
        this.props.addEndListener(c, u);
      }
      i != null && setTimeout(this.nextCallback, i);
    }, r.render = function() {
      var i = this.state.status;
      if (i === to)
        return null;
      var o = this.props, s = o.children;
      o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
      var a = v7(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ U.createElement(gm.Provider, {
          value: null
        }, typeof s == "function" ? s(i, a) : U.cloneElement(U.Children.only(s), a))
      );
    }, e;
  }(U.Component);
  zr.contextType = gm;
  zr.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: N.shape({
      current: typeof Element > "u" ? N.any : function(t10, e, r, n, i, o) {
        var s = t10[e];
        return N.instanceOf(s && "ownerDocument" in s ? s.ownerDocument.defaultView.Element : Element)(t10, e, r, n, i, o);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: N.oneOfType([N.func.isRequired, N.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: N.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: N.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: N.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: N.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: N.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: N.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function(e) {
      var r = w7;
      e.addEndListener || (r = r.isRequired);
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
        i[o - 1] = arguments[o];
      return r.apply(void 0, [e].concat(i));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: N.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: N.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: N.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: N.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: N.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: N.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: N.func
  } : {};
  function Zn() {
  }
  zr.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: Zn,
    onEntering: Zn,
    onEntered: Zn,
    onExit: Zn,
    onExiting: Zn,
    onExited: Zn
  };
  zr.UNMOUNTED = to;
  zr.EXITED = En;
  zr.ENTERING = kn;
  zr.ENTERED = ti;
  zr.EXITING = Zc;
  const _7 = zr;
  function mm() {
    const t10 = dm(pf);
    return define_process_env_default.NODE_ENV !== "production" && reactExports.useDebugValue(t10), t10[gf] || t10;
  }
  const S7 = (t10) => t10.scrollTop;
  function Jp(t10, e) {
    var r, n;
    const {
      timeout: i,
      easing: o,
      style: s = {}
    } = t10;
    return {
      duration: (r = s.transitionDuration) != null ? r : typeof i == "number" ? i : i[e.mode] || 0,
      easing: (n = s.transitionTimingFunction) != null ? n : typeof o == "object" ? o[e.mode] : o,
      delay: s.transitionDelay
    };
  }
  const E7 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  function $c(t10) {
    return `scale(${t10}, ${t10 ** 2})`;
  }
  const k7 = {
    entering: {
      opacity: 1,
      transform: $c(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  }, nc = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), yf = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const {
      addEndListener: n,
      appear: i = true,
      children: o,
      easing: s,
      in: a,
      onEnter: l,
      onEntered: c,
      onEntering: u,
      onExit: f,
      onExited: d,
      onExiting: h,
      style: g,
      timeout: p = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent: y = _7
    } = e, b = dn(e, E7), x = reactExports.useRef(), S = reactExports.useRef(), C = mm(), _ = reactExports.useRef(null), L = jn(_, o.ref, r), F = (B) => (O) => {
      if (B) {
        const q = _.current;
        O === void 0 ? B(q) : B(q, O);
      }
    }, V = F(u), W = F((B, O) => {
      S7(B);
      const {
        duration: q,
        delay: te,
        easing: Y
      } = Jp({
        style: g,
        timeout: p,
        easing: s
      }, {
        mode: "enter"
      });
      let K;
      p === "auto" ? (K = C.transitions.getAutoHeightDuration(B.clientHeight), S.current = K) : K = q, B.style.transition = [C.transitions.create("opacity", {
        duration: K,
        delay: te
      }), C.transitions.create("transform", {
        duration: nc ? K : K * 0.666,
        delay: te,
        easing: Y
      })].join(","), l && l(B, O);
    }), X = F(c), G = F(h), ie = F((B) => {
      const {
        duration: O,
        delay: q,
        easing: te
      } = Jp({
        style: g,
        timeout: p,
        easing: s
      }, {
        mode: "exit"
      });
      let Y;
      p === "auto" ? (Y = C.transitions.getAutoHeightDuration(B.clientHeight), S.current = Y) : Y = O, B.style.transition = [C.transitions.create("opacity", {
        duration: Y,
        delay: q
      }), C.transitions.create("transform", {
        duration: nc ? Y : Y * 0.666,
        delay: nc ? q : q || Y * 0.333,
        easing: te
      })].join(","), B.style.opacity = 0, B.style.transform = $c(0.75), f && f(B);
    }), P10 = F(d), z10 = (B) => {
      p === "auto" && (x.current = setTimeout(B, S.current || 0)), n && n(_.current, B);
    };
    return reactExports.useEffect(() => () => {
      clearTimeout(x.current);
    }, []), /* @__PURE__ */ jsxRuntimeExports.jsx(y, xe({
      appear: i,
      in: a,
      nodeRef: _,
      onEnter: W,
      onEntered: X,
      onEntering: V,
      onExit: ie,
      onExited: P10,
      onExiting: G,
      addEndListener: z10,
      timeout: p === "auto" ? null : p
    }, b, {
      children: (B, O) => /* @__PURE__ */ reactExports.cloneElement(o, xe({
        style: xe({
          opacity: 0,
          transform: $c(0.75),
          visibility: B === "exited" && !a ? "hidden" : void 0
        }, k7[B], g, o.props.style),
        ref: L
      }, O))
    }));
  });
  define_process_env_default.NODE_ENV !== "production" && (yf.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
     * Add a custom transition end trigger. Called with the transitioning DOM
     * node and a done callback. Allows for more fine grained transition end
     * logic. Note: Timeouts are still used as a fallback if provided.
     */
    addEndListener: N.func,
    /**
     * Perform the enter transition when it first mounts if `in` is also `true`.
     * Set this to `false` to disable this behavior.
     * @default true
     */
    appear: N.bool,
    /**
     * A single child content element.
     */
    children: Tg.isRequired,
    /**
     * The transition timing function.
     * You may specify a single easing or a object containing enter and exit values.
     */
    easing: N.oneOfType([N.shape({
      enter: N.string,
      exit: N.string
    }), N.string]),
    /**
     * If `true`, the component will transition in.
     */
    in: N.bool,
    /**
     * @ignore
     */
    onEnter: N.func,
    /**
     * @ignore
     */
    onEntered: N.func,
    /**
     * @ignore
     */
    onEntering: N.func,
    /**
     * @ignore
     */
    onExit: N.func,
    /**
     * @ignore
     */
    onExited: N.func,
    /**
     * @ignore
     */
    onExiting: N.func,
    /**
     * @ignore
     */
    style: N.object,
    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     *
     * Set to 'auto' to automatically calculate transition time based on height.
     * @default 'auto'
     */
    timeout: N.oneOfType([N.oneOf(["auto"]), N.number, N.shape({
      appear: N.number,
      enter: N.number,
      exit: N.number
    })])
  });
  yf.muiSupportAuto = true;
  const Qp = yf, C7 = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"], T7 = Yo(d9, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (t10, e) => e.root
  })({}), ym = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    var n;
    const i = fm(), o = mf({
      props: e,
      name: "MuiPopper"
    }), {
      anchorEl: s,
      component: a,
      components: l,
      componentsProps: c,
      container: u,
      disablePortal: f,
      keepMounted: d,
      modifiers: h,
      open: g,
      placement: p,
      popperOptions: y,
      popperRef: b,
      transition: x,
      slots: S,
      slotProps: C
    } = o, _ = dn(o, C7), L = (n = S == null ? void 0 : S.root) != null ? n : l == null ? void 0 : l.Root, F = xe({
      anchorEl: s,
      container: u,
      disablePortal: f,
      keepMounted: d,
      modifiers: h,
      open: g,
      placement: p,
      popperOptions: y,
      popperRef: b,
      transition: x
    }, _);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(T7, xe({
      as: a,
      direction: i == null ? void 0 : i.direction,
      slots: {
        root: L
      },
      slotProps: C ?? c
    }, F, {
      ref: r
    }));
  });
  define_process_env_default.NODE_ENV !== "production" && (ym.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: N.oneOfType([Co, N.object, N.func]),
    /**
     * Popper render function or node.
     */
    children: N.oneOfType([N.node, N.func]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: N.elementType,
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    components: N.shape({
      Root: N.elementType
    }),
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    componentsProps: N.shape({
      root: N.oneOfType([N.func, N.object])
    }),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: N.oneOfType([Co, N.func]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: N.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     * @default false
     */
    keepMounted: N.bool,
    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
     */
    modifiers: N.arrayOf(N.shape({
      data: N.object,
      effect: N.func,
      enabled: N.bool,
      fn: N.func,
      name: N.any,
      options: N.object,
      phase: N.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
      requires: N.arrayOf(N.string),
      requiresIfExists: N.arrayOf(N.string)
    })),
    /**
     * If `true`, the component is shown.
     */
    open: N.bool.isRequired,
    /**
     * Popper placement.
     * @default 'bottom'
     */
    placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
     * @default {}
     */
    popperOptions: N.shape({
      modifiers: N.array,
      onFirstUpdate: N.func,
      placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      strategy: N.oneOf(["absolute", "fixed"])
    }),
    /**
     * A ref that points to the used popper instance.
     */
    popperRef: Og,
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    slotProps: N.shape({
      root: N.oneOfType([N.func, N.object])
    }),
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: N.shape({
      root: N.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
    /**
     * Help supporting a react-transition-group/Transition component.
     * @default false
     */
    transition: N.bool
  });
  const bm = ym;
  function I7(t10) {
    return Uo("MuiTooltip", t10);
  }
  const O7 = Ku("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]), Gr = O7, P7 = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
  function R7(t10) {
    return Math.round(t10 * 1e5) / 1e5;
  }
  const D7 = (t10) => {
    const {
      classes: e,
      disableInteractive: r,
      arrow: n,
      touch: i,
      placement: o
    } = t10, s = {
      popper: ["popper", !r && "popperInteractive", n && "popperArrow"],
      tooltip: ["tooltip", n && "tooltipArrow", i && "touch", `tooltipPlacement${Jt(o.split("-")[0])}`],
      arrow: ["arrow"]
    };
    return Hu(s, I7, e);
  }, M7 = Yo(bm, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (t10, e) => {
      const {
        ownerState: r
      } = t10;
      return [e.popper, !r.disableInteractive && e.popperInteractive, r.arrow && e.popperArrow, !r.open && e.popperClose];
    }
  })(({
    theme: t10,
    ownerState: e,
    open: r
  }) => xe({
    zIndex: (t10.vars || t10).zIndex.tooltip,
    pointerEvents: "none"
  }, !e.disableInteractive && {
    pointerEvents: "auto"
  }, !r && {
    pointerEvents: "none"
  }, e.arrow && {
    [`&[data-popper-placement*="bottom"] .${Gr.arrow}`]: {
      top: 0,
      marginTop: "-0.71em",
      "&::before": {
        transformOrigin: "0 100%"
      }
    },
    [`&[data-popper-placement*="top"] .${Gr.arrow}`]: {
      bottom: 0,
      marginBottom: "-0.71em",
      "&::before": {
        transformOrigin: "100% 0"
      }
    },
    [`&[data-popper-placement*="right"] .${Gr.arrow}`]: xe({}, e.isRtl ? {
      right: 0,
      marginRight: "-0.71em"
    } : {
      left: 0,
      marginLeft: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "100% 100%"
      }
    }),
    [`&[data-popper-placement*="left"] .${Gr.arrow}`]: xe({}, e.isRtl ? {
      left: 0,
      marginLeft: "-0.71em"
    } : {
      right: 0,
      marginRight: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "0 0"
      }
    })
  })), N7 = Yo("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (t10, e) => {
      const {
        ownerState: r
      } = t10;
      return [e.tooltip, r.touch && e.touch, r.arrow && e.tooltipArrow, e[`tooltipPlacement${Jt(r.placement.split("-")[0])}`]];
    }
  })(({
    theme: t10,
    ownerState: e
  }) => xe({
    backgroundColor: t10.vars ? t10.vars.palette.Tooltip.bg : pm(t10.palette.grey[700], 0.92),
    borderRadius: (t10.vars || t10).shape.borderRadius,
    color: (t10.vars || t10).palette.common.white,
    fontFamily: t10.typography.fontFamily,
    padding: "4px 8px",
    fontSize: t10.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: "break-word",
    fontWeight: t10.typography.fontWeightMedium
  }, e.arrow && {
    position: "relative",
    margin: 0
  }, e.touch && {
    padding: "8px 16px",
    fontSize: t10.typography.pxToRem(14),
    lineHeight: `${R7(16 / 14)}em`,
    fontWeight: t10.typography.fontWeightRegular
  }, {
    [`.${Gr.popper}[data-popper-placement*="left"] &`]: xe({
      transformOrigin: "right center"
    }, e.isRtl ? xe({
      marginLeft: "14px"
    }, e.touch && {
      marginLeft: "24px"
    }) : xe({
      marginRight: "14px"
    }, e.touch && {
      marginRight: "24px"
    })),
    [`.${Gr.popper}[data-popper-placement*="right"] &`]: xe({
      transformOrigin: "left center"
    }, e.isRtl ? xe({
      marginRight: "14px"
    }, e.touch && {
      marginRight: "24px"
    }) : xe({
      marginLeft: "14px"
    }, e.touch && {
      marginLeft: "24px"
    })),
    [`.${Gr.popper}[data-popper-placement*="top"] &`]: xe({
      transformOrigin: "center bottom",
      marginBottom: "14px"
    }, e.touch && {
      marginBottom: "24px"
    }),
    [`.${Gr.popper}[data-popper-placement*="bottom"] &`]: xe({
      transformOrigin: "center top",
      marginTop: "14px"
    }, e.touch && {
      marginTop: "24px"
    })
  })), L7 = Yo("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (t10, e) => e.arrow
  })(({
    theme: t10
  }) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: t10.vars ? t10.vars.palette.Tooltip.bg : pm(t10.palette.grey[700], 0.9),
    "&::before": {
      content: '""',
      margin: "auto",
      display: "block",
      width: "100%",
      height: "100%",
      backgroundColor: "currentColor",
      transform: "rotate(45deg)"
    }
  }));
  let bs = false, ic = null, Hi = {
    x: 0,
    y: 0
  };
  function vs(t10, e) {
    return (r) => {
      e && e(r), t10(r);
    };
  }
  const vm = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    var n, i, o, s, a, l, c, u, f, d, h, g, p, y, b, x, S, C, _;
    const L = mf({
      props: e,
      name: "MuiTooltip"
    }), {
      arrow: F = false,
      children: V,
      components: W = {},
      componentsProps: X = {},
      describeChild: G = false,
      disableFocusListener: ie = false,
      disableHoverListener: P10 = false,
      disableInteractive: z10 = false,
      disableTouchListener: B = false,
      enterDelay: O = 100,
      enterNextDelay: q = 0,
      enterTouchDelay: te = 700,
      followCursor: Y = false,
      id: K,
      leaveDelay: $ = 0,
      leaveTouchDelay: se = 1500,
      onClose: he,
      onOpen: de,
      open: pe,
      placement: j = "bottom",
      PopperComponent: H,
      PopperProps: Z = {},
      slotProps: oe = {},
      slots: ue = {},
      title: R,
      TransitionComponent: k = Qp,
      TransitionProps: ee
    } = L, re = dn(L, P7), ye = mm(), I = ye.direction === "rtl", [v, w] = reactExports.useState(), [D, Q] = reactExports.useState(null), ae = reactExports.useRef(false), fe = z10 || Y, Ae = reactExports.useRef(), ve = reactExports.useRef(), be = reactExports.useRef(), Pe = reactExports.useRef(), [E, m] = Rg({
      controlled: pe,
      default: false,
      name: "Tooltip",
      state: "open"
    });
    let A = E;
    if (define_process_env_default.NODE_ENV !== "production") {
      const {
        current: Ce
      } = reactExports.useRef(pe !== void 0);
      reactExports.useEffect(() => {
        v && v.disabled && !Ce && R !== "" && v.tagName.toLowerCase() === "button" && console.error(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
`));
      }, [R, v, Ce]);
    }
    const M = Pg(K), J = reactExports.useRef(), ne = reactExports.useCallback(() => {
      J.current !== void 0 && (document.body.style.WebkitUserSelect = J.current, J.current = void 0), clearTimeout(Pe.current);
    }, []);
    reactExports.useEffect(() => () => {
      clearTimeout(Ae.current), clearTimeout(ve.current), clearTimeout(be.current), ne();
    }, [ne]);
    const le = (Ce) => {
      clearTimeout(ic), bs = true, m(true), de && !A && de(Ce);
    }, _e = Dg(
      /**
       * @param {React.SyntheticEvent | Event} event
       */
      (Ce) => {
        clearTimeout(ic), ic = setTimeout(() => {
          bs = false;
        }, 800 + $), m(false), he && A && he(Ce), clearTimeout(Ae.current), Ae.current = setTimeout(() => {
          ae.current = false;
        }, ye.transitions.duration.shortest);
      }
    ), Xe = (Ce) => {
      ae.current && Ce.type !== "touchstart" || (v && v.removeAttribute("title"), clearTimeout(ve.current), clearTimeout(be.current), O || bs && q ? ve.current = setTimeout(() => {
        le(Ce);
      }, bs ? q : O) : le(Ce));
    }, Ke = (Ce) => {
      clearTimeout(ve.current), clearTimeout(be.current), be.current = setTimeout(() => {
        _e(Ce);
      }, $);
    }, {
      isFocusVisibleRef: Qe,
      onBlur: ze,
      onFocus: Wm,
      ref: Um
    } = Mg(), [, wf] = reactExports.useState(false), xf = (Ce) => {
      ze(Ce), Qe.current === false && (wf(false), Ke(Ce));
    }, _f = (Ce) => {
      v || w(Ce.currentTarget), Wm(Ce), Qe.current === true && (wf(true), Xe(Ce));
    }, Sf = (Ce) => {
      ae.current = true;
      const Mt = V.props;
      Mt.onTouchStart && Mt.onTouchStart(Ce);
    }, Ef = Xe, kf = Ke, zm = (Ce) => {
      Sf(Ce), clearTimeout(be.current), clearTimeout(Ae.current), ne(), J.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", Pe.current = setTimeout(() => {
        document.body.style.WebkitUserSelect = J.current, Xe(Ce);
      }, te);
    }, Vm = (Ce) => {
      V.props.onTouchEnd && V.props.onTouchEnd(Ce), ne(), clearTimeout(be.current), be.current = setTimeout(() => {
        _e(Ce);
      }, se);
    };
    reactExports.useEffect(() => {
      if (!A)
        return;
      function Ce(Mt) {
        (Mt.key === "Escape" || Mt.key === "Esc") && _e(Mt);
      }
      return document.addEventListener("keydown", Ce), () => {
        document.removeEventListener("keydown", Ce);
      };
    }, [_e, A]);
    const qm = jn(V.ref, Um, w, r);
    !R && R !== 0 && (A = false);
    const il = reactExports.useRef(), Hm = (Ce) => {
      const Mt = V.props;
      Mt.onMouseMove && Mt.onMouseMove(Ce), Hi = {
        x: Ce.clientX,
        y: Ce.clientY
      }, il.current && il.current.update();
    }, Ti = {}, ol = typeof R == "string";
    G ? (Ti.title = !A && ol && !P10 ? R : null, Ti["aria-describedby"] = A ? M : null) : (Ti["aria-label"] = ol ? R : null, Ti["aria-labelledby"] = A && !ol ? M : null);
    const zt = xe({}, Ti, re, V.props, {
      className: $i(re.className, V.props.className),
      onTouchStart: Sf,
      ref: qm
    }, Y ? {
      onMouseMove: Hm
    } : {});
    define_process_env_default.NODE_ENV !== "production" && (zt["data-mui-internal-clone-element"] = true, reactExports.useEffect(() => {
      v && !v.getAttribute("data-mui-internal-clone-element") && console.error(["MUI: The `children` component of the Tooltip is not forwarding its props correctly.", "Please make sure that props are spread on the same element that the ref is applied to."].join(`
`));
    }, [v]));
    const Ii = {};
    B || (zt.onTouchStart = zm, zt.onTouchEnd = Vm), P10 || (zt.onMouseOver = vs(Ef, zt.onMouseOver), zt.onMouseLeave = vs(kf, zt.onMouseLeave), fe || (Ii.onMouseOver = Ef, Ii.onMouseLeave = kf)), ie || (zt.onFocus = vs(_f, zt.onFocus), zt.onBlur = vs(xf, zt.onBlur), fe || (Ii.onFocus = _f, Ii.onBlur = xf)), define_process_env_default.NODE_ENV !== "production" && V.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${V.props.title}\` or the Tooltip component.`].join(`
`));
    const Km = reactExports.useMemo(() => {
      var Ce;
      let Mt = [{
        name: "arrow",
        enabled: !!D,
        options: {
          element: D,
          padding: 4
        }
      }];
      return (Ce = Z.popperOptions) != null && Ce.modifiers && (Mt = Mt.concat(Z.popperOptions.modifiers)), xe({}, Z.popperOptions, {
        modifiers: Mt
      });
    }, [D, Z]), Oi = xe({}, L, {
      isRtl: I,
      arrow: F,
      disableInteractive: fe,
      placement: j,
      PopperComponentProp: H,
      touch: ae.current
    }), sl = D7(Oi), Cf = (n = (i = ue.popper) != null ? i : W.Popper) != null ? n : M7, Tf = (o = (s = (a = ue.transition) != null ? a : W.Transition) != null ? s : k) != null ? o : Qp, If = (l = (c = ue.tooltip) != null ? c : W.Tooltip) != null ? l : N7, Of = (u = (f = ue.arrow) != null ? f : W.Arrow) != null ? u : L7, Ym = eo(Cf, xe({}, Z, (d = oe.popper) != null ? d : X.popper, {
      className: $i(sl.popper, Z == null ? void 0 : Z.className, (h = (g = oe.popper) != null ? g : X.popper) == null ? void 0 : h.className)
    }), Oi), Xm = eo(Tf, xe({}, ee, (p = oe.transition) != null ? p : X.transition), Oi), Jm = eo(If, xe({}, (y = oe.tooltip) != null ? y : X.tooltip, {
      className: $i(sl.tooltip, (b = (x = oe.tooltip) != null ? x : X.tooltip) == null ? void 0 : b.className)
    }), Oi), Qm = eo(Of, xe({}, (S = oe.arrow) != null ? S : X.arrow, {
      className: $i(sl.arrow, (C = (_ = oe.arrow) != null ? _ : X.arrow) == null ? void 0 : C.className)
    }), Oi);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ reactExports.cloneElement(V, zt), /* @__PURE__ */ jsxRuntimeExports.jsx(Cf, xe({
        as: H ?? bm,
        placement: j,
        anchorEl: Y ? {
          getBoundingClientRect: () => ({
            top: Hi.y,
            left: Hi.x,
            right: Hi.x,
            bottom: Hi.y,
            width: 0,
            height: 0
          })
        } : v,
        popperRef: il,
        open: v ? A : false,
        id: M,
        transition: true
      }, Ii, Ym, {
        popperOptions: Km,
        children: ({
          TransitionProps: Ce
        }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tf, xe({
          timeout: ye.transitions.duration.shorter
        }, Ce, Xm, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(If, xe({}, Jm, {
            children: [R, F ? /* @__PURE__ */ jsxRuntimeExports.jsx(Of, xe({}, Qm, {
              ref: Q
            })) : null]
          }))
        }))
      }))]
    });
  });
  define_process_env_default.NODE_ENV !== "production" && (vm.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
     * If `true`, adds an arrow to the tooltip.
     * @default false
     */
    arrow: N.bool,
    /**
     * Tooltip reference element.
     */
    children: Tg.isRequired,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: N.object,
    /**
     * @ignore
     */
    className: N.string,
    /**
     * The components used for each slot inside.
     *
     * This prop is an alias for the `slots` prop.
     * It's recommended to use the `slots` prop instead.
     *
     * @default {}
     */
    components: N.shape({
      Arrow: N.elementType,
      Popper: N.elementType,
      Tooltip: N.elementType,
      Transition: N.elementType
    }),
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * This prop is an alias for the `slotProps` prop.
     * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
     *
     * @default {}
     */
    componentsProps: N.shape({
      arrow: N.object,
      popper: N.object,
      tooltip: N.object,
      transition: N.object
    }),
    /**
     * Set to `true` if the `title` acts as an accessible description.
     * By default the `title` acts as an accessible label for the child.
     * @default false
     */
    describeChild: N.bool,
    /**
     * Do not respond to focus-visible events.
     * @default false
     */
    disableFocusListener: N.bool,
    /**
     * Do not respond to hover events.
     * @default false
     */
    disableHoverListener: N.bool,
    /**
     * Makes a tooltip not interactive, i.e. it will close when the user
     * hovers over the tooltip before the `leaveDelay` is expired.
     * @default false
     */
    disableInteractive: N.bool,
    /**
     * Do not respond to long press touch events.
     * @default false
     */
    disableTouchListener: N.bool,
    /**
     * The number of milliseconds to wait before showing the tooltip.
     * This prop won't impact the enter touch delay (`enterTouchDelay`).
     * @default 100
     */
    enterDelay: N.number,
    /**
     * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
     * @default 0
     */
    enterNextDelay: N.number,
    /**
     * The number of milliseconds a user must touch the element before showing the tooltip.
     * @default 700
     */
    enterTouchDelay: N.number,
    /**
     * If `true`, the tooltip follow the cursor over the wrapped element.
     * @default false
     */
    followCursor: N.bool,
    /**
     * This prop is used to help implement the accessibility logic.
     * If you don't provide this prop. It falls back to a randomly generated id.
     */
    id: N.string,
    /**
     * The number of milliseconds to wait before hiding the tooltip.
     * This prop won't impact the leave touch delay (`leaveTouchDelay`).
     * @default 0
     */
    leaveDelay: N.number,
    /**
     * The number of milliseconds after the user stops touching an element before hiding the tooltip.
     * @default 1500
     */
    leaveTouchDelay: N.number,
    /**
     * Callback fired when the component requests to be closed.
     *
     * @param {React.SyntheticEvent} event The event source of the callback.
     */
    onClose: N.func,
    /**
     * Callback fired when the component requests to be open.
     *
     * @param {React.SyntheticEvent} event The event source of the callback.
     */
    onOpen: N.func,
    /**
     * If `true`, the component is shown.
     */
    open: N.bool,
    /**
     * Tooltip placement.
     * @default 'bottom'
     */
    placement: N.oneOf(["bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * The component used for the popper.
     * @default Popper
     */
    PopperComponent: N.elementType,
    /**
     * Props applied to the [`Popper`](/material-ui/api/popper/) element.
     * @default {}
     */
    PopperProps: N.object,
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
     *
     * @default {}
     */
    slotProps: N.shape({
      arrow: N.object,
      popper: N.object,
      tooltip: N.object,
      transition: N.object
    }),
    /**
     * The components used for each slot inside.
     *
     * This prop is an alias for the `components` prop, which will be deprecated in the future.
     *
     * @default {}
     */
    slots: N.shape({
      arrow: N.elementType,
      popper: N.elementType,
      tooltip: N.elementType,
      transition: N.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
    /**
     * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.
     */
    title: N.node,
    /**
     * The component used for the transition.
     * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
     * @default Grow
     */
    TransitionComponent: N.elementType,
    /**
     * Props applied to the transition element.
     * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
     */
    TransitionProps: N.object
  });
  const B7 = vm;
  var eu = {}, F7 = {
    get exports() {
      return eu;
    },
    set exports(t10) {
      eu = t10;
    }
  };
  (function(t10) {
    function e(r) {
      return r && r.__esModule ? r : {
        default: r
      };
    }
    t10.exports = e, t10.exports.__esModule = true, t10.exports.default = t10.exports;
  })(F7);
  var oc = {};
  function j7(t10) {
    return Uo("MuiSvgIcon", t10);
  }
  Ku("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const W7 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], U7 = (t10) => {
    const {
      color: e,
      fontSize: r,
      classes: n
    } = t10, i = {
      root: ["root", e !== "inherit" && `color${Jt(e)}`, `fontSize${Jt(r)}`]
    };
    return Hu(i, j7, n);
  }, z7 = Yo("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (t10, e) => {
      const {
        ownerState: r
      } = t10;
      return [e.root, r.color !== "inherit" && e[`color${Jt(r.color)}`], e[`fontSize${Jt(r.fontSize)}`]];
    }
  })(({
    theme: t10,
    ownerState: e
  }) => {
    var r, n, i, o, s, a, l, c, u, f, d, h, g, p, y, b, x;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0,
      transition: (r = t10.transitions) == null || (n = r.create) == null ? void 0 : n.call(r, "fill", {
        duration: (i = t10.transitions) == null || (o = i.duration) == null ? void 0 : o.shorter
      }),
      fontSize: {
        inherit: "inherit",
        small: ((s = t10.typography) == null || (a = s.pxToRem) == null ? void 0 : a.call(s, 20)) || "1.25rem",
        medium: ((l = t10.typography) == null || (c = l.pxToRem) == null ? void 0 : c.call(l, 24)) || "1.5rem",
        large: ((u = t10.typography) == null || (f = u.pxToRem) == null ? void 0 : f.call(u, 35)) || "2.1875rem"
      }[e.fontSize],
      // TODO v5 deprecate, v6 remove for sx
      color: (d = (h = (t10.vars || t10).palette) == null || (g = h[e.color]) == null ? void 0 : g.main) != null ? d : {
        action: (p = (t10.vars || t10).palette) == null || (y = p.action) == null ? void 0 : y.active,
        disabled: (b = (t10.vars || t10).palette) == null || (x = b.action) == null ? void 0 : x.disabled,
        inherit: void 0
      }[e.color]
    };
  }), bf = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const n = mf({
      props: e,
      name: "MuiSvgIcon"
    }), {
      children: i,
      className: o,
      color: s = "inherit",
      component: a = "svg",
      fontSize: l = "medium",
      htmlColor: c,
      inheritViewBox: u = false,
      titleAccess: f,
      viewBox: d = "0 0 24 24"
    } = n, h = dn(n, W7), g = xe({}, n, {
      color: s,
      component: a,
      fontSize: l,
      instanceFontSize: e.fontSize,
      inheritViewBox: u,
      viewBox: d
    }), p = {};
    u || (p.viewBox = d);
    const y = U7(g);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(z7, xe({
      as: a,
      className: $i(y.root, o),
      focusable: "false",
      color: c,
      "aria-hidden": f ? void 0 : true,
      role: f ? "img" : void 0,
      ref: r
    }, p, h, {
      ownerState: g,
      children: [i, f ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
        children: f
      }) : null]
    }));
  });
  define_process_env_default.NODE_ENV !== "production" && (bf.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
     * Node passed into the SVG element.
     */
    children: N.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: N.object,
    /**
     * @ignore
     */
    className: N.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
     * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
     * @default 'inherit'
     */
    color: N.oneOfType([N.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), N.string]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: N.elementType,
    /**
     * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
     * @default 'medium'
     */
    fontSize: N.oneOfType([N.oneOf(["inherit", "large", "medium", "small"]), N.string]),
    /**
     * Applies a color attribute to the SVG element.
     */
    htmlColor: N.string,
    /**
     * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
     * prop will be ignored.
     * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
     * `component`'s viewBox to the root node.
     * @default false
     */
    inheritViewBox: N.bool,
    /**
     * The shape-rendering attribute. The behavior of the different options is described on the
     * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
     * If you are having issues with blurry icons you should investigate this prop.
     */
    shapeRendering: N.string,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
    /**
     * Provides a human-readable title for the element that contains it.
     * https://www.w3.org/TR/SVG-access/#Equivalent
     */
    titleAccess: N.string,
    /**
     * Allows you to redefine what the coordinates without units mean inside an SVG element.
     * For example, if the SVG element is 500 (width) by 200 (height),
     * and you pass viewBox="0 0 50 20",
     * this means that the coordinates inside the SVG will go from the top left corner (0,0)
     * to bottom right (50,20) and each unit will be worth 10px.
     * @default '0 0 24 24'
     */
    viewBox: N.string
  });
  bf.muiName = "SvgIcon";
  const Gp = bf;
  function V7(t10, e) {
    function r(n, i) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Gp, xe({
        "data-testid": `${e}Icon`,
        ref: i
      }, n, {
        children: t10
      }));
    }
    return define_process_env_default.NODE_ENV !== "production" && (r.displayName = `${e}Icon`), r.muiName = Gp.muiName, /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(r));
  }
  const q7 = {
    configure: (t10) => {
      define_process_env_default.NODE_ENV !== "production" && console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.", "", "You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead", "", "The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401", "", "The updated documentation: https://mui.com/guides/classname-generator/"].join(`
`)), Lg.configure(t10);
    }
  }, H7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    capitalize: Jt,
    createChainedFunction: A4,
    createSvgIcon: V7,
    debounce: w4,
    deprecatedPropType: x4,
    isMuiElement: _4,
    ownerDocument: ha,
    ownerWindow: S4,
    requirePropFactory: E4,
    setRef: pa,
    unstable_ClassNameGenerator: q7,
    unstable_useEnhancedEffect: bi,
    unstable_useId: Pg,
    unsupportedProp: T4,
    useControlled: Rg,
    useEventCallback: Dg,
    useForkRef: jn,
    useIsFocusVisible: Mg
  }, Symbol.toStringTag, { value: "Module" })), K7 = /* @__PURE__ */ f0(H7);
  var Zp;
  function Y7() {
    return Zp || (Zp = 1, function(t10) {
      Object.defineProperty(t10, "__esModule", {
        value: true
      }), Object.defineProperty(t10, "default", {
        enumerable: true,
        get: function() {
          return e.createSvgIcon;
        }
      });
      var e = K7;
    }(oc)), oc;
  }
  const X7 = ({ text: t10, displayText: e }) => {
    const [r, n] = reactExports.useState(false);
    return /* @__PURE__ */ U.createElement(B7, { title: r ? "Copied link!" : "Copy link to clipboard" }, /* @__PURE__ */ U.createElement(
      "button",
      {
        id: "btn-invite",
        className: "button-black btn-invite",
        onClick: () => {
          const i = { url: t10, title: "Join my room" };
          navigator.share ? navigator.share(i).then(
            () => console.log("Hooray! Your content was shared to tha world")
          ).catch((o) => {
            console.log(
              `Oops! I couldn't share to the world because: ${o}`
            ), prompt("Copy the link below", t10);
          }) : (n(true), navigator.clipboard.writeText(t10).catch((o) => {
            console.log(
              `Oops! I couldn't share to the world because: ${o}`
            ), prompt("Copy the link below", t10);
          }), setTimeout(() => n(false), 1e3));
        }
      },
      r ? "Copied!" : "Share link"
    ));
  };
  var vf = {}, J7 = eu;
  Object.defineProperty(vf, "__esModule", {
    value: true
  });
  var Am = vf.default = void 0, Q7 = J7(Y7()), G7 = ny, Z7 = (0, Q7.default)(/* @__PURE__ */ (0, G7.jsx)("path", {
    d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"
  }), "Refresh");
  Am = vf.default = Z7;
  const wm = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzEiIGhlaWdodD0iMjYiIHZpZXdCb3g9IjAgMCAzMSAyNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wLjQ4OTEzNiA1LjI1MzE3QzAuNDg5MTM2IDIuNDkxNzUgMi43Mjc3MSAwLjI1MzE3NCA1LjQ4OTE0IDAuMjUzMTc0SDI1LjQ4OTFDMjguMjUwNiAwLjI1MzE3NCAzMC40ODkxIDIuNDkxNzUgMzAuNDg5MSA1LjI1MzE3VjE3LjI1MzJDMzAuNDg5MSAyMC4wMTQ2IDI4LjI1MDYgMjIuMjUzMiAyNS40ODkxIDIyLjI1MzJIMjIuNzM5MVYyMC4yNTMySDI1LjQ4OTFDMjcuMTQ2IDIwLjI1MzIgMjguNDg5MSAxOC45MSAyOC40ODkxIDE3LjI1MzJWNS4yNTMxN0MyOC40ODkxIDMuNTk2MzIgMjcuMTQ2IDIuMjUzMTcgMjUuNDg5MSAyLjI1MzE3SDUuNDg5MTRDMy44MzIyOCAyLjI1MzE3IDIuNDg5MTQgMy41OTYzMiAyLjQ4OTE0IDUuMjUzMTdWMTcuMjUzMkMyLjQ4OTE0IDE4LjkxIDMuODMyMjggMjAuMjUzMiA1LjQ4OTE0IDIwLjI1MzJINy40ODkxNFYyMi4yNTMySDUuNDg5MTRDMi43Mjc3MSAyMi4yNTMyIDAuNDg5MTM2IDIwLjAxNDYgMC40ODkxMzYgMTcuMjUzMlY1LjI1MzE3WiIgZmlsbD0iYmxhY2siLz4KPHBhdGggZD0iTTE0Ljk4OTEgMTUuMjUzMkwyMi4zNTA0IDI1Ljc1MzJINy42Mjc5MkwxNC45ODkxIDE1LjI1MzJaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K";
  var xm = {}, _m = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  }, $7 = _m;
  function Sm(t10) {
    this.mode = $7.MODE_8BIT_BYTE, this.data = t10;
  }
  Sm.prototype = {
    getLength: function(t10) {
      return this.data.length;
    },
    write: function(t10) {
      for (var e = 0; e < this.data.length; e++)
        t10.put(this.data.charCodeAt(e), 8);
    }
  };
  var eS = Sm, Em = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  }, As = Em;
  function mr(t10, e) {
    this.totalCount = t10, this.dataCount = e;
  }
  mr.RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4		
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7		
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10		
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ];
  mr.getRSBlocks = function(t10, e) {
    var r = mr.getRsBlockTable(t10, e);
    if (r == null)
      throw new Error("bad rs block @ typeNumber:" + t10 + "/errorCorrectLevel:" + e);
    for (var n = r.length / 3, i = new Array(), o = 0; o < n; o++)
      for (var s = r[o * 3 + 0], a = r[o * 3 + 1], l = r[o * 3 + 2], c = 0; c < s; c++)
        i.push(new mr(a, l));
    return i;
  };
  mr.getRsBlockTable = function(t10, e) {
    switch (e) {
      case As.L:
        return mr.RS_BLOCK_TABLE[(t10 - 1) * 4 + 0];
      case As.M:
        return mr.RS_BLOCK_TABLE[(t10 - 1) * 4 + 1];
      case As.Q:
        return mr.RS_BLOCK_TABLE[(t10 - 1) * 4 + 2];
      case As.H:
        return mr.RS_BLOCK_TABLE[(t10 - 1) * 4 + 3];
      default:
        return;
    }
  };
  var tS = mr;
  function km() {
    this.buffer = new Array(), this.length = 0;
  }
  km.prototype = {
    get: function(t10) {
      var e = Math.floor(t10 / 8);
      return (this.buffer[e] >>> 7 - t10 % 8 & 1) == 1;
    },
    put: function(t10, e) {
      for (var r = 0; r < e; r++)
        this.putBit((t10 >>> e - r - 1 & 1) == 1);
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(t10) {
      var e = Math.floor(this.length / 8);
      this.buffer.length <= e && this.buffer.push(0), t10 && (this.buffer[e] |= 128 >>> this.length % 8), this.length++;
    }
  };
  var rS = km, or = {
    glog: function(t10) {
      if (t10 < 1)
        throw new Error("glog(" + t10 + ")");
      return or.LOG_TABLE[t10];
    },
    gexp: function(t10) {
      for (; t10 < 0; )
        t10 += 255;
      for (; t10 >= 256; )
        t10 -= 255;
      return or.EXP_TABLE[t10];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
  };
  for (var yt = 0; yt < 8; yt++)
    or.EXP_TABLE[yt] = 1 << yt;
  for (var yt = 8; yt < 256; yt++)
    or.EXP_TABLE[yt] = or.EXP_TABLE[yt - 4] ^ or.EXP_TABLE[yt - 5] ^ or.EXP_TABLE[yt - 6] ^ or.EXP_TABLE[yt - 8];
  for (var yt = 0; yt < 255; yt++)
    or.LOG_TABLE[or.EXP_TABLE[yt]] = yt;
  var Cm = or, wn = Cm;
  function zs(t10, e) {
    if (t10.length == null)
      throw new Error(t10.length + "/" + e);
    for (var r = 0; r < t10.length && t10[r] == 0; )
      r++;
    this.num = new Array(t10.length - r + e);
    for (var n = 0; n < t10.length - r; n++)
      this.num[n] = t10[n + r];
  }
  zs.prototype = {
    get: function(t10) {
      return this.num[t10];
    },
    getLength: function() {
      return this.num.length;
    },
    multiply: function(t10) {
      for (var e = new Array(this.getLength() + t10.getLength() - 1), r = 0; r < this.getLength(); r++)
        for (var n = 0; n < t10.getLength(); n++)
          e[r + n] ^= wn.gexp(wn.glog(this.get(r)) + wn.glog(t10.get(n)));
      return new zs(e, 0);
    },
    mod: function(t10) {
      if (this.getLength() - t10.getLength() < 0)
        return this;
      for (var e = wn.glog(this.get(0)) - wn.glog(t10.get(0)), r = new Array(this.getLength()), n = 0; n < this.getLength(); n++)
        r[n] = this.get(n);
      for (var n = 0; n < t10.getLength(); n++)
        r[n] ^= wn.gexp(wn.glog(t10.get(n)) + e);
      return new zs(r, 0).mod(t10);
    }
  };
  var Tm = zs, qt = _m, $p = Tm, nS = Cm, qr = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  }, pt = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function(t10) {
      for (var e = t10 << 10; pt.getBCHDigit(e) - pt.getBCHDigit(pt.G15) >= 0; )
        e ^= pt.G15 << pt.getBCHDigit(e) - pt.getBCHDigit(pt.G15);
      return (t10 << 10 | e) ^ pt.G15_MASK;
    },
    getBCHTypeNumber: function(t10) {
      for (var e = t10 << 12; pt.getBCHDigit(e) - pt.getBCHDigit(pt.G18) >= 0; )
        e ^= pt.G18 << pt.getBCHDigit(e) - pt.getBCHDigit(pt.G18);
      return t10 << 12 | e;
    },
    getBCHDigit: function(t10) {
      for (var e = 0; t10 != 0; )
        e++, t10 >>>= 1;
      return e;
    },
    getPatternPosition: function(t10) {
      return pt.PATTERN_POSITION_TABLE[t10 - 1];
    },
    getMask: function(t10, e, r) {
      switch (t10) {
        case qr.PATTERN000:
          return (e + r) % 2 == 0;
        case qr.PATTERN001:
          return e % 2 == 0;
        case qr.PATTERN010:
          return r % 3 == 0;
        case qr.PATTERN011:
          return (e + r) % 3 == 0;
        case qr.PATTERN100:
          return (Math.floor(e / 2) + Math.floor(r / 3)) % 2 == 0;
        case qr.PATTERN101:
          return e * r % 2 + e * r % 3 == 0;
        case qr.PATTERN110:
          return (e * r % 2 + e * r % 3) % 2 == 0;
        case qr.PATTERN111:
          return (e * r % 3 + (e + r) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + t10);
      }
    },
    getErrorCorrectPolynomial: function(t10) {
      for (var e = new $p([1], 0), r = 0; r < t10; r++)
        e = e.multiply(new $p([1, nS.gexp(r)], 0));
      return e;
    },
    getLengthInBits: function(t10, e) {
      if (1 <= e && e < 10)
        switch (t10) {
          case qt.MODE_NUMBER:
            return 10;
          case qt.MODE_ALPHA_NUM:
            return 9;
          case qt.MODE_8BIT_BYTE:
            return 8;
          case qt.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + t10);
        }
      else if (e < 27)
        switch (t10) {
          case qt.MODE_NUMBER:
            return 12;
          case qt.MODE_ALPHA_NUM:
            return 11;
          case qt.MODE_8BIT_BYTE:
            return 16;
          case qt.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + t10);
        }
      else if (e < 41)
        switch (t10) {
          case qt.MODE_NUMBER:
            return 14;
          case qt.MODE_ALPHA_NUM:
            return 13;
          case qt.MODE_8BIT_BYTE:
            return 16;
          case qt.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + t10);
        }
      else
        throw new Error("type:" + e);
    },
    getLostPoint: function(t10) {
      for (var e = t10.getModuleCount(), r = 0, n = 0; n < e; n++)
        for (var i = 0; i < e; i++) {
          for (var o = 0, s = t10.isDark(n, i), a = -1; a <= 1; a++)
            if (!(n + a < 0 || e <= n + a))
              for (var l = -1; l <= 1; l++)
                i + l < 0 || e <= i + l || a == 0 && l == 0 || s == t10.isDark(n + a, i + l) && o++;
          o > 5 && (r += 3 + o - 5);
        }
      for (var n = 0; n < e - 1; n++)
        for (var i = 0; i < e - 1; i++) {
          var c = 0;
          t10.isDark(n, i) && c++, t10.isDark(n + 1, i) && c++, t10.isDark(n, i + 1) && c++, t10.isDark(n + 1, i + 1) && c++, (c == 0 || c == 4) && (r += 3);
        }
      for (var n = 0; n < e; n++)
        for (var i = 0; i < e - 6; i++)
          t10.isDark(n, i) && !t10.isDark(n, i + 1) && t10.isDark(n, i + 2) && t10.isDark(n, i + 3) && t10.isDark(n, i + 4) && !t10.isDark(n, i + 5) && t10.isDark(n, i + 6) && (r += 40);
      for (var i = 0; i < e; i++)
        for (var n = 0; n < e - 6; n++)
          t10.isDark(n, i) && !t10.isDark(n + 1, i) && t10.isDark(n + 2, i) && t10.isDark(n + 3, i) && t10.isDark(n + 4, i) && !t10.isDark(n + 5, i) && t10.isDark(n + 6, i) && (r += 40);
      for (var u = 0, i = 0; i < e; i++)
        for (var n = 0; n < e; n++)
          t10.isDark(n, i) && u++;
      var f = Math.abs(100 * u / e / e - 50) / 5;
      return r += f * 10, r;
    }
  }, iS = pt, oS = eS, Im = tS, Om = rS, gn = iS, sS = Tm;
  function br(t10, e) {
    this.typeNumber = t10, this.errorCorrectLevel = e, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
  }
  var Ut = br.prototype;
  Ut.addData = function(t10) {
    var e = new oS(t10);
    this.dataList.push(e), this.dataCache = null;
  };
  Ut.isDark = function(t10, e) {
    if (t10 < 0 || this.moduleCount <= t10 || e < 0 || this.moduleCount <= e)
      throw new Error(t10 + "," + e);
    return this.modules[t10][e];
  };
  Ut.getModuleCount = function() {
    return this.moduleCount;
  };
  Ut.make = function() {
    if (this.typeNumber < 1) {
      var t10 = 1;
      for (t10 = 1; t10 < 40; t10++) {
        for (var e = Im.getRSBlocks(t10, this.errorCorrectLevel), r = new Om(), n = 0, i = 0; i < e.length; i++)
          n += e[i].dataCount;
        for (var i = 0; i < this.dataList.length; i++) {
          var o = this.dataList[i];
          r.put(o.mode, 4), r.put(o.getLength(), gn.getLengthInBits(o.mode, t10)), o.write(r);
        }
        if (r.getLengthInBits() <= n * 8)
          break;
      }
      this.typeNumber = t10;
    }
    this.makeImpl(false, this.getBestMaskPattern());
  };
  Ut.makeImpl = function(t10, e) {
    this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
    for (var r = 0; r < this.moduleCount; r++) {
      this.modules[r] = new Array(this.moduleCount);
      for (var n = 0; n < this.moduleCount; n++)
        this.modules[r][n] = null;
    }
    this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(t10, e), this.typeNumber >= 7 && this.setupTypeNumber(t10), this.dataCache == null && (this.dataCache = br.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, e);
  };
  Ut.setupPositionProbePattern = function(t10, e) {
    for (var r = -1; r <= 7; r++)
      if (!(t10 + r <= -1 || this.moduleCount <= t10 + r))
        for (var n = -1; n <= 7; n++)
          e + n <= -1 || this.moduleCount <= e + n || (0 <= r && r <= 6 && (n == 0 || n == 6) || 0 <= n && n <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= n && n <= 4 ? this.modules[t10 + r][e + n] = true : this.modules[t10 + r][e + n] = false);
  };
  Ut.getBestMaskPattern = function() {
    for (var t10 = 0, e = 0, r = 0; r < 8; r++) {
      this.makeImpl(true, r);
      var n = gn.getLostPoint(this);
      (r == 0 || t10 > n) && (t10 = n, e = r);
    }
    return e;
  };
  Ut.createMovieClip = function(t10, e, r) {
    var n = t10.createEmptyMovieClip(e, r), i = 1;
    this.make();
    for (var o = 0; o < this.modules.length; o++)
      for (var s = o * i, a = 0; a < this.modules[o].length; a++) {
        var l = a * i, c = this.modules[o][a];
        c && (n.beginFill(0, 100), n.moveTo(l, s), n.lineTo(l + i, s), n.lineTo(l + i, s + i), n.lineTo(l, s + i), n.endFill());
      }
    return n;
  };
  Ut.setupTimingPattern = function() {
    for (var t10 = 8; t10 < this.moduleCount - 8; t10++)
      this.modules[t10][6] == null && (this.modules[t10][6] = t10 % 2 == 0);
    for (var e = 8; e < this.moduleCount - 8; e++)
      this.modules[6][e] == null && (this.modules[6][e] = e % 2 == 0);
  };
  Ut.setupPositionAdjustPattern = function() {
    for (var t10 = gn.getPatternPosition(this.typeNumber), e = 0; e < t10.length; e++)
      for (var r = 0; r < t10.length; r++) {
        var n = t10[e], i = t10[r];
        if (this.modules[n][i] == null)
          for (var o = -2; o <= 2; o++)
            for (var s = -2; s <= 2; s++)
              o == -2 || o == 2 || s == -2 || s == 2 || o == 0 && s == 0 ? this.modules[n + o][i + s] = true : this.modules[n + o][i + s] = false;
      }
  };
  Ut.setupTypeNumber = function(t10) {
    for (var e = gn.getBCHTypeNumber(this.typeNumber), r = 0; r < 18; r++) {
      var n = !t10 && (e >> r & 1) == 1;
      this.modules[Math.floor(r / 3)][r % 3 + this.moduleCount - 8 - 3] = n;
    }
    for (var r = 0; r < 18; r++) {
      var n = !t10 && (e >> r & 1) == 1;
      this.modules[r % 3 + this.moduleCount - 8 - 3][Math.floor(r / 3)] = n;
    }
  };
  Ut.setupTypeInfo = function(t10, e) {
    for (var r = this.errorCorrectLevel << 3 | e, n = gn.getBCHTypeInfo(r), i = 0; i < 15; i++) {
      var o = !t10 && (n >> i & 1) == 1;
      i < 6 ? this.modules[i][8] = o : i < 8 ? this.modules[i + 1][8] = o : this.modules[this.moduleCount - 15 + i][8] = o;
    }
    for (var i = 0; i < 15; i++) {
      var o = !t10 && (n >> i & 1) == 1;
      i < 8 ? this.modules[8][this.moduleCount - i - 1] = o : i < 9 ? this.modules[8][15 - i - 1 + 1] = o : this.modules[8][15 - i - 1] = o;
    }
    this.modules[this.moduleCount - 8][8] = !t10;
  };
  Ut.mapData = function(t10, e) {
    for (var r = -1, n = this.moduleCount - 1, i = 7, o = 0, s = this.moduleCount - 1; s > 0; s -= 2)
      for (s == 6 && s--; ; ) {
        for (var a = 0; a < 2; a++)
          if (this.modules[n][s - a] == null) {
            var l = false;
            o < t10.length && (l = (t10[o] >>> i & 1) == 1);
            var c = gn.getMask(e, n, s - a);
            c && (l = !l), this.modules[n][s - a] = l, i--, i == -1 && (o++, i = 7);
          }
        if (n += r, n < 0 || this.moduleCount <= n) {
          n -= r, r = -r;
          break;
        }
      }
  };
  br.PAD0 = 236;
  br.PAD1 = 17;
  br.createData = function(t10, e, r) {
    for (var n = Im.getRSBlocks(t10, e), i = new Om(), o = 0; o < r.length; o++) {
      var s = r[o];
      i.put(s.mode, 4), i.put(s.getLength(), gn.getLengthInBits(s.mode, t10)), s.write(i);
    }
    for (var a = 0, o = 0; o < n.length; o++)
      a += n[o].dataCount;
    if (i.getLengthInBits() > a * 8)
      throw new Error("code length overflow. (" + i.getLengthInBits() + ">" + a * 8 + ")");
    for (i.getLengthInBits() + 4 <= a * 8 && i.put(0, 4); i.getLengthInBits() % 8 != 0; )
      i.putBit(false);
    for (; !(i.getLengthInBits() >= a * 8 || (i.put(br.PAD0, 8), i.getLengthInBits() >= a * 8)); )
      i.put(br.PAD1, 8);
    return br.createBytes(i, n);
  };
  br.createBytes = function(t10, e) {
    for (var r = 0, n = 0, i = 0, o = new Array(e.length), s = new Array(e.length), a = 0; a < e.length; a++) {
      var l = e[a].dataCount, c = e[a].totalCount - l;
      n = Math.max(n, l), i = Math.max(i, c), o[a] = new Array(l);
      for (var u = 0; u < o[a].length; u++)
        o[a][u] = 255 & t10.buffer[u + r];
      r += l;
      var f = gn.getErrorCorrectPolynomial(c), d = new sS(o[a], f.getLength() - 1), h = d.mod(f);
      s[a] = new Array(f.getLength() - 1);
      for (var u = 0; u < s[a].length; u++) {
        var g = u + h.getLength() - s[a].length;
        s[a][u] = g >= 0 ? h.get(g) : 0;
      }
    }
    for (var p = 0, u = 0; u < e.length; u++)
      p += e[u].totalCount;
    for (var y = new Array(p), b = 0, u = 0; u < n; u++)
      for (var a = 0; a < e.length; a++)
        u < o[a].length && (y[b++] = o[a][u]);
    for (var u = 0; u < i; u++)
      for (var a = 0; a < e.length; a++)
        u < s[a].length && (y[b++] = s[a][u]);
    return y;
  };
  var aS = br, Af = {};
  Object.defineProperty(Af, "__esModule", {
    value: true
  });
  var lS = Object.assign || function(t10) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
    }
    return t10;
  }, cS = N, Ht = Rm(cS), Pm = U, ws = Rm(Pm);
  function Rm(t10) {
    return t10 && t10.__esModule ? t10 : { default: t10 };
  }
  function uS(t10, e) {
    var r = {};
    for (var n in t10)
      e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t10, n) && (r[n] = t10[n]);
    return r;
  }
  var fS = {
    bgColor: Ht.default.oneOfType([Ht.default.object, Ht.default.string]).isRequired,
    bgD: Ht.default.string.isRequired,
    fgColor: Ht.default.oneOfType([Ht.default.object, Ht.default.string]).isRequired,
    fgD: Ht.default.string.isRequired,
    size: Ht.default.number.isRequired,
    title: Ht.default.string,
    viewBoxSize: Ht.default.number.isRequired,
    xmlns: Ht.default.string
  }, dS = {
    title: void 0,
    xmlns: "http://www.w3.org/2000/svg"
  }, rl = (0, Pm.forwardRef)(function(t10, e) {
    var r = t10.bgColor, n = t10.bgD, i = t10.fgD, o = t10.fgColor, s = t10.size, a = t10.title, l = t10.viewBoxSize, c = uS(t10, ["bgColor", "bgD", "fgD", "fgColor", "size", "title", "viewBoxSize"]);
    return ws.default.createElement(
      "svg",
      lS({}, c, { height: s, ref: e, viewBox: "0 0 " + l + " " + l, width: s }),
      a ? ws.default.createElement(
        "title",
        null,
        a
      ) : null,
      ws.default.createElement("path", { d: n, fill: r }),
      ws.default.createElement("path", { d: i, fill: o })
    );
  });
  rl.displayName = "QRCodeSvg";
  rl.propTypes = fS;
  rl.defaultProps = dS;
  Af.default = rl;
  Object.defineProperty(xm, "__esModule", {
    value: true
  });
  var hS = Object.assign || function(t10) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
    }
    return t10;
  }, pS = aS, gS = Xo(pS), mS = Em, yS = Xo(mS), bS = N, Sr = Xo(bS), Dm = U, vS = Xo(Dm), AS = Af, wS = Xo(AS);
  function Xo(t10) {
    return t10 && t10.__esModule ? t10 : { default: t10 };
  }
  function xS(t10, e) {
    var r = {};
    for (var n in t10)
      e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t10, n) && (r[n] = t10[n]);
    return r;
  }
  var _S = {
    bgColor: Sr.default.oneOfType([Sr.default.object, Sr.default.string]),
    fgColor: Sr.default.oneOfType([Sr.default.object, Sr.default.string]),
    level: Sr.default.string,
    size: Sr.default.number,
    value: Sr.default.string.isRequired
  }, SS = {
    bgColor: "#FFFFFF",
    fgColor: "#000000",
    level: "L",
    size: 256
  }, nl = (0, Dm.forwardRef)(function(t10, e) {
    var r = t10.bgColor, n = t10.fgColor, i = t10.level, o = t10.size, s = t10.value, a = xS(t10, ["bgColor", "fgColor", "level", "size", "value"]), l = new gS.default(-1, yS.default[i]);
    l.addData(s), l.make();
    var c = l.modules;
    return vS.default.createElement(wS.default, hS({}, a, {
      bgColor: r,
      bgD: c.map(function(u, f) {
        return u.map(function(d, h) {
          return d ? "" : "M " + h + " " + f + " l 1 0 0 1 -1 0 Z";
        }).join(" ");
      }).join(" "),
      fgColor: n,
      fgD: c.map(function(u, f) {
        return u.map(function(d, h) {
          return d ? "M " + h + " " + f + " l 1 0 0 1 -1 0 Z" : "";
        }).join(" ");
      }).join(" "),
      ref: e,
      size: o,
      viewBoxSize: c.length
    }));
  });
  nl.displayName = "QRCode";
  nl.propTypes = _S;
  nl.defaultProps = SS;
  var Mm = xm.default = nl;
  function ES({
    zIndex: t10,
    demoMode: e,
    noAbsolute: r,
    noText: n,
    size: i = 256,
    containerStyles: o = {},
    baseUrl: s = "https://joinplayroom.com/"
  }) {
    const l = we().currentRoom, c = _3(s, l);
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        className: "room-code-sticker",
        style: {
          zIndex: t10 || "initial",
          position: r ? "initial" : "absolute",
          ...o
        }
      },
      /* @__PURE__ */ U.createElement("div", { className: "qr-code" }, /* @__PURE__ */ U.createElement(
        Mm,
        {
          id: "QRCodeScaled",
          size: i,
          style: { height: "auto", maxWidth: "100%", width: "100%" },
          value: c,
          viewBox: `0 0 ${i} ${i}`
        }
      )),
      !n && l && /* @__PURE__ */ U.createElement("div", { className: "room-code" }, /* @__PURE__ */ U.createElement("b", null, l), /* @__PURE__ */ U.createElement("span", null, "Scan QR code to join the room")),
      !n && !l && /* @__PURE__ */ U.createElement("div", { className: "room-code" }, /* @__PURE__ */ U.createElement("b", null, "Scan to start"), /* @__PURE__ */ U.createElement("span", null, "Download the game from the Appstore"))
    );
  }
  const kS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEwLjI3NDcgMC4wODEzNzY3QzcuNzI1NTcgMC4wODEzNzY3IDUuMjgwOTggMS4wOTM5NiAzLjQ3ODU3IDIuODk2MzdDMS42NzYxNSA0LjY5OSAwLjY2MzU3NCA3LjE0MzY0IDAuNjYzNTc0IDkuNjkyNUMwLjY2MzU3NCAxMi4yNDE0IDEuNjc2MTUgMTQuNjg2MiAzLjQ3ODU3IDE2LjQ4ODZDNS4yODEyIDE4LjI5MSA3LjcyNTg0IDE5LjMwMzYgMTAuMjc0NyAxOS4zMDM2QzEyLjgyMzUgMTkuMzAzNiAxNS4yNjg0IDE4LjI5MSAxNy4wNzA4IDE2LjQ4ODZDMTguODczMiAxNC42ODYgMTkuODg1OCAxMi4yNDE0IDE5Ljg4NTggOS42OTI1QzE5Ljg4NTggOC4wMDUyOSAxOS40NDE2IDYuMzQ3ODUgMTguNTk4MSA0Ljg4NjY3QzE3Ljc1NDYgMy40MjU1NCAxNi41NDEzIDIuMjEyMjUgMTUuMDgwMiAxLjM2ODczQzEzLjYxOTEgMC41MjUyMDkgMTEuOTYxNiAwLjA4MTA1NDcgMTAuMjc0NCAwLjA4MTA1NDdMMTAuMjc0NyAwLjA4MTM3NjdaTTEwLjI3NDcgMi40ODQyOUMxMC43NzkyIDIuNDg0MjkgMTEuODc4NSA0LjIwODQgMTIuMjUxIDcuNDQwMDhDMTAuOTQxMiA3LjI0MDQxIDkuNjA4MjggNy4yNDA0MSA4LjI5ODQgNy40NDAwOEM4LjY3MDkxIDQuMjA4MTMgOS43NzAyIDIuNDg0MjkgMTAuMjc0NyAyLjQ4NDI5SDEwLjI3NDdaTTMuNDgwNzEgMTIuMDk1N0M0LjE4NzIgMTEuNTIyNyA0Ljk2MzI1IDExLjA0MTMgNS43OTAzNiAxMC42NjMxQzUuODQ1NjYgMTIuNDgzOSA2LjE4NjEzIDE0LjI4NDkgNi43OTk1NiAxNi4wMDA0QzUuMjU0NTkgMTUuMTQ2NSA0LjA3NDYyIDEzLjc1OCAzLjQ4MDY2IDEyLjA5NTdIMy40ODA3MVpNNS44Mjk1NiA4LjA2MTk4QzQuODU4MDcgOC40MDc0NyAzLjkzMDU1IDguODY2MDggMy4wNjYyNyA5LjQyODQ1QzMuMTYyODYgNi44OTgxNSA0LjU4MDI0IDQuNjA0MjMgNi43OTk1NiAzLjM4NTM2QzYuMjU1MDUgNC44OTAxIDUuOTI4MiA2LjQ2NDc4IDUuODI5NTEgOC4wNjIwOUw1LjgyOTU2IDguMDYxOThaTTEwLjI3NDggMTYuOTAxMUM5LjY3NDE0IDE2LjkwMTEgOC4yMjAzIDE0LjQ0NyA4LjE3MjM1IDkuODk5NTNDOS41NjAzOCA5LjYyMzgxIDEwLjk4OTMgOS42MjM4MSAxMi4zNzcyIDkuODk5NTNDMTIuMzI5MyAxNC40NDcgMTAuODc1NSAxNi45MDExIDEwLjI3NDggMTYuOTAxMVpNMTMuNzUgMTZWMTYuMDAwMkMxNC4zNjM2IDE0LjI4MzYgMTQuNzA0MSAxMi40ODE2IDE0Ljc1OTIgMTAuNjU5N0MxNS41ODY2IDExLjAzOTEgMTYuMzYyNiAxMS41MjE0IDE3LjA2ODggMTIuMDk1NUMxNi40NzQ5IDEzLjc1NzggMTUuMjk0OSAxNS4xNDYyIDEzLjc0OTkgMTYuMDAwMkwxMy43NSAxNlpNMTQuNzIgOC4wNjE5M0MxNC42MjE0IDYuNDY0NjIgMTQuMjk0NSA0Ljg4OTg5IDEzLjc1IDMuMzg1MkMxNS45Njk0IDQuNjA0MTcgMTcuMzg2NyA2Ljg5ODEgMTcuNDgzMyA5LjQyODI5QzE2LjYxOSA4Ljg2NTk4IDE1LjY5MTUgOC40MDczNCAxNC43MiA4LjA2MTgyTDE0LjcyIDguMDYxOTNaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K", CS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTkiIHZpZXdCb3g9IjAgMCAyMCAxOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iNS43ODI0NyIgY3k9IjQuMjk2NjMiIHI9IjIuNDY5NTgiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMi4yIi8+CjxjaXJjbGUgY3g9IjE0LjM4NDYiIGN5PSI0LjI5NjYzIiByPSIyLjQ2OTU4IiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIuMiIvPgo8cmVjdCB4PSIxLjYiIHk9IjkuNzE4NDEiIHdpZHRoPSI4LjM2NDk5IiBoZWlnaHQ9IjcuNDIxNTgiIHJ4PSIxLjkiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMi4yIi8+CjxyZWN0IHg9IjEwLjIwMjEiIHk9IjkuNzE4NDEiIHdpZHRoPSI4LjM2NDk5IiBoZWlnaHQ9IjcuNDIxNTgiIHJ4PSIxLjkiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMi4yIi8+Cjwvc3ZnPgo=";
  const TS = [
    // 10.0.0.0 - 10.255.255.255
    /^(:{2}f{4}:)?10(?:\.\d{1,3}){3}$/,
    // 127.0.0.0 - 127.255.255.255
    /^(:{2}f{4}:)?127(?:\.\d{1,3}){3}$/,
    // 169.254.1.0 - 169.254.254.255
    /^(::f{4}:)?169\.254\.([1-9]|1?\d\d|2[0-4]\d|25[0-4])\.\d{1,3}$/,
    // 172.16.0.0 - 172.31.255.255
    /^(:{2}f{4}:)?(172\.1[6-9]|172\.2\d|172\.3[01])(?:\.\d{1,3}){2}$/,
    // 192.168.0.0 - 192.168.255.255
    /^(:{2}f{4}:)?192\.168(?:\.\d{1,3}){2}$/,
    // fc00::/7
    /^f[cd][\da-f]{2}(::1$|:[\da-f]{1,4}){1,7}$/,
    // fe80::/10
    /^fe[89ab][\da-f](::1$|:[\da-f]{1,4}){1,7}$/
  ], IS = new RegExp(
    `^(${TS.map((t10) => t10.source).join("|")})$`
  );
  function OS(t10) {
    const e = (
      // eslint-disable-next-line regexp/no-dupe-disjunctions
      new RegExp("(?![\\w-]{64})((^(?=[-\\w.]{1,253}\\.?$)((\\w{1,63}|(\\w[-\\w]{0,61}\\w))\\.?)+$)(?<!\\.{2}))")
    );
    return typeof t10 != "string" ? false : IS.test(t10) || t10 === "localhost" ? true : (e.test(t10), false);
  }
  function Nm() {
    const t10 = location.hostname;
    try {
      if (OS(t10))
        return "LOCAL";
    } catch {
    }
    return Zs(location.hostname + location.pathname).slice(0, 9);
  }
  function e0(t10, e) {
    return Math.floor(Math.random() * (e - t10 + 1)) + t10;
  }
  function PS(t10) {
    let e = "";
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = r.length;
    for (let i = 0; i < t10; ++i)
      e += r.charAt(Math.floor(Math.random() * n));
    return e;
  }
  const $n = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ], xs = [
    "Eclipse",
    "Crankshaft",
    "Firetruck",
    "President",
    "Bat",
    "Avocado",
    "Holiday",
    "Salad",
    "Boom",
    "Cornflakes"
  ];
  function t0(t10) {
    return t10 && t10.length > 0 ? t10[Math.floor(Math.random() * t10.length)] : Pa(Oa(PS(10)));
  }
  function RS({ hide: t10, playerState: e }) {
    var r;
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        "data-testid": "full-room-popup",
        id: "full-room-popup",
        className: "full-room-container"
      },
      /* @__PURE__ */ U.createElement(
        ki,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            maxWidth: "500px",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ U.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "100%",
              maxWidth: "360px",
              aspectRatio: "1/1",
              padding: "2.5rem 2rem 2.5rem 2rem"
            }
          },
          /* @__PURE__ */ U.createElement("span", { style: { fontSize: "40px" } }, ""),
          /* @__PURE__ */ U.createElement("div", null, /* @__PURE__ */ U.createElement("h1", { style: { marginBottom: "1rem", marginTop: "0rem" } }, "Kick Player"), /* @__PURE__ */ U.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                marginBottom: "2rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Remove ",
            ((r = e.getState("profile")) == null ? void 0 : r.name) || "this player",
            " ",
            "from the party?"
          )),
          /* @__PURE__ */ U.createElement(
            "button",
            {
              id: "btn-invite",
              className: "close-btn",
              onClick: () => {
                e.kick(), t10();
              }
            },
            "Kick"
          ),
          /* @__PURE__ */ U.createElement("button", { id: "btn-invite", className: "close-btn white", onClick: t10 }, "Cancel")
        )
      )
    );
  }
  function DS({
    baseUrl: t10,
    avatarsOverride: e,
    lockedNameField: r,
    lockedPhotoField: n,
    matchmakingOptions: i,
    onTurnbasedLaunch: o
  }) {
    var $, se, he, de, pe;
    const s = we(), a = _u(), l = i && a, c = Ei(), u = (j) => {
      if (!l)
        return { data: null, error: null, isLoading: false };
      const H = Nm(), Z = s.connection.getHostname(false) + "/api/game/" + H + "/matchmaking_total_players";
      return fetch(Z).then((oe) => oe.json());
    }, { data: f } = Uw(
      "dummy",
      u,
      {
        refreshInterval: 1e4
      }
    ), d = (f == null ? void 0 : f.totalPlayers) || 0, [h, g] = reactExports.useState(null), [p, y] = si("__matchmakingqueue"), [b, x] = si(
      "__matchmakingChosenRoom"
    ), [S, C] = reactExports.useState(
      !!window.isRunningOnNative
    ), [_, L] = reactExports.useState(false), [F, V] = reactExports.useState($n), W = s.getMyPlayerState() ? s.getMyPlayerState().getState("profile") : {
      name: xs[Math.floor(Math.random() * xs.length)] + e0(10, 99),
      color: $n[Math.floor(Math.random() * $n.length)]
    }, [X, G] = reactExports.useState({
      color: (W == null ? void 0 : W.color) || ie()[0],
      name: ct.get("playerName") || (W == null ? void 0 : W.name) || xs[Math.floor(Math.random() * xs.length)] + e0(10, 99),
      photo: (W == null ? void 0 : W.photo) || (ct.get("playerPhoto") && ct.get("playerPhoto") !== "false" ? ct.get("playerPhoto") : t0(e))
    });
    e1((j, H, Z, oe) => {
      const ue = ie();
      V(ue);
    });
    function ie() {
      const j = s.getPlayers();
      if (!j)
        return $n;
      const H = Object.keys(j).filter((oe) => oe !== s.connection.myId).map((oe) => {
        var ue;
        return (ue = j[oe].state.profile) == null ? void 0 : ue.color;
      });
      return $n.filter(
        (oe) => !H.includes(oe)
      );
    }
    function P10(j) {
      var Z;
      ct.set("playerName", j.name), j.photo && ct.set("playerPhoto", j.photo), ct.set("playerColor", j.color), s.getMyPlayerState().setState("profile", j, true), (Z = window._PLAYROOM_CONFIG) != null && Z.skipProfile && (j != null && j.photo) && s.setState("__launched", true);
    }
    const [z10, B] = reactExports.useState(false);
    reactExports.useEffect(() => {
      function j(Z) {
        var oe;
        (oe = Z.data) != null && oe.isRunningOnNative && (window.isRunningOnNative = Z.data.isRunningOnNative, C(Z.data.isRunningOnNative), L(true));
      }
      var H = { ...s == null ? void 0 : s.sdkOptions };
      return delete H.botOptions, window.parent.postMessage(
        {
          joinRoomURL: `${window.location.href}&streaming=true`,
          sdkOptions: H ?? {}
        },
        // "http://10.10.10.32:5175"
        "*"
      ), window.addEventListener("message", j, false), () => window.removeEventListener("message", j);
    }, [s]);
    const O = S && (($ = s == null ? void 0 : s.sdkOptions) == null ? void 0 : $.streamMode);
    if (h)
      return /* @__PURE__ */ U.createElement(
        RS,
        {
          playerState: h,
          hide: () => g(null)
        }
      );
    const q = (c == null ? void 0 : c.length) || 0, te = a && ((se = s.sdkOptions) == null ? void 0 : se.enableBots) && (!((he = s.sdkOptions) != null && he.maxPlayersPerRoom) || q < ((de = s.sdkOptions) == null ? void 0 : de.maxPlayersPerRoom)), Y = (pe = s.sdkOptions) == null ? void 0 : pe.turnBased, K = () => l ? /* @__PURE__ */ U.createElement(
      "span",
      {
        style: {
          opacity: d > 0 ? 1 : 0,
          color: "#00df59",
          marginTop: "1rem"
        }
      },
      /* @__PURE__ */ U.createElement(
        "span",
        {
          style: {
            backgroundColor: "#00df59",
            width: "0.5rem",
            height: "0.5rem",
            borderRadius: "50%",
            display: "inline-block",
            verticalAlign: "middle",
            marginBottom: "0.3rem",
            marginRight: "0.4rem"
          }
        }
      ),
      d,
      " ",
      d === 1 ? "player" : "players",
      " online"
    ) : null;
    return /* @__PURE__ */ U.createElement("div", { className: "main-menu" }, /* @__PURE__ */ U.createElement("div", { className: "platform" }, /* @__PURE__ */ U.createElement("div", { className: "profilecontainer" }, /* @__PURE__ */ U.createElement(
      "div",
      {
        style: { position: "relative", zIndex: 1, display: "inline-block" },
        onClick: () => {
          if (n)
            return;
          const j = t0(e);
          G({ ...X, photo: j }), P10({ ...X, photo: j });
        }
      },
      !n && /* @__PURE__ */ U.createElement("a", { className: "refresh-button" }, /* @__PURE__ */ U.createElement(Am, { style: { color: "white" } })),
      /* @__PURE__ */ U.createElement(
        "div",
        {
          className: "avatar-photo ",
          style: {
            backgroundImage: `url(${X && X.photo || wg})`,
            borderColor: X.color
            // boxShadow: `0 0 70px 50px ${profile.color}44`,
          }
        }
      )
    ), /* @__PURE__ */ U.createElement(
      "input",
      {
        type: "text",
        value: X.name,
        disabled: r,
        onChange: (j) => {
          G({ ...X, name: j.target.value }), j.target.value && P10({ ...X, name: j.target.value });
        },
        style: { borderColor: X.color },
        className: "input-name",
        maxLength: 10
      }
    ), /* @__PURE__ */ U.createElement("div", { className: "color-tray" }, $n.map((j) => {
      const H = F.includes(j);
      return /* @__PURE__ */ U.createElement(
        "span",
        {
          key: j,
          className: "color" + (j === X.color ? " active" : ""),
          style: {
            backgroundColor: j,
            opacity: H ? 1 : 0.5
          },
          onClick: H ? () => {
            G({ ...X, color: j }), P10({ ...X, color: j });
          } : () => {
          }
        }
      );
    })), !Y && /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement("div", { className: "party-hr" }, /* @__PURE__ */ U.createElement("span", null, "Party")), /* @__PURE__ */ U.createElement(
      _g,
      {
        mobileMode: true,
        showEmptySlots: 4,
        onPlayerKick: (j) => {
          g(j);
        }
      }
    )), /* @__PURE__ */ U.createElement("div", null, te && /* @__PURE__ */ U.createElement(
      "button",
      {
        id: "btn-addbot",
        className: "button-bot",
        onClick: () => {
          q5();
        }
      },
      " +"
    ))), p ? /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(K, null), /* @__PURE__ */ U.createElement(
      "button",
      {
        id: "btn-matchmaking",
        style: {
          cursor: "pointer",
          marginTop: "1rem",
          marginBottom: "6rem"
        },
        className: "button-black launch-btn btn-icon disabled",
        onClick: () => {
          a && y(false);
        }
      },
      b ? "Joining..." : "Connecting...",
      a && /* @__PURE__ */ U.createElement(
        "small",
        {
          style: {
            float: "right",
            padding: "0 1rem",
            fontSize: "0.8rem",
            marginTop: "0.2rem"
          }
        },
        "Cancel"
      )
    )) : /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(K, null), l && /* @__PURE__ */ U.createElement(
      "button",
      {
        id: "btn-matchmaking",
        style: {
          backgroundImage: `url(${kS})`,
          marginTop: "1rem"
        },
        className: "button-black launch-btn btn-icon",
        onClick: async () => {
          y(true);
        }
      },
      "Play Online"
    ), /* @__PURE__ */ U.createElement(
      "section",
      {
        style: {
          width: "100%",
          display: "flex",
          marginBottom: "1rem",
          gap: "1rem"
        }
      },
      O && /* @__PURE__ */ U.createElement(
        "button",
        {
          id: "btn-launchjoin",
          className: "button-black airplay-btn",
          onClick: () => L(true)
        },
        /* @__PURE__ */ U.createElement(
          "img",
          {
            src: wm,
            alt: "airplay-icon",
            className: "airplay-icon"
          }
        )
      ),
      /* @__PURE__ */ U.createElement(
        "section",
        {
          style: { width: "100rem", display: "flex", gap: "1rem" }
        },
        /* @__PURE__ */ U.createElement(
          "button",
          {
            id: "btn-launchjoin",
            style: l ? {
              marginTop: "1rem",
              backgroundImage: `url(${CS})`
            } : void 0,
            className: "button-black" + (a || Y ? " launch-btn" : " disabled") + (l ? " btn-icon" : ""),
            onClick: () => {
              a && !Y && s.setState("__launched", true), Y && o();
            }
          },
          a || Y ? l ? "Start Private" : "Launch" : "Waiting for host to start"
        ),
        l && /* @__PURE__ */ U.createElement(
          "button",
          {
            id: "btn-invite",
            style: {
              marginTop: "1rem",
              padding: "0rem 3rem 0rem 2rem"
            },
            className: "button-black",
            onClick: () => {
              B(true);
            }
          },
          "Invite"
        )
      )
    ), !l && (!Y || a && Y) && /* @__PURE__ */ U.createElement(
      "button",
      {
        id: "btn-invite",
        className: "button-black launch-btn",
        onClick: () => {
          B(true);
        }
      },
      "Invite"
    )), /* @__PURE__ */ U.createElement("p", { className: "sdk-version" }, "Multiplayer by Playroom v.", Wu.version), /* @__PURE__ */ U.createElement(
      MS,
      {
        show: z10,
        onClose: () => {
          B(false);
        },
        baseUrl: t10
      }
    ), /* @__PURE__ */ U.createElement(
      NS,
      {
        show: _,
        onClose: () => {
          L(false);
        }
      }
    )));
  }
  function MS({ show: t10, onClose: e, baseUrl: r }) {
    const n = we(), i = (r || window.location.href.split("#")[0]) + "#r=", o = n.currentRoom, s = x3(i, o);
    return t10 ? /* @__PURE__ */ U.createElement(Ag, null, /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          zIndex: 101
          // "-webkit-backdrop-filter": "blur(0.3rem)",
          // backdropFilter: "blur(0.3rem)",
        }
      },
      /* @__PURE__ */ U.createElement(
        ki,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            // width: "70rem",
            maxWidth: "500px",
            // height: "99rem",
            // maxHeight: "160vh",
            bottom: "0.7rem",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-10%) scale(0.9)",
            display: "flex",
            // height: "100%",
            // transform: "translate(-50%, -50%) scale(0.5)",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ U.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              // padding: "2rem",
              // gap: "2rem",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "95%",
              padding: "1rem"
            }
          },
          /* @__PURE__ */ U.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Party maker"),
          /* @__PURE__ */ U.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Invite friends to play together"
          ),
          /* @__PURE__ */ U.createElement(
            "div",
            {
              style: {
                backgroundColor: "#ff3666",
                height: "4rem",
                width: "4rem",
                transform: "scale(0.7)",
                borderRadius: "50%",
                position: "absolute",
                top: "1.5rem",
                right: "1rem",
                padding: "1rem",
                cursor: "pointer",
                textAlign: "center",
                display: e ? "flex" : "none",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center"
              },
              onClick: e
            },
            /* @__PURE__ */ U.createElement("img", { src: xg })
          ),
          /* @__PURE__ */ U.createElement(
            ES,
            {
              noAbsolute: true,
              baseUrl: i,
              size: 128,
              noText: true,
              containerStyles: {
                // transform: "scale(2.5)",
              }
            }
          ),
          /* @__PURE__ */ U.createElement(X7, { text: s })
        )
      )
    )) : null;
  }
  function NS({ show: t10, onClose: e }) {
    return t10 ? /* @__PURE__ */ U.createElement(Ag, null, /* @__PURE__ */ U.createElement("div", { className: "airplay-instruction-modal" }, /* @__PURE__ */ U.createElement(
      ki,
      {
        visible: true,
        center: true,
        style: {
          color: "#000",
          maxWidth: "500px",
          bottom: "0.7rem",
          position: "absolute",
          width: "100%",
          left: "50%",
          transform: "translateX(-50%) scale(0.9)",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          borderRadius: "4.5rem"
        }
      },
      /* @__PURE__ */ U.createElement("div", { className: "airplay-instruction-container" }, /* @__PURE__ */ U.createElement(
        "div",
        {
          style: {
            display: e ? "flex" : "none"
          },
          onClick: e,
          className: "close-icon"
        },
        /* @__PURE__ */ U.createElement("img", { src: xg, alt: "close-icon" })
      ), /* @__PURE__ */ U.createElement(
        "img",
        {
          src: wm,
          alt: "airplay-icon",
          className: "airplay-icon"
        }
      ), /* @__PURE__ */ U.createElement("h1", { className: "airplay-instruction-title" }, "Airplay on TV"), /* @__PURE__ */ U.createElement("ol", null, /* @__PURE__ */ U.createElement("li", null, "Connect your iPhone, iPad, or iPod touch to the same Wi-Fi network as your Apple TV."), /* @__PURE__ */ U.createElement("li", null, "Swipe down from the upper-right corner of the screen to open Control Center on this phone."), /* @__PURE__ */ U.createElement("li", null, "Tap Screen Mirroring ", /* @__PURE__ */ U.createElement("span", { className: "icon-screenmirror" }), "."), /* @__PURE__ */ U.createElement("li", null, "Select your Apple TV or any AirPlay compatible device."), /* @__PURE__ */ U.createElement("li", null, "If an AirPlay passcode appears on your TV screen, enter the passcode on your iOS or iPadOS device."), /* @__PURE__ */ U.createElement("li", null, "Return to this app to continue.")))
    ))) : null;
  }
  const LS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAxNyAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC42NDIxODgiIHk9IjAuNjQyMTg4IiB3aWR0aD0iMTQuNzcwMyIgaGVpZ2h0PSIyNi4zMjk3IiByeD0iMS45MjY1NiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxLjI4NDM4Ii8+CjxyZWN0IHg9IjYuMTAwODMiIHk9IjIuMjQ3NjkiIHdpZHRoPSIzLjg1MzEzIiBoZWlnaHQ9IjEuMjg0MzgiIHJ4PSIwLjY0MjE4OCIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==", BS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQ4IiBoZWlnaHQ9IjQ0OCIgdmlld0JveD0iMCAwIDY0OCA0NDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMV84KSI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIxX2RfMV84KSI+CjxwYXRoIGQ9Ik00OTAuNjY3IDIwQzU1My41MiAyMCA1ODQuOTQ3IDIwIDYwNC40NzMgMzkuNTI2M0M2MjQgNTkuMDUyMyA2MjQgOTAuNDc5MyA2MjQgMTUzLjMzM1YyODYuNjY3QzYyNCAzNDkuNTIgNjI0IDM4MC45NDcgNjA0LjQ3MyA0MDAuNDczQzU4NC45NDcgNDIwIDU1My41MiA0MjAgNDkwLjY2NyA0MjBINDU3LjMzM0gxOTAuNjY3SDE1Ny4zMzNDOTQuNDc5MyA0MjAgNjMuMDUyMyA0MjAgNDMuNTI2MyA0MDAuNDczQzI0IDM4MC45NDcgMjQgMzQ5LjUyIDI0IDI4Ni42NjdWMTUzLjMzM0MyNCA5MC40NzkzIDI0IDU5LjA1MjMgNDMuNTI2MyAzOS41MjYzQzYzLjA1MjMgMjAgOTQuNDc5MyAyMCAxNTcuMzMzIDIwSDE5MC42NjdINDU3LjMzM0g0OTAuNjY3WiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSI0MCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc2hhcGUtcmVuZGVyaW5nPSJjcmlzcEVkZ2VzIi8+CjwvZz4KPHBhdGggZD0iTTQyNCAxNTMuMzMzVjE1My42NjciIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iNjYuNjY2NyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik00OTAuNjY3IDI4Ni42NjdWMjg3IiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjY2LjY2NjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjA3LjMzMyAxMzYuNjY3VjMwMy4zMzMiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMjgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjkwLjY2NyAyMjBIMTI0IiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjI4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9nPgo8ZGVmcz4KPGZpbHRlciBpZD0iZmlsdGVyMF9kXzFfOCIgeD0iLTMuMDUxNzZlLTA1IiB5PSItMy4wNTE3NmUtMDUiIHdpZHRoPSI2NDgiIGhlaWdodD0iNDQ4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd18xXzgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMV84IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8ZmlsdGVyIGlkPSJmaWx0ZXIxX2RfMV84IiB4PSItMy4wNTE3NmUtMDUiIHk9Ii0zLjA1MTc2ZS0wNSIgd2lkdGg9IjY0OCIgaGVpZ2h0PSI0NDgiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+CjxmZU9mZnNldCBkeT0iNCIvPgo8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIyIi8+CjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPgo8ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4yNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzFfOCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd18xXzgiIHJlc3VsdD0ic2hhcGUiLz4KPC9maWx0ZXI+CjwvZGVmcz4KPC9zdmc+Cg==";
  function FS({
    zIndex: t10,
    demoMode: e,
    noAbsolute: r,
    noText: n,
    size: i = 256,
    containerStyles: o = {},
    baseUrl: s = "https://joinplayroom.com/"
  }) {
    const l = we().currentRoom;
    return reactExports.useEffect(() => {
    }, []), /* @__PURE__ */ U.createElement(
      "div",
      {
        className: "room-code-sticker",
        style: {
          zIndex: t10 || "initial",
          position: r ? "initial" : "absolute",
          ...o
        }
      },
      /* @__PURE__ */ U.createElement("div", { className: "qr-code" }, /* @__PURE__ */ U.createElement(
        Mm,
        {
          id: "QRCodeScaled",
          size: i,
          style: { height: "auto", maxWidth: "100%", width: "100%" },
          value: e ? "https://joinplayroom.com/demohost" : `${s}R${l || ""}`,
          viewBox: `0 0 ${i} ${i}`
        }
      )),
      !n && l && /* @__PURE__ */ U.createElement("div", { className: "room-code" }, /* @__PURE__ */ U.createElement("b", null, l), /* @__PURE__ */ U.createElement("span", null, "Scan QR code to join the room")),
      !n && !l && /* @__PURE__ */ U.createElement("div", { className: "room-code" }, /* @__PURE__ */ U.createElement("b", null, "Scan to start"), /* @__PURE__ */ U.createElement("span", null, "Download the game from the Appstore"))
    );
  }
  function r0() {
    const { innerWidth: t10, innerHeight: e } = window;
    return {
      width: t10,
      height: e
    };
  }
  function jS() {
    let t10 = document.querySelector('meta[name="viewport"]');
    t10 || (t10 = document.createElement("meta"), t10.name = "viewport", t10.content = "width=device-width, initial-scale=1.0", document.head.appendChild(t10));
  }
  function Lm() {
    const [t10, e] = reactExports.useState(
      r0()
    );
    return reactExports.useEffect(() => {
      function r() {
        e(r0());
      }
      return jS(), window.addEventListener("resize", r), () => window.removeEventListener("resize", r);
    }, []), t10;
  }
  class Bm {
    /**
     * Constructor
     */
    constructor(e) {
      this.start = Date.now(), this.current = this.start, this.elapsed = 0, this.delta = 16, this.onTick = e, this.tick = this.tick.bind(this), this.tick();
    }
    /**
     * Tick
     */
    tick() {
      this.ticker = window.requestAnimationFrame(this.tick);
      const e = Date.now();
      this.delta = e - this.current, this.elapsed = e - this.start, this.current = e, this.delta > 60 && (this.delta = 60), this.onTick(this.delta, this.elapsed);
    }
    /**
     * Stop
     */
    stop() {
      window.cancelAnimationFrame(this.ticker);
    }
  }
  const n0 = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ];
  function WS(t10) {
    var e = Math.PI / 2, r, n;
    t10 > -e && t10 < e ? r = "right" : r = "left", t10 > 0 ? n = "up" : n = "down";
    let i = {};
    return r && (i.x = r), n && (i.y = n), i;
  }
  function US(t10, e) {
    return t10 === 0 && e === 0 ? NaN : -Math.atan2(e, t10);
  }
  function zS() {
    return new Promise((t10, e) => {
      we().connection.once("sync", () => {
        t10();
      });
    });
  }
  async function VS() {
    const t10 = we();
    await zS(), Object.values(t10.getPlayers()).filter(
      (o) => o.getState("__proxyBy")
    ).forEach((o) => {
      t10.connection.removeProxyPlayer(o.id);
    });
    let r = [];
    function n(o, s) {
      const a = r.find(
        (c) => c.joystick.id == o.id && c.joystick.index == o.index
      );
      if (a)
        return a.player;
      if (!s)
        return;
      const l = t10.connection.addProxyPlayer();
      return l.setState("profile", {
        name: "Gamepad " + (r.length + 1),
        // TODO: check and use avatars override here if provided.
        photo: Pa(Oa(l.id)),
        color: n0[r.length % n0.length]
      }), l.setState("__gamepad", true), r.push({ player: l, joystick: o }), l.on("quit", () => {
        const c = r.findIndex((u) => u.player.id == l.id);
        r.splice(c, 1);
      }), l;
    }
    const i = new Bm(() => {
      var l;
      const o = (l = navigator.getGamepads()) == null ? void 0 : l.map((c, u) => [c, u]).filter(([c, u]) => c && c.connected), s = t10.sdkOptions, a = (s == null ? void 0 : s.joystickConfig) || false;
      o.forEach(([c]) => {
        let u = n(c);
        const f = c.buttons.slice(0, 4).map((p) => p.pressed);
        if (!u) {
          if (!f.some((y) => y) || !s.spectator && s.maxPlayersPerRoom && Object.values(t10.connection.playerStates).filter((y) => !y.playerIsSpectator).length >= s.maxPlayersPerRoom || s.spectator && s.maxSpectatorsPerRoom && Object.values(t10.connection.playerStates).filter((y) => y.playerIsSpectator).length >= s.maxSpectatorsPerRoom)
            return;
          u = n(c, true);
        }
        f.forEach((p, y) => {
          var x, S;
          let b = `ctr-button${y + 1}`;
          a && a.buttons && (u.getState(b) && u.setState(b, void 0), b = (x = a.buttons[y]) != null && x.id ? `ctr-${(S = a.buttons[y]) == null ? void 0 : S.id}` : b), u.setState(b, p);
        });
        let d = c.axes;
        Math.abs(d[0]) < 0.1 && Math.abs(d[1]) < 0.1 && (d = [0, 0]);
        const h = US(d[0], d[1]), g = Math.PI * 0.5;
        isNaN(h) ? (u.setState("ctr-joystick", false), u.setState("ctr-angle", 0), u.setState("ctr-dpad", null)) : (u.setState("ctr-joystick", true), u.setState("ctr-angle", h + g), u.setState("ctr-dpad", WS(h)));
      });
    });
    return () => {
      i.stop();
    };
  }
  function qS(t10, e) {
    return Math.floor(Math.random() * (e - t10 + 1)) + t10;
  }
  function HS(t10) {
    let e = "";
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = r.length;
    for (let i = 0; i < t10; ++i)
      e += r.charAt(Math.floor(Math.random() * n));
    return e;
  }
  const i0 = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ], o0 = [
    "Eclipse",
    "Crankshaft",
    "Firetruck",
    "President",
    "Bat",
    "Avocado",
    "Holiday",
    "Salad",
    "Boom",
    "Cornflakes",
    "Pancake",
    "Penguin",
    "Pirate",
    "Pumpkin",
    "Rainbow",
    "Squirrel"
  ];
  function KS(t10) {
    return t10 && t10.length > 0 ? t10[Math.floor(Math.random() * t10.length)] : Pa(Oa(HS(10)));
  }
  function YS(t10) {
    const e = {
      color: i0[Math.floor(Math.random() * i0.length)],
      name: ct.get("playerName") || o0[Math.floor(Math.random() * o0.length)] + qS(10, 99),
      photo: ct.get("playerPhoto") && ct.get("playerPhoto") !== "false" ? ct.get("playerPhoto") : KS(t10)
    };
    return ct.set("playerName", e.name), ct.set("playerPhoto", e.photo), e;
  }
  const XS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAYAAABX5MJvAAAABmJLR0QA/wD/AP+gvaeTAAAC5klEQVRYhcWXTYhWVRjHf88Yo9OX6JCCSUVFm9RwYy0UgjIqN30QERTt0lAUXLSw3LkUEUpEUKGCgmgnfVFBRCVRFEolusgw1PwYtIRmyJn5ubj3xTvHc+Z9Z3rf8b977nk+fvee53zcoI3UW4DbgZva+WZ0GTgLnIkIpxSp3qq+oR6yOzqn7lcf6BTg6TqoFxpTd6n9kwFsUMd7BNDUV+qcHMCT6ugMALT0Tqt21AD9wBHg7ik1z//X6oj4oq82XrwOAACvA7Qgnmnj/C3wKnAXMB/4vn4+BpwBhmt7FFgJzAXWAG8D/06Sd5V6GwDq6cK8HVGXppHqYvVOdVbj2Tx1ScZ3rrp7kt5YjTrLaumkGlbva/OFOpIaVisip5f7gH6uTktTb0XEsW5A1LvlRiC3aw7kikM1t292A6ABchj4MjdWgvgwIk50E6LWzqlAdPUrNPQxcM0U5yB+i4jvekFQ98a+TiAO5BLUS/Jz9YS6TY2Mz8NWJ+9R9bkCy0e55APJkllTgPg08Xs2Gb9RPd8YH1EXF3INNfzW5b5EaVk+mNgPJfa9wGDDng0sL+Q62jRyEH8WAg8n9qHEPg7807BHgV8LuSbUSCH+i4iRQuBa4Ceqs2AP8F5zMCIuAS8Bp4AhYH1E/F7IdWmClfTEuUJQV6XumKwnxmYCIq2TQixQF6UR6jJ1r3pzp1XUF9StheEJDXsD1bV8vAYK4F31+Yg43/D7BfgR+Fn9hqpJ/wBONt5qkOq+cQ/wBPADsCUBC2Az8Ejj8Uhr8K9kDxhSN6mzkyTbC8dxqtNqXxK7Sj2Y8X2s5fBJIdlxda06qN6v/t0hhOoWq7vKo+qBgs+YurAF8UoHSafzK9Au5mu4etueQ7WL3VFopF7p8Yj4rDlnT03zbaerD7JY6mszBHJQLf9gW63vCz0qPm71YzzQdqKsVsM29ViXil9U31dX5OpdczHJAC0EFjHxmO5Uw1Qb2smIuFxyugJxsR5V03UvzwAAAABJRU5ErkJggg==", JS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAdCAYAAABBsffGAAAABmJLR0QA/wD/AP+gvaeTAAABJElEQVRIidXWvy5EQRzF8e9ZOhSegURDxQOgolLsxhuo6LVK7bYbWglaL0DCshqFwgP4F6VuNUexJLJ75+7M3XuDU84988nkN1Nc+K9R/4JtAXOSHmIR21vARt/yUVaxZvvddj0Bb3owe7VAfwo4tb1vO9QZmryNAnaBM9vTZePfWQc6tuerwAFmgbbtRhU4wCRw8nUPY2XjkHgPRV/CGnBre6EKHGCG3j1shgrjI+AAE8AxcJ/1cZST/0zmMy0Lz8yfxz+AiyrwZ2AZuCsbvwKWJLVDhaJ4C1iR9JJXSn3nXWBH0kFMOQV/AhqSrmM3xI7lkt58o+FYvAWsSnpNgSF/LF1gW9JhKjoMfwTqkjpF4RBuYFHSW4JzzuA/0E3hU/16PgGdnmndigVImAAAAABJRU5ErkJggg==", QS = "/.proxy/_pr_content", GS = "https://play.joinplayroom.app";
  function _s(t10) {
    return t10.replace(GS, `${QS}`);
  }
  const Pn = reactExports.forwardRef((t10, e) => {
    const { enableEventCapturing: r = false, ...n } = t10;
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        ...n,
        ref: e,
        style: {
          ...n.style,
          pointerEvents: r ? "auto" : "none"
        }
      },
      n.children
    );
  });
  Pn.displayName = "View";
  function Zr(t10, e) {
    return e === "native" ? +getComputedStyle(document.documentElement).getPropertyValue(`--sa${t10}`).slice(0, -2) : +getComputedStyle(document.documentElement).getPropertyValue(`--dsa${t10}`).slice(0, -2);
  }
  function sc(t10) {
    const e = Zr("t", t10 == null ? void 0 : t10.top), r = Zr("b", t10 == null ? void 0 : t10.bottom);
    return window.innerHeight - (e + r);
  }
  function ac(t10) {
    const e = Zr("l", t10 == null ? void 0 : t10.left), r = Zr("r", t10 == null ? void 0 : t10.right);
    return window.innerWidth - (e + r);
  }
  const bt = {
    "16_9": {
      width: 1280,
      height: 720,
      widthRatio: 16,
      heightRatio: 9,
      mWidth: 720,
      mHeight: 1280,
      mWidthRatio: 9,
      mHeightRatio: 16
    },
    "4_3": {
      width: 1024,
      height: 768,
      widthRatio: 4,
      heightRatio: 3,
      mWidth: 768,
      mHeight: 1024,
      mWidthRatio: 3,
      mHeightRatio: 4
    }
  }, lc = (t10) => {
    const {
      children: e,
      backgroundNode: r,
      ratio: n = "16_9",
      containerStyle: i,
      parentContainerStyle: o,
      anchor: s,
      autoAdjustAspectRatio: a = false,
      lockOrientation: l = "landscape",
      maintainAspectRatioBy: c = "width",
      disabled: u,
      safeAreaInsets: f = {
        top: "discord",
        bottom: "discord",
        left: "discord",
        right: "discord"
      }
    } = t10, d = reactExports.useRef(!u), h = reactExports.useRef(null), g = reactExports.useRef(null), [p, y] = reactExports.useState(), [b, x] = reactExports.useState(F()), { width: S, height: C, widthRatio: _, heightRatio: L } = b;
    reactExports.useEffect(() => {
      function ie() {
        const P10 = F();
        x(P10);
      }
      return ie(), window.addEventListener("resize", ie), () => window.removeEventListener("resize", ie);
    }, [n]), reactExports.useEffect(() => (V(), window.addEventListener("resize", V), () => {
      window.removeEventListener("resize", V);
    }), [b, s, c]);
    function F() {
      let ie = bt[n].mWidth, P10 = bt[n].mHeight, z10 = bt[n].mWidthRatio, B = bt[n].mHeightRatio, O = true;
      return l === "landscape" ? (ie = bt[n].width, P10 = bt[n].height, z10 = bt[n].widthRatio, B = bt[n].heightRatio, O = false) : l === "portrait" ? (ie = bt[n].mWidth, P10 = bt[n].mHeight, z10 = bt[n].mWidthRatio, B = bt[n].mHeightRatio, O = true) : ac(f) > sc(f) && (ie = bt[n].width, P10 = bt[n].height, z10 = bt[n].widthRatio, B = bt[n].heightRatio, O = false), {
        width: ie,
        height: P10,
        widthRatio: z10,
        heightRatio: B,
        isPortraitMode: O
      };
    }
    function V() {
      const ie = g.current, P10 = h.current;
      if (ie && P10 && d.current) {
        let z10 = S, B = C;
        if (typeof c != "string") {
          const O = ac(f) / sc(f), q = W(
            O >= c.breakpointByAspectRatio ? c.ratioBy[1] : c.ratioBy[0]
          );
          z10 = q.newWidth, B = q.newHeight;
        } else {
          const O = W(c);
          z10 = O.newWidth, B = O.newHeight;
        }
        ie.style.transform = `scale(${z10 / S}, ${B / C})`, ie.style.opacity = "1", s ? (X(), G({ width: z10, height: B, anchor: s }), y(s)) : p && (X(), y(null));
      }
    }
    function W(ie) {
      const P10 = ac(f), z10 = sc(f);
      let B = P10, O = z10;
      return ie === "width" ? (B = P10, O = B * L / _, a && O > z10 && (O = z10, B = O * _ / L)) : ie === "height" ? (O = z10, B = O * _ / L, a && B > P10 && (B = P10, O = B * L / _)) : ie === "both" && (B = P10, O = z10), { newWidth: B, newHeight: O };
    }
    function X() {
      const ie = h.current;
      ie && (ie.style.top = "initial", ie.style.bottom = "initial", ie.style.left = "initial", ie.style.right = "initial");
    }
    function G(ie) {
      const { width: P10, height: z10, anchor: B } = ie, O = h.current;
      if (O) {
        if (B === "top" || B === "bottom") {
          const q = O.getBoundingClientRect().height - (Zr("t", f.top) + Zr("b", f.bottom)) - z10;
          O.style[B] = `${q / 2 * -1}px`;
          return;
        }
        if (B === "left" || B === "right") {
          const q = O.getBoundingClientRect().width - (Zr("l", f.left) + Zr("r", f.right)) - P10;
          O.style[B] = `${q / 2 * -1}px`;
          return;
        }
        if (B === "top-left" || B === "top-right" || B === "bottom-left" || B === "bottom-right") {
          const q = B.split("-");
          G({ ...ie, anchor: q[0] }), G({ ...ie, anchor: q[1] });
          return;
        }
      }
    }
    return u ? e : /* @__PURE__ */ U.createElement(U.Fragment, null, r && /* @__PURE__ */ U.createElement(Pn, { className: "sw_background-node" }, r), /* @__PURE__ */ U.createElement(
      Pn,
      {
        ref: h,
        className: "sw_parent-container",
        style: {
          ...o,
          width: "100vw",
          height: "100%"
        }
      },
      /* @__PURE__ */ U.createElement(
        Pn,
        {
          ref: g,
          className: "sw_container",
          style: {
            ...i,
            width: S,
            height: C
          }
        },
        e
      )
    ));
  }, Fm = ({
    isRunningOnDiscord: t10,
    adConfig: e,
    callbacks: r,
    onClose: n
  }) => {
    const [o, s] = reactExports.useState(0), [a, l] = reactExports.useState(false), [c, u] = reactExports.useState(false), [f, d] = reactExports.useState(false), h = reactExports.useRef(null), g = () => {
      l(false), u(false), n();
    }, p = () => {
      var S, C;
      ar.track("ads-skipped", {
        gameId: e.requestGameId,
        adGameId: e.game_id,
        gameAdName: e.game_name,
        adName: e.name,
        skipped_at: h.current.currentTime
      }), (C = (S = r.detail) == null ? void 0 : S.skipCallback) == null || C.call(S), g();
    }, y = () => {
      var S, C;
      ar.track("ads-completed", {
        gameId: e.requestGameId,
        adGameId: e.game_id,
        gameAdName: e.game_name,
        adName: e.name,
        total_duration: h.current.duration
      }), (C = (S = r.detail) == null ? void 0 : S.completeCallback) == null || C.call(S), g();
    }, b = () => {
      var S, C, _, L, F;
      ar.track("ads-action-button-clicked", {
        gameId: e.requestGameId,
        adGameId: e.game_id,
        gameAdName: e.game_name,
        adName: e.name,
        actionUrl: e.action_button_url
      }), t10 ? (_ = (C = (S = Cs == null ? void 0 : Cs()) == null ? void 0 : S.commands) == null ? void 0 : C.openExternalLink) == null || _.call(C, {
        url: e.action_button_url
      }) : window.open(e.action_button_url, "_blank"), (F = (L = r.detail) == null ? void 0 : L.actionButtonClick) == null || F.call(L), g();
    };
    reactExports.useEffect(() => (e != null && e.name && u(true), () => {
      u(false);
    }), [e == null ? void 0 : e.name]), reactExports.useEffect(() => {
      let S;
      return a && (S = setTimeout(() => {
        d(true);
      }, 1e4)), () => {
        clearTimeout(S);
      };
    }, [a]);
    const x = (S) => {
      const C = Math.floor(S / 60), _ = Math.floor(S % 60);
      return `${String(C).padStart(2, "0")}:${String(_).padStart(
        2,
        "0"
      )}`;
    };
    return c ? /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(
      "div",
      {
        className: "ad-wrapper",
        style: { backgroundColor: e.background_color }
      },
      /* @__PURE__ */ U.createElement("div", { className: "ad-content" }, /* @__PURE__ */ U.createElement(
        "video",
        {
          ref: h,
          src: t10 ? _s(e.video) : e.video,
          autoPlay: true,
          className: "ad-video",
          onPlay: () => l(true),
          onEnded: y,
          poster: t10 ? _s(e.video_placeholder_image) : e.video_placeholder_image,
          onLoadedMetadata: () => {
            h.current && s(h.current.duration);
          },
          onTimeUpdate: () => {
            h.current && s(
              h.current.duration - h.current.currentTime
            );
          }
        }
      )),
      /* @__PURE__ */ U.createElement(lc, { maintainAspectRatioBy: "height", anchor: "bottom-left" }, /* @__PURE__ */ U.createElement(Pn, { className: "bottom-left-overlay-container" }, /* @__PURE__ */ U.createElement("div", { className: "bottom-left-overlay" }, /* @__PURE__ */ U.createElement("div", { className: "header-container" }, (e == null ? void 0 : e.header_image) && /* @__PURE__ */ U.createElement(
        "img",
        {
          src: t10 ? _s(e == null ? void 0 : e.header_image) : e == null ? void 0 : e.header_image,
          alt: "Header",
          className: "header-image"
        }
      ), /* @__PURE__ */ U.createElement("p", { className: "header-text" }, e.header)), /* @__PURE__ */ U.createElement("div", { className: "ad-body" }, /* @__PURE__ */ U.createElement(
        "img",
        {
          src: t10 ? _s(e.thumbnail) : e.thumbnail,
          alt: "Ad",
          className: "ad-thumbnail"
        }
      ), /* @__PURE__ */ U.createElement("div", { className: "ad-description" }, /* @__PURE__ */ U.createElement("h2", { className: "ad-title" }, e.title), /* @__PURE__ */ U.createElement("p", { className: "ad-subtitle" }, e.sub_title), /* @__PURE__ */ U.createElement("button", { className: "action-button", onClick: b }, /* @__PURE__ */ U.createElement(
        "img",
        {
          src: XS,
          alt: "Join",
          className: "action-icon"
        }
      ), /* @__PURE__ */ U.createElement("span", { className: "action-text" }, e.action_button_text))))))),
      /* @__PURE__ */ U.createElement(lc, { maintainAspectRatioBy: "height", anchor: "top-right" }, /* @__PURE__ */ U.createElement(Pn, { className: "skip-button-container" }, /* @__PURE__ */ U.createElement(
        "button",
        {
          className: `skip-button ${f ? "active" : "disabled"}`,
          onClick: p,
          disabled: !f
        },
        /* @__PURE__ */ U.createElement("span", { className: "skip-text" }, "SKIP"),
        /* @__PURE__ */ U.createElement("img", { src: JS, alt: "Skip", className: "skip-icon" })
      ))),
      /* @__PURE__ */ U.createElement(lc, { maintainAspectRatioBy: "height", anchor: "top-left" }, /* @__PURE__ */ U.createElement(Pn, { className: "top-left-overlay-container" }, /* @__PURE__ */ U.createElement("div", { className: "top-left-overlay" }, /* @__PURE__ */ U.createElement("span", { className: "overlay-title" }, "Promo"), /* @__PURE__ */ U.createElement("span", { className: "overlay-time" }, x(o)))))
    )) : /* @__PURE__ */ U.createElement("div", { className: "ad-loading" }, /* @__PURE__ */ U.createElement("div", { className: "loading-spinner" }));
  };
  Fm.propTypes = {
    isRunningOnDiscord: N.bool.isRequired,
    adConfig: N.shape({
      name: N.string.isRequired,
      game_id: N.string.isRequired,
      game_name: N.string.isRequired,
      header: N.string.isRequired,
      header_image: N.string.isRequired,
      key: N.string.isRequired,
      action_button_text: N.string.isRequired,
      action_button_url: N.string.isRequired,
      title: N.string.isRequired,
      sub_title: N.string,
      thumbnail: N.string.isRequired,
      video: N.string.isRequired,
      video_placeholder_image: N.string,
      background_color: N.string.isRequired,
      requestGameId: N.string.isRequired
    }).isRequired,
    callbacks: N.shape({
      actionButtonClick: N.func,
      completeCallback: N.func,
      skipCallback: N.func,
      errorCallback: N.func
    }),
    onClose: N.func.isRequired
  };
  const ZS = ({ isRunningOnDiscord: t10, gameId: e, callbacks: r, onClose: n }) => {
    const [i, o] = reactExports.useState();
    return reactExports.useEffect(() => {
      e && (async () => {
        var c, u;
        const l = `${we().connection.getHostname(
          false
        )}/api/ads/random?gameId=${e}`;
        try {
          const f = await fetch(l, {
            method: "GET",
            headers: {
              "Content-Type": "application/json"
            }
          });
          if (!f.ok)
            throw new Error("Failed to fetch ad");
          const d = await f.json();
          d.name ? (ar.track("ads-started", {
            gameId: e,
            gameAdName: d.game_name,
            adName: d.name,
            adGameId: d.game_id
          }), o(d)) : n();
        } catch (f) {
          ar.track("ads-failed", {
            gameId: e,
            errorMessage: (f == null ? void 0 : f.message) || "Failed to fetch ad"
          }), (u = (c = r.detail) == null ? void 0 : c.errorCallback) == null || u.call(c), console.log("Failed to fetch ad"), n();
        }
      })();
    }, [e]), i ? /* @__PURE__ */ U.createElement(
      Fm,
      {
        isRunningOnDiscord: t10,
        adConfig: { ...i, requestGameId: e },
        callbacks: r,
        onClose: n
      }
    ) : null;
  };
  function $S({ options: t10 = {}, onStart: e, onReject: r }) {
    const { height: n } = Lm(), i = _u(), [o, s] = reactExports.useState(false), [a, l] = reactExports.useState(false), [c, u] = reactExports.useState(false), [f, d] = reactExports.useState(false), [h, g] = reactExports.useState(false), [p, y] = reactExports.useState(null), [b, x] = si("__matchmakingqueue"), [S, C] = si(
      "__matchmakingChosenRoom"
    ), _ = bc.getUrlHashParameter("streaming"), L = xn("player_name") ? decodeURIComponent(xn("player_name")) : void 0, F = xn("player_photo") ? decodeURIComponent(xn("player_photo")) : void 0, V = bc.getUrlHashParameter("skipLobby");
    let W = {
      ...t10
    };
    const X = YS(W.avatars);
    W.profile = W.profile || {
      name: X.name,
      photo: X.photo
    }, L && (W.profile = {
      ...W.profile,
      name: L
    }), F && (W.profile = {
      ...W.profile,
      photo: F
    });
    const G = we(W), ie = t10.spectator || false, P10 = t10.streamMode || false, z10 = _ || P10 && !sw() || ie, [B] = si("__launched"), [O, q] = reactExports.useState(false), te = t10.skipLobby || V;
    reactExports.useEffect(() => {
      o && (t10.skipLobby || V) && !t10.matchmaking && G.setState("__launched", true);
    }, [o]), reactExports.useEffect(() => {
      (B || O) && e();
    }, [B, O]), reactExports.useEffect(() => {
      var Z, oe;
      const de = document.createElement("style");
      de.innerHTML = rw, document.head.appendChild(de);
      const pe = document.createElement("style");
      pe.innerHTML = [sg, ag, lg, tw].join(`
`), document.head.appendChild(pe);
      let j = xn("r") ? xn("r").slice(1) : t10.roomCode;
      j ? z10 ? G.spectateRoom(j, false, true, true) : G.joinRoom(j, true, true) : z10 ? G.spectateRoom(void 0, true, true) : G.createRoom(void 0, true, true), G.once("connection_initiated", () => {
        G.connection.once("connected", () => {
          $s("r", "R" + G.currentRoom), s(true), ar.track("SDK: Connected", { gameId: t10.gameId }), t10.matchmaking && te && x(true);
        }), G.connection.once("disconnected", (ue) => {
          $t.roomLimitExceed.code === ue.eventCode ? Y() : $t.roomSpectatorsLimitExceed.code === ue.eventCode ? K() : $t.playerKicked.code === ue.eventCode ? $() : $t.playerLeave.code === ue.eventCode ? se() : ue.reason === "MANUAL_DISCONNECT" ? s(false) : window.location.reload();
        });
      }), ar.track("SDK: Insert Coin", {
        ...t10,
        isStreamScreen: z10
      }), (Z = we().sdkOptions) != null && Z.allowGamepads && z10 && VS(), (oe = we().sdkOptions) != null && oe.enableBots && U5();
      const H = (ue) => {
        g(true), y(ue);
      };
      return document.addEventListener("start-ad-event", H), () => {
        g(false), document.removeEventListener("start-ad-event", H);
      };
    }, []), reactExports.useEffect(() => {
      (async () => {
        var oe;
        if (!b || !i)
          return;
        const pe = Math.max(
          1,
          parseInt(
            (((oe = t10.matchmaking) == null ? void 0 : oe.waitBeforeCreatingNewRoom) || 5e3) / 1e3
          )
        ), j = Nm(), H = Object.keys(G.getPlayers()).length, Z = G.connection.getHostname(false) + "/api/game/" + j + "/matchmaking_find?forPlayers=" + H;
        ar.track("SDK: Matchmaking", { gameId: t10.gameId });
        for (let ue = 0; ue < pe; ue++) {
          if (await xl(1e3), !G.getState("__matchmakingqueue"))
            return;
          const R = await fetch(Z, {
            method: "GET",
            headers: {
              "Content-Type": "application/json"
            }
          });
          if (R.ok) {
            const k = await R.json(), ee = ue === pe - 1;
            k.room && (k.new && ee || !k.new) && C(k.room);
          }
        }
      })();
    }, [b, i]), reactExports.useEffect(() => {
      (async () => {
        if (S) {
          await xl(1e3);
          const pe = JSON.parse(
            JSON.stringify(G.getMyPlayerState().getState())
          );
          G.leaveRoom(), $s("r", void 0), await xl(100), G.joinRoom(S, true, true), G.once("connected", () => {
            Object.keys(pe || {}).forEach((j) => {
              G.getMyPlayerState().setState(j, pe[j]);
            }), G.setState("__launched", true), G.emit("matchmaking_room_joined");
          });
        }
      })();
    }, [S]);
    const Y = () => {
      !(W != null && W.skipLobby) && !V && l(true), r({ message: $t.roomLimitExceed.reason });
    }, K = () => {
      r({ message: $t.roomSpectatorsLimitExceed.reason });
    }, $ = () => {
      !(W != null && W.skipLobby) && !V && u(true), r({ message: $t.playerKicked.reason });
    }, se = () => {
      d(true), r({ message: $t.playerLeave.reason });
    }, he = () => {
      l(false);
    };
    return h ? /* @__PURE__ */ U.createElement(
      ZS,
      {
        isRunningOnDiscord: !!t10.discord,
        gameId: t10.gameId,
        callbacks: p,
        onClose: () => g(false)
      }
    ) : a ? /* @__PURE__ */ U.createElement(rE, { hide: he }) : c ? /* @__PURE__ */ U.createElement(nE, { hide: () => u(false) }) : f ? /* @__PURE__ */ U.createElement(iE, { hide: () => d(false) }) : !o || B || te || O ? null : /* @__PURE__ */ U.createElement("div", { className: "bootstrap-wrapper" }, /* @__PURE__ */ U.createElement("div", { className: "playroom" }, /* @__PURE__ */ U.createElement("div", { className: "modal-container fullscreen " }, /* @__PURE__ */ U.createElement("div", { "data-pop": "slide-up", id: "popup", className: "show" }, /* @__PURE__ */ U.createElement("div", { className: "popupcontrols" }), /* @__PURE__ */ U.createElement(
      "div",
      {
        className: "popupcontent",
        style: { transform: `scale(${Math.min(1, n / 880)})` }
      },
      !z10 && o && /* @__PURE__ */ U.createElement(
        DS,
        {
          baseUrl: t10.baseUrl,
          avatarsOverride: t10.avatars,
          lockedNameField: !!L,
          lockedPhotoField: !!F,
          matchmakingOptions: t10.matchmaking,
          onTurnbasedLaunch: () => q(true)
        }
      ),
      z10 && /* @__PURE__ */ U.createElement(eE, { baseUrl: t10.baseUrl, show: true })
    )), /* @__PURE__ */ U.createElement("div", { id: "overlay", className: "show" }))));
  }
  function eE({ show: t10, baseUrl: e }) {
    var u, f, d;
    const r = we(), n = (e || window.location.href.split("#")[0]) + "#r=", i = (u = r.sdkOptions) == null ? void 0 : u.allowGamepads, o = Ei(true), [s] = si("__gamepadPressedTime"), a = o.every((h) => h.getState("__gamepad")) && o.length > 0, l = (o == null ? void 0 : o.length) || 0, c = !((f = r.sdkOptions) != null && f.maxPlayersPerRoom) || l < ((d = r.sdkOptions) == null ? void 0 : d.maxPlayersPerRoom);
    return reactExports.useEffect(() => {
      let h = {};
      if (a) {
        let g = function() {
          const y = Object.values(r.getPlayers()).map(
            (S) => new Ac(S)
          );
          let b = {};
          y.forEach((S) => {
            S.isAnyButtonPressed() ? (h[S.playerState.id] || (h[S.playerState.id] = (/* @__PURE__ */ new Date()).getTime()), b[S.playerState.id] = (/* @__PURE__ */ new Date()).getTime() - h[S.playerState.id], b[S.playerState.id] > 2e3 && r.setState("__launched", true)) : (h[S.playerState.id] = void 0, b[S.playerState.id] = void 0);
          });
          let x = 0;
          Object.values(b).forEach((S) => {
            S > x && (x = S);
          }), r.setState("__gamepadPressedTime", x);
        };
        const p = new Bm(g);
        return () => {
          p.stop(), r.setState("__gamepadPressedTime", void 0);
        };
      }
    }, [a]), t10 ? /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          zIndex: 101
          // "-webkit-backdrop-filter": "blur(0.3rem)",
          // backdropFilter: "blur(0.3rem)",
        }
      },
      /* @__PURE__ */ U.createElement(
        ki,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            // width: "70rem",
            maxWidth: "500px",
            // height: "99rem",
            // maxHeight: "160vh",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            // height: "100%",
            // transform: "translate(-50%, -50%) scale(0.5)",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ U.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              // padding: "2rem",
              // gap: "2rem",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "95%",
              padding: "1rem"
            }
          },
          /* @__PURE__ */ U.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Party maker"),
          /* @__PURE__ */ U.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Invite friends to play together"
          ),
          /* @__PURE__ */ U.createElement(
            FS,
            {
              noAbsolute: true,
              baseUrl: n,
              size: 128,
              noText: true,
              containerStyles: {
                // transform: "scale(2.5)",
              }
            }
          ),
          i ? /* @__PURE__ */ U.createElement("div", { style: { marginBottom: "2rem" } }, /* @__PURE__ */ U.createElement(s0, { expanded: true }), /* @__PURE__ */ U.createElement("hr", null), /* @__PURE__ */ U.createElement(
            tE,
            {
              allGamepads: a,
              holdProgress: s,
              playerLimitHasReached: !c
            }
          )) : /* @__PURE__ */ U.createElement(s0, null),
          /* @__PURE__ */ U.createElement(_g, { showEmptySlots: 4 })
        )
      )
    ) : null;
  }
  function tE({ allGamepads: t10, holdProgress: e, playerLimitHasReached: r }) {
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "row",
          padding: "1rem 2rem",
          transform: "scale(0.8)",
          marginTop: "2rem",
          alignItems: "center"
        }
      },
      /* @__PURE__ */ U.createElement(
        "img",
        {
          src: BS,
          style: {
            objectFit: "contain",
            height: "105%",
            width: "3rem",
            marginRight: "1rem",
            animation: "1s wiggle 3s ease-in-out infinite"
          }
        }
      ),
      /* @__PURE__ */ U.createElement(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            lineHeight: "normal",
            textAlign: "left",
            justifyContent: "center"
          }
        },
        /* @__PURE__ */ U.createElement(
          "h2",
          {
            style: {
              padding: "0",
              margin: "0",
              lineHeight: "normal"
            }
          },
          r ? "Room is full" : "Press button on game pad",
          t10 && /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement("br", null), /* @__PURE__ */ U.createElement(
            "div",
            {
              style: {
                backgroundImage: "linear-gradient(to right, rgb(141 107 237), rgb(141 107 237))",
                backgroundRepeat: "no-repeat",
                backgroundPositionY: "bottom",
                paddingBottom: "0.5rem",
                backgroundSize: `${e ? e / 2e3 * 100 : 0}% 20%`
              }
            },
            "Press & hold to launch"
          ))
        )
      )
    );
  }
  function s0({ expanded: t10 }) {
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          // background: "#000000",
          // color: "#ffffff",
          transform: "scale(0.8)",
          display: "flex",
          flexDirection: "row",
          borderRadius: "1rem",
          padding: "1rem 2rem",
          marginTop: "-3rem",
          marginBottom: "2rem"
        }
      },
      /* @__PURE__ */ U.createElement(
        "img",
        {
          src: LS,
          style: {
            objectFit: "contain",
            height: "105%",
            width: "2rem",
            marginRight: t10 ? "2rem" : "1rem",
            animation: "1s wiggle 3s ease-in-out infinite"
          }
        }
      ),
      /* @__PURE__ */ U.createElement(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            lineHeight: "normal",
            textAlign: "left",
            justifyContent: "center"
          }
        },
        /* @__PURE__ */ U.createElement(
          "h2",
          {
            style: {
              padding: "0",
              margin: "0",
              lineHeight: "normal"
            }
          },
          "Scan the code ",
          t10 ? " from phone" : ""
        )
      )
    );
  }
  function rE({ hide: t10 }) {
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        "data-testid": "full-room-popup",
        id: "full-room-popup",
        className: "full-room-container"
      },
      /* @__PURE__ */ U.createElement(
        ki,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            maxWidth: "500px",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ U.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "100%",
              maxWidth: "360px",
              aspectRatio: "1/1",
              padding: "2.5rem 2rem 2.5rem 2rem"
            }
          },
          /* @__PURE__ */ U.createElement("span", { style: { fontSize: "40px" } }, ""),
          /* @__PURE__ */ U.createElement("div", null, /* @__PURE__ */ U.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Room is full"), /* @__PURE__ */ U.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Looks like the game is in progress"
          )),
          /* @__PURE__ */ U.createElement("button", { id: "btn-invite", className: "close-btn", onClick: t10 }, "Close")
        )
      )
    );
  }
  function nE({ hide: t10 }) {
    return /* @__PURE__ */ U.createElement(
      "div",
      {
        "data-testid": "full-room-popup",
        id: "full-room-popup",
        className: "full-room-container"
      },
      /* @__PURE__ */ U.createElement(
        ki,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            maxWidth: "500px",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ U.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "100%",
              maxWidth: "360px",
              aspectRatio: "1/1",
              padding: "2.5rem 2rem 2.5rem 2rem"
            }
          },
          /* @__PURE__ */ U.createElement("span", { style: { fontSize: "40px" } }, ""),
          /* @__PURE__ */ U.createElement("div", null, /* @__PURE__ */ U.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Disconnected"), /* @__PURE__ */ U.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "You were removed from the party"
          )),
          /* @__PURE__ */ U.createElement("button", { id: "btn-invite", className: "close-btn", onClick: t10 }, "Close")
        )
      )
    );
  }
  function iE() {
    return reactExports.useEffect(() => {
      console.log("Player left the room");
    }, []), null;
  }
  function cc(t10 = {}, e, r) {
    if (window.__playroomjs_mounted)
      return;
    var n = document.createElement("div");
    document.body.appendChild(n), window.__playroomjs_mounted = true;
    const i = (o) => {
      delete window.__playroomjs_mounted, we.reset(), r(o);
    };
    oE(
      /* @__PURE__ */ U.createElement($S, { options: t10, onStart: e, onReject: i }),
      n
    );
  }
  function oE(t10, e) {
    try {
      clientExports.createRoot(e).render(t10);
    } catch {
      yr.render(t10, e);
    }
  }
  const sE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0oAAANKCAYAAAC02r7tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAJKMSURBVHgB7P13lGTped95/u69YdNX2vKuq7ur2gNomAZAoOFEigBJQCIJzpwjDXfEkTlaacThH7ua0e5yjjRnj2bnSHtmNbPSWVkuJVKOFEkJokhCAEk4gnDtvSlvs9Jnhrv3zvPcG1FVHV3VXSYzKyPy++m+FZGRmZGZkVFR7+8+7/u8gaRUAAAAAIArQgEAAAAA3oKgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCgIAAHdFUCzaH8F135c2GgIA3D0EJQDA3WVBIbAjmppSUC7bv0z2T1Nqt6fJDT4+lMLwHUPGVuc/r6JIKpXsx7nO5A57d+OFF6Q4VrK6KgDA5iMoAQDuqiwoWDiqfurTKuzZq3DHDilJlNygohJ4uLBAVZieVuBhowdlP0N1QEGlkgema9/nIcqOi7/w80qWl5S89JIAAJuPoAQAuLu8omRBqfzIoyo98KCisRGlaarUqinX/XD7WA9I4eBg71aUPBxZRSwoXKcqFuR/ZD9n2JtBEAD6AUEJAHB3tStK5UcfU+VDT1hQGspuTm/w4b0ZjW6Dh6kerZgBQD8gKAEAtoS0VlO6uqrUg1JiFaVGV0XJE1IQZtWmIE3Vt4qhVZxoSgsAdxtBCQCwRVg4uraBQ3cY8jeDpP2u/g1KQftHu26TBwDApiEoAQC2llQ3nnfXz5WkbtWqAquyAQDuDk5XAQCwBXmziqxdOgDgrqCiBADAFhSNT0hsOgsAdw1BCQCALcYnGBYOHHjrmi0AwKZi6h0AAFtQMDCgoFwRAODuoKIEAMAWVD56TEGzKQDA3UFFCQCALSgcGckbOpRKtAoHgLuAV14AALagaHpG4eSUgmpVKjABBAA2G0EJALDtpVvoSOwP7+EQjY4qmppS8fA9WXUJALC5CEoAgG1vKwWlzjfklSSfehdOTmbT7wAAm4taPgCg77SUh46WelArtj/sGBtSsntGlSc+rOTCBbXOnNFEVLQznEH2YXUrO/nRTFMlVyMWAGCdEJQAAH2jExcGgjxMvNs/cv5+n1oR6eYF13zO7UzLKLfvo/0tvqO4WNLazE6tTcyoNTKlqSRU1P4hZ+O6HU2djWuqJbEAAOuLoAQA6Bu+Pav/w7bHUsiwXU69SxjZYe/3SW2DuonU0ub3X7EPH2lf3goPVzvte/OAVXy3z7VKUWvHuJZ+5EeUHp9XujqsvbOrKsT5JrR/VLusP1q7rF9fPq3TyZoAAOuLoAQA6HmdSpJHCM8fD1gYOWxX3h+9cxrxkOShpXALQSmrJAVXP/dW+MdXg6tVqXeS1YgqJTWnJ6S9+5QentPA3EuKWi374mXdm7TUsjD15dULOh/U7XoiAMD6ISgBAPpC1jHODs9Gu+04YmHpifAWSz5biAcl3z8pHBpSOj4uTUxZuno9qzQFUUnThYpWk6aGwojOTACwAQhKAABsQdeGn6X33q/6zLhGvvu8onheBasm7QrLGq8UdU9xSJdaDb3RXBEAYP1wEgoAgC0oaB+ZSlnp2LDiSik7lCQq+s1WTRoJihoKOO8JAOuNoAQAwBZX2j2lgWOHtPrYfVo5dlDpyprCOFE5LOi+0pAeKg0LALC+CEoAAGxxhShSqVhQeGSfAjsUdv75TrW/NKjD5SEBANYXtXoAALa4QsGDUajovv3SQCVvu+cbMaWp9hUHtJz05Na6ALClEZQAANji0vYRHT2sdHKHVu47qNLcoop2HIqqisrSfaXhLDCdabGnEgCsB4ISAABbXGefqHBiRGkcq7lzQlGjqeLsvIajosbCWFOFkpJWKgDA+mCNEgAAW1zYPgYqJZUnR7X8hY+rcXR/1v1uICposlDVh8vjurc4KADA+iAoAQDQQ8JCIeuCF0yPqzkxpiRNVUxSHSwNamdUVTEI1Lvb7ALA1kFQAgCglxQjDTx0j3TfAa0d3K2kVFCh2dT7KxM6XB5UJYgUBkQlALhTBCUAAHqI14vKlZLS+/Zr9TMfUH16TGmpqPuLg3YM6f7yiAbZgBYA7hivpAAA9BAvFoVRqHR4QPHMuJJySYUw1HAaaDgs2lFQREUJAO4YFSUAAHpMZEf12EGNfuFJNT72Hq08dp9Ub+reoKqfGzmonVFFAIA7Q1ACAKAHeVgq+hVfp3Rot9JCQdVCUXuKAxqPStoRlgQAuH0EJQAAepDPnfe6UfDwESUfflRJqajx8oAeLY/qUHFQuwtUlQDgTrBGCQCAHlbaN52tWVp7z/0Kz8+q+toJvc/Ckq9Veq6xKADA7SEoAQDQw8KRIYVxqsa+GZWbLZVeTrU7qiihoQMA3BGm3gEA0MMG7Bgaqkr/p88q/RMfULp7Sk+WxvVT2qE9hap2RKxVAoDbQVACAKAPFKoVqy4NqjUzoUKlonJU0K5CRRMEJQC4LUy9AwCgx4XFgob271RjtablC/Maml9SsZnqRwd36qn6gl5tLAsAcGuoKAEA0Ad8RVI4PqrosfvUstBU3zWp94ZDOhJUNRIWVQz4Jx8AbgUVJQAA+oDHoGh8RNF77lfrwC6lq3W999VBnQvXsg54cZKqmSYCANwcTi8BANAnvE14pVpW8wsfV+3P/4R2jU/rkbEZ/fTwXu0vDggAcPOoKAEA0CeCIFAYWGVpdEixXx8a1Eiyqt1RWaNBIZt+R1UJAG4OQQkAgD4RtI+RI/uU2uXcp96nqVeP64t/uKw3okVdjGp6rbUqAMC7IygBANBnOlvNpk88rMJASeXXT+nohWUtLKZ6bYmgBAA3gzVKAAD0mawDnl/58CMqPnKfRvbs1LHRKX2oOiEAwM2hogQAQJ8aHRtSev8Brf70Z3Tkt0Lt+06ih0ojWklivdFaEQDgxqgoAQDQp4rFgoKpMSX37tP45IR27ZjQ/qiqibCUNX4IrkzSAwB0o6IEAEAfCyfHVPRjflHR4X36P/9PL+rZeFnPNBcUB6laqQAA10FQAgCgj3nNKLIj3TWtVjPR7j17tLA8p0P1M5qNm7oY1wUAeDuCEgAAfSxsH7WjB9Q6slcPP/iQipfP64OXT+ipxgJBCQBugKAEAMA2UCpGKhYiJf/Vj2nny2/oZ19+Xb+2dEoXWnVdTBpsRAsAXQhKAABsA2GY929qHdyt8vKKDpYGNRmVVQ3o6wQA10NQAgBgGwkeOKDqzh06OPI/6Au/8ds6Ysdfu/AUU/AAoAunkQAA2EayhuCVkrRrUjsO7dehY0d1z+CY9herAgBcRUUJAIBtJDtDWi1LDxzWnvkl7YkjfeTlp/SmXZ5orgkAkCMoAQB6XtA+XJJKS2mqWqBrbsVbBPa4RKGC+/ZLI0P68e98RyfOndUf/tF/0EoaayVpCQC2O4ISAKCv+P6pXhdpCu8otLA0PS5N7tCDh45oLCxqOIjUShOtCABAUAIA9BUPSqt20Jrg3aVhaEeqsb/6M6qcvai/9dor+nfnXtWvn3slC0w0DAewnRGUAAB9xwf4qfCu2tMTI6sqhXFLRx55UPeUmrpn7bJOLM9rpUVdDsD2Rdc7AAC2Kc9J2UBgoKzqnp16/Bf+vD73Ez+u/+aBD2rX4IgAYDujogQAALLmDsn0Du196Kg+tLqmb144odJaQ883lgQA2xEVJQAAkAWldGZcex46pg998km9d2qvjhWHBQDbFRUlAACQ8bOnwb4ZadeE/uv/+1/Xx59+Tmf+x7+hS626XqGyBGCbISgBAIBM1tuhEGXH4M5pTc0vaNfklJqLcyo2V9RM6YMHYPsgKAEAgLcZfOw+7TuyR//X1f+Hvvatb2rtn/0TvdlaZTNaANsGQQkAAFxXoVTS7vc8qEejRJ+fvaRf+9pXdPrSRS0mtA0H0P8ISgAA4LqiUlF73vOQykODGo5DfefF57V4eY6gBGBbICgBAIB3NLxrWkd/9BP66bnz+vCJk/rbf+/vKk6lehoLAPoVQQkAALwjryj5cfSRh7VjYlLT45NarK2qubqiNE2zAwD6DUEJAADclA9/5hPZ5crikv7oe9/RL//bf6XV+poaTabiAeg/BCUAAHBL7nngPi3FDX3k3Bk98+wzOnfhvJqtJpUlAH2FoAQAAG7JE5/+hHYfuUfTe/bon/zjf6TFry9oMW4RlAD0FYISAAC4ZVNTk/rYkx9TUinqYz/2Of3jX/qnOnv6tBbtAIB+QFACAAC3bGBwIDuOHL1f5R07VBoaUqlaFQD0C4ISAGBLSJstpQ2aAvSa99x3X3ZM/JNf0ndefEF/43/7e2q89JIdLwoAehlBCQBw9yWJ0paFpGZD6E3DpaJ2WWXp8Yce0vlAOhe3tHzunFq1mv1uWwKAXhPZ8YsCAOAuCfyPNNXAJz+pcGxMhb178nfEiW6Vb3/qZwAPhYH2BYEeCwNhc8wMDerwnt168pOf0PDBQ1ravUdnnn5asXfDaxCAAfQeKkoAgC0hbcVK2Y+np5Ut8E7HqZ48fFj7R0cUWaXw8sWLevq3fkvxxQuKL1wQAPQKghIAYGvwCtJtVJGwdYR2jFhYum9yUvtmpvWVWkOnzp/Xc9/9rtLaGkEJQE8hKAEAgPURBDayCOW97ypWTfobDxzVwoPHdOzhR/Sdp36g7z31lJZ/6zcVnz6t1skTAoCtjKAEAADWj4WlwKpKvjpsqlJRKZUe2Tmj+tJh1eJYr5w7p6VdpxSUSkobdSWzs0pqtayhBwBsJQQlAACwvryyZIdPxdthV3/GqkzvOXqfnrz/Pv1/nviwXp6b0/Jv/oaar7yitd//qmTVpWR1VQCwlRCUAADAhpv0GlOQ6icGKjoejOkPPvhBzR88qDMHDij5/veUWniqP/WDrKFHsrAgALjbCEoAAGDDTVhOmrCwNDRQ1dlqVac/+CGdqdV0+UNPKN25U+n582qeOqV0bZWgBGBLICgBAIBNsysINGWh6W8XQ70SVvX75ZJ++2e+qNlmQwOf/Wy2Zqn+x3+smlWZWqdPZ9Pz0uVlJctLAoDNRFACAACbxtctFe2YssC0HEn7gkj7igVFVmma3Z2oOTSs1sULKl6eVVCwYYqFpHhx0T7JrjdbSltNqV7P7itNUwHARiEoAQCATeUd8cp2HLWwdDQK9HiSat6OvzMyouWxUb10+IAGfvKnFFkOajzztOJz56zC9H01X35ZjZdfUuPZZ5R6p7xGQwCwUQhKAADgrpqx5DRqlz9hoemSxahhC02nE2neKkbpzLSCoUFVBwdUuvdeVR5/v5qvvKxkbU1N75Y3N5cfCwt5u3GrPmWVpjgWANwJghIAALirdno7ceVB6bRlnHqcqOZVJp9Zt3NGob2/fOQeqyI1sqN1wgLSyrLWvvPHar3+uh2vWWg6mYWkZGVFQZIoJSgBuEMEJQAAsCWM2FGxzPRno1CPBanOKtWX4lTn00SnLDgFYSgNVVU8vF+FVkvF/XusslSz8LSm1plzipeW1XrzzazxQ+vcOas0XVa6tKTmieP2MXXFFy9m0/V8nVNqny/WOAF4BwQlAACwJRTbx6CFpWYYaMpyzIsWZgp2uZDmtzUtRGlwMFvnFI6OKmp/bjSzW4kHpekpxQsLis6cUXL+vN22pKBcVlKrKRwYyNqPZ3s1+Qa3VnVKrfqUBSavQq2tZffl7wcAghIAANhyjgR+BHqPhaOzlmO+FCd62qpKTzdinbBLqwepqryLnh/R+JiiyXGVrNrUkTYt/NjHZgHIKkixhaZ0ccFCk1Wgjh+3ypMFq3aYipcWVf/KV7IOe62TJwQABCUAALBleQgaDbxDnlWbLDSNWfXnu1ZPWrLwdMmuWz1IXv8pxKmCNFF7uVMuyI+gWFAaRQpTqyAVAgWNAbvZPrfZUMEqUF5t8uYQrZdessQVEZQAZAhKAABgy/KpeDvs+GQU6j0WjOYV6V9adem8BaX/aOGoZpc+Ya5it0Xd/RsiT0kWtSoVhR6ahqr57X7zPYff9rVq3/5jBeWK6k8/JQAgKAEAgJ4waOUiD06fs9C0aAFpv739uoWn15JUx+2o2ft8K9rOdLzQG0B4zcnXH/kdBF136OWnMMzXKfnh+zKxPglAG0EJAAD0hFL7eMgCTiPIO+QNWRWpaZeX7Kin+dolb/CQZaK0/cd1mttdCU5+WGUqtYqU4lZ+AIAISgAAoAd5YHqvBab3FgL9N3b9Kd+k1i5/s5XorAWm5+1tn5Ln9aEB5XkoEgDcPIISAADoed5SfNTKRPeGgYa9OGRvX7bbF+1Ybe+X5EuYgmsOAHgnBCUAANDzvJW4txT/kAWl8xaMXrFs9C2rKr1hx5fjNAtJK8orUT748TVMBCYA74SgBAAA+oYHoB0Wmu4PvFteoJUw1WF7e95ufyHJu+X59WULU6kdgXfLs0um5QHoRlACAAB9wytE1faxM+zcIl20MNRIA9WUaqXd38GrTFlYIigBuA6CEgAA6GvvDfNJdj9k1aWz2V5M0lfjVKctLT1vx2wY6nLWQpyJeACuIigBAIC+Vu5cBoFSO0YtLN1nmWjCjiiRztvlBYU6WS5rrVpVPch2X1KSpgKwfRGUAADAtjHuf1gQ+slCkG1Oe9EOrzKds0z0z6ZndHGtpqUgUiNN7P0EJWA7IygBAIBtydcljcgbQAQaCVJ9bnq/lmuhPjywX2fVtPDU1IW4plqS6HRrLQtPtTQWgO2BoAQAALYlHwR5UBrJliYFmpzep1a9qIYFpedU0/Na07P1BS3ETS0mTa1aSKrFBCVguyAoAQCAbc2jT0t5J7yC1ZfGC1VNlkf04XJJrSRWyypJL3lgsrB0tlnTy60lXWw19N3anFWZYs226lq2y3qaCED/ICgBAIBtLW0fHQWrLhWCSNXQhklBlL13NRnQaNxS2dcv2dsDQV2zcT2bilcOQgtRLfuYOJueFyvNjzS/pCkE0JsISgAAAFf4JrQWbxI/WhaZ8pbhB8s+SS+//hmPVb5eyT7Gp+Odbq7qjeaKLlll6bnGouas8vSmvX2mtaYzzTWt2MckNIYAeg5BCQAA4AauxJsr0+o8OuW3FoJAVUWaLlRUCiPtKybaUxrSWtrKpuN9e21W39ZlPW/hqUFVCeg5BCUAAIAbageca4JO2q4zZVP0wlBVC0kzwYA6FSevHjXipipBmFWZXmkuZ1PyAPQWghIAAMAtSa+pNPk1C0jeNjzI602h3VIKCxaUIg0EYTs+Aeg1BCUAAIA7kr7lwje0De2I/CAmAT2LoAQAALCevMpkFaY4TdQIUto4AD0qFAAAAADgLQhKAAAAANCFqXcAAACmVSkpsAMAHBUlAAAAkxQipXYAgCMoAQAAAEAXpt4BAIBtzRt4Z3sf+WW2LdKdt/T27WVTiY53QA8jKAEAgG0tah8TaR5tUs9Jd5CV/F7iNFbT24MniQD0JqbeAQAArBerRsV2UbeQtJK0tBA3rbpEXQnoRQQlAACAdZWqZdUpD0trVllKU4IS0IsISgAAAADQhaAEAAAAAF0ISgAAAADQhaAEAAAAAF0ISgAAAADQhaAEAAAAAF3YcBYAgK3INypt2RHH9q91lB/BHeyCineVhnb+OArtMrCHOhCPNrC9EZQAANiK5pakpRXpxePSA4elXZP2r3ZIWNpAqyODSkaHlAyUVA5CVTyshky+AbYrghIAAFuRb1I6vyw986qN4GvS1A7pwUPSQEWqlIX1F1slKbFglEY2PErYJBbY7ghKAABsRbFVM+YWlXzp69LOCQXDAwr+6s9Ik2P2NkFpXXkotaNhFbu4GCkqFJW0YqnVsgpeShUP2KYISgAAbEWRr5eJFBSL0htnFSyvWJHDBu3Dgwo+/6R0YKeCA7uEdeBBKAtDBCIAVxGUAADYinzgHraPxWXp8qL0wpvSxKh0aV6aGhMAYOMQlAAA2OpKRaUDFQWnLkinL0p//e9JRw8qtSP4U5+w6tKubHoeAGD9EJQAAOgV0TVd7+aswvT6aaXffFbBmUvS++6XqtW84hQyhex2BKWCQgulQbmkIK1LLQHYxghKAAD0imIhD0reaOCkVZdeP6P05HmlM+M2sE+lvTMKxoaV7SdPWLplkVfthqoKB+3S96/yboMR7cGB7YqgBABAr+kM3n1j1IVlqWmlj1/9HWn3lNJnXlXwgQeypg86SLOHm9LuegcA1yIoAQDQa7yqFLWrRvWmtFaXZheyoKTVNWl6R36doAQAt42gBAB3SRBF9ipcUFAq2YA3VDA4dPOfbGe/09UVpfW60lpN2IY6La3L7epSkkjnZ6UT55T84Q/suRUp/MlPSffslT78SL5h7fCAcB3tx3JkaTXb5De4vJBPb2TaHbCtEZQAYB0EYWcqlF0Wiwo8ALUvVSxlg9YsGEV2uw3Isr1xfI8cf3+5nH1eODR8818wTZRYUFKtnoUlf1s+e6jVsgxlV+JYaaORDZ7TplUckjgPVb6Bpr2dXaK/dIKTPdeyJ0Nix9lLWcc8vfimtGwhYHzUqk3jeSUq+zhcK7C/RmrPwGOFFwCCEgCsBw9FHpKsOlSY2algeFiFnTsVDg4qmJ5WNDyi0G4Lx8aykBTtGM8/3j+vUslCUzQ6evNfzwJQstKuKFkgShsWhuKW4sWF7LZkdVXxeassWLUpuXhJ6dKiWufPK75wXsniotKFBaHPeEjyZg92BLGN+FsWiP/916QhqyJNjkkffFA6uFvBT386/7jxEeGtQm/gkB0pS5YAEJQA4GaFO3YoLFiwGRtVODCgcHRM0bidnR8aUmn/gWwKnQeh7KhUFdjtgQ9aLSR12g57dckDUuBVJK8seVgK85bP3pL4pvkormlVIqsUZVUjHxin7eqRV5OsYpTU8gpSurSc3Z6uranx3HNqnjmlxX/w94U+5lPG/DlSKefVRt+s9jsvZhvWJrPz0g57Tj54WNo1qWDXlDQ2mD8PkUm84pZSVQK2O4ISANykLPxY9Seams5CUmHXLhX271doYanyyKMWdOx9MzNZiMqCkE+/8+l2vi+Lz4p6l3HorZ7AfrdBXOeMeFpr5mua7PCwF73xOkFpO8gqTPb88xDtDR7eXM2fFGu1fL2SByN/jowOSSMDWUdxtJGQAIigBABvka8jilS6/34Fo6Mqv/dxFSYnFU1OqXjwoIKBQRUOWDjySlG5vQapPeUuE/nLapgPtNL2YQPV9CbaD6/3TJ+0s2bFqguBt5G2I7JqWGI/C7aPlv3emyV7TgdR/o/+uVnp9EXpudeVWmBKp8YUfOL9Fp7s8oceswppNZ+uBwDbHEEJwLYVtINEp/rjR2gVI68aFfYfUDgyqoKFIw9KhakpRbv3ZGuOCjt3ZdWhoHh1MXx6zZW0E5A6c3f8jL6/tc6LHm7q3vxrtjce7YSl7OfG9mC/61Yaa9WeLfW0JYvsGm2FCv2pubSaTf1MfU3OqfOSNwU5c0naMZx3fKtW8vuwEwIAsB0RlABsX9Vq1lih9OhjWQOG8nveo9K996l4330qWCjK1hyNDFyZhdMJJmkzrxCltS3eOa4TzGK/9J8iVLK2pmRpUdgeAqsizSZ1PV27rKfrCzrdXNN/P3FUJat8TgwPK603FJy0kPTLX8oqqcm//F0F9+5TcGSf9MQj2RomPXyPAGA7IigB2B68gYId0a7dCgYGVDxwIO9KNzKi0sOPZA0Yirvs7YkJReMTCv1semgVo1bSLg5dU7/xtss92hHLmzp4WOpnXr9btoPdpa6K7fn7emNFT9Xn9UsLxzVVKOuHBmc0bsOAcZ826nsweaVxxR61N88qXbBHcH5Jmhi1t09Lw4PSzHje+KFqH38rjUcAoEcRlABsC9naIwtKhX37FE1NqfLRH1LJK0czMyo99LDCStk+Ju90lc2ca++nkk1Luon1Rb3CW4lvh6BkQ3yCUltiz10/Xmsu69trl7USt3RPaUg7CxXdWx7RRLHa3ofLnuMr9tzwkPTaKaWvnJAGraJ64py0xwLSw/dKA/ax4TBBCcC2QFAC0J/s7Hi2xmhiUsWj96t4/1EV9uxV5QMfyEJRtHNG4dCghaNC1ogha6/dSt+y1ugKNlTpOfU0+3VCvkQtUMFOEhRlRxDqzdaqLsR1nW6t6dHKmB4tj+lzQ7u0IyxqR9kqqcW85XyWOFctbv7RcxaYLCB94xkl+2asolRW+PixrMW4Du+xqtOYNGoVp0qJFuMA+gpBCUDf6OxJlO1f5NWj3XsU7dljFaOHVH7svSrs3aPKo49lHxMOlq98XtJIrrTPRu/z32K7IIg2X6HmM+s8xqwkLa0p1kLSzJsy2vP+EassrURllaKSimGgop9A8GpqsyUtt6tMvg+YT8fzS68oTe/ITyJ4+3lvP+7BqeRNUfLOkdleTr0WnLyq7M1P/HUkSARgeyMoAegbwaAFpOFhDX72cyrec0SDf/JPKtoxpuK+PVc+xvdn9cFdstUbMQAbyFfeNezvwfdqc9nxzdVZTVpI+ss77tGDVmXyI/LNle1jUw8+7emnwexCtkYv/dXfyQORd8TbOSmNWHX24SNZeEofvTdfzzQzkXfQ66WwNDJkSbJuryNWIVtatRDYyAMfgG2JoASgp4VDwwqqFRUPHlK0c2fWrKHy+PusmrRb0fhYtvlrpz13hlID8DZLacsKSKn+YO2SLqVNXUoaur80osGwoLGwM1RI8pJUYH+BioWrAWh5Na8+vXFaunQ539B2x6g0bhWm/TN59ck3tfVLn57n0/g8fBS34BDEq0lWVUqzNvoCsM0RlAD0tHBm2qpG4xr86S+q/NDDKj/8sAqTdja7vdjc1x4ljVgAbuxsK2/w8dr8so5ZQDpWGtZ/Obpf9xaHtWNgIp+7ZykpDdvNTa6pMmluUboYK/WmDz7lrvKUNFBR6p0jHz+adcwLjh3KO+hNjkl7py0sVbZmUIquThvMwpIAbGcEJQA9JSgUsil2paNHVbRj4DM/rGhySuUH7s82gw0GBq1gZGer6/nUOpYdAbfmeGtFl9rNHiYLJX1ucLf2FKt6vwWm8bCskleYUp+8l16tLhXy27IyTNY9r5Y3gvja03mF5qvfzRo+pCND+ZQ8D0rTdjlsFd+ddmJj91TWJEI7J/Kqjt+f3y/T3gDcRQQlAL0lCLNNYsPxCRUOHFTlkUfzPZD27bra2rvRsjEbCQm4HatJrFXFalrwuRAX9YBVlUphqJrdnkRZW4j8A7MFTLo6Ba8zw9WDknfN8ymvq5fzt1tWcfJQNDSQN4Tw6XeLq9L4aH4n/rZ9TFZ1ajdl4SwHgLuNoARgy/Ng5AOnoc//KRXvv19Df/onVZiZsmP6ymawyVpT/SjpuuxcT7tuu1aqty/D6gxvaWGBmzWfNLPj/zX3ioaDgqajkn50eLd2Far62dEDqoZFjRWsMpSdobAK07XFH7/u0/NUvHJT4CcvFlekrCFEkm/c7NPcSgWlXjmyalTqa5kq5awZhCZHFXiw8mYRXoHyaXsWqIKhat4kwqtO/vFZF77i+rQn9/sqFQUAjqAEYMsKymWFo6MqHjqsaGyHqh/5cN6wYXzM3le52qShx088d779TgC69sfpDPui9vW3rJnwGUr2h7+Ql6752PCat698vA1CfZZUwwa8cVTUeGlIvgIj7Fqx7i3SfVKVVxOadj1ufz++YWnL3lNLrsazur03Kx7QHaPvWY1WS2ms5+oLOtuqWViqaMoOb/jg3fKGooI9l8L2861d2u1+XnR6lHuAStoVI59mFwRXP7TezCtLVrkKvCmEhx8PVj4Nb2QwW/uUhabR4fx+vDudtyT3kynVUn6bhyX/WlnDCL/tFsLTxXnp8mLeFj1pf38Ati2CEoAtK6hUVDxyrwY/92MqP/yIBj/5pIKBava+tBn3fJOGtOtoti+vrfr4bk8ekgpBfm7eh6L5ZX6bDRM1YAPNkeDqC7qdg5ede1fJN9299gtasKxbFaBZHNB8ZbK9EWn0tu+pGbe0mLa0kLTUkIelVI041ooNlH3tSsclb5Rh6YtZjv1vzX73a/Yc+M+rF7O3X6gv6sHyqH54cEYfqE7ooD3rBqKyZR4PPfaMCdLrlDXzjnJvWXfUaQiR5hvcBt5Bz9++NH/1fXFyZRpemjWJsK/jbbz9fgbaTSE8IPn1Tstyr1R5eBqzvyHeVOJmLS7na6vW6nknv3alC8D2RFACsKV4Fck3ix347OcUzcxo4MlPqnTkHkWTE0p9UN/Mu26lPbQX5LUboCZdt/tRbm8EOmUhqGLXh5QHpKJd39UORqN2ZtsjoleKRmzg5vFm2N8O8tuurShdqTD5yfquvl1xsaKkPKxmaacNAq0K0DWI9AX6XlWq23faSPOQlI1VLTi1Uh8wJ3YZZz/Hby+f02vNZX2nNidsL2esqrRsz4nTrVV9szarmaiiD1cnNV0o64hVKytBpIpVLq/8RU3Tdm7qrjIFVxtAdHTWPXVuuyaJZ5tKe7XH1zn5E9w3wu3cR7a2qXM9aHfga1eZbpbftx1BvZFPD+y1DXMBrCuCEoAtxbva+dqD8nt9L6Q9Gvj0ZxTameKgVMgqSGmc9twi704g8vrX9YKSRxkfjo3ZAM/Dz1QnLNnlEbvNQ9OkDfz8Ng9SE0Eensbbn3fdaXk3UrDP9HUl0Wh+Jr46eJ1v2KpE9jXe8r0mPvkqv63hQck+xqdgeZAiKG0/c0kjO443Vy0s1TTh0+/sRMbBZFB77PkVWUipXFkZdxN/X6+t2gRX/ni7pF1h8kCTnXlIrqlKpVdv64Sn26kI+cf7dL7OfQDYtghKALaEaHo6m2Y3+nN/XsXDhzXw8Y9mg55sHNSyQXqPNGvwINEJRHZOOhvueajxalDFBl17LfD41Lj7Ag9Ege6xtyeDvII0HeTvG9cmyZLa9QexYZq+ddpecPWsfFYpsJ/sQKGq49GKsL292VzJju9aYK7a82R3VNYjlTE9XB7VF0b2aCws6WB55Gp1M21XhW9nbZtXirLpojdZJUpv88QKlSQAIigB2AKK+/ersGu3Sg89lHWyi0ZH2wlJ12/htoWk17n0IZxXg4ZtYJhNlbNj2N+2ILS/PYVurx3jXh2yS2+Q7C/GHpZK2rjvM2/K4A9tmq1fYjdNrDdv7FFLE12M6zreWtUz9QUN+ro4e74NhgUNBAUN+do4dVVr0rddWR9UhADcAYISgLvKu9oNffG/yELSwI/8SRXG7Mxzqbjl2313T6fzBgydiUYz7VB0zA6vDh2xcLTXru+zy4Ptpgy3sGpiXfj36I/oWpyqGSfZ9L48KN36wDSgyx1uoG4h6XRc0+m1mr62Nqt/v3xGwxaUPje0W8esqnSsNKzHrNrkVaYgq1J2Kj7XXcG0PghLAG4TQQnApssaNpTKKj/+eFZNGvjMpxVNTSvMOtoFWUe7reja7nSdnOGtEArtpgtVu9xng7JdQd5w4VDgHeiCrHI0GuSVpYK2SCHnTip1PrC1H2I5jbOBMXAjq/b8iJOmvl27nE3P+15hTk9blWmqULbQZCdJrMrk14csNBUCn+7mR/vJeb0W4wCwiQhKADadh6RgeFgDT35C5UceyYJSZzyUNlpX90faYjqd67xBdqeJgk+xG7RQ9IBXj+x4Igq0O8gbM+zU1n2RDdoL3297GGqfv5y0smlWwI2sJbHWrO767bXLFoS8W2Oghyqj2l2o6vODsXYVqyra7ZVCJT+JELTXBt2oxTgAbCKCEoBN45Wk0kMPa+CTn1T1k59S5cFjCnfsUNpK2otnts6oqFNw8Sl1nYDka4h8GPfRMMgaMXhDhmMWjHba9QPtz6u2W3dn+xypv11OGlpJ1m+KZNpqWlBuCP0pbm9g/HRtQc8Fi/rm6qwGwkg7rKr0RHXSLov6oF2ORcVsmt5IVFLl2n2+0quVpnSLJyh/zfCTCKsWFJfSlnp7xzdg+yIoAdgU4eBgvoHsvn0q7N2n4t69CkfHstuTZvKOHdg2U+c76NRJfJpcZ+PWTjvuvWGoKbvcZ2/ssY+Ybq9F2m6SdH2Gq75vk1e4vLth0mzebENp9JjOKqRm6ocFCYsPpSTUioWh1xrLmrRgtNMqS3NxUcMWnsYtaHgjiMEospMPoaJ2J8as5hSEetuzZKtsG9DeFiqx/3zHsRZVV6BnEZQAbAqvIHlAGv/F/1HRYNUC0oDSug2May1tJZ3GDH4GOAtHQd6A4aBdfjLKQ9F7wrxqVBTWRZJklaTk0iXFZ89kNxGWtoeGhYjZONHvrl7I3v6VpVNXWowfLg1pslDW54Z2adoC1JHSsEYtOI1ZiMobQXSeJemNN7S9K4Ls9WPFqknLdixme5AB6EUEJQAbqrBnj6I9ezX4Iz+qaOdOC0hVKSpkDRu2yglgH9R0ptp5+PEGDQctDPlWrA/b5Z4gX3d0yFscB1uoIQPQh5p2umIuaeq11orOxXULU2kWkPYUq5qx4DQTVazyNKCSVXZ3Zo0gCllTCF8DFeh6+x+lb7nYjDAV+ndiVS8a7gG9jaAEYEN5SCp/4AMa/NHPKhwfzypJ8pDU2jrTUTotvv3SQ5I3Z3jUBmG+EeyPZOuR8s1gAWy8lgWjy2lTlxv5+jffi6lsFSSfmnegOJAdD5fHNGLh6NHKqIWlqkoWTCJ7f/i2v6fXNITIClBeedqEeqV9iSgLbrxuAL2MoARg3QXFoqKpKVU/9nFVn/yEqp/4hFWWdmXv8+l2d3seSrbxqvI23345HOQtvB+1UHTErt9r1x+woGSRLmvrvVGbwAK4Oc000SWrLnmnxVeby/p2bS7btNbD0w4/wpL2lgaytU1Hi8Masqq1r3fyPZwqFrLGPUTZ/RTCqCu8pG9d23TN9dueypemW2e9FIA7QlACsH6CfAgSTkyosHuPyo88qvKxYyodOaIrZ3Zbd3dN0rXDF9//yL/jnV4xsssHLCjd3+5mtzfgBRLYKhL7m1tP03zfLvv/gurZ9LbTdkJjKChadamoM601jRdKaiZx9vZ8sWFvlzUQFNRIkmyfprI3hrBL/1yfqhemPlkvyafK2de5tiIVqFN9ukXtghX1JKD3MQ4AsG6Cgr2k2MBl9C/9ZZUfekjDf+rz8nFNdnLVN5G9i2dZO2uQ1pTvf+RVovfYMGavhaM/XQizsHQf0+uAnuHhyZslLCvWubiml5tL2e3/+pqP8WrTgFWUHimPqmrVJN+/aaq9rml/YUAjVnnaZbd5sBq1atTIW6bvdQWdIHyX76hTSYrsPvLXmJCoBPQ0ghKAO+eVJAtIxXvuUTQ5pfIDD6iwZ3d7A6L2/kh3KSR1AlJnH5NJ+15H7fKwjV8e8s1h2xWlIUIS0HfqaZxFldNWbfKKknegO2XXfTre8Wgl67DnnfV8yt5I1oq8kLUi9/2dyvbxPmGv2K5ADUbFK1Unf1/UDkH+dqHTRiKrJiWqt/dPqmUNwrf+vk8Aro+gBOCOeUiSVZPKH/iQyo8/rsE/8WmFwyNKso1kk7u6kWxWzFKe2fw4ZKd699nA5qcin2anbLNYAP3JN3xdtbByOX77RsalwENQkFWcBi0oDVqVqWwByW/bE1U1bsHIN8EdsiqTh6UDVnkqZCEp0li7UuX8Nu+6l03pa7+e+BTBi62aluOmWinbzQK9iqAE4I5444bivfeq+pkf1tCf/BGVH3pQwcBQ3tUuzs+lbrZOFcmHRt7u25s1HLPxy34LST8T2dnibA2SDW4EYLvy7nqxHY0g1ZIFqihotDe0DfR6sJIFoEK2limfQOcBKWyva8yrTDmvLOUVqCi73fn91qyidKK1qnmrYsU0dwB6EkEJwJ2xalI0Pp5Nuyvs35/tm5RVku5y56fOdDsPSv5CNxPklaRj7c1iBwRgO0vaJ3E8xGSNyG/z5coDlU/hq1pFqtiuKGWVbKskrdrhHfsA9CaCEoA7MvZ/+euqPPaohr/weaXNREk9zqfb3QWd6XU+6PGF1J+w6tEjNnD5XOSbxtr3uo2n2fl5bg+NzVpN6dKKUj81/m5r0wG8K69M+XqkJd3djp4A1h9BCcBtKd17r4JKRZVHHlFx/4GrZ2PTuzPVzqtHPu73atFBC0RjlgOesDBw0AOSf790nxLntQEAuHkEJQC3pfy+x1XYt1+DP/4T2dtJnOZrku7SdLu6f09+WB56fxRkrb6/WAizKkpF8JDkYZKVEgAA3ByCEoBbEk3PqHjwkAY/+zkV7zmS7y3ic/Bbm9vZqTPg94DktSLvXvdgmB9PeNcqu6y034ermvZ7atTq2doy0fEPAIAbIigBuCXh4KAKhw6p9OBDKh09dmUX+rs15c5XBfh0uxH7Po60p9s9aseYcD2xBaVWs72WgqAEAMANEZQA3JSgXFbpoYdV/egPafQv/kUVdu1UUCkorW/uAmYPR51pZP6VPxAF2mUD/r9YCDWpfENZXtgAAMCdYjwB4F35XkkelMoPP6zSAw+osNNCUnVg01uAp9ccQxaIBu3yoTDUXrvc036b9Ug3RjMHAABuHkEJwLsKRkezxg1jP/8LinaMKRobySpJaX1z1yV52+9OLPMNZD9gIelno1CjQd7IATdGMwcAAG4NQQnAjVkQCeyofvAJlY4dU2FmyipLFaXNeFOXJHUG+P6CNWqVo4ctGL3Pvq/3hVZFCvI1SnhnvhopFM0tAAC4WQQlADfkIUlRpMqHPqSKtwOfmVYaJ0obm1tJ8mqIr0fyUDRpx5NWRXrMQtJ7Qob9N8sfKQIlAAA3j6AE4IbKj79f5Q9+SEM/8eMqHj5sAclCUrp5K138KzXs8LVHRask/Vwh1D2W3Z4MQpXISLekEzbvTPCWitRcq66VeHObeQAAsFkISgCuK6xWFY6Pq7Bvn8KhIXt7QElj8wbFPtUuq4LYH0N2zdt/77FjRqGGCEm3pdMIY720LDQnrHoCAPQpghKAtwksJJU/+kMa+vwXNPxTX7S3K0riZFM73K3aUbFAtNsqST8ThXp/e6odXe22jstJSyvp5k7DBABgsxCUALxFVj3aMa7BP/HDKt1/v8JKKa8ZJJsTkrxm5V9pzELStIWkT1g4eiiU9ga8YN0JmjkAAHBrGHcAeItg0ILS5KQGLChlXe4sKMlbgSebszbJg5LXKLyStN9G9X/Cqkn3tEMTbh/NHAAAuDUEJQBvMfgTP6HikXtVOnww63iX7Ze0CcUkD0e+T5K3/7Zopv+2GGrcLh+0itKAcKdC+yWW7BhdWVM6u2g3BJSXAAB4BwQlAJmgWMyO0oMPqXjooMLBQaWt2I6NryR1cpiP23cF+dqkBy0wVe0YEdZD0D5KTavZNZrX3AoAAK6HoAQgUzx8T7YmafhP/6Si6WklHpA2YV2Sf4WaHV41mrBg9OcKoe7zdUlMtQMAAHcRQQnY5oIospRUUmHvHpUfe0zhQFWeUVIPSRuckzq1qqLykPRIKM3Y1x4XAADA3UVQAra7MMo63ZUfeUyDP/EFhYMWlKJAaXPj2z77V/AsVrVwdJ+FpD9diPSoVZMISgAA4G4jKAHbXDQ5oYHPfk6VDz+h0n33WImpYCFpY0tJXknykOST66p2/NeFUPdbRenxkDVJG8YrhL4+aWlV6dyigtCSKdMbAQC4oVAAtrdyWdHuPYomJrLKUpqm2bGR/N4TXa0mHbIBu7cD90oSZ282iP9OvcX7tc0cyEkAANwQYxJgGyu/73GVH31M4z//CwpKRSWtNK88bGBQ6uyT5Jd/Jgr1kFWRfjLinM2G899ryx75WkPBas1Ok1FRAgDgnRCUgG2suG9f1uEuKET5vjobHJKcV5IG7EsNWjljt33NPYzVAQDAFkRQAraxoZ/8KRVmphUOVbPmDb5v0kbpTLXzVuAPWCXjvRaSftyOQyFJCQAAbD0EJWAbinbvVrRjXJX3vV8ql5TG6UYXklT3r2vHAxaMPhyF+pRdjjL1CwAAbFEEJWAbisbHFe3arcKBA9k6lSwkbXBQ8lqVv+B404Yjlo8etqA0IAAAgK2JoARsI1lL6EJBA5/6tCof/ZjCSiHbWHYj90zye/Yea1MWkHZaQPr5QqBddn1QNF0DAABbF0EJ2E5KJUUTk9nUu6JXk9I8rGxUO/BOocq/xl7LaPYVs5A0bAd97m5B9kC2H83kmt9VZ31XeBOPpn+oT3UknQIAcFMISsA2Uti1W+UPfFBVOyqPv1dJI96wLnd+r506la9N+mIUam/gXe4Yqd8S3/so23gqzfc/iq+p/nm3wuzQu4clf9wjWoIDAHCzCErANhEUClkr8Mrj71c0OZHfuIEdHDpByafb7bTB+f12TDNGf6tGS6rVpeXVbI+jdGVN8mmQa/X8aDbzDWL999S53cOShycPPANlqxIW8yNr8R4qGKhIRXtpr5SUVitZOArGhtrVpFuoQAEAsM0RlIDtIoryoPR+D0pTnTl32ki+qayvTfLGDUft641RzXirlj1CiyvSuVmp3pDOX5Z8M9i5JenyQn59rZEHo4ZdLq1mG8Yqbgel0UELROX8KFtYKlpYGh+1AGUBaWxYmhjJQ9SBXflltZz/zmnJDgDAuyIoAdvEwMc+ruqHnlD50ceutATfKL5XUtWrSHb5aatefL4QaGS7hiQPOXWrAi0sS/MrSp96ya5bOHrxjbyatGjh5/xsHoDml/Ipdv45eZLNg821j92VDoXpW9cbBfkf2Xozryz5m4OVrHlHsndagVeZBqtKT1+UZuetwsg0PAAA3glBCehzQXswHE1NKRwdUVipZAPpNNm4tUnOvoqm7OtMWPVi21WSPOh41cerRD5VbnnNKkSL+XHqQh6aTp3PA1T2voW8cuRT8Doinyp3zRS5rAoUdIWmJA9SnQfdr8fX3Obhq7OOyYOSVZSChSWlPp1vHabfJfZFEgEA0J8ISkC/KxazwfXgn/pJFQ/sV+AtwX1tTGv9g1LSPsp27Lfx/F+2StIBu9yhbcan0FkYSr/3otKzl6RvPy9dnMuOwNcZeZjxsNJpsOBBxq8Pr9/OUnnRKa9IBV5FykJUnE3BC/xrrkNQWkhbWks3rrU8AAB3E0EJ6HPhxERWRSoeOaJox458yt0GzbrzIbMHpWPZmqQ8JI1tl37Uc1YtWqkpfeOM9NpJ6YIFoxffVLC4amHpYt6IoRXnlaEgal92HRvB79eDmAclD0jr2PluJWmpTlACAPQpghLQ5yIPSiOjFpTuVWCD82zK3QYFJb9bb+Bwrw3Ej9rXOridptx5AwYPR1/7gfT0K9LJC3acy8JR0KkaRZ2AZB9fKGrDdR7/aJ1/D+0mICuxBaWEyXcAgP5EUAL6XPnxD6h48KBVlYpZuSf1aV/rnJS8ptC0Y8jG41VLAZ8phLqn3zOSry9aXFH6whsWiM4r/fK3s4pScPxs3p3Oq0e+LqhUvKZqJBooAADQIwhKQJ8KfA2KVTAKe/eoePhwVtXIlt6v89qkThM2j19DlgQmwnx90nQ/BwJv271gFaTzVkHyoOTh6NnX8nVHXlnqBKJOSAIAAD2HoAT0qWBgMOt0V/3gh1R+z3vz2VIbMOUubt9tZMfHLSS9zwLaPZYUBtWH2tPM0t/+Zl5J+r1vZ3sgBQvLCnwvI59W53sVAQCAnkdQAvpUMFC1atJehcPD2XXfnydNN6bTXdn3PrVwtC8IddCuF/utiOLT6Lxa9MrJvOX3d19QcOqC0uU1Bf6YeuUoa5IgAADQJwhKQJ/yJg7FRx9VtGuXorFRpY34yiL89eRrkyYtIdxn1ZRHraz0Aaso3Xnj6S3G9yNaWVP6+9/L9z/6ta/kbbdbebttqkgAAPQfghLQh4JiUdH0tCqPvUfhYDVbJpO299RZL52WECU79tr9PxkF2mOByUNS3xRWvPGFN2rw9UfPvnp1P6TO5q++DiykjAQAQD8iKAH9JsgH8OHgkAr79iustjcxTTemiYOvTRqz4z77usNBn80+8w1aZxekl45LX39aevmEtLSSbwybPc6EJAAA+hVBCegzQbGk0kMPq/Se96r6kY9m1aWktf5T7urK90z6QhTqgxYYPmpHX8UGn2Z39pKS//evZG3AAztUKeUhKey7yYUAAKALQQnoQ97tLtqxQ0G20Wiaz5NbRx67PCr4C8hOq6xMBHlI6ougtFbPj+Pn8g1jG628YUOhs1nsVv0pg3d88+be+Q6BOm1/Vj6PUwAA9DuCEtBngsEBVT/2cZXvv0+hVUDSektpsn5JyYfI3hLc2xf4wPmHLYxNBeqfBg6nL0ivnlLyD/9dNu0uWFnLN47d4g0b3hJ9usNcEN7oI7ukb72edr3NnlAAgG2EoAT0kSCKLBxVVD52LOt2txE8cvmUuyNWXRloX/ZFz7fFVasinVH6zWeUfusZBfPLUr2Zd7XbMmuRgqtVnWsvXSfU2GXLgnEjTbSYNtWyt5fSlneHt99bopq9r55ePziPRIUs8BYtWJUUqWz3PxAUVLDLkfCafy4Cph4CAPofQQnoJxaUglIpC0nh2Jg2Qqei5PfuU+6m1CdaFv9OX5ReelP64+ellVoePoolbV3dAS4PS4ldNtJYi3EzC0WX4rr9ztIsPC3YbWtJfN17myqUs1BUCSINWDAasMskTFUJQ4285Z8LKksAgP5HUAL6SOmBB1W857CKh48oKJflhYP1XE7SGV5X7PhUFOqefhkvf/s56dnXlPzTf591tQs8JPl0uy3w8wVBu+H6lbVBqWYt+NQt7HgAOtuq63xzTa80lrWYNPRGazULRKsWiFaUV5bW7PDw5NUlfzu+wZOiEkZXKkpF+3oF+7pDFpaKdmvFqk2jYVG7ihUdKQ5nIWrRKlVraSwAAPoRQQnoI8HIiKLpnQqrFmUKhXVdm+T83go2Xh+2AfR4kDdy6GnNVn68flp644x0aU5BK9GVzhSb/vO9vb+6h5umRdSl2MJP0lQtaem0BSMPKKdaa7rUqmWB6WRzVfMWjk7HNTUtDHmQWrPP89+ZhyPPRnE7LCU3aNpQSvIpdV5VstqkIq8uWUjyt4txlE2/m7MwthS3sopTzb5GI13nTiEAAGwRBCWgjxQPHVLx3nsVDlWV2sA6bazf2X4fWjfsmLAB9NEw0P02eL631/cRujQvLSwr/dXfzZo4BMtr+ZokP+6CoPPnNWuAli0MXY4b+tbarJ6tL+iMhaRnGotatsD0cnNZ66kTehrvVIWsCwCAbYGgBPSDMLSxtZ35n5xSYWZG662zuawP30flm8tKQ+rhFxDvbNBsSs+8qtQ3kT1/WVpph6S7sUfSlWAUqGaVogWrEHnVyKs3312d1aJVkl5sLOlCq64lu37e3k8lBwCAjUVQAvqAhyRv5OD7JxV27tRG6AQlb+Jwn1WThrM1LD3KpyTWm0qfeU362g+kC7OSVeDuVgvwILi6C5U3WrhgIem7VkF6o7mif7VwwsJTkk2pAwAAm4egBPSBYHBI4ehI3szh6FGlcar1LDh4O/DIjv02oH8gCvTJKNRIL8+6O3VB+vWvSF/5Y+m517OQqfLmTrcLOlUke0yPN5azgPRL82/olIWk7zfmNW+VI18LtEqzBAAA7gqCEtAHgkJBYXVAqpQVVAYsJKXr2u6uM/VuyMb2QxaQBu24O6t41sFaXVpdk85eknyvpGbc7nC3Scmv/XUS+/3U7VGt2+XpVi3rUvemVZC8i93Z1pqWLTjVmV4HAMBdQ1AC+kA0OanS/feruHNG0diIUh/8r2NQ8opSycb3HwlDHbOB/pB62O9/T3rlpNJf/2r+tk+3C6NNaQUeZPMXo2yJ1GK8pufqi/qdlXP6jeUzOmPh6GLcEAAA2BoISkAfCEdHVThwwKpJlfyGdH0qSp1Kkr9QVO04bGFiulen3DWalvhipd95QTpn1aQ4zqfc+fquDf+Zguw/hYFONVezTV+/vHJWJ+z6d2pzWXMGptgBALC1EJSAPhCOjSna3w5KwfpNu/N7yfZOsmPABvqHrZo01ctBqW7Hdy0oLa9moSkPShv9AwV5Dgvytt8nm8s621zTLy0c16xVkHy6HQAA2HoISkAfiCYmVT56VOFANRuUr9ekOw9JFi2038LEAbvjQ3Y5qN6UvnhCev2U9OJxZY9QpbzhISm4Zj+k5+oL2VS7fzT/WjbN7rhVk1iDBADA1kVQAvpAUC4rHB5REK3vX+lORckn9A0GeUjq2SYO84v5fklLVsEpRJveCtz3Qjpl1aOnLTD5BrLsgwQAwNZGUAJ6me+dtGNc0fS0opmdCkolrRcfxncqU/d7W3DfO0k9yLvcLa5k+yWlv/89e4yKGz/dLsjXJNWTRK82l/X3517Vt2uX9e21ywIAAL2BoAT0MN9o1hs5BIODCqpVpT5AX79md9k0Pn+RmAyliV5dm7SyJr15RppdsGrSah6SNqwVeJD970vEErv8QW1OLzWW9KIdl1p1YfO0LOZ7D0HfptdPH4QCAODWEJSAXmZBKZqZUWFiUpEFJkVFJes0o8vvxjeZ9al2+2z0f0/Qm0kpvTgvfft56bVTCi5czqfcbdTPEuStG3yQHiex/tXCCT3fWNTvrZ4XNo+fK/CAZBFZnVYZFQEAcGsISkAviwoqHDyoaGpCYbWST5VL1qcteLY2KfC24IF22un4nWGPBSUv63gF6eR5pd7p7tJCVoHL2oFvAG/c4JvItuyR+/rqJb1UX9Tvr13SxbgmbJ5AV7u9+3PYq0pVAQBw6whKQA8LCpHC8XEFQ0NSyf46N5N1bQ3uFSUPSyM29BxRj/HA6OuT5pek42ft+iYEFqtUxVbS85D0TQ9LzSUtJy1h81wblPw5zO5UAIDbRVACelkUqbh7j6Lh4Xw2WZrY/+sTlHx4v0t5E4e9dn2HekzNQtKX/1j6zgsKXjlpZYXSBnW6C64MzN9sLOvvX35F/3H1vJ61sAQAAHoXQQnoUT6NLGvmULbBf2Fj/ioXLQFYrSqrLPWkS/PS4nJ7TdLGrUvyP861ajrdWtNJOxbipgAAQG8jKAG9ysJRUKlkzRzCwfXdBrYzZcmrSEfCQNVea+TgHS2W15R8/SkLS3MKonADO91F2X1/aelM1uHuV5dOCQAA9D6CEtCjgmIx2zcp8jVK3ho8vbrv0Z3o7J80aLli3ELSLjt67oXi3GXp9AXpzMV8nVIhWv+g5K3Yg1CXrJK0GLf0ry0g+aayAACgPxCUgF4V2eC/YGFpYNBC0/ptNNsJW36PXqca9eu91hl8eVW6vJg3coiTPCRtyM8QZOFo1sLSd2uX1dT6rA8DAAB3H0EJ6FFBpapwaEjR7j0Khoe1Xrydsr8w7LZwsc+OQ1ZRWr8YtjnSF9+UXj6hoLPBbHF9X+q8ktSyEl4jaejfLJzUH65e1CzVJAAA+gpBCehVXlGySlI4MJBNw8uKGetY0Bi0kDRgGWNAPfZC4V3/vKI0O9+uJrXXJ63n1Du7r0YS60xzTSebq3rTjiSlmgQAQD8hKAE9KhiwitLgQLZGyasmqYeCdeBNHAqWKSaDvJlDT+2f5I+BB6XTF6VTF+xt+2k2pJFDqBMWkn5v+ay+U7usZxsLAgAA/YWgBPSo0KfeVat2JczX36xDRcPvwe5NVp/SlHyNUo8tTmq2rmwym84vK/C26f74rJd24JqP63qjuayvrc3qvF0HAAD9h6AE9ChvDe5HVjHxKsodBqXOzL1OUJq0kDSgHtNoSitrSufajRy82120fkGps7WsB6U3s6B0SfOsTQIAoC8RlIAeFY2OKhwba6+/SddtfZKHpAELBL5/0vg6FmM2xeJK1hY8OHlBOjdrr3BhvkZp3eTVu19ZOKHv1easmlTT+kx4BAAAWw1BCehR3sAhLBS13sL24Y0ceu4FohXnU+9arfx6eZ0en/aUu5bHojTUuXgtawveooEDAAB9i6AE9KjQKkrB6KjWiw/5vTrieyZV7NinfA+lXpJNuXvjjLRSsx8mWccmDp3NZVdVS2L928XTWk1jAQCA/kVQAnpUUCopKJezLJDVNdapuuF7JpXtqMqn4fVYM4daQ1pYXueQ1BHodHNNC1ZJWrOQVE+ZdAcAQD8jKAE9KhgczPZQ8iwTWFRK16GZg9dIqhYwBu0+R8MgC0w9xfdPOnspb+qwrkEpv68X60s60VzR5bghAADQ3whKADKdrndTFgp2+vQ75Y0dekbLKjyzC9Jrp6S19QsyPuWuadWjVtLS9+tzeq7GnkkbJWk0lNZptw4A2Bp6racVgA3kQcmn3HklKZJ6Z+JdlvLsj7pVkpbX8o1m1/XuU8UWluatknSRfZM2jj3GaczaLwDA1kBFCUCm08zBN5qdVl5R6hm+JumyVXrmFpXOLynwfaXWZaPZIGsvfrq5qjcbS/pubU4/qM0LGyO5cEFxuaeeeQCAPkZFCehRQcnqPpX1W0XUWeHkHe+q6jFeTapZpacZX21qsY5rlBaSho4317IpeAAAYHsgKAE9KhgeVjA4tG7z4zrNHEa9kUPQY93uvIK0uJqHJd8/yb/9dXx1O9OqWTXpsuaTpgAAwPZAUAJ6VFCtZl3v1jvSjLSPnmJVpHR5RWknKK1Dq3Rv4uBVqVrc0sVmTa82VlRPqChtKN9AuVQSAABbAUEJ6FHZPkrF9e9LV24fPSWbeteQmq18vdL6bCmVNXFopbGWrJJ0Ma6xd9JGi+yfpCgSAABbAUEJQNbEwV8MPHbtCIPs2PasmuRNxn/gLcEbC3q5saTVtCVsnHB0VNHkpAAA2AoISkCPStd5zxmPRpF6rC34hgqyY9UqSg2rUsVZfQkbKQgjBVSUAABbBO3BgR4VX7yocHDwjgfvnbbg/mIQBXlVqac2mt1ArTTRqcaaZuOGVhP299loPpU0KPfcxE8AQJ8iKAG9qtnMj3Uqc+RT74KsPXh5W5eUgryiluabzJ5trWmZbncbKgjztUnR+LgKU9NU7tZZvtbO/kx5ZAHgVjD1DuhVXuGI16/K0emoXRBnUHKpEgtKC1ZNqtHEYWN5O3oLS0F1IGt7j/Xl+YiQBAC3jvEQsM11pt75tLsBO4bs+oC2sSD/w7vdrSUtvdRc0aWkIWygqKBwaFjFfXtVPHQof1Iyrl8ngQX92CqjNS3Z87lBYAKAm0ZFCUA2Jg10tarUky8MUZhP4VqnzXJ9D1tv4FC3QWaL/ZM2ViHK2t37PkphqUxQ6vBQY0/EtPP8u83ntj+Xfb1d4tPveGAB4KYRlAD0Pg9J0+PSsNXCil4o95RzZwNCPwu/Erd0KW5ojal3GyocGlLBKknhjh0KBgbyqWJCtjfY6po0u6C00bIHqnM6AwCwGQhKQI9KFpeULC1lI8rUB093UEnJu94FGrTLijd0UI/xAaSHpGqlHZTu/KWtZY9qw46FpJmFJmyccHBIxf37LTANWmWpmG8anBCV1Gja0co2Ug48rPvfcXISAGwaghLQo5LlJcUWlK4sOQhuPyx5UPKW4AP2+QNZ17seG40F9lI2bDGvWlZQKKzLK5t3CWtaQPJmDnWC0obyNveFffuzwCSfguchiemO7aDUVGBBKfuLTkgCgE1FUAJ6Vb1hx/ptONvh23323D5KPoAcsGrS6JDSybFszYvWYdG634NvONtkAfyGCkdGVDr2gMLhIYXeVYTHO5P6lLvFlU7bOgEANhdd74AelTYbSlvX7KPkYWEdxlKhevDEtVfAPBxVSvkUvOBOBtt5ZS6xBzNu7z+TsGJmw2SbzA4NK5qayvZSyhAKcqv1/IQIjwcA3BVUlIAe1bp0UfHFi7qSjnptutxGmNqh4IFDeXXpjqZuBZpPmlqIW8LG8ZBUOHyPikfvV/k978kCUxITCjqCi3MK5pbyqYg8LACw6QhKQK9qNJU27Gxzq8UZ57bAA9L4aNYF7041bHBat5qSxy0e3g1SKKiwZ4+iySmFA9X8Npo4XLW8Kq3V20/A239cvCKaPY8FALgVBCWgRyWrq0pXVpTW6nlYoqIkjQ4qOLAzryg5ryrdZspZSZtatopSM02yKXhYf15RKj7wgIqHDiraMarQp97FNM7oyNYozVtFqRXfUcrxT221wxIA4OYRlIAeldZqWVBqXThvoWlFQUjrYI2NSId2S3unle6cyNoqM/Demrw7YTgwoMHP/AlVHnlEuI6zl7I9lK6E/fD2/sleS2OdbdW0mjKVFABuBc0cgF5lASCxSpIHpryiJJTsJW2wqrRatuvFfBoXj8vWZIP+oFxWYWZGweCgcB1eLfYW4Xc499NPFfheYFSUAODWEJSAHuX7KAUL82qdOKGwUlJh53R2+7aeJDYymB3Bo/fleyu9dsoCk7/jVl7qfOF8ol1RRY1CrLLdT6f7HdZP5f0fUOnoUZUfeSzvMthM1uXJe20Y8Db3o+rBdvcejny63dlZaWVNd8p7CVbtjEEkAMCtICgBvcoH7l5RWl2Vmk2tFz/73PNnnqfG8qPom88G+QD8FitLkQ3eI9Z9rT97TAOrJhX37Vdx/wEFvm+S/XLSdQyiPkFtWMo2Ty6qB+eY1xp5W/BOYLrD56E/tk1fo0TWB4BbQlACelTazLveteYuq7h252edOzwk9fpKhmDvTDbYTH1fJR8c+jol74R3CwPOchBlB9ZX4A0b7Cg++KDK73tcQamgNLZnXWP91pJ5MJq03/WYBbCKepBXkRaW7bKWhyV/zMLbjXtWDbW/1atxy6qiTL4DgFtBUAJ6WJokii9cyDrg3QmPA94Va81CxaodNU8XvVxNObwnaz2d7t8pLa5k+9FkP090az+Tf/RQWMwWw7dYCL8uookJhTMzKj/0sIrHHlDaSta1muTyoGS/O/Uobwt+aT577madGwvhLVdEg84nJLGadh/L/hymeyMA3BKCEtDLbACULi1J9bruhA+p/Fxzw45mdga6x6ecefc7r1D4nko+0Dx/Wbcj9IpEEGYtwrE+gqEhRTM7Fe3Zo8LOmTvdIui6wnZI6slqkvOpd8tWVVqr5QH/Tk5a2AMc2/O3lrW5BwDcCtqDA72s1VLzxAm1Ls9ni+FTn54T3d50MR9ENdqXPT+g8jPwY4MKvvgZBe9/IA9LneMmeUAaCCKNWUXJr+MO+dqkclkDn/ikJv6H/5vK996jsFzI1+DEdx5EPWsl7cPPAD5kX29Pj1ZFUwv26Ssn8yl43vkuDG89LLUDlleHa/aoeFWUvncAcGv41x/ocenamtK6nXluNhTYWeM7HRum/dRPe9wqSztGlI4O5Y0dbiYodbasscchtAdzICyoQFBaF4XduxVOTioctUpfGG1I15CofXjD8WovPpW940KjtT7VJL87eUUpb+YQ07kRAG4J//oDPSxtttQ6fSpbpxTPzWdrlm51HU63vKLUB2GpWlbwgQel9xyVHjisdKBig8/GzX2uDSi9ijRkg/l9hapGw55rML3lhMPDqn72c6p89IdUevhhK9kNKGmtf1LybvBD9vy9JwyydUo9xUOSV9cuLUinLuYNSMI7+2e6kcRaSVuaixtqEpQA4JYQlIBeZoOgrJnDwkLeJtyC0q2ODf3j/YXAWxWs2UCq1j56X5BXkWZ2SI8fUzA9nm9I64PRm/j5wqw9eKjhqJjtpYTbF/q6pPEJVZ/4sIr79rWLJDf3e7hZnW6NI0EekEaDfO+gnuInOrwt+GULSmcvWQkuysPS7cqm3iWq2euEHzFr7QDglvCvP9DD0tiD0nkl8/NKvEV4Eut2xob+KbGNWb3JuB931hpii/AfyoPS9IQCC0pZYOpMv0tuJiiFKgaRhsOCSiEvlXciGBxSOOFB6SNZUMp+N+n6ByXfTcwD0pRVk0Z92mSvVZR8vda1QelO2oIH+f5UtXYjh1rSyjZOBgDcPLreAb3MBpq+l5KHpeaLL6i4e0YaHNDtSPK7ywab/dQIO/CNZ3c8bAPPWQtN40r/xW/nZ+qrN+qJlub701pIKllIerA0ojcbK8LtG/sLf1HFgwctJO2SFzXS+vo/wzqNHPZZPjgc5GuUei0npas1pcfPSRcuK5idz9v33aFlC0iLSVOzaVN1KkoAcEsISkCvs3ST1OtKVlZuq3tYoKvtwf3Sh7D5mec+aergociPHcPSzslsf6VMp5rxLovlB9sVJZ+Kl7DG45Z4lzs/Cvv2ZkcQFbwMag/9+g7YO89WPwbtz2FvxKEe1PC24Ct5pzvfJPmOmzkE2XS7lj1vfbNZYhIA3BqCEtAHkkuX1HjhBcUf/yEbIE7pVnmXsHr7mLNB1VA/db7r+KHHJG/u8DvfklZq0hunrapUuhqc3iZVwQaph0oDmi6UNWgVplXFdA67BaVHH1P5Ax/Q4Be+oGjHeN68IVn/x88bkPhv0Rs5PGBVmEfD3nz+BpcWFHz7+aw9eNb5rnwnTUTyx2DJqknLVk1aTthFCQBuFUEJ6APxwoJaJ09kU3eyUaOfhb7NAX3DuxP3YU5SqZit90g/8T7p3Kx08bKCtN1lLNun5u2f4gFyOqpoIixlne8accI6j5vgVaRoekblRx7RwMc+rrDcnubo68PW+eHr7J9UtWPInve77fe4sxefvz6N1v/+nrmYB3l/bt5RRSmvs83GDUISANwmVigDfcC73vnGs8lazcZXdzbA8jVKzX7MAh6UBioWlB5X+r5j0mA136DXF9Bfb/Ruj2MelMoat8ODEvsp3ZygUlFh3z6VH35E1Y8/KVU8KKU33XHwVvlvsGzP97EsKOVHz/HHZWVN6emLFpjWrgalO7tTzbYsKMX9tOoQADYP/+oDfSBZXFTr1Cm1Tp9WfO6cgmKo4DbbCi/Z+GxB/Ss8elDpBx7Sys/+mBoPHlJsj1XqYSl+61n3LHDa/0OFsvYWBvRQaSSbfod3VpiaVvnRx7Tj539BA5/4hApjI1klKW1sXFXDo9cuyxTv89bgyqtLPefUhbyadH423+8rut3nWpD91+kqeL5V00J8k/uHAQDegqAE9IG0UVe6vJy3CbfQFGQVpVu6iyuL4bP24Kn6doJZMDIozYwrfuCgkskdSkaH8krH29bOpNnj4VWkkaioXYVKtmYJ1xdYdS4II0W7d6uwZ69KDz2ows4ZC+2Fqy0V11mqq40chr2SFPo6pR5t5LCwbGcpVqXlmoIkueONZnNp1vWuQbc7ALgtrFEC+kC6tqbYjsbzzymoVlR+8OhtBSUfms3ayLMapFe64PXj2ZRwdFCVT30gW49Ve+iIRv/Bv1WwvJpv7nmdaYv3lIf0Ge3Ul2sXdcbO0OPtfK8kX5s09tf+O5Xuv0/lo/cpbcZKahs37asz/B+yX9dROz4ZBpro0Sds+spJ6Y0zCs5dyps4FNanevlGa0UXEypKAHA7CEpAH4kvX1Y8O9s+g69bburg8cDignzXIL+Lfp1o5j+n/2zR3unsrdr9BxWdPq/y+bk8LF0ZpOaP3YB9tDd1GA0KVrkoaCllzUdH4FPEiiWVHnhAhV27VTx8SNH4eN4kY4PLkp1udzvtdzhuz/VR9fBz1huMeFWpE9TXYX2SP7fn4mZWVQIA3DqCEtBH4rNn1HpzXElnPyUf9GcD1ncfsXam3l1WvsYjVv9WlPznyhovHz2o2I7Zl4+r+Pzrmvq1r+Rn8729dGfqU5poIippMAi128LS2WhNSy0GnlcUiwqHhjTwiU+q8pGPqvr4+7JmDkl94x8jr5P4b+mo/b4O2a9sV9iD0+6S9t/VF49bWLrc/ot450EpW2NnYelkc1XzSVMAgFtHUAL6SOP1N5TagD6Zm88G/NHwsNKb3IS2E4qWbHC1kAbZxrP9vogxah+Dn/uokkfu1UW7PvDScQ36oLVSygJTakfRQlMhLOt9AxMasdD02sIbgj08g4MqPfSwhn7ypzXw5MdUPHTIglNZaWtj18R0WoKX7RixJ+6nokD3BHlI6rlVZIsr2Z5J6Yv2nFpYUVAs3tn6pCD/wytJjTS2kNTQCu3BAeC2EJSAPpKuLCtdtqjTbNiAK7paJrqFKVB+lt6GbVcWyvezznC0sH9n1ha9vmda5dMX8w54aaejRWofF9oJ/lA7LCRNFcpCW6GgaHpapaNHs8YN0YRVM727XbKxz5zOc9NDbsWe4NMWkgaDHgxJrmmPV6PZDkyNvJq5Dj9Iw6Jkzaqh3siBvb8A4PYQlIA+km06a4Ot+nPPqbh7lwo7RrPbb2aY1Fm3s2ABwQefJ2ywO2U3Tm+DTm9DdrQsLBX++s8q/vZzmvv281mDh9AHr1GSTS+zkpI+NTCjlcq4/t7cq2ra41RLt+eZ+nByUkGprJl/8P9Tce8elR97xMJ5oqQeX51KtoH8UfdA/7Eo1D5Lux8Pe/c5mn7n+Wx9UnBhLg9J0TrUcS3Uv9lY0eW4rsWkZZGJoAQAt4OgBPQbqya13nhDYdaQ4AHdKh9S+bS7JTtGtX348NTXLYUTY9m6pcZj9yu4OKfCqycV2ln5oNnUSFhQyYLj3uKADUCbOt1c03biXe18PVLliQ8rHBnNQlJ4beOGdOMH5J2v4P94+bqkvb0c5L3ydmleOjt7tYK5Lo0cgqyBw4I9RxNteIEPAPoWQQnoM2mjqdq3/yifeqcndatiG1T5NDRfr7ND24cHpYpVQ1qHd6t1zx4tewey0xc19L//K0XNlgWlliarFXvVLOux8qjeaK5uu6DkIalw8JCGf/qLKt57b15JspCUNDansubjff9K/rvyZ/eHrQKzp1eDkqcXD5gnzkkvHc+ne/qGxusQktzluKmzzZpVPtlDCQBuF0EJ6DNpq6nGiy+oYGf747kFBdVBG1VG+UDsHXSaOXg1qWFD0vM2kNuzTuslekYYZgNw/5EH3/+AkiNLWq3XFT37mgp2VBZWFFpg+hODO/XNtVn9oD6fTcGL+3wwGpRKqnzoCZXuP6rqk09aQHpUhakpC+WtzSgiXeGPsk+522dhYr/9ku4Jg96dGrpiIfvifBaU0uPn8o1512mTWe/UeN5C/KnGqgAAt4+gBPSbVkvx2bOKL11SsrqmsFxR4NPwbvKkvw9GvaLkU+/q2n46a7VK+2cUz+zQ0uqqolpdyZtnVVq0oGQVuwdLIzrVWlXRPtoXyvf7SiVfj1Q84hWkx1T99GdUGBux24pK1ja/7bQH+RE79ltA8l2werbq6Q0c5haVXl608s9CHpLWLfSlWkma2RolAMDt8/HALwpA/0gSpcvLCgcGFE1MqLh/r6LBwXdt2dxpkFdrX075Why7cm8PL5S/E1lgsoA5MG1D8WOH1frk+9Uol1TfN6M9b16ws0xB9jG+R81s3FC/CUdHFU3PaOTnfi6bajf2V/+qyu97n90+nM/PbG3uwhcf8vuZvUl7Xv6wPSe/WAi075oKYM85eU76/e9L33pGgW82m7Wjv7OKkndmbKV5SPr1pdN6ubmi4y2qSgBwu6goAX3Ip98lK8tqnTopLa9IvuC+c7b6JudK2Wdlg1M/g9+zg9E70Pl5IwtHhR3DiqtlJQ8eVjo9rui1UxpeGtR9J2p6Ll3Vyeaa1vqgA14Q5WtkopmdKuzZkx3lYw+oeN+9Cscn5ZWKIGsdH7Q3NN0cna/kjTS8gcNuC0pTvbpvkmvF+dS7MxfszES76rMe1SS7D8+wq0mcdbtjo1kAuDMEJaBPxWfPqfb1r2vgU59ROLNb8jUQ2QLydx7Qeyjygamd49aiHd6uYKB9+3ZVsbP9fqx+4clsmt3yrgntfOE1ffb3hvTSi2s6s7qk1/rgzH1glcdweFgDX/iCqk982I6PqLhrSkG5osQrkhaObnYD4/WStA+PET7V7qeiUA9ZUNrVy00cVmtKT5xX+k2rJq1aUCoVdefymrAH9otxXSfs+fh6c1kAgNtHUAL6VLy0pOZrr6p15nQ2Ba+wf+9NFZM6k3+W7IOX0kCLqZ/J395BqcNfMLOOa/ftVzA2JE2M6eHvDat1/DW98ZXfUWpn8tNaTb3CK0gegsLJCXuOTGZT66IdO7KGDYV9+xSNjWTb7WYVkCTd9B2IO63qPZwetWB01L4VD0kzvVzebNlP9PIJyYKSvLOi7zu1HnsntdXTRHNxQ6sWmBp0vAOAO0JQAvpUurSoxqureVCanlbh4D4FXhF4l8/rjEGX7AM9JHlTh+3UJvyd+Atm9vjdf0CFe/aq8N5jenj3kEZfeU3/9I++lu21FPdQUFJoQWlgQMV9B1S8/36NfPFnss1kve13R1pvvev6to3SaQfuE8jutaD0oIWkh3t9zVyzHZROnlcwv5xtZKx1/JkaSR6U1iy01wlKAHBHCEpAn0r9THXDBkzf+Ibic+dU+eD7b+rz/EXBh1dnLFSdtONNO2ZskDog+Hn/TtAMrQpQqJb1wSc/qvc98X49f99hHT93Vr/11a+o8fTTalpATS/NKo1b2gqCYlFBpaJoasrC0aAGf/RHFY1PqPTe96q4c0bRrp2Khofz7tKNpL0B6t3bqdQDkk/7PGDPvTHLEf9lMdTuXl8oV2tIlxeV/O4f2V+wiwp8Gqzvd3anTRx0df3h5bim79ZmtZJsjecdAPQyghLQr9qD3GRuTvGFi0r9THbq672DfLB/g0Fwp/udD7N8mflK1v56e3a+u54rj4Q9jr5Mplwpq1wuaf++fUqsOjP4+mtWKZhXEkXZ45zUbXDsYckGxZ3w6rLrG/H9+TflA287fP+jjF2GlarC4SFFO3fa5agKBw4oHBm1atI+RRPj2fTM7GfLglJ7HdtdCkr+VbOug/bHsB077WcZt8uxXl2X1LFWz4+5JQUemvzHWdeHOFXNKkkL9nxriWoSANwpghLQ59a++Q3Vvvtdjf6V/1bh6IgKO6cVWGi6UZO2TlByF22g/HwS6H2Bt2UWrscH73b87INH9bI9Xuef+JCeXljUyVpNwR/8vhKr5jWeey7b1yq+dFHNl19SWq8rXVrSuvPvxUJRMGSBaHJKpSP3ZtfLjz6qwq5dKh07psKefQp37FA4WL7ye/apdV5F2qjwdqu8LUYlyPdK8uYNHwkD3WfX16PlwV319CvSqQsK/NKn25VL67TJbC5NE6soNfSd2rwWt0glEwB6GUEJ6HPpqg07rarReOF5FffvU9GC0s2sU/LmDd4zy6fg1e1I2u2YcX2dPX4+YQPgulWZmmGkyw89pOTQQZXuOax4YUHJ/IJaJ44rrdUVz122wNRQsmo1u5WVrOLkH5NN1fOqkzdaCG7wiBcKecWoWs2m04V+WCDyjWHDsdFs3VE0Np41ZMjWIO2aUTCchye/zNqAN+OrzwO/chen2XXE7W+lLO9wF+jTYd7AYSpQbz/32o9t+urJLChlDRyCddxgNsh7bfjaJN9k9nLSUJOKEgDcMYIS0Oc8KPkwrfHiCwp9PUTwnpv6PB+YrqQelPIpeHd/GL21+YvphB2ftArIG+WKLhVTLT38YBYwK3Z7srKqeGUtqzB5Ral1/ryS5SW1Ll5UcvFCFp6aJ05k7/M9sEKvDEU36DVYqWZhKRzfYYFozCqFYxaGdluVaDBbaxT4NLuRUUUzeWvvsH032e/QRtS+xj+birnF+Hfkw/shG/jP2BPwU/ZY3mfXp3t9yp3zsHRtUAqD9QtKlpRi5dUkD0mzFpaaWyD4AkCvIygB28Tqf/ptpWurKn/oCYXtSkTauPFg2V8cfH3SORvTnbfLGRt3zfTDgHUD+dSwKTs+HQV60MLJP2glOmdvz9tjFxVKKowUFVXLvkBJxcMHlbZa2ebAab2Z3Zas1fK1THYE7zQlKypkLaUDC0vZUSxk65Hy68Wsm51XpLKPs/tN68lbq0dbTKezXaldOforhShrAf6ohYkh9YELc3Zclp5+VTp3yZ4oxXVtCZ4HpUAv1pf0RmNV80lLMUEJAO4YQQnYJpqnTqp0/oKSy3MKpiOFA9Ubjpk9DvkwrmUfsGZvLGRtwlOC0rvwx8ynjR2wAf6oPWa7LaR4s/CFbKZVmHUnCEuFK4vAusPLlW7OybsMctvtpK/MzAvecnFlFl3q95NVkLbuoDnV1eYNk/Znwa48Yj/fsF0fUx/wX8bSatblTnOL+XUPSev2VymvTMX2ZS5ZJWnJQlKTtuAAsC58QsYvCkDf8+53gQ1A00JRBd9XaWb6XffH8TP9Pu3ugHx9UqD7e30Pm00yony62L32eB2y4wULKrENXpfiRAU75M0TWvlldsTtw91MJaDTutsDUHz1ftLO/XbuL7m7Lb7fjf/Evg7Oe/NN2eP15wqhPm/HJ+0x29kPTzV/7P138vWnpN/8fem5N7P1glkTh3U56dBuDG73tWwB6VcWj+u15opetwMAcOdYmw1sI/HiopovvZi1C0+WVxR4/+UbhJ9O52IPS3N2XBZu1ag8ZEoftFfawzaY9bU3Hg5uOOGxE4Bu5ehB/l232pfj9rgctOfgE6FX4qQ96iPeCvzMJemsHWdmlf32b7Tu7HbZ4+cVpDULShetorQQNwUAWB9MvQO2kfj0Ga19+cuqvO/9Khy6R8WD+xT41KzrrFXyoNSpKJ22AfkwSx5u2T4bxO6wo2THl2JfbC+dSNPscfUNfK9txZ7ZButKkvbhzyuPDEfssXmfBaWfKuQtwPtiTVKH75X0wuvS8+2jYD9xaR3PT7afPPW4paVWXa82ljUbNwQAWB8EJWAbSWtrap09q9q3vmHXa9rx1/6K0my03lk089aBug/p/EXijB0le9dF5WtwRoSbVbXDA0AUhnogSPXLcapZe5xfsYDqQcEbQPjj3O+TGrPOi7q6JukxC0e77fK/KobZNMU9Qf5Y9Y2GVXbOzSr5j9+QXj6hILZ4XCzcsIJ7e4JsodrZuKY3Wit6o7mi2o02SAMA3DKCErCNeJc12RFfvKjWmdPZbdkUOw9K16lmdCoeNXvXqg3yO1UA3Dx/vLxKsivwF9xAI/Y4rmZdytIr0xu3C68kdYKSN2rYY6HhATs8fPdVJcl5C/BaPQtLWl7N/35tUBr2cLSStLIjoZE/AKyb7fbvNADjm5B6G+k9/+l3FY4Mq3TsaL4BaVdzh86g1lc9+FqS/7kUabe9ajxE97vb5uu9vF34P2zFes0Gz9+wClPncfbA8LbpeD2sM83OO/951Wy3PW/eH+bHD0dh1gK8X4N3+q+/LD37mvTP/n0+5c473YXrvCzYqkm+KfH/OvuSvleb0z9beFMAgPVDMwdgO/Kz3XGs1vHjis+dy0azqd6+AWb3oP2yDeyXOLVyRwrt45A91oft0fU1OmM+7SzI14T50QlOvajzvXd+Dv9HxkP2TjsetDcOtTvaeae7vozbFoC9s106O2+peOHq7et9csHuzyN2K020kDSzzWYBAOuLqXfANuTrk3wQu/TPf1mlBx9S5aMfy9/hZ719LcU1o/RO2XnFQtJ3rPrhe/c8QZvw2zbshz18P1cI9aY9pu9NUv16nOi0PcgvpPm6JX9h9rVLvfgoewXJQ5JXkXzNUcV+iI/b88WrR3/WfmafcrejnyuSiyvSqv30X/6O0lPnr7TvXu+g5I3B60msWtLSs2tzero2JwDA+iIoAdtY/dlnlDQbqn396yoc2K/SgQNK4s5Kkqt88O7DvJdsUD8d5K3CvaEDLyB3xpsYPG4homqXXq37bQuiF+3ypD38jfSta8I6l1spYvizpBOMOm+XA19/FGhvkG+8u99+tg/ZMRrkeyWV1OdeOSG9dkqBhSQtLFvprLjODRza7IzFmdaKXm8s6VRc0yXaggPAumOcA2xjrdOnFQ4MqvHaqwpHhqRDB677cT59ygfE5+y4ZMeqHYPiBeROeYvwg0G+NqlmIeJNSxpVO87HeUjqNG33YfZW7IzXPc3Oj6yKpHxqoa9le8hCwnvsqGib8D2TXjlpZxMWpTWrLA1uRC+/fFLsglWTTjRXs5bgK2lLAID15Scpf1EAtqckUbK0pNYbr1tgGlJh/yELTIMKvI1x/PbGDnZ+PBsI+8ape20QPMAMvHUxGHg3PAsUdnzAQsXHo0C7w7xl9iUbEPsLtQ27s0Diw+HOdMhrH/6N+lVcW1vsbJbr0+o6rb59at0e+77fG+XVsT9XjPSn7PpPRqEeDUPt3S4hyatHz76m9Ne/Kn35j/OQVCisewOHoP2bji0Y/cHqBf3W8lm90lzWckJQAoD1xglhYDvzlsVxnDV0aJ44rsbLL6kyOqxgaPAteyt1BuE+UF+1Tzmb5pdJQEeY9RC2D2/qULRH29cnzdn1EQsZ8xZP1tIgm47nVSY/mvY76XSUc53QdKfBKX2H2zr3Vwp8nVUe3nb492zf+F57+0Dobwe6vx36xrWNNC2krFgwevVkXlFaWskD0kak1yCPyQutpi7FdZ1urWk1Ye8kANgIBCVgm0sbdbXOntHa739V8aVLKj34gIKBwbyxQ5K1w7sy3vOB+QU7vpuk+lSYalrbaErVJvEpjV5h2hPlj/qTFpLmLRg9Yw/+83Z5xn4fz9rjn1V1Ur0lMLnOFL1bma7XWWvUuZ9r76+zPs0vvYI42p5S52vUPhTl3eyOWaDz73vbPhe8gcObZ5T+y9+Vjp+1apLF2YHK+ne6c3afdXsevNBY1DP1hawteDOlFSUAbASCEoBMfOF8Np2q/v3vq7Brt8oPP+Q70Sq9ps7glQ7vl3fKRtKn7HLQ3nWEPZU2lFdmBuwx9ty6034fi/a4PxCEWrPbz1pg8il5i2k+Nc+X8zfav7E4zafJddYQdf+WOlWoTjXLg1DUrhCWlDdd8GMiyKdbztj34FMuJ+xyX5Cvr9rbvs3fv63/Mfn+S9IbZ6QzF7PW4FkDhw3USBN9b21Op5tr2cbFKdshAsCGICgByMQXLmSHB6V4bk6Vxx5Wek1pwQfV/oJRS/OQ5GFpKPSgJGyg8XYQ9Y1+PQjF9ps4FeYNNZ6LE6swpdlUyFP2ttU1sn2uWj5NL/CPSbOQlKRvn5qXtN+O2s0kPBwNtDeAHbav6W3Mh+w4HObT6B4M8851M+1q0sZGgR7zg5ftF2C11tMWlKoWL4sb+09rI8mD0pnWmv2uCUkAsFEISgDeYvEf/UOrKO1S+YEHVJyZVrRzRkk9ztYqebXBqxReefqGlSy8S9vH2VNp03Q2qz3QfsjvsTJT3A5DfniQOq98St5aml6pMtVvcH/++/TA49Uhrwp5QCrafU+qXWG6cgTZ2qRO5YnfeC71VuCXFqRf/U/5DRULSWGkDRFE2Uy+1+vLOtFc0X9au0ADBwDYYAQlAG+RzM4qLpUUnzurcKCqcHo622TWOzek15y9XrIBuu/907Lhc2f6FjZWJ6B0qjnF4Npbr3bE83DkU/O8KtRov32j+/N/BDwo+fqioTBvJDGht1egcA1fu+dlusUVpecuKfA1Sv5obVQDhysCXY4b2bGcNLO9tgAAG4egBOAt4oV5JbU1zf7Nv6nhL/6Mhn7mv1A0NqKgZC8X9VZWUfC1Ky/bGO01O960wZpPxZpmrdJd5y/oO/1KlnL4fWyYWiPfJ+k3/kD6w+9bGm3lzU9KGz8h8beWz+i4VZSW6XQHABuOoATg7eJYrZMnVf/BDxRNTmngE59QND2VDwa9XbidTV9rn83+vl0/aIPyacbl2A58f7Ezl5T+0TN5O/DZhXxN0kY9/4O8trdoFaRaGuu5xkK2ySwAYOMRlAC8TdpqWVA6YUHp+9lArfzoowonJy0oRdm0o8DOZvvULj+n/QMLSr5M6f2sVcJ2YM/31PdK+v3vWUn1lIJL89LokDZSEIRasqA016rrmdq8TrdqAgBsPJ9F84sCgOtIl5fVOnFcwcBAtnap4nss2e1eUXJ+3QOTL/Q/EuZrlcrkJfSzf/170td+IH31u/n+SV5NijZwhZ6dqPD/vrxyTv9x5ay+unZJq2lMQ3AA2ARUlADcULK8lB2N555VUCwqXVuVwoICO8JsM9pUF2zE5sd5u15tt5UG+s5qu4rzwpvSyfPS3GK+JqmwQV3unP19atlJiTiI9UZzRS82lhTb37OEJg4AsCmoKAF4V81XX1HjhedVPHK/0kZdxX27FcaJIhuvzSnvquabnu4Lfb8fSkroP+k3n5GeflX6u/9COn0hD0h+bODzPQiLWrLq0R9bFelXFk/od1bOZ+uUAACbg4oSgHcXx9k0vNo3v6FkYU6FXTsVjk8oiCIV4jTbp8c3oT2XBrpo13eIFxf0idU1pV5NeuGNbG1S0KnmhBvZED/I/o+V6HJc11P1Bc3FDSUCAGwmKkoA3p0NDtNmU82XXrKKUlPR/oMqTE8qHBqUWkm2V4+dY9d+Gzz6svYZO8tOUEI/SC7MKT1xXvrV35GsqhSsrCnbWKy4gdWk9rqkRpJPufvf5l/VK81lLcRNAQA2D0EJwM3zvVtqNcUXL6qwd69SqzQVJsbtzLcP6lIN2Lhx3qpKj/jGpUH+AgP0JF+Dd3E+C0f60tcVvPCmAl+X5J0fo2Bj96myIOad7r62elFP1+b1a0unNZc01WJtEgBsqo2cOwCgn3hVyUJS6+zZbApe8403FF+aVegdv2zg6NPvTtrY8kX7uBWlagnoYd7ZcXlVeuOMgm8/byXTWTtJUM873IUb/U+n33+g1xvLetMqSmdba6qxwSwAbDo/JcYpKgC3rLBrt4JKRbv+3W8q2jGmwr49ajRaasWp/rtCqGNWVfqTEedi0IPOWSg6f1np3/j/5td936SBysa2AXc+5S6IdKlV07JVkD765n9WI010Ma4LALD5WEYA4LZ49zvXfPFFJbt3KpqasBvzs+2X7ByMtwy38/Eqtg9gy2tZHbRllZvjZyVfl+TrkZqtDe9u120+buhUazULSQ3OZQLAXcMaJQC3JV1by/ZYar7xejYlqXTsISWVslI78362lWjFPuYRC03+IjNAx3D0goXlbF1S+r/8svQH35dePi7FiVQubU5Qypo4SL+2eFK/uXha36hdVp124ABw1xCUANwZqywly8uKL88qsGBUKJTUGhlSy6+nqco28ttlA8B81QWwBTWsarSwovQ7L0i/8y3pj57NGzm4aHOqSb6J84W4rmdr8/p3S2f0tdolXU7ocgcAdxNT7wDckXh2tt0JLFJx334F0zOq757Rgr39jFWW9qfKuuLxYoMtK02y/ZL05hnpj5/P1yX5lLvBqjZPoJUkzho4vNZa1qvNFQEA7i6aOQC4Y0HBYpAdxT17FU5Oavxv/i2Fhw+pbMeT9grzMassfd4qTCOUlLDVnLkkvfiG0l/6knTiXL4+yYN/GGxOJSmIsn+J36wv6T+vXtTfnX1JZ+OaZuOGAAB3Fyd5AdyxNFsE31J8+bKS1VW1XnxBYW1N6Y4dOlup6KVyWTYczVqGjwvYArxpQxznVaTX7ThuIcn3SfI1ScXCJoSkIPs/ab/1fGNRL9UXdT6uazmluT4AbAWsUQKwbtJa3uCh/uxzit88rvKBQ7psg86XJsZ1r1WV6lZdOhBQVsIWML+cNW9I/+4/l772VLtxgwWnymY2bgjUTBO1kkS/cP4pfb8+rzeaK4rZWBYAtgSCEoD1F3j78IbSlRWl9bqvVNfQ2JjmwlBH7bq/n5bhuCsaTen8nPTt55TaoW8+I11ezNckZVPuNmnvr/aeSd9fu6yXGkv65cXjWfOGlYRqEgBsFUy9A7DukoWFLCQtXzivZHHBBqAFffPgIe0sFPV5G4tOprQMx11Sb2YbyKbfeFr63ovSG2ftCWuVpFJxU/dKypcIB3qmvqA3G8t6xQ4AwNZCMwcAG8bbhQfVanbs+Et/WdUDB/WRP/Nn9dkoyI5hcbYGmyf16tEbp5X+89/OOtsFl5estLl5jRtyVkkKI51trunZ2pz+1uwLerG+mLUGBwBsLYxRAGyYNEmyypLsqJ84bmPRQGcuXtS5oQFdtKMaRdn+Sps02QnblU+3syM9fVG6ZBXOC3MKllbzNUnlwuaFpPbXaaSp5pKGTrZWtZQ0Nc9+SQCwJVFRArBpwsFBDXzux3XvD/+w7v2RH9HPT+zQ/aWSdgjYOOkf/kB69aTSv/PPs3AULK9ZQCrZqcJIm8k3lfWQ9JJVkn539bz+zuzLumSVpHqaCACw9dDMAcAm8n7INiis17V2+bIGBwa0ZLceGB7Kzths7rAVfcu7xq3VJasgpb6BrAelH7yc7ZMUJGnesMEbN2xmJSkItZq0dNmC0a8sntAP1ub1XGNRdSWcrQSALYqpdwA2TdpsqPHsMzq/sKDZV1/VVycmdcZGiR/ftVNle39JwDpoB6XUN4/9vW9nHe70xplszVy2Hqm42f/0eYe7UCtJTZdaa/qNpdPZhrKLTLkDgC2NihKATZfWa0rmLmvu9dd19nvf06lCQecWF3Vg794sLFFZwm07ecEqR2eV/OPflL76XQXf8PbfC3kVyafaReGmVpK8cUPLglsjifW/z72qLy2f09fWLmXrkmJqSQCwpVFRArDpfG8lP+Zee1U1C0jPnzql8ZERed8vVmvgjqzV8oYNL5+Qzl+2Y1aq+nqkQl5N2nRBFofiNNFLjWWdaK5oib2SAKAn0MwBwN3lZ91LJe2+/6geePJT+kt/5r/UPQf265GpKQHvyv8Fa1lt5ulXJDvSX/9qvhbJq0i+DqnU7moXbG5I8ql2Hvq9kvTvl87YcVr/duWMlglJANAzmHoH4K7ztSMF3/AzTVW06xfPn9e+mZ1qtloaqFQEXNfyqrSwJD1lIempl6VnX7OQdD67PYiTfJrdZk61y+ShzP+bixt6vr6ob9Vm9Z3anE601phuBwA9hKl3AO66tNnU5ePHs+P866+qNDSkew8c1OToqCbHHhZwXT61bnZB6f//P0ivnbbjVN6wwYNRuai7IshaN2RXfR3SbyyfztYkfc3CEgCgt1BRArCltCw0NVZWdPbceZ187XVNFMsqR4WslbjCcNOnUGEL8W52zZbS41Y1evZVpf/2K0q/9YwCryYtLEve+vuuVJGUV5GC8EpI+u3ls/ra6kX9q+VTOtFY00rKlDsA6DVUlABsKY3lZTXs8j9/+fd05tBhffSeo5qZnNK0r1nyBfnkpO3Lg1Irli7NSa+ekr71rJVtFvPKkrf89q52Hqa3gBfqi3qqNq9nagsCAPQmmjkA0FYV2ln6or1M/dSRR/Teqb36c7/432vkwB7pvv3CNvOdF6TXTymxKpJOnVdw8nzerMGDUenunvPzSlLHry+e0g9qc/pf517Npt4BAHoXFSUAW5edxkntdM5cfU1vLl7W2VdeU7yyph0+MB4asKNqg+TilqkiYB15M4bVmrRix+pq3u775DlpcUVBo9meYhfd5QpjcOXr19JEZ1r2PG2u6HhrVTXFAgD0NipKALa8ahCpYNWl/2nyIR3bd0Cf/rHPSo/cKz1qx/6ZfEoe+stSHo7Sbz8rvXlW+r1v513u1upbZ5pdu7ude90C0j+ce03/YeWsnma6HQD0BZo5ANjysg077c+FpKX51WXtnW9Ipy9q8LWzClbr2XWNjeSnfghNvWtuMQtI6Ve+K33vRaVf+rr0nRcVvHIiD07XNmu4myHJA1IYZfsk+Uay/2TudX197ZL+3coZnWisqp6ybTIA9ANGFAC2PA9JsY2Rf1CfUytu6fTzL6l6aVHTJ2at3FSWpnZI9x+wVzQbPFfKQo9aswBcs+D7zKtKL85J33g672bnU/AGKnk48krSlhBYUErseZlm3e3Ox3UaNwBAn2HqHYCe0WnucLhQ1aeHdupTw7v0qZFdGiyUpIO7pUM7FRywy8eP5eGJpg9bm6818ul1FywUvfim9K1nlM4tKXj9dN7eu9bIq0eusxbpLreHD8KCammsxVZd/2bxlJ6qz+tfLJ7I3rec0AIcAPoJFSUAPSOxs/exDZTPJg291FjW6Mqs7kvKGi2WtetM0T4gyasS3uxhajx/2ysQ3vShYhWJqgWqckm4S/z34eGobseiVYqW16SnX5XOz2abxaYnL+S3ewXJA1Fnel24BXrCtzvbrSax5qx69FJ9Qc83FvRifYmABAB9iooSgJ72t6ce1sHioH5qYJcUx9k+O+nYcDZVK/CK0q4J6egh6cHDCnZPSXunhbvA90DyRgxnL0nnZpV+/Snp9AWlX7PLtZqCeQtIpVIeispFbTVeSfJ/Ml+pzembtVn904XjerGxqLPNmgAA/YmKEoCe9nurF7QzKmsqLOpAVNWBYlWBByYflHu3tEsLNjC/LL1+WunEaB6YfF3TTgtQ4/b2YCVvMR5sgapFv6k3supReuJcXiV684x0xoLSmYvSG2eyVt8+vS7wJg2VUrvd91b6PQTt78eqmK011aya9KuLJ/WqVTO9DfhSTAtwAOhnBCUAPe13V85rzELSIasqfWxgSvsqQ4qsqhQ0W3kXtY6JMQtF1ayi4RWn4D33S0eCfGqet5smKK2/bIqdhaFnXpPm7XfxzWeyKpJOXcjfZ1WmwMORr0PaglMig86fQahzzTXNx3X9SwtKvpHsaQtOAID+xtQ7AH3Bw9KjlTE9Uh7VXxg7bJWlQQ1FpXxdTJrY//ZSF7R3sPVwND6cr2MaGVDw0D15hemBw3ZHQ3bY+3aMXG0kgHfn3emsipc+/4bUac5w/nI2zS7bKNbCa772qP3x3cF0CwXVoL0eyetF36/N6Qdrc/rlxeM6ZeHoRHM168Lo6+UAAP2NihKAvuBn+c+1ahqNCtnmn6Ug0v6omHUMj9JQQWLDW+8xXq/nTQJ8oOtj3aWVPBx5W+rRwWy9TFbtcB6UfFpetndPu/IEqdluXuBT6+IkD6Oz8/ZYruUVo1mrHp26aIHpch6aPER5UPLH3ENqYatNsXPBlRDnLb/9qXEpbuiMVZKOt1Y1a9fPW1BqskcSAGwbVJQA9J37SsM6WBzQ35p8SBOFig6XrTrkL3VeWfKBbraDbXx1kO+HD9w9DPk6Jj+OHZSGrNp07FDeEGLXZN4IorOfz3bWXnOU+lQ6D0HeoOHVk1ZBslB05kL+uF4bhEqFt3ax23KCPCN5JcmOCxa0L1no/p8vvainGgv6QZ39kQBgO+L0KIC+s2Bn/08r1H9aPa99FpjWLBztLlY0EhazvZgyWTAK8y5rSZifNvLbvJrkg//j5/IKkjeFmLTgNDkmzUzkLcbHRvJKk7cd9+DkH+e3h+1qSRhujZbWt8OrPv4YtDsIamnVKkj+mKzkrb2XV/Ng5I/Ls69JK1aBm1vKq0hejct+7vCtoSgIr06522qC4MpapEWrSi5Z5fEbqxd1oVXXaxaYLsdNAQC2JypKAPpSaC9vgxZcHqvs0OeHduuTgzM6apWmSuStp1MrLl2nY5lXlrwa4gGhM73MQlBqlSUPRYGvXfJQ9IBVmXaMKtg/k69tGh2yEDVuIamQrXnKQpQHpl7Tqa55KFpZy6tG3jlwfknBS8eVXrbKyonzSmcXstAU+PojX/vVsseq2J6imAXFoGeaY2Trkdqd7V5pLOqV+qL+n1ZJumAVpZebywIAbF8EJQB9Katr2ADYmzyMRSU9boFpf2FAf3HHEVUtQO0qVvPqiZRPx+vI1i6leQDo6Az8w/agerBdRcoqSZUsHKT7prOAFHjladjCUqWchSkNWKVpxIJUtZy3JfdQ5YHK10P5/fm0tI2aktb5WZwHP2+msFrPW3YvLOUVosuLeXXIj4uX82qSV4gsHKUekPx6rZGvR2q08s+J2+uNPFRm/4Rssc1h31Fnml3ezW7eAtGZ1pp+b+WCnqrP66navF5qLKllP18tpf03AGxnTL0D0JeyZUg22PVF+H4MBpEW46ZWkmZ7Glh78X5397KgE4rab2dVlvRqOPDDqy2d6529f3xKmre4nl7Mu+ZlezXV81DlAcNbk/tUPf+YoletKhv/Cnztz+ahptEOSx585tsByKtC/r0v28906pzdloen1AOUV5D8Z/UK27VhrnO9GLWn1fXiNEP/GQI1LCT78+IVC0cvWjXp2fpCdhtnEAEAVJQAbCtTVl3aWxzQTw3v06cHZ3SsNKyBqJwXQrwzXvZRN/GyeG21xjU7VZY4D1ZJu0rlQapSUtrp9tZpBpFtsBoq8OrSjvaUvs6mqz6NbWJEgYWrtDMF8GZ4GPIuc/49NK1q5OuHfE+phWWl/v34fa018jVHWWUoUeDByT8vboehoP09R+11RlGvBqG38s7witrJ1ILQ99bmdLK5ov/l8ks6ZVUl30AWAIBrUVECsK3UlOhiXNf3anMqWQA42VzVQ9UdGg9LmgwLWSZIFV4Tgm4QmrrDQ2fPpewOvLNelN9He9pedlbKA4lXcfxjPMCE7SlrHmA6G9+G7VbkXs2pFNvT226SB7TF1fZaqzifRudrsVbrCpI0D0u+nihur8XKKmLh1cYWQbvK1pli2OsBqf39B+3ZgZft9+4NG45bKPru2mW7XNXZVt2qjLcQRgEA2wYVJQDb1pHikKatmvQXdtyje0qD+kh18kqL6CxgeNOHO3mJTK5d+6T22qd2e/LkLu3Hc+0eRp1g1A+h6Ho8oAZXm2o80w5H/2LxuP7Irr9OFQkA8A4ISgC2rdGwqLINpI+Vh7SnMKAPVSZ0xK7fUxrS4eKgCp31N+1pdncUmjoVqrTr7U2QeGBI/QU/vRqOOvooIGWVozDvYOdht2aVomU7Xm4sZQ0b/s3iSa1aAH6usaDzVJIAAO+CqXcAtq0Fb+ygpubXGpqMlm1gHaumWMNhpP3FgfYLZCdI3GGwuVLFuXKDNkvqgc++/yDdDufFgiuXHoOW7XfsQenl+qK+tHxWvgptNaGbHQDg3VFRAoBrFCzQRPbS+CNDOzUTlfVnRg9km9Z6a/Eg9OjkFaY4ry5ti+CxdXW2is02+m2btcrRrFWL/vnCcb3eWNE31y7pYtLQItUjAMAtoqIEANfIZtnZ+HsubmSb1j5dX9B83NRCsalJC0slG5SPBVE2jS1sV2ryT5Q477QZgrdV5Xx63aofFmBfry/pvIWl461VnYnXVEsTqxnyewEA3DoqSgBwAx6UBtvT8Lyi9GNDu7W7UNHHB6YsMBU0EJWUvYSmydXNa3lJ3UCdzWLDK90Ffc+jl+qLej47FvSllXM6ZUHpXKsmAADuBEEJAG7AXyB9Kt5QUNSABabdxaqGg4I+Wp3UVKGsg6VhHSxUs+szFqDyasc1L6tJcvP7MqFLJxS1H1NvGGhhNLZg5FPpLsY1fbc2l20W+621WV1q1XXJbj9rIWkxblkliXVIAIA7w9Q7ALgBjzdNG5zPpQ3NWdHotA3CnTd98E1rl5KWKlWpbAP5LCjlI3tdPQcVZFP0iEl3ovN45hex/T4W4oZON1f1zdVLuhTX9eWVC1llqZ7epZbrAIC+REUJAG5RJQiz1uFFewndEZU0ZNWmjw9OayIq67HSmPaXqtoRlrS3NJS3GHfZ1Ly3NoCg2tSuG10bMNvX84erpZMWTuctGH3Dqkanmmt6qj6vc1ZN8vbevo7MP2zNm2ukTHsEAKwvKkoAcItq2ZqkvHrhjQIWkkDHmyvZgH5HkL+srkSxSpFP2SvYC60FK/s4bwHRedENguD6Z6r6uSnEdfds8lBkESdIlcWeNH98W0lqR9MqR97FrqHjjVULSGvZhrFeRZq1x7qZJkQjAMCGoaIEAOts2qpMvpbp0eoO7SxU9L7yjqwhxAE7dhUGVLQqUzlqtxrPdDrnJX3ddjzoNGG4djqdVYNa9vP65rCvNpezfY9+d/l8Nq3xxcaSXrHbzrdqWkliEYsAAJuJoAQA62zQQlJn3dKQVZR2F6oat/A0YcfB4pCqYaRDpSENBJFGPVR51ck+fiIsZZWm8C2b0aZdl9d5143ev2GCd3zzrTfk/8z4fysWfurZWqI0q76t2fUL3nzBwtG5Zk3HWyvZx7zcWFbDAtQl+xivHPltDapHAIBNRlACgE1QtmpKyY6jxRGNWDD6yMBEtqYpqzIVq6paaLq3NKzI1z6F186Kvlptepu3rHfavJfy4NogdL3pdN1VI6VZE4YLzZVs41fvVPe6Xfc1Rs81FrNW3i/UF3U6XtOaVY5oygAA2AoISgCwCbxK5PlhKPA1S4GGo0IWnEoWkKYtMHmQOlgctGpTQWNRMatGjVmFaY9d+vt8Ct9AaB+vKJu655Wnot9xttbprY0QNlbWpzu7bFmg8UgTtytGfvPlpJFtAHvGKkReKVrwdUatPACdscvLFo788Nu9CYPf7q28a1mlKc7ug9oRAGArICgBwF3mnfPKFqX2FKyyFEUat6C0rzCY3b7fb/NNbwsD2TS+igUrD1PeS8+Dk4ckr0KFod9i15V32fMX9/BKV+1bD09pu0bVKVr5RdK+tZXE2S11C0S+vqhp72zZez04nWvVtZw2dbyxYqGpmVWN3mysatVC0Pm4lr09n+TT7uI+XYsFAOgPBCUA2OJ8/ZJPzRsJCllr8snIqkwWjPYUq9k0Pr99yEKVh6hJu4yyalNgtxWvfO7N6myyu5pcrfZ4GPLpcB5uvEo0G9ezt88017Kq0ELczEKQv2/ZPqelNOtIBwBAL6M9OABscR45vA35iuJsA1wldUVJmLXTrlpwqmRHIZuSN9SuNnlYKlslyi8rnb2cbkJWibI/6+0NXD3wJFnVKM0aKnhwWklb2dvzFpD8tjWrLPl0u5pXlXwKngAA6H1UlACgz5VvISh1xNkaJP55AABsXwQlAOhz4R2sUQIAYLsiKAEAAABAl1ufjwEAAAAAfY6gBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAD4P9qvYwEAAACAQf7W+8dQFgEAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAE66La9ksQ6vKAAAAAElFTkSuQmCC";
  function aE(t10, e, r) {
    let n = false;
    return new Promise((i, o) => {
      let s;
      const l = `wss://live-api.joinplayroom.com/?service=tiktok&username=${t10}`;
      s = new WebSocket(l), s.onmessage = function(c) {
        if (n)
          e(c.data ? JSON.parse(c.data) : null);
        else
          try {
            JSON.parse(c.data).type === "streamStart" && (n = true, i(s));
          } catch {
          }
      }, s.onopen = function(c) {
      }, s.onerror = function(c) {
        o();
      }, s.onclose = function(c) {
        n ? r() : o();
      };
    });
  }
  function lE({ options: t10 = {}, onStart: e }) {
    const { width: r, height: n } = Lm(), [i, o] = reactExports.useState(false), s = we();
    return reactExports.useEffect(() => {
      const a = document.createElement("style");
      a.innerHTML = [sg, ag, lg].join(`
`), document.head.appendChild(a), s.createRoom(null, true, true);
    }, []), i ? null : /* @__PURE__ */ U.createElement("div", { className: "bootstrap-wrapper" }, /* @__PURE__ */ U.createElement("div", { className: "playroom" }, /* @__PURE__ */ U.createElement("div", { className: "modal-container fullscreen " }, /* @__PURE__ */ U.createElement("div", { "data-pop": "slide-up", id: "popup", className: "show" }, /* @__PURE__ */ U.createElement("div", { className: "popupcontrols" }), /* @__PURE__ */ U.createElement(
      "div",
      {
        className: "popupcontent",
        style: { transform: `scale(${Math.min(1, n / 844)})` }
      },
      /* @__PURE__ */ U.createElement(
        cE,
        {
          options: t10,
          onStart: () => {
            o(true), s.setState("__launched", true), e();
          },
          onMessage: (a) => {
            s.emit("live:tiktok:msg", a);
          }
        }
      )
    )), /* @__PURE__ */ U.createElement("div", { id: "overlay", className: "show" }))));
  }
  function cE({ options: t10 = {}, onStart: e, onMessage: r }) {
    const [n, i] = reactExports.useState(false), [o, s] = reactExports.useState(""), [a, l] = reactExports.useState(null), [c, u] = reactExports.useState(null);
    async function f() {
      try {
        const d = await aE(
          o,
          (h) => {
            r(h);
          },
          () => {
            i(false);
          }
        );
        u(d), e(d);
      } catch (d) {
        console.log(d), l(setTimeout(f, 5e3));
      }
    }
    return /* @__PURE__ */ U.createElement("div", { className: "main-menu" }, /* @__PURE__ */ U.createElement("div", { className: "platform" }, /* @__PURE__ */ U.createElement("div", { className: "profilecontainer" }, /* @__PURE__ */ U.createElement("div", { className: "steps-container" }, /* @__PURE__ */ U.createElement("div", { className: "step-item active" }), /* @__PURE__ */ U.createElement("div", { className: "step-item " + (n ? " loading" : "") }, /* @__PURE__ */ U.createElement("span", null))), !n && /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          textAlign: "left",
          color: "#fff",
          padding: "1rem 0rem"
        }
      },
      /* @__PURE__ */ U.createElement("b", { className: "title" }, "Connect to TikTok"),
      /* @__PURE__ */ U.createElement("p", { className: "subtitle" }, "Enter your TikTok username which you will live stream from.")
    ), /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          position: "relative",
          zIndex: 1,
          display: "inline-block"
        }
      },
      /* @__PURE__ */ U.createElement(
        "div",
        {
          className: "avatar-photo ",
          style: {
            border: "none",
            // tiktok style double shadow
            boxShadow: "2px 2px 0px 0px rgba(254,40,84,1), -2px -2px 0px -0px rgba(36,246,250,1)",
            backgroundImage: `url(${sE})`
          }
        }
      )
    ), /* @__PURE__ */ U.createElement(
      "input",
      {
        type: "text",
        placeholder: "username",
        value: o,
        onChange: (d) => {
          s(d.target.value);
        },
        autoCapitalize: "none",
        autoCorrect: "off",
        className: "input-name"
      }
    )), n && /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(
      "div",
      {
        style: {
          textAlign: "left",
          color: "#fff",
          padding: "1rem 0rem"
        }
      },
      /* @__PURE__ */ U.createElement("b", { className: "title" }, "Waiting for stream..."),
      /* @__PURE__ */ U.createElement("p", { className: "subtitle" }, "Open TikTok and go live from ", /* @__PURE__ */ U.createElement("b", null, "@", o), ' in "Mobile gaming" mode.')
    ))), /* @__PURE__ */ U.createElement(
      "section",
      {
        style: { width: "100%", display: "flex", marginBottom: "1rem" }
      },
      /* @__PURE__ */ U.createElement(
        "button",
        {
          id: "btn-launchjoin",
          className: "button-black launch-btn",
          disabled: !o,
          onClick: async () => {
            if (n) {
              i(false), a && clearTimeout(a), l(null), c && c.close();
              return;
            }
            i(true), f();
          }
        },
        n ? "Cancel" : "Launch"
      )
    ), /* @__PURE__ */ U.createElement("p", { className: "sdk-version" }, "Multiplayer by Playroom v.", Wu.version)));
  }
  function uE(t10 = {}, e) {
    if (!window.__playroomjs_mounted) {
      var r = document.createElement("div");
      document.body.appendChild(r), window.__playroomjs_mounted = true, fE(/* @__PURE__ */ U.createElement(lE, { options: t10, onStart: e }), r);
    }
  }
  function fE(t10, e) {
    try {
      clientExports.createRoot(e).render(t10);
    } catch {
      yr.render(t10, e);
    }
  }
  function jm(t10, e) {
    return ea(t10, false) + e;
  }
  async function dE(t10, e, r) {
    try {
      if (!t10.gameId) {
        r("gameId is required for Web authentication");
        return;
      }
      let n = sessionStorage.getItem("pr_discord_jwt"), i = null;
      n ? (i = await hE(t10.gameId, n), i != null && i._discord_id && ct.set("myId", "DCD-" + (i == null ? void 0 : i._discord_id))) : (n = sessionStorage.getItem("pr_google_jwt"), n && (i = await pE(t10.gameId, n), i != null && i._google_id && ct.set("myId", i == null ? void 0 : i._google_id))), e({ ...t10, profile: i });
    } catch (n) {
      r(new Error("Web authentication failed: " + n.message));
    }
  }
  const hE = async (t10, e) => {
    var r, n, i;
    try {
      const o = `${jm(
        {},
        "/api/auth/discord/get-user"
      )}?gameId=${t10}`, s = await fetch(o, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${e}`,
          "Content-Type": "application/json"
        }
      });
      if (!s.ok)
        throw new Error("Failed to fetch user");
      const a = await s.json();
      return { name: ((r = a == null ? void 0 : a.user) == null ? void 0 : r.global_name) || ((n = a == null ? void 0 : a.user) == null ? void 0 : n.username) || "", photo: a.avatarSrc, _discord_id: (i = a == null ? void 0 : a.user) == null ? void 0 : i.id };
    } catch (o) {
      throw new Error(o);
    }
  }, pE = async (t10, e) => {
    var r, n;
    try {
      const i = `${jm(
        {},
        "/api/auth/google/get-user"
      )}?gameId=${t10}`, o = await fetch(i, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${e}`,
          "Content-Type": "application/json"
        }
      });
      if (!o.ok)
        throw new Error("Failed to fetch user");
      const s = await o.json();
      return { name: ((r = s == null ? void 0 : s.user) == null ? void 0 : r.displayName) ?? "", photo: s.user.photoUrl, _google_id: (n = s == null ? void 0 : s.user) == null ? void 0 : n.email };
    } catch (i) {
      throw new Error(i);
    }
  };
  typeof window < "u" && (window._PLAYROOM_CONFIG = {
    ...window._PLAYROOM_CONFIG || {},
    sessionStorage: true,
    sdkMode: true,
    sdkVersion: Wu.version
  }, ar.track("SDK: Loaded", {
    cdn: !!window.Playroom
  }));
  function tk(t10 = {
    spectator: false,
    streamMode: false,
    baseUrl: "",
    allowGamepads: false,
    enableBots: false,
    botOptions: {},
    avatars: [],
    roomCode: void 0,
    skipLobby: false,
    liveMode: void 0,
    maxSpectatorsPerRoom: void 0,
    maxPlayersPerRoom: void 0,
    defaultStates: {},
    defaultPlayerStates: {},
    matchmaking: void 0,
    gameId: "",
    persistentMode: void 0,
    turnBased: void 0,
    discord: void 0,
    auth: void 0
  }, e = void 0, r = void 0) {
    if (typeof t10 != "object")
      throw new Error("options must be an object");
    if (!t10.streamMode && t10.allowGamepads)
      throw new Error("allowGamepads only works in stream mode");
    return t10.matchmaking && (typeof t10.matchmaking != "object" ? t10.matchmaking = { waitBeforeCreatingNewRoom: 5e3 } : t10.matchmaking = {
      waitBeforeCreatingNewRoom: 5e3,
      ...t10.matchmaking
    }), t10.turnBased && (t10.persistentMode = true), t10.turnBased && t10.turnBased.challengeId && (t10.roomCode = t10.turnBased.challengeId), t10.persistentMode && (window._PLAYROOM_CONFIG.sessionStorage = false), document.dispatchEvent(new CustomEvent("SDKInit")), new Promise((n, i) => {
      const o = () => {
        e && e(), n();
      }, s = (a) => {
        r && r(a), i(a);
      };
      if (t10.liveMode)
        return uE(t10, o);
      if (t10.discord)
        return l3(
          t10,
          (a) => cc(a, o, s),
          s
        );
      if (t10.auth)
        return dE(
          t10,
          (a) => cc(a, o, s),
          s
        );
      cc(t10, o, s);
    });
  }
  function rk(t10, e, r, n) {
    if (o1()) {
      console.warn("Ads are not supported on mobile."), r();
      return;
    }
    const i = new CustomEvent("start-ad-event", {
      detail: {
        actionButtonClick: t10,
        completeCallback: e,
        skipCallback: r,
        errorCallback: n
      }
    });
    document.dispatchEvent(i);
  }
  const Playroom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Analytics: ar,
    Bot: ig,
    DQNBaseBot: j5,
    DQNBotJoystick: QE,
    Joystick: Ac,
    Multiplayer: we,
    RPC: qE,
    addBot: q5,
    clearTurns: $E,
    getAllTurns: ZE,
    getChallengeId: zE,
    getDiscordAccessToken: SE,
    getDiscordAuth: EE,
    getDiscordClient: Cs,
    getDiscordSDK: g3,
    getDiscordServerData: i1,
    getMyTurnData: ek,
    getParticipants: UE,
    getPersistentData: i1,
    getRoomCode: zE,
    getSpectators: WE,
    getState: NE,
    handlePlayerKeyDown: FE,
    handlePlayerKeyRelease: jE,
    insertCoin: tk,
    insertDiscordServerData: C3,
    insertPersistentData: C3,
    isHost: LE,
    isSpectator: BE,
    isStreamScreen: w3,
    me: Ln,
    myPlayer: Ln,
    onDisconnect: VE,
    onPlayerJoin: RE,
    onTikTokLiveEvent: DE,
    openDiscordInviteDialog: _E,
    resetPlayersStates: PE,
    resetStates: OE,
    saveMyTurnData: GE,
    setDiscordServerData: k3,
    setPersistentData: k3,
    setState: ME,
    startAd: rk,
    startMatchmaking: HE,
    switchRole: YE,
    transferHost: KE,
    useIsHost: _u,
    useMultiplayerState: si,
    useParticipantsList: A3,
    useParticipantsState: TE,
    usePlayerState: IE,
    usePlayersList: Ei,
    usePlayersState: kE,
    useSpectatorsList: v3,
    useSpectatorsState: CE,
    waitForPlayerState: xE,
    waitForState: wE
  }, Symbol.toStringTag, { value: "Module" }));
  window.Playroom = Playroom;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var eventemitter3 = { exports: {} };
  var hasRequiredEventemitter3;
  function requireEventemitter3() {
    if (hasRequiredEventemitter3) return eventemitter3.exports;
    hasRequiredEventemitter3 = 1;
    (function(module) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events2() {
      }
      if (Object.create) {
        Events2.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events2().__proto__) prefix = false;
      }
      function EE2(fn2, context, once) {
        this.fn = fn2;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn2, context, once) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE2(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events2();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a12, a22, a32, a42, a52) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a12), true;
            case 3:
              return listeners.fn.call(listeners.context, a12, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a12, a22, a32), true;
            case 5:
              return listeners.fn.call(listeners.context, a12, a22, a32, a42), true;
            case 6:
              return listeners.fn.call(listeners.context, a12, a22, a32, a42, a52), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a12);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a12, a22);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a12, a22, a32);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on2(event, fn2, context) {
        return addListener(this, event, fn2, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn2, context) {
        return addListener(this, event, fn2, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn2) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn2 || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events2();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module.exports = EventEmitter2;
      }
    })(eventemitter3);
    return eventemitter3.exports;
  }
  var eventemitter3Exports = requireEventemitter3();
  var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x2) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el2 = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el2] = curr[el2] || { _errors: [] };
              } else {
                curr[el2] = curr[el2] || { _errors: [] };
                curr[el2]._errors.push(mapper(issue));
              }
              curr = curr[el2];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        overrideMap,
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var _ZodEnum_cache, _ZodNativeEnum_cache;
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a2, _b2;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b2 = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b2 !== void 0 ? _b2 : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a2;
      const ctx = {
        common: {
          issues: [],
          async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform2) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform: transform2 }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip2, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip2)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip2)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a2) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a2, _b2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
        local: (_b2 = options === null || options === void 0 ? void 0 : options.local) !== null && _b2 !== void 0 ? _b2 : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch2) => ch2.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch2) => ch2.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch2) => ch2.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch2) => ch2.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((ch2) => ch2.kind === "base64");
    }
    get minLength() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    var _a2;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
          return true;
        } else if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        } else if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    var _a2;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a2, _b2, _c2, _d2;
            const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn2 = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn2, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn2, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function custom(check, params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a2, _b2;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b2 = (_a2 = p.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
          const p22 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  }
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  var BigInteger = { exports: {} };
  var hasRequiredBigInteger;
  function requireBigInteger() {
    if (hasRequiredBigInteger) return BigInteger.exports;
    hasRequiredBigInteger = 1;
    (function(module) {
      var bigInt2 = function(undefined$1) {
        var BASE2 = 1e7, LOG_BASE2 = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        var supportsNativeBigInt = typeof BigInt === "function";
        function Integer(v, radix, alphabet, caseSensitive) {
          if (typeof v === "undefined") return Integer[0];
          if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
          return parseValue(v);
        }
        function BigInteger2(value, sign) {
          this.value = value;
          this.sign = sign;
          this.isSmall = false;
        }
        BigInteger2.prototype = Object.create(Integer.prototype);
        function SmallInteger(value) {
          this.value = value;
          this.sign = value < 0;
          this.isSmall = true;
        }
        SmallInteger.prototype = Object.create(Integer.prototype);
        function NativeBigInt(value) {
          this.value = value;
        }
        NativeBigInt.prototype = Object.create(Integer.prototype);
        function isPrecise(n) {
          return -MAX_INT < n && n < MAX_INT;
        }
        function smallToArray(n) {
          if (n < 1e7)
            return [n];
          if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
          return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
        }
        function arrayToSmall(arr) {
          trim(arr);
          var length = arr.length;
          if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
              case 0:
                return 0;
              case 1:
                return arr[0];
              case 2:
                return arr[0] + arr[1] * BASE2;
              default:
                return arr[0] + (arr[1] + arr[2] * BASE2) * BASE2;
            }
          }
          return arr;
        }
        function trim(v) {
          var i10 = v.length;
          while (v[--i10] === 0) ;
          v.length = i10 + 1;
        }
        function createArray(length) {
          var x = new Array(length);
          var i10 = -1;
          while (++i10 < length) {
            x[i10] = 0;
          }
          return x;
        }
        function truncate2(n) {
          if (n > 0) return Math.floor(n);
          return Math.ceil(n);
        }
        function add2(a, b) {
          var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE2, sum, i10;
          for (i10 = 0; i10 < l_b; i10++) {
            sum = a[i10] + b[i10] + carry;
            carry = sum >= base ? 1 : 0;
            r[i10] = sum - carry * base;
          }
          while (i10 < l_a) {
            sum = a[i10] + carry;
            carry = sum === base ? 1 : 0;
            r[i10++] = sum - carry * base;
          }
          if (carry > 0) r.push(carry);
          return r;
        }
        function addAny(a, b) {
          if (a.length >= b.length) return add2(a, b);
          return add2(b, a);
        }
        function addSmall(a, carry) {
          var l = a.length, r = new Array(l), base = BASE2, sum, i10;
          for (i10 = 0; i10 < l; i10++) {
            sum = a[i10] - base + carry;
            carry = Math.floor(sum / base);
            r[i10] = sum - carry * base;
            carry += 1;
          }
          while (carry > 0) {
            r[i10++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r;
        }
        BigInteger2.prototype.add = function(v) {
          var n = parseValue(v);
          if (this.sign !== n.sign) {
            return this.subtract(n.negate());
          }
          var a = this.value, b = n.value;
          if (n.isSmall) {
            return new BigInteger2(addSmall(a, Math.abs(b)), this.sign);
          }
          return new BigInteger2(addAny(a, b), this.sign);
        };
        BigInteger2.prototype.plus = BigInteger2.prototype.add;
        SmallInteger.prototype.add = function(v) {
          var n = parseValue(v);
          var a = this.value;
          if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
          }
          var b = n.value;
          if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
          }
          return new BigInteger2(addSmall(b, Math.abs(a)), a < 0);
        };
        SmallInteger.prototype.plus = SmallInteger.prototype.add;
        NativeBigInt.prototype.add = function(v) {
          return new NativeBigInt(this.value + parseValue(v).value);
        };
        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
        function subtract2(a, b) {
          var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE2, i10, difference;
          for (i10 = 0; i10 < b_l; i10++) {
            difference = a[i10] - borrow - b[i10];
            if (difference < 0) {
              difference += base;
              borrow = 1;
            } else borrow = 0;
            r[i10] = difference;
          }
          for (i10 = b_l; i10 < a_l; i10++) {
            difference = a[i10] - borrow;
            if (difference < 0) difference += base;
            else {
              r[i10++] = difference;
              break;
            }
            r[i10] = difference;
          }
          for (; i10 < a_l; i10++) {
            r[i10] = a[i10];
          }
          trim(r);
          return r;
        }
        function subtractAny(a, b, sign) {
          var value;
          if (compareAbs(a, b) >= 0) {
            value = subtract2(a, b);
          } else {
            value = subtract2(b, a);
            sign = !sign;
          }
          value = arrayToSmall(value);
          if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
          }
          return new BigInteger2(value, sign);
        }
        function subtractSmall(a, b, sign) {
          var l = a.length, r = new Array(l), carry = -b, base = BASE2, i10, difference;
          for (i10 = 0; i10 < l; i10++) {
            difference = a[i10] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i10] = difference < 0 ? difference + base : difference;
          }
          r = arrayToSmall(r);
          if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
          }
          return new BigInteger2(r, sign);
        }
        BigInteger2.prototype.subtract = function(v) {
          var n = parseValue(v);
          if (this.sign !== n.sign) {
            return this.add(n.negate());
          }
          var a = this.value, b = n.value;
          if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
          return subtractAny(a, b, this.sign);
        };
        BigInteger2.prototype.minus = BigInteger2.prototype.subtract;
        SmallInteger.prototype.subtract = function(v) {
          var n = parseValue(v);
          var a = this.value;
          if (a < 0 !== n.sign) {
            return this.add(n.negate());
          }
          var b = n.value;
          if (n.isSmall) {
            return new SmallInteger(a - b);
          }
          return subtractSmall(b, Math.abs(a), a >= 0);
        };
        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
        NativeBigInt.prototype.subtract = function(v) {
          return new NativeBigInt(this.value - parseValue(v).value);
        };
        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
        BigInteger2.prototype.negate = function() {
          return new BigInteger2(this.value, !this.sign);
        };
        SmallInteger.prototype.negate = function() {
          var sign = this.sign;
          var small = new SmallInteger(-this.value);
          small.sign = !sign;
          return small;
        };
        NativeBigInt.prototype.negate = function() {
          return new NativeBigInt(-this.value);
        };
        BigInteger2.prototype.abs = function() {
          return new BigInteger2(this.value, false);
        };
        SmallInteger.prototype.abs = function() {
          return new SmallInteger(Math.abs(this.value));
        };
        NativeBigInt.prototype.abs = function() {
          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
        };
        function multiplyLong(a, b) {
          var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE2, product, carry, i10, a_i, b_j;
          for (i10 = 0; i10 < a_l; ++i10) {
            a_i = a[i10];
            for (var j = 0; j < b_l; ++j) {
              b_j = b[j];
              product = a_i * b_j + r[i10 + j];
              carry = Math.floor(product / base);
              r[i10 + j] = product - carry * base;
              r[i10 + j + 1] += carry;
            }
          }
          trim(r);
          return r;
        }
        function multiplySmall(a, b) {
          var l = a.length, r = new Array(l), base = BASE2, carry = 0, product, i10;
          for (i10 = 0; i10 < l; i10++) {
            product = a[i10] * b + carry;
            carry = Math.floor(product / base);
            r[i10] = product - carry * base;
          }
          while (carry > 0) {
            r[i10++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r;
        }
        function shiftLeft(x, n) {
          var r = [];
          while (n-- > 0) r.push(0);
          return r.concat(x);
        }
        function multiplyKaratsuba(x, y) {
          var n = Math.max(x.length, y.length);
          if (n <= 30) return multiplyLong(x, y);
          n = Math.ceil(n / 2);
          var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
          var ac2 = multiplyKaratsuba(a, c), bd2 = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
          var product = addAny(addAny(ac2, shiftLeft(subtract2(subtract2(abcd, ac2), bd2), n)), shiftLeft(bd2, 2 * n));
          trim(product);
          return product;
        }
        function useKaratsuba(l12, l22) {
          return -0.012 * l12 - 0.012 * l22 + 15e-6 * l12 * l22 > 0;
        }
        BigInteger2.prototype.multiply = function(v) {
          var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
          if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE2) {
              return new BigInteger2(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
          }
          if (useKaratsuba(a.length, b.length))
            return new BigInteger2(multiplyKaratsuba(a, b), sign);
          return new BigInteger2(multiplyLong(a, b), sign);
        };
        BigInteger2.prototype.times = BigInteger2.prototype.multiply;
        function multiplySmallAndArray(a, b, sign) {
          if (a < BASE2) {
            return new BigInteger2(multiplySmall(b, a), sign);
          }
          return new BigInteger2(multiplyLong(b, smallToArray(a)), sign);
        }
        SmallInteger.prototype._multiplyBySmall = function(a) {
          if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
          }
          return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
        };
        BigInteger2.prototype._multiplyBySmall = function(a) {
          if (a.value === 0) return Integer[0];
          if (a.value === 1) return this;
          if (a.value === -1) return this.negate();
          return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
        };
        SmallInteger.prototype.multiply = function(v) {
          return parseValue(v)._multiplyBySmall(this);
        };
        SmallInteger.prototype.times = SmallInteger.prototype.multiply;
        NativeBigInt.prototype.multiply = function(v) {
          return new NativeBigInt(this.value * parseValue(v).value);
        };
        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
        function square(a) {
          var l = a.length, r = createArray(l + l), base = BASE2, product, carry, i10, a_i, a_j;
          for (i10 = 0; i10 < l; i10++) {
            a_i = a[i10];
            carry = 0 - a_i * a_i;
            for (var j = i10; j < l; j++) {
              a_j = a[j];
              product = 2 * (a_i * a_j) + r[i10 + j] + carry;
              carry = Math.floor(product / base);
              r[i10 + j] = product - carry * base;
            }
            r[i10 + l] = carry;
          }
          trim(r);
          return r;
        }
        BigInteger2.prototype.square = function() {
          return new BigInteger2(square(this.value), false);
        };
        SmallInteger.prototype.square = function() {
          var value = this.value * this.value;
          if (isPrecise(value)) return new SmallInteger(value);
          return new BigInteger2(square(smallToArray(Math.abs(this.value))), false);
        };
        NativeBigInt.prototype.square = function(v) {
          return new NativeBigInt(this.value * this.value);
        };
        function divMod1(a, b) {
          var a_l = a.length, b_l = b.length, base = BASE2, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i10, l, q;
          if (remainder.length <= a_l) remainder.push(0);
          divisor.push(0);
          divisorMostSignificantDigit = divisor[b_l - 1];
          for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i10 = 0; i10 < l; i10++) {
              carry += quotientDigit * divisor[i10];
              q = Math.floor(carry / base);
              borrow += remainder[shift + i10] - (carry - q * base);
              carry = q;
              if (borrow < 0) {
                remainder[shift + i10] = borrow + base;
                borrow = -1;
              } else {
                remainder[shift + i10] = borrow;
                borrow = 0;
              }
            }
            while (borrow !== 0) {
              quotientDigit -= 1;
              carry = 0;
              for (i10 = 0; i10 < l; i10++) {
                carry += remainder[shift + i10] - base + divisor[i10];
                if (carry < 0) {
                  remainder[shift + i10] = carry + base;
                  carry = 0;
                } else {
                  remainder[shift + i10] = carry;
                  carry = 1;
                }
              }
              borrow += carry;
            }
            result[shift] = quotientDigit;
          }
          remainder = divModSmall(remainder, lambda)[0];
          return [arrayToSmall(result), arrayToSmall(remainder)];
        }
        function divMod2(a, b) {
          var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE2, guess, xlen, highx, highy, check;
          while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
              result.push(0);
              continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
              highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
              check = multiplySmall(b, guess);
              if (compareAbs(check, part) <= 0) break;
              guess--;
            } while (guess);
            result.push(guess);
            part = subtract2(part, check);
          }
          result.reverse();
          return [arrayToSmall(result), arrayToSmall(part)];
        }
        function divModSmall(value, lambda) {
          var length = value.length, quotient = createArray(length), base = BASE2, i10, q, remainder, divisor;
          remainder = 0;
          for (i10 = length - 1; i10 >= 0; --i10) {
            divisor = remainder * base + value[i10];
            q = truncate2(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i10] = q | 0;
          }
          return [quotient, remainder | 0];
        }
        function divModAny(self2, v) {
          var value, n = parseValue(v);
          if (supportsNativeBigInt) {
            return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
          }
          var a = self2.value, b = n.value;
          var quotient;
          if (b === 0) throw new Error("Cannot divide by zero");
          if (self2.isSmall) {
            if (n.isSmall) {
              return [new SmallInteger(truncate2(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self2];
          }
          if (n.isSmall) {
            if (b === 1) return [self2, Integer[0]];
            if (b == -1) return [self2.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE2) {
              value = divModSmall(a, abs);
              quotient = arrayToSmall(value[0]);
              var remainder = value[1];
              if (self2.sign) remainder = -remainder;
              if (typeof quotient === "number") {
                if (self2.sign !== n.sign) quotient = -quotient;
                return [new SmallInteger(quotient), new SmallInteger(remainder)];
              }
              return [new BigInteger2(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
          }
          var comparison = compareAbs(a, b);
          if (comparison === -1) return [Integer[0], self2];
          if (comparison === 0) return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
          if (a.length + b.length <= 200)
            value = divMod1(a, b);
          else value = divMod2(a, b);
          quotient = value[0];
          var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
          if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
          } else quotient = new BigInteger2(quotient, qSign);
          if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
          } else mod = new BigInteger2(mod, mSign);
          return [quotient, mod];
        }
        BigInteger2.prototype.divmod = function(v) {
          var result = divModAny(this, v);
          return {
            quotient: result[0],
            remainder: result[1]
          };
        };
        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger2.prototype.divmod;
        BigInteger2.prototype.divide = function(v) {
          return divModAny(this, v)[0];
        };
        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
          return new NativeBigInt(this.value / parseValue(v).value);
        };
        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger2.prototype.over = BigInteger2.prototype.divide;
        BigInteger2.prototype.mod = function(v) {
          return divModAny(this, v)[1];
        };
        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
          return new NativeBigInt(this.value % parseValue(v).value);
        };
        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger2.prototype.remainder = BigInteger2.prototype.mod;
        BigInteger2.prototype.pow = function(v) {
          var n = parseValue(v), a = this.value, b = n.value, value, x, y;
          if (b === 0) return Integer[1];
          if (a === 0) return Integer[0];
          if (a === 1) return Integer[1];
          if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
          if (n.sign) {
            return Integer[0];
          }
          if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
          if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
              return new SmallInteger(truncate2(value));
          }
          x = this;
          y = Integer[1];
          while (true) {
            if (b & true) {
              y = y.times(x);
              --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
          }
          return y;
        };
        SmallInteger.prototype.pow = BigInteger2.prototype.pow;
        NativeBigInt.prototype.pow = function(v) {
          var n = parseValue(v);
          var a = this.value, b = n.value;
          var _02 = BigInt(0), _12 = BigInt(1), _22 = BigInt(2);
          if (b === _02) return Integer[1];
          if (a === _02) return Integer[0];
          if (a === _12) return Integer[1];
          if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
          if (n.isNegative()) return new NativeBigInt(_02);
          var x = this;
          var y = Integer[1];
          while (true) {
            if ((b & _12) === _12) {
              y = y.times(x);
              --b;
            }
            if (b === _02) break;
            b /= _22;
            x = x.square();
          }
          return y;
        };
        BigInteger2.prototype.modPow = function(exp2, mod) {
          exp2 = parseValue(exp2);
          mod = parseValue(mod);
          if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
          var r = Integer[1], base = this.mod(mod);
          if (exp2.isNegative()) {
            exp2 = exp2.multiply(Integer[-1]);
            base = base.modInv(mod);
          }
          while (exp2.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp2.isOdd()) r = r.multiply(base).mod(mod);
            exp2 = exp2.divide(2);
            base = base.square().mod(mod);
          }
          return r;
        };
        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger2.prototype.modPow;
        function compareAbs(a, b) {
          if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
          }
          for (var i10 = a.length - 1; i10 >= 0; i10--) {
            if (a[i10] !== b[i10]) return a[i10] > b[i10] ? 1 : -1;
          }
          return 0;
        }
        BigInteger2.prototype.compareAbs = function(v) {
          var n = parseValue(v), a = this.value, b = n.value;
          if (n.isSmall) return 1;
          return compareAbs(a, b);
        };
        SmallInteger.prototype.compareAbs = function(v) {
          var n = parseValue(v), a = Math.abs(this.value), b = n.value;
          if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
          }
          return -1;
        };
        NativeBigInt.prototype.compareAbs = function(v) {
          var a = this.value;
          var b = parseValue(v).value;
          a = a >= 0 ? a : -a;
          b = b >= 0 ? b : -b;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        BigInteger2.prototype.compare = function(v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var n = parseValue(v), a = this.value, b = n.value;
          if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
          }
          if (n.isSmall) {
            return this.sign ? -1 : 1;
          }
          return compareAbs(a, b) * (this.sign ? -1 : 1);
        };
        BigInteger2.prototype.compareTo = BigInteger2.prototype.compare;
        SmallInteger.prototype.compare = function(v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var n = parseValue(v), a = this.value, b = n.value;
          if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
          }
          if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
          }
          return a < 0 ? 1 : -1;
        };
        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
        NativeBigInt.prototype.compare = function(v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var a = this.value;
          var b = parseValue(v).value;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
        BigInteger2.prototype.equals = function(v) {
          return this.compare(v) === 0;
        };
        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger2.prototype.eq = BigInteger2.prototype.equals;
        BigInteger2.prototype.notEquals = function(v) {
          return this.compare(v) !== 0;
        };
        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger2.prototype.neq = BigInteger2.prototype.notEquals;
        BigInteger2.prototype.greater = function(v) {
          return this.compare(v) > 0;
        };
        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger2.prototype.gt = BigInteger2.prototype.greater;
        BigInteger2.prototype.lesser = function(v) {
          return this.compare(v) < 0;
        };
        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger2.prototype.lt = BigInteger2.prototype.lesser;
        BigInteger2.prototype.greaterOrEquals = function(v) {
          return this.compare(v) >= 0;
        };
        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger2.prototype.geq = BigInteger2.prototype.greaterOrEquals;
        BigInteger2.prototype.lesserOrEquals = function(v) {
          return this.compare(v) <= 0;
        };
        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger2.prototype.leq = BigInteger2.prototype.lesserOrEquals;
        BigInteger2.prototype.isEven = function() {
          return (this.value[0] & 1) === 0;
        };
        SmallInteger.prototype.isEven = function() {
          return (this.value & 1) === 0;
        };
        NativeBigInt.prototype.isEven = function() {
          return (this.value & BigInt(1)) === BigInt(0);
        };
        BigInteger2.prototype.isOdd = function() {
          return (this.value[0] & 1) === 1;
        };
        SmallInteger.prototype.isOdd = function() {
          return (this.value & 1) === 1;
        };
        NativeBigInt.prototype.isOdd = function() {
          return (this.value & BigInt(1)) === BigInt(1);
        };
        BigInteger2.prototype.isPositive = function() {
          return !this.sign;
        };
        SmallInteger.prototype.isPositive = function() {
          return this.value > 0;
        };
        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
        BigInteger2.prototype.isNegative = function() {
          return this.sign;
        };
        SmallInteger.prototype.isNegative = function() {
          return this.value < 0;
        };
        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
        BigInteger2.prototype.isUnit = function() {
          return false;
        };
        SmallInteger.prototype.isUnit = function() {
          return Math.abs(this.value) === 1;
        };
        NativeBigInt.prototype.isUnit = function() {
          return this.abs().value === BigInt(1);
        };
        BigInteger2.prototype.isZero = function() {
          return false;
        };
        SmallInteger.prototype.isZero = function() {
          return this.value === 0;
        };
        NativeBigInt.prototype.isZero = function() {
          return this.value === BigInt(0);
        };
        BigInteger2.prototype.isDivisibleBy = function(v) {
          var n = parseValue(v);
          if (n.isZero()) return false;
          if (n.isUnit()) return true;
          if (n.compareAbs(2) === 0) return this.isEven();
          return this.mod(n).isZero();
        };
        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger2.prototype.isDivisibleBy;
        function isBasicPrime(v) {
          var n = v.abs();
          if (n.isUnit()) return false;
          if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
          if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
          if (n.lesser(49)) return true;
        }
        function millerRabinTest(n, a) {
          var nPrev = n.prev(), b = nPrev, r = 0, d, i10, x;
          while (b.isEven()) b = b.divide(2), r++;
          next: for (i10 = 0; i10 < a.length; i10++) {
            if (n.lesser(a[i10])) continue;
            x = bigInt2(a[i10]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
              x = x.square().mod(n);
              if (x.isUnit()) return false;
              if (x.equals(nPrev)) continue next;
            }
            return false;
          }
          return true;
        }
        BigInteger2.prototype.isPrime = function(strict) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined$1) return isPrime;
          var n = this.abs();
          var bits = n.bitLength();
          if (bits <= 64)
            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
          var logN = Math.log(2) * bits.toJSNumber();
          var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
          for (var a = [], i10 = 0; i10 < t; i10++) {
            a.push(bigInt2(i10 + 2));
          }
          return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger2.prototype.isPrime;
        BigInteger2.prototype.isProbablePrime = function(iterations, rng2) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined$1) return isPrime;
          var n = this.abs();
          var t = iterations === undefined$1 ? 5 : iterations;
          for (var a = [], i10 = 0; i10 < t; i10++) {
            a.push(bigInt2.randBetween(2, n.minus(2), rng2));
          }
          return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger2.prototype.isProbablePrime;
        BigInteger2.prototype.modInv = function(n) {
          var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
          while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
          }
          if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
          if (t.compare(0) === -1) {
            t = t.add(n);
          }
          if (this.isNegative()) {
            return t.negate();
          }
          return t;
        };
        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger2.prototype.modInv;
        BigInteger2.prototype.next = function() {
          var value = this.value;
          if (this.sign) {
            return subtractSmall(value, 1, this.sign);
          }
          return new BigInteger2(addSmall(value, 1), this.sign);
        };
        SmallInteger.prototype.next = function() {
          var value = this.value;
          if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
          return new BigInteger2(MAX_INT_ARR, false);
        };
        NativeBigInt.prototype.next = function() {
          return new NativeBigInt(this.value + BigInt(1));
        };
        BigInteger2.prototype.prev = function() {
          var value = this.value;
          if (this.sign) {
            return new BigInteger2(addSmall(value, 1), true);
          }
          return subtractSmall(value, 1, this.sign);
        };
        SmallInteger.prototype.prev = function() {
          var value = this.value;
          if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
          return new BigInteger2(MAX_INT_ARR, true);
        };
        NativeBigInt.prototype.prev = function() {
          return new NativeBigInt(this.value - BigInt(1));
        };
        var powersOfTwo = [1];
        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE2) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
        var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
        function shift_isSmall(n) {
          return Math.abs(n) <= BASE2;
        }
        BigInteger2.prototype.shiftLeft = function(v) {
          var n = parseValue(v).toJSNumber();
          if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
          }
          if (n < 0) return this.shiftRight(-n);
          var result = this;
          if (result.isZero()) return result;
          while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
          }
          return result.multiply(powersOfTwo[n]);
        };
        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger2.prototype.shiftLeft;
        BigInteger2.prototype.shiftRight = function(v) {
          var remQuo;
          var n = parseValue(v).toJSNumber();
          if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
          }
          if (n < 0) return this.shiftLeft(-n);
          var result = this;
          while (n >= powers2Length) {
            if (result.isZero() || result.isNegative() && result.isUnit()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
          }
          remQuo = divModAny(result, powersOfTwo[n]);
          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        };
        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger2.prototype.shiftRight;
        function bitwise(x, y, fn2) {
          y = parseValue(y);
          var xSign = x.isNegative(), ySign = y.isNegative();
          var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
          var xDigit = 0, yDigit = 0;
          var xDivMod = null, yDivMod = null;
          var result = [];
          while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
              xDigit = highestPower2 - 1 - xDigit;
            }
            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
              yDigit = highestPower2 - 1 - yDigit;
            }
            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn2(xDigit, yDigit));
          }
          var sum = fn2(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);
          for (var i10 = result.length - 1; i10 >= 0; i10 -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt2(result[i10]));
          }
          return sum;
        }
        BigInteger2.prototype.not = function() {
          return this.negate().prev();
        };
        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger2.prototype.not;
        BigInteger2.prototype.and = function(n) {
          return bitwise(this, n, function(a, b) {
            return a & b;
          });
        };
        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger2.prototype.and;
        BigInteger2.prototype.or = function(n) {
          return bitwise(this, n, function(a, b) {
            return a | b;
          });
        };
        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger2.prototype.or;
        BigInteger2.prototype.xor = function(n) {
          return bitwise(this, n, function(a, b) {
            return a ^ b;
          });
        };
        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger2.prototype.xor;
        var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE2 & -BASE2) * (BASE2 & -BASE2) | LOBMASK_I;
        function roughLOB(n) {
          var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE2 | LOBMASK_BI;
          return x & -x;
        }
        function integerLogarithm(value, base) {
          if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
          }
          return { p: bigInt2(1), e: 0 };
        }
        BigInteger2.prototype.bitLength = function() {
          var n = this;
          if (n.compareTo(bigInt2(0)) < 0) {
            n = n.negate().subtract(bigInt2(1));
          }
          if (n.compareTo(bigInt2(0)) === 0) {
            return bigInt2(0);
          }
          return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));
        };
        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger2.prototype.bitLength;
        function max(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.greater(b) ? a : b;
        }
        function min(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.lesser(b) ? a : b;
        }
        function gcd(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          if (a.equals(b)) return a;
          if (a.isZero()) return b;
          if (b.isZero()) return a;
          var c = Integer[1], d, t;
          while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
          }
          while (a.isEven()) {
            a = a.divide(roughLOB(a));
          }
          do {
            while (b.isEven()) {
              b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
              t = b;
              b = a;
              a = t;
            }
            b = b.subtract(a);
          } while (!b.isZero());
          return c.isUnit() ? a : a.multiply(c);
        }
        function lcm(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          return a.divide(gcd(a, b)).multiply(b);
        }
        function randBetween(a, b, rng2) {
          a = parseValue(a);
          b = parseValue(b);
          var usedRNG = rng2 || Math.random;
          var low = min(a, b), high = max(a, b);
          var range = high.subtract(low).add(1);
          if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
          var digits = toBase(range, BASE2).value;
          var result = [], restricted = true;
          for (var i10 = 0; i10 < digits.length; i10++) {
            var top = restricted ? digits[i10] + (i10 + 1 < digits.length ? digits[i10 + 1] / BASE2 : 0) : BASE2;
            var digit = truncate2(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i10]) restricted = false;
          }
          return low.add(Integer.fromArray(result, BASE2, false));
        }
        var parseBase = function(text, base, alphabet, caseSensitive) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          text = String(text);
          if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
          }
          var length = text.length;
          var i10;
          var absBase = Math.abs(base);
          var alphabetValues = {};
          for (i10 = 0; i10 < alphabet.length; i10++) {
            alphabetValues[alphabet[i10]] = i10;
          }
          for (i10 = 0; i10 < length; i10++) {
            var c = text[i10];
            if (c === "-") continue;
            if (c in alphabetValues) {
              if (alphabetValues[c] >= absBase) {
                if (c === "1" && absBase === 1) continue;
                throw new Error(c + " is not a valid digit in base " + base + ".");
              }
            }
          }
          base = parseValue(base);
          var digits = [];
          var isNegative = text[0] === "-";
          for (i10 = isNegative ? 1 : 0; i10 < text.length; i10++) {
            var c = text[i10];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
              var start = i10;
              do {
                i10++;
              } while (text[i10] !== ">" && i10 < text.length);
              digits.push(parseValue(text.slice(start + 1, i10)));
            } else throw new Error(c + " is not a valid character");
          }
          return parseBaseFromArray(digits, base, isNegative);
        };
        function parseBaseFromArray(digits, base, isNegative) {
          var val = Integer[0], pow = Integer[1], i10;
          for (i10 = digits.length - 1; i10 >= 0; i10--) {
            val = val.add(digits[i10].times(pow));
            pow = pow.times(base);
          }
          return isNegative ? val.negate() : val;
        }
        function stringify(digit, alphabet) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          if (digit < alphabet.length) {
            return alphabet[digit];
          }
          return "<" + digit + ">";
        }
        function toBase(n, base) {
          base = bigInt2(base);
          if (base.isZero()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
          }
          if (base.equals(-1)) {
            if (n.isZero()) return { value: [0], isNegative: false };
            if (n.isNegative())
              return {
                value: [].concat.apply(
                  [],
                  Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
                ),
                isNegative: false
              };
            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
          }
          var neg = false;
          if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
          }
          if (base.isUnit()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            return {
              value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
          }
          var out = [];
          var left = n, divmod;
          while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
              digit = base.minus(digit).abs();
              left = left.next();
            }
            out.push(digit.toJSNumber());
          }
          out.push(left.toJSNumber());
          return { value: out.reverse(), isNegative: neg };
        }
        function toBaseString(n, base, alphabet) {
          var arr = toBase(n, base);
          return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
            return stringify(x, alphabet);
          }).join("");
        }
        BigInteger2.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        SmallInteger.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        NativeBigInt.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        BigInteger2.prototype.toString = function(radix, alphabet) {
          if (radix === undefined$1) radix = 10;
          if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
          var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
          while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
          }
          var sign = this.sign ? "-" : "";
          return sign + str;
        };
        SmallInteger.prototype.toString = function(radix, alphabet) {
          if (radix === undefined$1) radix = 10;
          if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
          return String(this.value);
        };
        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
        NativeBigInt.prototype.toJSON = BigInteger2.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
          return this.toString();
        };
        BigInteger2.prototype.valueOf = function() {
          return parseInt(this.toString(), 10);
        };
        BigInteger2.prototype.toJSNumber = BigInteger2.prototype.valueOf;
        SmallInteger.prototype.valueOf = function() {
          return this.value;
        };
        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
          return parseInt(this.toString(), 10);
        };
        function parseStringValue(v) {
          if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate2(x))
              return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
          }
          var sign = v[0] === "-";
          if (sign) v = v.slice(1);
          var split = v.split(/e/i);
          if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
          if (split.length === 2) {
            var exp2 = split[1];
            if (exp2[0] === "+") exp2 = exp2.slice(1);
            exp2 = +exp2;
            if (exp2 !== truncate2(exp2) || !isPrecise(exp2)) throw new Error("Invalid integer: " + exp2 + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
              exp2 -= text.length - decimalPlace - 1;
              text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp2 < 0) throw new Error("Cannot include negative exponent part for integers");
            text += new Array(exp2 + 1).join("0");
            v = text;
          }
          var isValid2 = /^([0-9][0-9]*)$/.test(v);
          if (!isValid2) throw new Error("Invalid integer: " + v);
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
          }
          var r = [], max2 = v.length, l = LOG_BASE2, min2 = max2 - l;
          while (max2 > 0) {
            r.push(+v.slice(min2, max2));
            min2 -= l;
            if (min2 < 0) min2 = 0;
            max2 -= l;
          }
          trim(r);
          return new BigInteger2(r, sign);
        }
        function parseNumberValue(v) {
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
          }
          if (isPrecise(v)) {
            if (v !== truncate2(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
          }
          return parseStringValue(v.toString());
        }
        function parseValue(v) {
          if (typeof v === "number") {
            return parseNumberValue(v);
          }
          if (typeof v === "string") {
            return parseStringValue(v);
          }
          if (typeof v === "bigint") {
            return new NativeBigInt(v);
          }
          return v;
        }
        for (var i = 0; i < 1e3; i++) {
          Integer[i] = parseValue(i);
          if (i > 0) Integer[-i] = parseValue(-i);
        }
        Integer.one = Integer[1];
        Integer.zero = Integer[0];
        Integer.minusOne = Integer[-1];
        Integer.max = max;
        Integer.min = min;
        Integer.gcd = gcd;
        Integer.lcm = lcm;
        Integer.isInstance = function(x) {
          return x instanceof BigInteger2 || x instanceof SmallInteger || x instanceof NativeBigInt;
        };
        Integer.randBetween = randBetween;
        Integer.fromArray = function(digits, base, isNegative) {
          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
        };
        return Integer;
      }();
      if (module.hasOwnProperty("exports")) {
        module.exports = bigInt2;
      }
    })(BigInteger);
    return BigInteger.exports;
  }
  var BigIntegerExports = requireBigInteger();
  var bigInt = /* @__PURE__ */ getDefaultExportFromCjs(BigIntegerExports);
  const MAX_BIG_INT = 64;
  const SMALL_INT = 16;
  const PARTS = MAX_BIG_INT / SMALL_INT;
  function checkBrowserSupportsBigInt() {
    try {
      BigInt;
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function fromHexReverseArray(hexValues, start, size) {
    let value = 0;
    for (let i = 0; i < size; i++) {
      const byte = hexValues[start + i];
      if (byte === void 0) {
        break;
      }
      value += byte * 16 ** i;
    }
    return value;
  }
  function toHexReverseArray(value) {
    const sum = [];
    for (let i = 0; i < value.length; i++) {
      let s = Number(value[i]);
      for (let j = 0; s || j < sum.length; j++) {
        s += (sum[j] || 0) * 10;
        sum[j] = s % 16;
        s = (s - sum[j]) / 16;
      }
    }
    return sum;
  }
  function splitBigInt(value) {
    const sum = toHexReverseArray(value);
    const parts = Array(PARTS);
    for (let i = 0; i < PARTS; i++) {
      parts[PARTS - 1 - i] = fromHexReverseArray(sum, i * PARTS, PARTS);
    }
    return parts;
  }
  class HighLow {
    static fromString(value) {
      return new HighLow(splitBigInt(value), value);
    }
    static fromBit(index2) {
      const parts = Array(PARTS);
      const offset = Math.floor(index2 / SMALL_INT);
      for (let i = 0; i < PARTS; i++) {
        parts[PARTS - 1 - i] = i === offset ? 1 << index2 - offset * SMALL_INT : 0;
      }
      return new HighLow(parts);
    }
    constructor(parts, str) {
      this.parts = parts;
      this.str = str;
    }
    and({ parts }) {
      return new HighLow(this.parts.map((v, i) => v & parts[i]));
    }
    or({ parts }) {
      return new HighLow(this.parts.map((v, i) => v | parts[i]));
    }
    xor({ parts }) {
      return new HighLow(this.parts.map((v, i) => v ^ parts[i]));
    }
    not() {
      return new HighLow(this.parts.map((v) => ~v));
    }
    equals({ parts }) {
      return this.parts.every((v, i) => v === parts[i]);
    }
    /**
     * For the average case the string representation is provided, but
     * when we need to convert high and low to string we just let the
     * slower big-integer library do it.
     */
    toString() {
      if (this.str != null) {
        return this.str;
      }
      const array = new Array(MAX_BIG_INT / 4);
      this.parts.forEach((value, offset) => {
        const hex = toHexReverseArray(value.toString());
        for (let i = 0; i < 4; i++) {
          array[i + offset * 4] = hex[4 - 1 - i] || 0;
        }
      });
      return this.str = bigInt.fromArray(array, 16).toString();
    }
    toJSON() {
      return this.toString();
    }
  }
  const SUPPORTS_BIGINT = checkBrowserSupportsBigInt();
  if (SUPPORTS_BIGINT && BigInt.prototype.toJSON == null) {
    BigInt.prototype.toJSON = function() {
      return this.toString();
    };
  }
  const HIGH_LOW_CACHE = {};
  const convertToBigFlag = SUPPORTS_BIGINT ? function convertToBigFlagBigInt(value) {
    return BigInt(value);
  } : function convertToBigFlagHighLow(value) {
    if (value instanceof HighLow) {
      return value;
    }
    if (typeof value === "number") {
      value = value.toString();
    }
    if (HIGH_LOW_CACHE[value] != null) {
      return HIGH_LOW_CACHE[value];
    }
    HIGH_LOW_CACHE[value] = HighLow.fromString(value);
    return HIGH_LOW_CACHE[value];
  };
  const EMPTY_FLAG = convertToBigFlag(0);
  const flagAnd = SUPPORTS_BIGINT ? function flagAndBigInt(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first & second;
  } : function flagAndHighLow(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first.and(second);
  };
  const flagOr = SUPPORTS_BIGINT ? function flagOrBigInt(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first | second;
  } : function flagOrHighLow(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first.or(second);
  };
  const flagXor = SUPPORTS_BIGINT ? function flagXorBigInt(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first ^ second;
  } : function flagXorHighLow(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first.xor(second);
  };
  const flagNot = SUPPORTS_BIGINT ? function flagNotBigInt(first = EMPTY_FLAG) {
    return ~first;
  } : function flagNotHighLow(first = EMPTY_FLAG) {
    return first.not();
  };
  const flagEquals = SUPPORTS_BIGINT ? function flagEqualsBigInt(first, second) {
    return first === second;
  } : function flagEqualsHighLow(first, second) {
    if (first == null || second == null) {
      return first == second;
    }
    return first.equals(second);
  };
  function flagOrMultiple(...flags) {
    let result = flags[0];
    for (let i = 1; i < flags.length; i++) {
      result = flagOr(result, flags[i]);
    }
    return result;
  }
  function flagHas(base, flag) {
    return flagEquals(flagAnd(base, flag), flag);
  }
  function flagHasAny(base, flag) {
    return !flagEquals(flagAnd(base, flag), EMPTY_FLAG);
  }
  function flagAdd(base, flag) {
    return flag === EMPTY_FLAG ? base : flagOr(base, flag);
  }
  function flagRemove(base, flag) {
    return flag === EMPTY_FLAG ? base : flagXor(base, flagAnd(base, flag));
  }
  const getFlag = SUPPORTS_BIGINT ? function getFlagBigInt(index2) {
    return BigInt(1) << BigInt(index2);
  } : function getFlagHighLow(index2) {
    return HighLow.fromBit(index2);
  };
  var BigFlagUtils = {
    combine: flagOrMultiple,
    add: flagAdd,
    remove: flagRemove,
    filter: flagAnd,
    invert: flagNot,
    has: flagHas,
    hasAny: flagHasAny,
    equals: flagEquals,
    deserialize: convertToBigFlag,
    getFlag
  };
  var RPCCloseCodes;
  (function(RPCCloseCodes2) {
    RPCCloseCodes2[RPCCloseCodes2["CLOSE_NORMAL"] = 1e3] = "CLOSE_NORMAL";
    RPCCloseCodes2[RPCCloseCodes2["CLOSE_UNSUPPORTED"] = 1003] = "CLOSE_UNSUPPORTED";
    RPCCloseCodes2[RPCCloseCodes2["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_CLIENTID"] = 4e3] = "INVALID_CLIENTID";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_ORIGIN"] = 4001] = "INVALID_ORIGIN";
    RPCCloseCodes2[RPCCloseCodes2["RATELIMITED"] = 4002] = "RATELIMITED";
    RPCCloseCodes2[RPCCloseCodes2["TOKEN_REVOKED"] = 4003] = "TOKEN_REVOKED";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_VERSION"] = 4004] = "INVALID_VERSION";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_ENCODING"] = 4005] = "INVALID_ENCODING";
  })(RPCCloseCodes || (RPCCloseCodes = {}));
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["INVALID_PAYLOAD"] = 4e3] = "INVALID_PAYLOAD";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_COMMAND"] = 4002] = "INVALID_COMMAND";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_GUILD"] = 4003] = "INVALID_GUILD";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_EVENT"] = 4004] = "INVALID_EVENT";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_CHANNEL"] = 4005] = "INVALID_CHANNEL";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_PERMISSIONS"] = 4006] = "INVALID_PERMISSIONS";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_CLIENTID"] = 4007] = "INVALID_CLIENTID";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_ORIGIN"] = 4008] = "INVALID_ORIGIN";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_TOKEN"] = 4009] = "INVALID_TOKEN";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_USER"] = 4010] = "INVALID_USER";
  })(RPCErrorCodes || (RPCErrorCodes = {}));
  var Orientation$1;
  (function(Orientation2) {
    Orientation2["LANDSCAPE"] = "landscape";
    Orientation2["PORTRAIT"] = "portrait";
  })(Orientation$1 || (Orientation$1 = {}));
  var Platform;
  (function(Platform2) {
    Platform2["MOBILE"] = "mobile";
    Platform2["DESKTOP"] = "desktop";
  })(Platform || (Platform = {}));
  const Permissions = Object.freeze({
    CREATE_INSTANT_INVITE: BigFlagUtils.getFlag(0),
    KICK_MEMBERS: BigFlagUtils.getFlag(1),
    BAN_MEMBERS: BigFlagUtils.getFlag(2),
    ADMINISTRATOR: BigFlagUtils.getFlag(3),
    MANAGE_CHANNELS: BigFlagUtils.getFlag(4),
    MANAGE_GUILD: BigFlagUtils.getFlag(5),
    ADD_REACTIONS: BigFlagUtils.getFlag(6),
    VIEW_AUDIT_LOG: BigFlagUtils.getFlag(7),
    PRIORITY_SPEAKER: BigFlagUtils.getFlag(8),
    STREAM: BigFlagUtils.getFlag(9),
    VIEW_CHANNEL: BigFlagUtils.getFlag(10),
    SEND_MESSAGES: BigFlagUtils.getFlag(11),
    SEND_TTS_MESSAGES: BigFlagUtils.getFlag(12),
    MANAGE_MESSAGES: BigFlagUtils.getFlag(13),
    EMBED_LINKS: BigFlagUtils.getFlag(14),
    ATTACH_FILES: BigFlagUtils.getFlag(15),
    READ_MESSAGE_HISTORY: BigFlagUtils.getFlag(16),
    MENTION_EVERYONE: BigFlagUtils.getFlag(17),
    USE_EXTERNAL_EMOJIS: BigFlagUtils.getFlag(18),
    VIEW_GUILD_INSIGHTS: BigFlagUtils.getFlag(19),
    CONNECT: BigFlagUtils.getFlag(20),
    SPEAK: BigFlagUtils.getFlag(21),
    MUTE_MEMBERS: BigFlagUtils.getFlag(22),
    DEAFEN_MEMBERS: BigFlagUtils.getFlag(23),
    MOVE_MEMBERS: BigFlagUtils.getFlag(24),
    USE_VAD: BigFlagUtils.getFlag(25),
    CHANGE_NICKNAME: BigFlagUtils.getFlag(26),
    MANAGE_NICKNAMES: BigFlagUtils.getFlag(27),
    MANAGE_ROLES: BigFlagUtils.getFlag(28),
    MANAGE_WEBHOOKS: BigFlagUtils.getFlag(29),
    MANAGE_GUILD_EXPRESSIONS: BigFlagUtils.getFlag(30),
    USE_APPLICATION_COMMANDS: BigFlagUtils.getFlag(31),
    REQUEST_TO_SPEAK: BigFlagUtils.getFlag(32),
    MANAGE_EVENTS: BigFlagUtils.getFlag(33),
    MANAGE_THREADS: BigFlagUtils.getFlag(34),
    CREATE_PUBLIC_THREADS: BigFlagUtils.getFlag(35),
    CREATE_PRIVATE_THREADS: BigFlagUtils.getFlag(36),
    USE_EXTERNAL_STICKERS: BigFlagUtils.getFlag(37),
    SEND_MESSAGES_IN_THREADS: BigFlagUtils.getFlag(38),
    USE_EMBEDDED_ACTIVITIES: BigFlagUtils.getFlag(39),
    MODERATE_MEMBERS: BigFlagUtils.getFlag(40),
    VIEW_CREATOR_MONETIZATION_ANALYTICS: BigFlagUtils.getFlag(41),
    USE_SOUNDBOARD: BigFlagUtils.getFlag(42),
    CREATE_GUILD_EXPRESSIONS: BigFlagUtils.getFlag(43),
    CREATE_EVENTS: BigFlagUtils.getFlag(44),
    USE_EXTERNAL_SOUNDS: BigFlagUtils.getFlag(45),
    SEND_VOICE_MESSAGES: BigFlagUtils.getFlag(46),
    SEND_POLLS: BigFlagUtils.getFlag(49),
    USE_EXTERNAL_APPS: BigFlagUtils.getFlag(50)
  });
  const UNKNOWN_VERSION_NUMBER = -1;
  const HANDSHAKE_SDK_VERSION_MINIMUM_MOBILE_VERSION = 250;
  function zodCoerceUnhandledValue(inputObject) {
    return preprocessType((arg) => {
      var _a2;
      const [objectKey] = (_a2 = Object.entries(inputObject).find(([, value]) => value === arg)) !== null && _a2 !== void 0 ? _a2 : [];
      if (arg != null && objectKey === void 0) {
        return inputObject.UNHANDLED;
      }
      return arg;
    }, stringType().or(numberType()));
  }
  function fallbackToDefault(schema) {
    const transform2 = custom().transform((data) => {
      const res = schema.safeParse(data);
      if (res.success) {
        return res.data;
      }
      return schema._def.defaultValue();
    });
    transform2.overlayType = schema;
    return transform2;
  }
  const InitiateImageUploadResponseSchema = z.object({ image_url: z.string() }).describe('Response for "INITIATE_IMAGE_UPLOAD" Command');
  const OpenShareMomentDialogRequestSchema = z.object({ mediaUrl: z.string().max(1024) }).describe('Request for "OPEN_SHARE_MOMENT_DIALOG" Command');
  const AuthenticateRequestSchema = z.object({ access_token: z.union([z.string(), z.null()]).optional() }).describe('Request for "AUTHENTICATE" Command');
  const AuthenticateResponseSchema = z.object({
    access_token: z.string(),
    user: z.object({
      username: z.string(),
      discriminator: z.string(),
      id: z.string(),
      avatar: z.union([z.string(), z.null()]).optional(),
      public_flags: z.number(),
      global_name: z.union([z.string(), z.null()]).optional()
    }),
    scopes: z.array(fallbackToDefault(z.enum([
      "identify",
      "email",
      "connections",
      "guilds",
      "guilds.join",
      "guilds.members.read",
      "guilds.channels.read",
      "gdm.join",
      "bot",
      "rpc",
      "rpc.notifications.read",
      "rpc.voice.read",
      "rpc.voice.write",
      "rpc.video.read",
      "rpc.video.write",
      "rpc.screenshare.read",
      "rpc.screenshare.write",
      "rpc.activities.write",
      "webhook.incoming",
      "messages.read",
      "applications.builds.upload",
      "applications.builds.read",
      "applications.commands",
      "applications.commands.permissions.update",
      "applications.commands.update",
      "applications.store.update",
      "applications.entitlements",
      "activities.read",
      "activities.write",
      "activities.invites.write",
      "relationships.read",
      "relationships.write",
      "voice",
      "dm_channels.read",
      "role_connections.write",
      "presences.read",
      "presences.write",
      "openid",
      "dm_channels.messages.read",
      "dm_channels.messages.write",
      "gateway.connect",
      "account.global_name.update",
      "payment_sources.country_code",
      "sdk.social_layer_presence",
      "sdk.social_layer",
      "lobbies.write",
      "application_identities.write"
    ]).or(z.literal(-1)).default(-1))),
    expires: z.string(),
    application: z.object({
      description: z.string(),
      icon: z.union([z.string(), z.null()]).optional(),
      id: z.string(),
      rpc_origins: z.array(z.string()).optional(),
      name: z.string()
    })
  }).describe('Response for "AUTHENTICATE" Command');
  const GetActivityInstanceConnectedParticipantsResponseSchema = z.object({
    participants: z.array(z.object({
      id: z.string(),
      username: z.string(),
      global_name: z.union([z.string(), z.null()]).optional(),
      discriminator: z.string(),
      avatar: z.union([z.string(), z.null()]).optional(),
      flags: z.number(),
      bot: z.boolean(),
      avatar_decoration_data: z.union([
        z.object({ asset: z.string(), skuId: z.string().optional(), expiresAt: z.number().optional() }),
        z.null()
      ]).optional(),
      premium_type: z.union([z.number(), z.null()]).optional(),
      nickname: z.string().optional()
    }))
  }).describe('Response for "GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS" Command');
  const ShareInteractionRequestSchema = z.object({
    command: z.string(),
    options: z.array(z.object({ name: z.string(), value: z.string() })).optional(),
    content: z.string().max(2e3).optional(),
    require_launch_channel: z.boolean().optional(),
    preview_image: z.object({ height: z.number(), url: z.string(), width: z.number() }).optional(),
    components: z.array(z.object({
      type: z.literal(1),
      components: z.array(z.object({
        type: z.literal(2),
        style: z.number().gte(1).lte(5),
        label: z.string().max(80).optional(),
        custom_id: z.string().max(100).describe("Developer-defined identifier for the button; max 100 characters").optional()
      })).max(5).optional()
    })).optional(),
    pid: z.number().optional()
  }).describe('Request for "SHARE_INTERACTION" Command');
  const ShareInteractionResponseSchema = z.object({ success: z.boolean() }).describe('Response for "SHARE_INTERACTION" Command');
  const ShareLinkRequestSchema = z.object({
    custom_id: z.string().max(64).optional(),
    message: z.string().max(1e3),
    link_id: z.string().max(64).optional()
  }).describe('Request for "SHARE_LINK" Command');
  const ShareLinkResponseSchema = z.object({ success: z.boolean(), didCopyLink: z.boolean(), didSendMessage: z.boolean() }).describe('Response for "SHARE_LINK" Command');
  const GetRelationshipsResponseSchema = z.object({
    relationships: z.array(z.object({
      type: z.number(),
      user: z.object({
        id: z.string(),
        username: z.string(),
        global_name: z.union([z.string(), z.null()]).optional(),
        discriminator: z.string(),
        avatar: z.union([z.string(), z.null()]).optional(),
        flags: z.number(),
        bot: z.boolean(),
        avatar_decoration_data: z.union([
          z.object({ asset: z.string(), skuId: z.string().optional(), expiresAt: z.number().optional() }),
          z.null()
        ]).optional(),
        premium_type: z.union([z.number(), z.null()]).optional()
      }),
      presence: z.object({
        status: z.string(),
        activity: z.union([
          z.object({
            session_id: z.string().optional(),
            type: z.number().optional(),
            name: z.string(),
            url: z.union([z.string(), z.null()]).optional(),
            application_id: z.string().optional(),
            status_display_type: z.number().optional(),
            state: z.string().optional(),
            state_url: z.string().optional(),
            details: z.string().optional(),
            details_url: z.string().optional(),
            emoji: z.union([
              z.object({
                name: z.string(),
                id: z.union([z.string(), z.null()]).optional(),
                animated: z.union([z.boolean(), z.null()]).optional()
              }),
              z.null()
            ]).optional(),
            assets: z.object({
              large_image: z.string().optional(),
              large_text: z.string().optional(),
              large_url: z.string().optional(),
              small_image: z.string().optional(),
              small_text: z.string().optional(),
              small_url: z.string().optional()
            }).optional(),
            timestamps: z.object({ start: z.number().optional(), end: z.number().optional() }).optional(),
            party: z.object({
              id: z.string().optional(),
              size: z.array(z.number()).min(2).max(2).optional(),
              privacy: z.number().optional()
            }).optional(),
            secrets: z.object({ match: z.string().optional(), join: z.string().optional() }).optional(),
            sync_id: z.string().optional(),
            created_at: z.number().optional(),
            instance: z.boolean().optional(),
            flags: z.number().optional(),
            metadata: z.object({}).optional(),
            platform: z.string().optional(),
            supported_platforms: z.array(z.string()).optional(),
            buttons: z.array(z.string()).optional(),
            hangStatus: z.string().optional()
          }),
          z.null()
        ]).optional()
      }).optional()
    }))
  }).describe('Response for "GET_RELATIONSHIPS" Command');
  const InviteUserEmbeddedRequestSchema = z.object({ user_id: z.string(), content: z.string().min(0).max(1024).optional() }).describe('Request for "INVITE_USER_EMBEDDED" Command');
  const GetUserRequestSchema = z.object({ id: z.string().max(64) }).describe('Request for "GET_USER" Command');
  const GetUserResponseSchema = z.union([
    z.object({
      id: z.string(),
      username: z.string(),
      global_name: z.union([z.string(), z.null()]).optional(),
      discriminator: z.string(),
      avatar: z.union([z.string(), z.null()]).optional(),
      flags: z.number(),
      bot: z.boolean(),
      avatar_decoration_data: z.union([z.object({ asset: z.string(), skuId: z.string().optional(), expiresAt: z.number().optional() }), z.null()]).optional(),
      premium_type: z.union([z.number(), z.null()]).optional()
    }),
    z.null()
  ]);
  const GetQuestEnrollmentStatusRequestSchema = z.object({ quest_id: z.string() }).describe('Request for "GET_QUEST_ENROLLMENT_STATUS" Command');
  const GetQuestEnrollmentStatusResponseSchema = z.object({ quest_id: z.string(), is_enrolled: z.boolean(), enrolled_at: z.union([z.string(), z.null()]).optional() }).describe('Response for "GET_QUEST_ENROLLMENT_STATUS" Command');
  const QuestStartTimerRequestSchema = z.object({ quest_id: z.string() }).describe('Request for "QUEST_START_TIMER" Command');
  const QuestStartTimerResponseSchema = z.object({ success: z.boolean() }).describe('Response for "QUEST_START_TIMER" Command');
  var Command;
  (function(Command2) {
    Command2["INITIATE_IMAGE_UPLOAD"] = "INITIATE_IMAGE_UPLOAD";
    Command2["OPEN_SHARE_MOMENT_DIALOG"] = "OPEN_SHARE_MOMENT_DIALOG";
    Command2["AUTHENTICATE"] = "AUTHENTICATE";
    Command2["GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS"] = "GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS";
    Command2["SHARE_INTERACTION"] = "SHARE_INTERACTION";
    Command2["SHARE_LINK"] = "SHARE_LINK";
    Command2["GET_RELATIONSHIPS"] = "GET_RELATIONSHIPS";
    Command2["INVITE_USER_EMBEDDED"] = "INVITE_USER_EMBEDDED";
    Command2["GET_USER"] = "GET_USER";
    Command2["GET_QUEST_ENROLLMENT_STATUS"] = "GET_QUEST_ENROLLMENT_STATUS";
    Command2["QUEST_START_TIMER"] = "QUEST_START_TIMER";
  })(Command || (Command = {}));
  const emptyResponseSchema = z.object({}).optional().nullable();
  const emptyRequestSchema = z.void();
  const Schemas = {
    [Command.INITIATE_IMAGE_UPLOAD]: {
      request: emptyRequestSchema,
      response: InitiateImageUploadResponseSchema
    },
    [Command.OPEN_SHARE_MOMENT_DIALOG]: {
      request: OpenShareMomentDialogRequestSchema,
      response: emptyResponseSchema
    },
    [Command.AUTHENTICATE]: {
      request: AuthenticateRequestSchema,
      response: AuthenticateResponseSchema
    },
    [Command.GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS]: {
      request: emptyRequestSchema,
      response: GetActivityInstanceConnectedParticipantsResponseSchema
    },
    [Command.SHARE_INTERACTION]: {
      request: ShareInteractionRequestSchema,
      response: ShareInteractionResponseSchema
    },
    [Command.SHARE_LINK]: {
      request: ShareLinkRequestSchema,
      response: ShareLinkResponseSchema
    },
    [Command.GET_RELATIONSHIPS]: {
      request: emptyRequestSchema,
      response: GetRelationshipsResponseSchema
    },
    [Command.INVITE_USER_EMBEDDED]: {
      request: InviteUserEmbeddedRequestSchema,
      response: emptyResponseSchema
    },
    [Command.GET_USER]: {
      request: GetUserRequestSchema,
      response: GetUserResponseSchema
    },
    [Command.GET_QUEST_ENROLLMENT_STATUS]: {
      request: GetQuestEnrollmentStatusRequestSchema,
      response: GetQuestEnrollmentStatusResponseSchema
    },
    [Command.QUEST_START_TIMER]: {
      request: QuestStartTimerRequestSchema,
      response: QuestStartTimerResponseSchema
    }
  };
  const DISPATCH = "DISPATCH";
  var Commands$1;
  (function(Commands2) {
    Commands2["AUTHORIZE"] = "AUTHORIZE";
    Commands2["GET_GUILDS"] = "GET_GUILDS";
    Commands2["GET_GUILD"] = "GET_GUILD";
    Commands2["GET_CHANNEL"] = "GET_CHANNEL";
    Commands2["GET_CHANNELS"] = "GET_CHANNELS";
    Commands2["SELECT_VOICE_CHANNEL"] = "SELECT_VOICE_CHANNEL";
    Commands2["SELECT_TEXT_CHANNEL"] = "SELECT_TEXT_CHANNEL";
    Commands2["SUBSCRIBE"] = "SUBSCRIBE";
    Commands2["UNSUBSCRIBE"] = "UNSUBSCRIBE";
    Commands2["CAPTURE_SHORTCUT"] = "CAPTURE_SHORTCUT";
    Commands2["SET_CERTIFIED_DEVICES"] = "SET_CERTIFIED_DEVICES";
    Commands2["SET_ACTIVITY"] = "SET_ACTIVITY";
    Commands2["GET_SKUS"] = "GET_SKUS";
    Commands2["GET_ENTITLEMENTS"] = "GET_ENTITLEMENTS";
    Commands2["GET_SKUS_EMBEDDED"] = "GET_SKUS_EMBEDDED";
    Commands2["GET_ENTITLEMENTS_EMBEDDED"] = "GET_ENTITLEMENTS_EMBEDDED";
    Commands2["START_PURCHASE"] = "START_PURCHASE";
    Commands2["SET_CONFIG"] = "SET_CONFIG";
    Commands2["SEND_ANALYTICS_EVENT"] = "SEND_ANALYTICS_EVENT";
    Commands2["USER_SETTINGS_GET_LOCALE"] = "USER_SETTINGS_GET_LOCALE";
    Commands2["OPEN_EXTERNAL_LINK"] = "OPEN_EXTERNAL_LINK";
    Commands2["ENCOURAGE_HW_ACCELERATION"] = "ENCOURAGE_HW_ACCELERATION";
    Commands2["CAPTURE_LOG"] = "CAPTURE_LOG";
    Commands2["SET_ORIENTATION_LOCK_STATE"] = "SET_ORIENTATION_LOCK_STATE";
    Commands2["OPEN_INVITE_DIALOG"] = "OPEN_INVITE_DIALOG";
    Commands2["GET_PLATFORM_BEHAVIORS"] = "GET_PLATFORM_BEHAVIORS";
    Commands2["GET_CHANNEL_PERMISSIONS"] = "GET_CHANNEL_PERMISSIONS";
    Commands2["AUTHENTICATE"] = "AUTHENTICATE";
    Commands2["GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS"] = "GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS";
    Commands2["GET_QUEST_ENROLLMENT_STATUS"] = "GET_QUEST_ENROLLMENT_STATUS";
    Commands2["GET_RELATIONSHIPS"] = "GET_RELATIONSHIPS";
    Commands2["GET_USER"] = "GET_USER";
    Commands2["INITIATE_IMAGE_UPLOAD"] = "INITIATE_IMAGE_UPLOAD";
    Commands2["INVITE_USER_EMBEDDED"] = "INVITE_USER_EMBEDDED";
    Commands2["OPEN_SHARE_MOMENT_DIALOG"] = "OPEN_SHARE_MOMENT_DIALOG";
    Commands2["QUEST_START_TIMER"] = "QUEST_START_TIMER";
    Commands2["SHARE_INTERACTION"] = "SHARE_INTERACTION";
    Commands2["SHARE_LINK"] = "SHARE_LINK";
  })(Commands$1 || (Commands$1 = {}));
  const ReceiveFramePayload = objectType({
    cmd: stringType(),
    data: unknownType(),
    evt: nullType(),
    nonce: stringType()
  }).passthrough();
  const ScopesObject = Object.assign(Object.assign({}, AuthenticateResponseSchema.shape.scopes.element.overlayType._def.innerType.options[0].Values), { UNHANDLED: -1 });
  const Scopes = zodCoerceUnhandledValue(ScopesObject);
  const Relationship = GetRelationshipsResponseSchema.shape.relationships.element;
  const User = objectType({
    id: stringType(),
    username: stringType(),
    discriminator: stringType(),
    global_name: stringType().optional().nullable(),
    avatar: stringType().optional().nullable(),
    avatar_decoration_data: objectType({
      asset: stringType(),
      sku_id: stringType().optional()
    }).nullable(),
    bot: booleanType(),
    flags: numberType().optional().nullable(),
    premium_type: numberType().optional().nullable()
  });
  const GuildMember = objectType({
    user: User,
    nick: stringType().optional().nullable(),
    roles: arrayType(stringType()),
    joined_at: stringType(),
    deaf: booleanType(),
    mute: booleanType()
  });
  const GuildMemberRPC = objectType({
    user_id: stringType(),
    nick: stringType().optional().nullable(),
    guild_id: stringType(),
    avatar: stringType().optional().nullable(),
    avatar_decoration_data: objectType({
      asset: stringType(),
      sku_id: stringType().optional().nullable()
    }).optional().nullable(),
    color_string: stringType().optional().nullable()
  });
  const Emoji = objectType({
    id: stringType(),
    name: stringType().optional().nullable(),
    roles: arrayType(stringType()).optional().nullable(),
    user: User.optional().nullable(),
    require_colons: booleanType().optional().nullable(),
    managed: booleanType().optional().nullable(),
    animated: booleanType().optional().nullable(),
    available: booleanType().optional().nullable()
  });
  const VoiceState = objectType({
    mute: booleanType(),
    deaf: booleanType(),
    self_mute: booleanType(),
    self_deaf: booleanType(),
    suppress: booleanType()
  });
  const UserVoiceState = objectType({
    mute: booleanType(),
    nick: stringType(),
    user: User,
    voice_state: VoiceState,
    volume: numberType()
  });
  const StatusObject = {
    UNHANDLED: -1,
    IDLE: "idle",
    DND: "dnd",
    ONLINE: "online",
    OFFLINE: "offline"
  };
  const Status = zodCoerceUnhandledValue(StatusObject);
  const Activity = objectType({
    name: stringType(),
    type: numberType(),
    url: stringType().optional().nullable(),
    created_at: numberType().optional().nullable(),
    timestamps: objectType({
      start: numberType(),
      end: numberType()
    }).partial().optional().nullable(),
    application_id: stringType().optional().nullable(),
    details: stringType().optional().nullable(),
    details_url: stringType().url().optional().nullable(),
    state: stringType().optional().nullable(),
    state_url: stringType().url().optional().nullable(),
    emoji: Emoji.optional().nullable(),
    party: objectType({
      id: stringType().optional().nullable(),
      size: arrayType(numberType()).optional().nullable()
    }).optional().nullable(),
    assets: objectType({
      large_image: stringType().nullable(),
      large_text: stringType().nullable(),
      large_url: stringType().url().optional().nullable(),
      small_image: stringType().nullable(),
      small_text: stringType().nullable(),
      small_url: stringType().url().optional().nullable()
    }).partial().optional().nullable(),
    secrets: objectType({
      join: stringType(),
      match: stringType()
    }).partial().optional().nullable(),
    instance: booleanType().optional().nullable(),
    flags: numberType().optional().nullable()
  });
  const PermissionOverwriteTypeObject = {
    UNHANDLED: -1,
    ROLE: 0,
    MEMBER: 1
  };
  const PermissionOverwrite = objectType({
    id: stringType(),
    type: zodCoerceUnhandledValue(PermissionOverwriteTypeObject),
    allow: stringType(),
    deny: stringType()
  });
  const ChannelTypesObject = {
    UNHANDLED: -1,
    DM: 1,
    GROUP_DM: 3,
    GUILD_TEXT: 0,
    GUILD_VOICE: 2,
    GUILD_CATEGORY: 4,
    GUILD_ANNOUNCEMENT: 5,
    GUILD_STORE: 6,
    ANNOUNCEMENT_THREAD: 10,
    PUBLIC_THREAD: 11,
    PRIVATE_THREAD: 12,
    GUILD_STAGE_VOICE: 13,
    GUILD_DIRECTORY: 14,
    GUILD_FORUM: 15
  };
  const Channel = objectType({
    id: stringType(),
    type: zodCoerceUnhandledValue(ChannelTypesObject),
    guild_id: stringType().optional().nullable(),
    position: numberType().optional().nullable(),
    permission_overwrites: arrayType(PermissionOverwrite).optional().nullable(),
    name: stringType().optional().nullable(),
    topic: stringType().optional().nullable(),
    nsfw: booleanType().optional().nullable(),
    last_message_id: stringType().optional().nullable(),
    bitrate: numberType().optional().nullable(),
    user_limit: numberType().optional().nullable(),
    rate_limit_per_user: numberType().optional().nullable(),
    recipients: arrayType(User).optional().nullable(),
    icon: stringType().optional().nullable(),
    owner_id: stringType().optional().nullable(),
    application_id: stringType().optional().nullable(),
    parent_id: stringType().optional().nullable(),
    last_pin_timestamp: stringType().optional().nullable()
  });
  const PresenceUpdate = objectType({
    user: User,
    guild_id: stringType(),
    status: Status,
    activities: arrayType(Activity),
    client_status: objectType({
      desktop: Status,
      mobile: Status,
      web: Status
    }).partial()
  });
  const Role = objectType({
    id: stringType(),
    name: stringType(),
    color: numberType(),
    hoist: booleanType(),
    position: numberType(),
    permissions: stringType(),
    managed: booleanType(),
    mentionable: booleanType()
  });
  const Guild = objectType({
    id: stringType(),
    name: stringType(),
    owner_id: stringType(),
    icon: stringType().nullable(),
    icon_hash: stringType().optional().nullable(),
    splash: stringType().nullable(),
    discovery_splash: stringType().nullable(),
    owner: booleanType().optional().nullable(),
    permissions: stringType().optional().nullable(),
    region: stringType(),
    afk_channel_id: stringType().nullable(),
    afk_timeout: numberType(),
    widget_enabled: booleanType().optional().nullable(),
    widget_channel_id: stringType().optional().nullable(),
    verification_level: numberType(),
    default_message_notifications: numberType(),
    explicit_content_filter: numberType(),
    roles: arrayType(Role),
    emojis: arrayType(Emoji),
    features: arrayType(stringType()),
    mfa_level: numberType(),
    application_id: stringType().nullable(),
    system_channel_id: stringType().nullable(),
    system_channel_flags: numberType(),
    rules_channel_id: stringType().nullable(),
    joined_at: stringType().optional().nullable(),
    large: booleanType().optional().nullable(),
    unavailable: booleanType().optional().nullable(),
    member_count: numberType().optional().nullable(),
    voice_states: arrayType(VoiceState).optional().nullable(),
    members: arrayType(GuildMember).optional().nullable(),
    channels: arrayType(Channel).optional().nullable(),
    presences: arrayType(PresenceUpdate).optional().nullable(),
    max_presences: numberType().optional().nullable(),
    max_members: numberType().optional().nullable(),
    vanity_url_code: stringType().nullable(),
    description: stringType().nullable(),
    banner: stringType().nullable(),
    premium_tier: numberType(),
    premium_subscription_count: numberType().optional().nullable(),
    preferred_locale: stringType(),
    public_updates_channel_id: stringType().nullable(),
    max_video_channel_users: numberType().optional().nullable(),
    approximate_member_count: numberType().optional().nullable(),
    approximate_presence_count: numberType().optional().nullable()
  });
  const ChannelMention = objectType({
    id: stringType(),
    guild_id: stringType(),
    type: numberType(),
    name: stringType()
  });
  const Attachment = objectType({
    id: stringType(),
    filename: stringType(),
    size: numberType(),
    url: stringType(),
    proxy_url: stringType(),
    height: numberType().optional().nullable(),
    width: numberType().optional().nullable()
  });
  const EmbedFooter = objectType({
    text: stringType(),
    icon_url: stringType().optional().nullable(),
    proxy_icon_url: stringType().optional().nullable()
  });
  const Image = objectType({
    url: stringType().optional().nullable(),
    proxy_url: stringType().optional().nullable(),
    height: numberType().optional().nullable(),
    width: numberType().optional().nullable()
  });
  const Video = Image.omit({ proxy_url: true });
  const EmbedProvider = objectType({
    name: stringType().optional().nullable(),
    url: stringType().optional().nullable()
  });
  const EmbedAuthor = objectType({
    name: stringType().optional().nullable(),
    url: stringType().optional().nullable(),
    icon_url: stringType().optional().nullable(),
    proxy_icon_url: stringType().optional().nullable()
  });
  const EmbedField = objectType({
    name: stringType(),
    value: stringType(),
    inline: booleanType()
  });
  const Embed = objectType({
    title: stringType().optional().nullable(),
    type: stringType().optional().nullable(),
    description: stringType().optional().nullable(),
    url: stringType().optional().nullable(),
    timestamp: stringType().optional().nullable(),
    color: numberType().optional().nullable(),
    footer: EmbedFooter.optional().nullable(),
    image: Image.optional().nullable(),
    thumbnail: Image.optional().nullable(),
    video: Video.optional().nullable(),
    provider: EmbedProvider.optional().nullable(),
    author: EmbedAuthor.optional().nullable(),
    fields: arrayType(EmbedField).optional().nullable()
  });
  const Reaction = objectType({
    count: numberType(),
    me: booleanType(),
    emoji: Emoji
  });
  const MessageActivity = objectType({
    type: numberType(),
    party_id: stringType().optional().nullable()
  });
  const MessageApplication = objectType({
    id: stringType(),
    cover_image: stringType().optional().nullable(),
    description: stringType(),
    icon: stringType().optional().nullable(),
    name: stringType()
  });
  const MessageReference = objectType({
    message_id: stringType().optional().nullable(),
    channel_id: stringType().optional().nullable(),
    guild_id: stringType().optional().nullable()
  });
  const Message = objectType({
    id: stringType(),
    channel_id: stringType(),
    guild_id: stringType().optional().nullable(),
    author: User.optional().nullable(),
    member: GuildMember.optional().nullable(),
    content: stringType(),
    timestamp: stringType(),
    edited_timestamp: stringType().optional().nullable(),
    tts: booleanType(),
    mention_everyone: booleanType(),
    mentions: arrayType(User),
    mention_roles: arrayType(stringType()),
    mention_channels: arrayType(ChannelMention),
    attachments: arrayType(Attachment),
    embeds: arrayType(Embed),
    reactions: arrayType(Reaction).optional().nullable(),
    nonce: unionType([stringType(), numberType()]).optional().nullable(),
    pinned: booleanType(),
    webhook_id: stringType().optional().nullable(),
    type: numberType(),
    activity: MessageActivity.optional().nullable(),
    application: MessageApplication.optional().nullable(),
    message_reference: MessageReference.optional().nullable(),
    flags: numberType().optional().nullable(),
    stickers: arrayType(unknownType()).optional().nullable(),
    // Cannot self reference, but this is possibly a Message
    referenced_message: unknownType().optional().nullable()
  });
  const VoiceDevice = objectType({
    id: stringType(),
    name: stringType()
  });
  const KeyTypesObject = {
    UNHANDLED: -1,
    KEYBOARD_KEY: 0,
    MOUSE_BUTTON: 1,
    KEYBOARD_MODIFIER_KEY: 2,
    GAMEPAD_BUTTON: 3
  };
  const ShortcutKey = objectType({
    type: zodCoerceUnhandledValue(KeyTypesObject),
    code: numberType(),
    name: stringType()
  });
  const VoiceSettingModeTypeObject = {
    UNHANDLED: -1,
    PUSH_TO_TALK: "PUSH_TO_TALK",
    VOICE_ACTIVITY: "VOICE_ACTIVITY"
  };
  const VoiceSettingsMode = objectType({
    type: zodCoerceUnhandledValue(VoiceSettingModeTypeObject),
    auto_threshold: booleanType(),
    threshold: numberType(),
    shortcut: arrayType(ShortcutKey),
    delay: numberType()
  });
  const VoiceSettingsIO = objectType({
    device_id: stringType(),
    volume: numberType(),
    available_devices: arrayType(VoiceDevice)
  });
  const CertifiedDeviceTypeObject = {
    UNHANDLED: -1,
    AUDIO_INPUT: "AUDIO_INPUT",
    AUDIO_OUTPUT: "AUDIO_OUTPUT",
    VIDEO_INPUT: "VIDEO_INPUT"
  };
  const CertifiedDevice = objectType({
    type: zodCoerceUnhandledValue(CertifiedDeviceTypeObject),
    id: stringType(),
    vendor: objectType({
      name: stringType(),
      url: stringType()
    }),
    model: objectType({
      name: stringType(),
      url: stringType()
    }),
    related: arrayType(stringType()),
    echo_cancellation: booleanType().optional().nullable(),
    noise_suppression: booleanType().optional().nullable(),
    automatic_gain_control: booleanType().optional().nullable(),
    hardware_mute: booleanType().optional().nullable()
  });
  const SkuTypeObject = {
    UNHANDLED: -1,
    APPLICATION: 1,
    DLC: 2,
    CONSUMABLE: 3,
    BUNDLE: 4,
    SUBSCRIPTION: 5
  };
  const Sku = objectType({
    id: stringType(),
    name: stringType(),
    type: zodCoerceUnhandledValue(SkuTypeObject),
    price: objectType({
      amount: numberType(),
      currency: stringType()
    }),
    application_id: stringType(),
    flags: numberType(),
    release_date: stringType().nullable()
  });
  const EntitlementTypesObject = {
    UNHANDLED: -1,
    PURCHASE: 1,
    PREMIUM_SUBSCRIPTION: 2,
    DEVELOPER_GIFT: 3,
    TEST_MODE_PURCHASE: 4,
    FREE_PURCHASE: 5,
    USER_GIFT: 6,
    PREMIUM_PURCHASE: 7
  };
  const Entitlement = objectType({
    id: stringType(),
    sku_id: stringType(),
    application_id: stringType(),
    user_id: stringType(),
    gift_code_flags: numberType(),
    type: zodCoerceUnhandledValue(EntitlementTypesObject),
    gifter_user_id: stringType().optional().nullable(),
    branches: arrayType(stringType()).optional().nullable(),
    starts_at: stringType().optional().nullable(),
    // ISO string
    ends_at: stringType().optional().nullable(),
    // ISO string
    parent_id: stringType().optional().nullable(),
    consumed: booleanType().optional().nullable(),
    deleted: booleanType().optional().nullable(),
    gift_code_batch_id: stringType().optional().nullable()
  });
  const OrientationLockStateTypeObject = {
    UNHANDLED: -1,
    UNLOCKED: 1,
    PORTRAIT: 2,
    LANDSCAPE: 3
  };
  const OrientationLockState = zodCoerceUnhandledValue(OrientationLockStateTypeObject);
  const ThermalStateTypeObject = {
    UNHANDLED: -1,
    NOMINAL: 0,
    FAIR: 1,
    SERIOUS: 2,
    CRITICAL: 3
  };
  const ThermalState = zodCoerceUnhandledValue(ThermalStateTypeObject);
  const OrientationTypeObject = {
    UNHANDLED: -1,
    PORTRAIT: 0,
    LANDSCAPE: 1
  };
  const Orientation = zodCoerceUnhandledValue(OrientationTypeObject);
  const LayoutModeTypeObject = {
    UNHANDLED: -1,
    FOCUSED: 0,
    PIP: 1,
    GRID: 2
  };
  const LayoutMode = zodCoerceUnhandledValue(LayoutModeTypeObject);
  const common = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Activity,
    Attachment,
    CertifiedDevice,
    CertifiedDeviceTypeObject,
    Channel,
    ChannelMention,
    ChannelTypesObject,
    get Commands() {
      return Commands$1;
    },
    DISPATCH,
    Embed,
    EmbedAuthor,
    EmbedField,
    EmbedFooter,
    EmbedProvider,
    Emoji,
    Entitlement,
    EntitlementTypesObject,
    Guild,
    GuildMember,
    GuildMemberRPC,
    Image,
    KeyTypesObject,
    LayoutMode,
    LayoutModeTypeObject,
    Message,
    MessageActivity,
    MessageApplication,
    MessageReference,
    Orientation,
    OrientationLockState,
    OrientationLockStateTypeObject,
    OrientationTypeObject,
    PermissionOverwrite,
    PermissionOverwriteTypeObject,
    PresenceUpdate,
    Reaction,
    ReceiveFramePayload,
    Relationship,
    Role,
    Scopes,
    ScopesObject,
    ShortcutKey,
    Sku,
    SkuTypeObject,
    Status,
    StatusObject,
    ThermalState,
    ThermalStateTypeObject,
    User,
    UserVoiceState,
    Video,
    VoiceDevice,
    VoiceSettingModeTypeObject,
    VoiceSettingsIO,
    VoiceSettingsMode,
    VoiceState
  }, Symbol.toStringTag, { value: "Module" }));
  const ERROR = "ERROR";
  var Events;
  (function(Events2) {
    Events2["READY"] = "READY";
    Events2["VOICE_STATE_UPDATE"] = "VOICE_STATE_UPDATE";
    Events2["SPEAKING_START"] = "SPEAKING_START";
    Events2["SPEAKING_STOP"] = "SPEAKING_STOP";
    Events2["ACTIVITY_LAYOUT_MODE_UPDATE"] = "ACTIVITY_LAYOUT_MODE_UPDATE";
    Events2["ORIENTATION_UPDATE"] = "ORIENTATION_UPDATE";
    Events2["CURRENT_USER_UPDATE"] = "CURRENT_USER_UPDATE";
    Events2["CURRENT_GUILD_MEMBER_UPDATE"] = "CURRENT_GUILD_MEMBER_UPDATE";
    Events2["ENTITLEMENT_CREATE"] = "ENTITLEMENT_CREATE";
    Events2["THERMAL_STATE_UPDATE"] = "THERMAL_STATE_UPDATE";
    Events2["ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE"] = "ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE";
    Events2["RELATIONSHIP_UPDATE"] = "RELATIONSHIP_UPDATE";
    Events2["ACTIVITY_JOIN"] = "ACTIVITY_JOIN";
    Events2["QUEST_ENROLLMENT_STATUS_UPDATE"] = "QUEST_ENROLLMENT_STATUS_UPDATE";
  })(Events || (Events = {}));
  const DispatchEventFrame = ReceiveFramePayload.extend({
    evt: nativeEnumType(Events),
    nonce: stringType().nullable(),
    cmd: literalType(DISPATCH),
    data: objectType({}).passthrough()
  });
  const ErrorEvent = ReceiveFramePayload.extend({
    evt: literalType(ERROR),
    data: objectType({
      code: numberType(),
      message: stringType().optional()
    }).passthrough(),
    cmd: nativeEnumType(Commands$1),
    nonce: stringType().nullable()
  });
  const OtherEvent = DispatchEventFrame.extend({
    evt: stringType()
  });
  const EventFrame = unionType([DispatchEventFrame, OtherEvent, ErrorEvent]);
  function parseEventPayload(data) {
    const event = data.evt;
    if (!(event in Events)) {
      throw new Error(`Unrecognized event type ${data.evt}`);
    }
    const eventSchema = EventSchema[event];
    return eventSchema.payload.parse(data);
  }
  const EventSchema = {
    /**
     * @description
     * The READY event is emitted by Discord's RPC server in reply to a client
     * initiating the RPC handshake. The event includes information about
     * - the rpc server version
     * - the discord client configuration
     * - the (basic) user object
     *
     * Unlike other events, READY will only be omitted once, immediately after the
     * Embedded App SDK is initialized
     *
     * # Supported Platforms
     * | Web | iOS | Android |
     * |-----|-----|---------|
     * |   |   |       |
     *
     * Required scopes: []
     *
     */
    [Events.READY]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.READY),
        data: objectType({
          v: numberType(),
          config: objectType({
            cdn_host: stringType().optional(),
            api_endpoint: stringType(),
            environment: stringType()
          }),
          user: objectType({
            id: stringType(),
            username: stringType(),
            discriminator: stringType(),
            avatar: stringType().optional()
          }).optional()
        })
      })
    },
    [Events.VOICE_STATE_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.VOICE_STATE_UPDATE),
        data: UserVoiceState
      }),
      subscribeArgs: objectType({
        channel_id: stringType()
      })
    },
    [Events.SPEAKING_START]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.SPEAKING_START),
        data: objectType({
          lobby_id: stringType().optional(),
          channel_id: stringType().optional(),
          user_id: stringType()
        })
      }),
      subscribeArgs: objectType({
        lobby_id: stringType().nullable().optional(),
        channel_id: stringType().nullable().optional()
      })
    },
    [Events.SPEAKING_STOP]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.SPEAKING_STOP),
        data: objectType({
          lobby_id: stringType().optional(),
          channel_id: stringType().optional(),
          user_id: stringType()
        })
      }),
      subscribeArgs: objectType({
        lobby_id: stringType().nullable().optional(),
        channel_id: stringType().nullable().optional()
      })
    },
    [Events.ACTIVITY_LAYOUT_MODE_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ACTIVITY_LAYOUT_MODE_UPDATE),
        data: objectType({
          layout_mode: zodCoerceUnhandledValue(LayoutModeTypeObject)
        })
      })
    },
    [Events.ORIENTATION_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ORIENTATION_UPDATE),
        data: objectType({
          screen_orientation: zodCoerceUnhandledValue(OrientationTypeObject),
          /**
           * @deprecated use screen_orientation instead
           */
          orientation: nativeEnumType(Orientation$1)
        })
      })
    },
    [Events.CURRENT_USER_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.CURRENT_USER_UPDATE),
        data: User
      })
    },
    [Events.CURRENT_GUILD_MEMBER_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.CURRENT_GUILD_MEMBER_UPDATE),
        data: GuildMemberRPC
      }),
      subscribeArgs: objectType({
        guild_id: stringType()
      })
    },
    [Events.ENTITLEMENT_CREATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ENTITLEMENT_CREATE),
        data: objectType({ entitlement: Entitlement })
      })
    },
    [Events.THERMAL_STATE_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.THERMAL_STATE_UPDATE),
        data: objectType({ thermal_state: ThermalState })
      })
    },
    [Events.ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE),
        data: objectType({
          participants: GetActivityInstanceConnectedParticipantsResponseSchema.shape.participants
        })
      })
    },
    [Events.RELATIONSHIP_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.RELATIONSHIP_UPDATE),
        data: Relationship
      })
    },
    [Events.ACTIVITY_JOIN]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ACTIVITY_JOIN),
        data: objectType({
          applicationId: stringType(),
          secret: stringType()
        })
      })
    },
    [Events.QUEST_ENROLLMENT_STATUS_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.QUEST_ENROLLMENT_STATUS_UPDATE),
        data: objectType({
          quest_id: stringType(),
          is_enrolled: booleanType(),
          enrolled_at: stringType().date()
        })
      })
    }
  };
  function assertUnreachable(_x2, runtimeError) {
    throw runtimeError;
  }
  const EmptyResponse = objectType({}).nullable();
  const AuthorizeResponse = objectType({
    code: stringType()
  });
  const GetGuildsResponse = objectType({
    guilds: arrayType(objectType({
      id: stringType(),
      name: stringType()
    }))
  });
  const GetGuildResponse = objectType({
    id: stringType(),
    name: stringType(),
    icon_url: stringType().optional(),
    members: arrayType(GuildMember)
  });
  const GetChannelResponse = objectType({
    id: stringType(),
    type: zodCoerceUnhandledValue(ChannelTypesObject),
    guild_id: stringType().optional().nullable(),
    name: stringType().optional().nullable(),
    topic: stringType().optional().nullable(),
    bitrate: numberType().optional().nullable(),
    user_limit: numberType().optional().nullable(),
    position: numberType().optional().nullable(),
    voice_states: arrayType(UserVoiceState),
    messages: arrayType(Message)
  });
  const GetChannelsResponse = objectType({
    channels: arrayType(Channel)
  });
  const NullableChannelResponse = GetChannelResponse.nullable();
  const SelectVoiceChannelResponse = GetChannelResponse.nullable();
  const SelectTextChannelResponse = GetChannelResponse.nullable();
  const VoiceSettingsResponse = objectType({
    input: VoiceSettingsIO,
    output: VoiceSettingsIO,
    mode: VoiceSettingsMode,
    automatic_gain_control: booleanType(),
    echo_cancellation: booleanType(),
    noise_suppression: booleanType(),
    qos: booleanType(),
    silence_warning: booleanType(),
    deaf: booleanType(),
    mute: booleanType()
  });
  const SubscribeResponse = objectType({
    evt: stringType()
  });
  const CaptureShortcutResponse = objectType({ shortcut: ShortcutKey });
  const SetActivityResponse = Activity;
  const GetSkusResponse = objectType({ skus: arrayType(Sku) });
  const GetEntitlementsResponse = objectType({ entitlements: arrayType(Entitlement) });
  const StartPurchaseResponse = arrayType(Entitlement).nullable();
  const SetConfigResponse = objectType({
    use_interactive_pip: booleanType()
  });
  const UserSettingsGetLocaleResponse = objectType({
    locale: stringType()
  });
  const EncourageHardwareAccelerationResponse = objectType({
    enabled: booleanType()
  });
  const GetChannelPermissionsResponse = objectType({
    permissions: bigIntType().or(stringType())
  });
  const OpenExternalLinkResponse = fallbackToDefault(objectType({ opened: booleanType().or(nullType()) }).default({ opened: null }));
  const GetPlatformBehaviorsResponse = objectType({
    iosKeyboardResizesView: optionalType(booleanType())
  });
  const ResponseFrame = ReceiveFramePayload.extend({
    cmd: nativeEnumType(Commands$1),
    evt: nullType()
  });
  function parseResponseData({ cmd, data }) {
    switch (cmd) {
      case Commands$1.AUTHORIZE:
        return AuthorizeResponse.parse(data);
      case Commands$1.CAPTURE_SHORTCUT:
        return CaptureShortcutResponse.parse(data);
      case Commands$1.ENCOURAGE_HW_ACCELERATION:
        return EncourageHardwareAccelerationResponse.parse(data);
      case Commands$1.GET_CHANNEL:
        return GetChannelResponse.parse(data);
      case Commands$1.GET_CHANNELS:
        return GetChannelsResponse.parse(data);
      case Commands$1.GET_CHANNEL_PERMISSIONS:
        return GetChannelPermissionsResponse.parse(data);
      case Commands$1.GET_GUILD:
        return GetGuildResponse.parse(data);
      case Commands$1.GET_GUILDS:
        return GetGuildsResponse.parse(data);
      case Commands$1.GET_PLATFORM_BEHAVIORS:
        return GetPlatformBehaviorsResponse.parse(data);
      case Commands$1.GET_CHANNEL:
        return GetChannelResponse.parse(data);
      case Commands$1.SELECT_TEXT_CHANNEL:
        return SelectTextChannelResponse.parse(data);
      case Commands$1.SELECT_VOICE_CHANNEL:
        return SelectVoiceChannelResponse.parse(data);
      case Commands$1.SET_ACTIVITY:
        return SetActivityResponse.parse(data);
      case Commands$1.GET_SKUS_EMBEDDED:
        return GetSkusResponse.parse(data);
      case Commands$1.GET_ENTITLEMENTS_EMBEDDED:
        return GetEntitlementsResponse.parse(data);
      case Commands$1.SET_CONFIG:
        return SetConfigResponse.parse(data);
      case Commands$1.START_PURCHASE:
        return StartPurchaseResponse.parse(data);
      case Commands$1.SUBSCRIBE:
      case Commands$1.UNSUBSCRIBE:
        return SubscribeResponse.parse(data);
      case Commands$1.USER_SETTINGS_GET_LOCALE:
        return UserSettingsGetLocaleResponse.parse(data);
      case Commands$1.OPEN_EXTERNAL_LINK:
        return OpenExternalLinkResponse.parse(data);
      case Commands$1.SET_ORIENTATION_LOCK_STATE:
      case Commands$1.SET_CERTIFIED_DEVICES:
      case Commands$1.SEND_ANALYTICS_EVENT:
      case Commands$1.OPEN_INVITE_DIALOG:
      case Commands$1.CAPTURE_LOG:
      case Commands$1.GET_SKUS:
      case Commands$1.GET_ENTITLEMENTS:
        return EmptyResponse.parse(data);
      case Commands$1.AUTHENTICATE:
      case Commands$1.GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS:
      case Commands$1.GET_QUEST_ENROLLMENT_STATUS:
      case Commands$1.GET_RELATIONSHIPS:
      case Commands$1.GET_USER:
      case Commands$1.INITIATE_IMAGE_UPLOAD:
      case Commands$1.INVITE_USER_EMBEDDED:
      case Commands$1.OPEN_SHARE_MOMENT_DIALOG:
      case Commands$1.QUEST_START_TIMER:
      case Commands$1.SHARE_INTERACTION:
      case Commands$1.SHARE_LINK:
        const { response } = Schemas[cmd];
        return response.parse(data);
      default:
        assertUnreachable(cmd, new Error(`Unrecognized command ${cmd}`));
    }
  }
  function parseResponsePayload(payload) {
    return Object.assign(Object.assign({}, payload), { data: parseResponseData(payload) });
  }
  const responses = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AuthenticateResponse: AuthenticateResponseSchema,
    AuthorizeResponse,
    CaptureShortcutResponse,
    EmptyResponse,
    EncourageHardwareAccelerationResponse,
    GetChannelPermissionsResponse,
    GetChannelResponse,
    GetChannelsResponse,
    GetEntitlementsResponse,
    GetGuildResponse,
    GetGuildsResponse,
    GetPlatformBehaviorsResponse,
    GetSkusResponse,
    InitiateImageUploadResponse: InitiateImageUploadResponseSchema,
    NullableChannelResponse,
    OpenExternalLinkResponse,
    ResponseFrame,
    SelectTextChannelResponse,
    SelectVoiceChannelResponse,
    SetActivityResponse,
    SetConfigResponse,
    StartPurchaseResponse,
    SubscribeResponse,
    UserSettingsGetLocaleResponse,
    VoiceSettingsResponse,
    parseResponsePayload
  }, Symbol.toStringTag, { value: "Module" }));
  objectType({
    frame_id: stringType(),
    platform: nativeEnumType(Platform).optional().nullable()
  });
  objectType({
    v: literalType(1),
    encoding: literalType("json").optional(),
    client_id: stringType(),
    frame_id: stringType()
  });
  const ClosePayload = objectType({
    code: numberType(),
    message: stringType().optional()
  });
  const IncomingPayload = objectType({
    evt: stringType().nullable(),
    nonce: stringType().nullable(),
    data: unknownType().nullable(),
    cmd: stringType()
  }).passthrough();
  function parseIncomingPayload(payload) {
    const incoming = IncomingPayload.parse(payload);
    if (incoming.evt != null) {
      if (incoming.evt === ERROR) {
        return ErrorEvent.parse(incoming);
      }
      return parseEventPayload(EventFrame.parse(incoming));
    } else {
      return parseResponsePayload(ResponseFrame.passthrough().parse(incoming));
    }
  }
  function commandFactory(sendCommand, cmd, response, transferTransform = () => void 0) {
    const payload = ReceiveFramePayload.extend({
      cmd: literalType(cmd),
      data: response
    });
    return async (args) => {
      const reply = await sendCommand({ cmd, args, transfer: transferTransform(args) });
      const parsed = payload.parse(reply);
      return parsed.data;
    };
  }
  function schemaCommandFactory(cmd, transferTransform = () => void 0) {
    const response = Schemas[cmd].response;
    const payload = ReceiveFramePayload.extend({
      cmd: literalType(cmd),
      data: response
    });
    return (sendCommand) => async (args) => {
      const reply = await sendCommand({
        // @ts-expect-error - Merge commands
        cmd,
        args,
        transfer: transferTransform(args)
      });
      const parsed = payload.parse(reply);
      return parsed.data;
    };
  }
  const authorize = (sendCommand) => commandFactory(sendCommand, Commands$1.AUTHORIZE, AuthorizeResponse);
  const captureLog = (sendCommand) => commandFactory(sendCommand, Commands$1.CAPTURE_LOG, EmptyResponse);
  const encourageHardwareAcceleration = (sendCommand) => commandFactory(sendCommand, Commands$1.ENCOURAGE_HW_ACCELERATION, EncourageHardwareAccelerationResponse);
  const getChannel = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_CHANNEL, GetChannelResponse);
  const getEntitlements = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_ENTITLEMENTS_EMBEDDED, GetEntitlementsResponse);
  const getSkus = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_SKUS_EMBEDDED, GetSkusResponse);
  const getChannelPermissions = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_CHANNEL_PERMISSIONS, GetChannelPermissionsResponse);
  const getPlatformBehaviors = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_PLATFORM_BEHAVIORS, GetPlatformBehaviorsResponse);
  const openExternalLink = (sendCommand) => commandFactory(sendCommand, Commands$1.OPEN_EXTERNAL_LINK, OpenExternalLinkResponse);
  const openInviteDialog = (sendCommand) => commandFactory(sendCommand, Commands$1.OPEN_INVITE_DIALOG, EmptyResponse);
  Activity.pick({
    state: true,
    state_url: true,
    details: true,
    details_url: true,
    timestamps: true,
    assets: true,
    party: true,
    secrets: true,
    instance: true,
    type: true
  }).extend({
    type: Activity.shape.type.optional(),
    instance: Activity.shape.instance.optional()
  }).nullable();
  const setActivity = (sendCommand) => commandFactory(sendCommand, Commands$1.SET_ACTIVITY, SetActivityResponse);
  const setConfig = (sendCommand) => commandFactory(sendCommand, Commands$1.SET_CONFIG, SetConfigResponse);
  function compatCommandFactory({ sendCommand, cmd, response, fallbackTransform: fallbackTransform2, transferTransform = () => void 0 }) {
    const payload = ReceiveFramePayload.extend({
      cmd: literalType(cmd),
      data: response
    });
    return async (args) => {
      try {
        const reply = await sendCommand({ cmd, args, transfer: transferTransform(args) });
        const parsed = payload.parse(reply);
        return parsed.data;
      } catch (error) {
        if (error.code === RPCErrorCodes.INVALID_PAYLOAD) {
          const fallbackArgs = fallbackTransform2(args);
          const reply = await sendCommand({ cmd, args: fallbackArgs, transfer: transferTransform(fallbackArgs) });
          const parsed = payload.parse(reply);
          return parsed.data;
        } else {
          throw error;
        }
      }
    };
  }
  const fallbackTransform = (args) => {
    return {
      lock_state: args.lock_state,
      picture_in_picture_lock_state: args.picture_in_picture_lock_state
    };
  };
  const setOrientationLockState = (sendCommand) => compatCommandFactory({
    sendCommand,
    cmd: Commands$1.SET_ORIENTATION_LOCK_STATE,
    response: EmptyResponse,
    fallbackTransform
  });
  const startPurchase = (sendCommand) => commandFactory(sendCommand, Commands$1.START_PURCHASE, StartPurchaseResponse);
  const userSettingsGetLocale = (sendCommand) => commandFactory(sendCommand, Commands$1.USER_SETTINGS_GET_LOCALE, UserSettingsGetLocaleResponse);
  const authenticate = schemaCommandFactory(Command.AUTHENTICATE);
  const getActivityInstanceConnectedParticipants = schemaCommandFactory(Command.GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS);
  const getQuestEnrollmentStatus = schemaCommandFactory(Command.GET_QUEST_ENROLLMENT_STATUS);
  const getRelationships = schemaCommandFactory(Command.GET_RELATIONSHIPS);
  const getUser = schemaCommandFactory(Command.GET_USER);
  const initiateImageUpload = schemaCommandFactory(Command.INITIATE_IMAGE_UPLOAD);
  const inviteUserEmbedded = schemaCommandFactory(Command.INVITE_USER_EMBEDDED);
  const openShareMomentDialog = schemaCommandFactory(Command.OPEN_SHARE_MOMENT_DIALOG);
  const questStartTimer = schemaCommandFactory(Command.QUEST_START_TIMER);
  const shareInteraction = schemaCommandFactory(Command.SHARE_INTERACTION);
  const shareLink = schemaCommandFactory(Command.SHARE_LINK);
  function commands(sendCommand) {
    return {
      authorize: authorize(sendCommand),
      captureLog: captureLog(sendCommand),
      encourageHardwareAcceleration: encourageHardwareAcceleration(sendCommand),
      getChannel: getChannel(sendCommand),
      getChannelPermissions: getChannelPermissions(sendCommand),
      getEntitlements: getEntitlements(sendCommand),
      getPlatformBehaviors: getPlatformBehaviors(sendCommand),
      getSkus: getSkus(sendCommand),
      openExternalLink: openExternalLink(sendCommand),
      openInviteDialog: openInviteDialog(sendCommand),
      setActivity: setActivity(sendCommand),
      setConfig: setConfig(sendCommand),
      setOrientationLockState: setOrientationLockState(sendCommand),
      startPurchase: startPurchase(sendCommand),
      userSettingsGetLocale: userSettingsGetLocale(sendCommand),
      // Backward compatibility - getInstanceConnectedParticipants is an alias for getActivityInstanceConnectedParticipants
      getInstanceConnectedParticipants: getActivityInstanceConnectedParticipants(sendCommand),
      // START-GENERATED-SECTION
      authenticate: authenticate(sendCommand),
      getActivityInstanceConnectedParticipants: getActivityInstanceConnectedParticipants(sendCommand),
      getQuestEnrollmentStatus: getQuestEnrollmentStatus(sendCommand),
      getRelationships: getRelationships(sendCommand),
      getUser: getUser(sendCommand),
      initiateImageUpload: initiateImageUpload(sendCommand),
      inviteUserEmbedded: inviteUserEmbedded(sendCommand),
      openShareMomentDialog: openShareMomentDialog(sendCommand),
      questStartTimer: questStartTimer(sendCommand),
      shareInteraction: shareInteraction(sendCommand),
      shareLink: shareLink(sendCommand)
      // END-GENERATED-SECTION
    };
  }
  class SDKError extends Error {
    constructor(code, message = "") {
      super(message);
      this.code = code;
      this.message = message;
      this.name = "Discord SDK Error";
    }
  }
  function getDefaultSdkConfiguration() {
    return {
      disableConsoleLogOverride: false
    };
  }
  const consoleLevels = ["log", "warn", "debug", "info", "error"];
  function wrapConsoleMethod(console2, level, callback) {
    const _consoleMethod = console2[level];
    const _console = console2;
    if (!_consoleMethod) {
      return;
    }
    console2[level] = function() {
      const args = [].slice.call(arguments);
      const message = "" + args.join(" ");
      callback(level, message);
      _consoleMethod.apply(_console, args);
    };
  }
  var version = "2.4.0";
  const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native = { randomUUID };
  let getRandomValues;
  const rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      if (typeof crypto === "undefined" || !crypto.getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
      getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
  }
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  function v4(options, buf, offset) {
    var _a2;
    if (native.randomUUID && true && !options) {
      return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? ((_a2 = options.rng) == null ? void 0 : _a2.call(options)) ?? rng();
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
  }
  var Opcodes;
  (function(Opcodes2) {
    Opcodes2[Opcodes2["HANDSHAKE"] = 0] = "HANDSHAKE";
    Opcodes2[Opcodes2["FRAME"] = 1] = "FRAME";
    Opcodes2[Opcodes2["CLOSE"] = 2] = "CLOSE";
    Opcodes2[Opcodes2["HELLO"] = 3] = "HELLO";
  })(Opcodes || (Opcodes = {}));
  const ALLOWED_ORIGINS = new Set(getAllowedOrigins());
  function getAllowedOrigins() {
    if (typeof window === "undefined")
      return [];
    return [
      window.location.origin,
      "https://discord.com",
      "https://discordapp.com",
      "https://ptb.discord.com",
      "https://ptb.discordapp.com",
      "https://canary.discord.com",
      "https://canary.discordapp.com",
      "https://staging.discord.co",
      "http://localhost:3333",
      "https://pax.discord.com",
      "null"
    ];
  }
  function getRPCServerSource() {
    var _a2;
    return [(_a2 = window.parent.opener) !== null && _a2 !== void 0 ? _a2 : window.parent, !!document.referrer ? document.referrer : "*"];
  }
  class DiscordSDK {
    getTransfer(payload) {
      var _a2;
      switch (payload.cmd) {
        case Commands$1.SUBSCRIBE:
        case Commands$1.UNSUBSCRIBE:
          return void 0;
        default:
          return (_a2 = payload.transfer) !== null && _a2 !== void 0 ? _a2 : void 0;
      }
    }
    constructor(clientId, configuration) {
      this.sdkVersion = version;
      this.mobileAppVersion = null;
      this.source = null;
      this.sourceOrigin = "";
      this.eventBus = new EventEmitter();
      this.pendingCommands = /* @__PURE__ */ new Map();
      this.sendCommand = (payload) => {
        var _a2;
        if (this.source == null)
          throw new Error("Attempting to send message before initialization");
        const nonce = v4();
        (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.postMessage([Opcodes.FRAME, Object.assign(Object.assign({}, payload), { nonce })], this.sourceOrigin, this.getTransfer(payload));
        const promise = new Promise((resolve, reject) => {
          this.pendingCommands.set(nonce, { resolve, reject });
        });
        return promise;
      };
      this.commands = commands(this.sendCommand);
      this.handleMessage = (event) => {
        if (!ALLOWED_ORIGINS.has(event.origin))
          return;
        const tuple = event.data;
        if (!Array.isArray(tuple)) {
          return;
        }
        const [opcode, data] = tuple;
        switch (opcode) {
          case Opcodes.HELLO:
            return;
          case Opcodes.CLOSE:
            return this.handleClose(data);
          case Opcodes.HANDSHAKE:
            return this.handleHandshake();
          case Opcodes.FRAME:
            return this.handleFrame(data);
          default:
            throw new Error("Invalid message format");
        }
      };
      this.isReady = false;
      this.clientId = clientId;
      this.configuration = configuration !== null && configuration !== void 0 ? configuration : getDefaultSdkConfiguration();
      if (typeof window !== "undefined") {
        window.addEventListener("message", this.handleMessage);
      }
      if (typeof window === "undefined") {
        this.frameId = "";
        this.instanceId = "";
        this.customId = null;
        this.referrerId = null;
        this.platform = Platform.DESKTOP;
        this.guildId = null;
        this.channelId = null;
        this.locationId = null;
        return;
      }
      const urlParams = new URLSearchParams(this._getSearch());
      const frameId = urlParams.get("frame_id");
      if (!frameId) {
        throw new Error("frame_id query param is not defined");
      }
      this.frameId = frameId;
      const instanceId = urlParams.get("instance_id");
      if (!instanceId) {
        throw new Error("instance_id query param is not defined");
      }
      this.instanceId = instanceId;
      const platform = urlParams.get("platform");
      if (!platform) {
        throw new Error("platform query param is not defined");
      } else if (platform !== Platform.DESKTOP && platform !== Platform.MOBILE) {
        throw new Error(`Invalid query param "platform" of "${platform}". Valid values are "${Platform.DESKTOP}" or "${Platform.MOBILE}"`);
      }
      this.platform = platform;
      this.customId = urlParams.get("custom_id");
      this.referrerId = urlParams.get("referrer_id");
      this.guildId = urlParams.get("guild_id");
      this.channelId = urlParams.get("channel_id");
      this.locationId = urlParams.get("location_id");
      this.mobileAppVersion = urlParams.get("mobile_app_version");
      [this.source, this.sourceOrigin] = getRPCServerSource();
      this.addOnReadyListener();
      this.handshake();
    }
    close(code, message) {
      var _a2;
      window.removeEventListener("message", this.handleMessage);
      const nonce = v4();
      (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.postMessage([Opcodes.CLOSE, { code, message, nonce }], this.sourceOrigin);
    }
    async subscribe(event, listener, ...rest) {
      const [subscribeArgs] = rest;
      const listenerCount = this.eventBus.listenerCount(event);
      const emitter = this.eventBus.on(event, listener);
      if (Object.values(Events).includes(event) && event !== Events.READY && listenerCount === 0) {
        await this.sendCommand({
          cmd: Commands$1.SUBSCRIBE,
          args: subscribeArgs,
          evt: event
        });
      }
      return emitter;
    }
    async unsubscribe(event, listener, ...rest) {
      const [unsubscribeArgs] = rest;
      if (event !== Events.READY && this.eventBus.listenerCount(event) === 1) {
        await this.sendCommand({
          cmd: Commands$1.UNSUBSCRIBE,
          evt: event,
          args: unsubscribeArgs
        });
      }
      return this.eventBus.off(event, listener);
    }
    async ready() {
      if (this.isReady) {
        return;
      } else {
        await new Promise((resolve) => {
          this.eventBus.once(Events.READY, resolve);
        });
      }
    }
    parseMajorMobileVersion() {
      if (this.mobileAppVersion && this.mobileAppVersion.includes(".")) {
        try {
          return parseInt(this.mobileAppVersion.split(".")[0]);
        } catch (_a2) {
          return UNKNOWN_VERSION_NUMBER;
        }
      }
      return UNKNOWN_VERSION_NUMBER;
    }
    handshake() {
      var _a2;
      const handshakePayload = {
        v: 1,
        encoding: "json",
        client_id: this.clientId,
        frame_id: this.frameId
      };
      const majorMobileVersion = this.parseMajorMobileVersion();
      if (this.platform === Platform.DESKTOP || majorMobileVersion >= HANDSHAKE_SDK_VERSION_MINIMUM_MOBILE_VERSION) {
        handshakePayload["sdk_version"] = this.sdkVersion;
      }
      (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.postMessage([Opcodes.HANDSHAKE, handshakePayload], this.sourceOrigin);
    }
    addOnReadyListener() {
      this.eventBus.once(Events.READY, () => {
        this.overrideConsoleLogging();
        this.isReady = true;
      });
    }
    overrideConsoleLogging() {
      if (this.configuration.disableConsoleLogOverride)
        return;
      const sendCaptureLogCommand = (level, message) => {
        this.commands.captureLog({
          level,
          message
        });
      };
      consoleLevels.forEach((level) => {
        wrapConsoleMethod(console, level, sendCaptureLogCommand);
      });
    }
    handleClose(data) {
      ClosePayload.parse(data);
    }
    handleHandshake() {
    }
    handleFrame(payload) {
      var _a2, _b2;
      let parsed;
      try {
        parsed = parseIncomingPayload(payload);
      } catch (e) {
        console.error("Failed to parse", payload);
        console.error(e);
        return;
      }
      if (parsed.cmd === "DISPATCH") {
        this.eventBus.emit(parsed.evt, parsed.data);
      } else {
        if (parsed.evt === ERROR) {
          if (parsed.nonce != null) {
            (_a2 = this.pendingCommands.get(parsed.nonce)) === null || _a2 === void 0 ? void 0 : _a2.reject(parsed.data);
            this.pendingCommands.delete(parsed.nonce);
            return;
          }
          this.eventBus.emit("error", new SDKError(parsed.data.code, parsed.data.message));
        }
        if (parsed.nonce == null) {
          console.error("Missing nonce", payload);
          return;
        }
        (_b2 = this.pendingCommands.get(parsed.nonce)) === null || _b2 === void 0 ? void 0 : _b2.resolve(parsed);
        this.pendingCommands.delete(parsed.nonce);
      }
    }
    _getSearch() {
      return typeof window === "undefined" ? "" : window.location.search;
    }
  }
  function can(permission, permissions) {
    return BigFlagUtils.has(BigFlagUtils.deserialize(permissions), permission);
  }
  var PermissionUtils = {
    can
  };
  var MAX_DIGITS = 1e9, defaults = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed during run-time using `Decimal.config`.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
    // `toFixed`, `toPrecision` and `toSignificantDigits`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -MAX_E
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to MAX_E
    // The natural logarithm of 10.
    // 115 digits
    LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
  }, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s) x.s = 1;
    return x;
  };
  P.comparedTo = P.cmp = function(y) {
    var i, j, xdL, ydL, x = this;
    y = new x.constructor(y);
    if (x.s !== y.s) return x.s || -y.s;
    if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;
    xdL = x.d.length;
    ydL = y.d.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
  };
  P.decimalPlaces = P.dp = function() {
    var x = this, w = x.d.length - 1, dp2 = (w - x.e) * LOG_BASE;
    w = x.d[w];
    if (w) for (; w % 10 == 0; w /= 10) dp2--;
    return dp2 < 0 ? 0 : dp2;
  };
  P.dividedBy = P.div = function(y) {
    return divide(this, new this.constructor(y));
  };
  P.dividedToIntegerBy = P.idiv = function(y) {
    var x = this, Ctor = x.constructor;
    return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
  };
  P.equals = P.eq = function(y) {
    return !this.cmp(y);
  };
  P.exponent = function() {
    return getBase10Exponent(this);
  };
  P.greaterThan = P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y) {
    return this.cmp(y) >= 0;
  };
  P.isInteger = P.isint = function() {
    return this.e > this.d.length - 2;
  };
  P.isNegative = P.isneg = function() {
    return this.s < 0;
  };
  P.isPositive = P.ispos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return this.s === 0;
  };
  P.lessThan = P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.logarithm = P.log = function(base) {
    var r, x = this, Ctor = x.constructor, pr2 = Ctor.precision, wpr = pr2 + 5;
    if (base === void 0) {
      base = new Ctor(10);
    } else {
      base = new Ctor(base);
      if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
    }
    if (x.s < 1) throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
    if (x.eq(ONE)) return new Ctor(0);
    external = false;
    r = divide(ln(x, wpr), ln(base, wpr), wpr);
    external = true;
    return round(r, pr2);
  };
  P.minus = P.sub = function(y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
  };
  P.modulo = P.mod = function(y) {
    var q, x = this, Ctor = x.constructor, pr2 = Ctor.precision;
    y = new Ctor(y);
    if (!y.s) throw Error(decimalError + "NaN");
    if (!x.s) return round(new Ctor(x), pr2);
    external = false;
    q = divide(x, y, 0, 1).times(y);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return exp(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return ln(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s || 0;
    return x;
  };
  P.plus = P.add = function(y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
  };
  P.precision = P.sd = function(z10) {
    var e, sd2, w, x = this;
    if (z10 !== void 0 && z10 !== !!z10 && z10 !== 1 && z10 !== 0) throw Error(invalidArgument + z10);
    e = getBase10Exponent(x) + 1;
    w = x.d.length - 1;
    sd2 = w * LOG_BASE + 1;
    w = x.d[w];
    if (w) {
      for (; w % 10 == 0; w /= 10) sd2--;
      for (w = x.d[0]; w >= 10; w /= 10) sd2++;
    }
    return z10 && e > sd2 ? e : sd2;
  };
  P.squareRoot = P.sqrt = function() {
    var e, n, pr2, r, s, t, wpr, x = this, Ctor = x.constructor;
    if (x.s < 1) {
      if (!x.s) return new Ctor(0);
      throw Error(decimalError + "NaN");
    }
    e = getBase10Exponent(x);
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(x.d);
      if ((n.length + e) % 2 == 0) n += "0";
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    pr2 = Ctor.precision;
    s = wpr = pr2 + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, wpr + 2)).times(0.5);
      if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
        n = n.slice(wpr - 3, wpr + 1);
        if (s == wpr && n == "4999") {
          round(t, pr2 + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        } else if (n != "9999") {
          break;
        }
        wpr += 4;
      }
    }
    external = true;
    return round(r, pr2);
  };
  P.times = P.mul = function(y) {
    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd2 = x.d, yd2 = (y = new Ctor(y)).d;
    if (!x.s || !y.s) return new Ctor(0);
    y.s *= x.s;
    e = x.e + y.e;
    xdL = xd2.length;
    ydL = yd2.length;
    if (xdL < ydL) {
      r = xd2;
      xd2 = yd2;
      yd2 = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--; ) r.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k = xdL + i; k > i; ) {
        t = r[k] + yd2[i] * xd2[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; ) r.pop();
    if (carry) ++e;
    else r.shift();
    y.d = r;
    y.e = e;
    return external ? round(y, Ctor.precision) : y;
  };
  P.toDecimalPlaces = P.todp = function(dp2, rm2) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp2 === void 0) return x;
    checkInt32(dp2, 0, MAX_DIGITS);
    if (rm2 === void 0) rm2 = Ctor.rounding;
    else checkInt32(rm2, 0, 8);
    return round(x, dp2 + getBase10Exponent(x) + 1, rm2);
  };
  P.toExponential = function(dp2, rm2) {
    var str, x = this, Ctor = x.constructor;
    if (dp2 === void 0) {
      str = toString(x, true);
    } else {
      checkInt32(dp2, 0, MAX_DIGITS);
      if (rm2 === void 0) rm2 = Ctor.rounding;
      else checkInt32(rm2, 0, 8);
      x = round(new Ctor(x), dp2 + 1, rm2);
      str = toString(x, true, dp2 + 1);
    }
    return str;
  };
  P.toFixed = function(dp2, rm2) {
    var str, y, x = this, Ctor = x.constructor;
    if (dp2 === void 0) return toString(x);
    checkInt32(dp2, 0, MAX_DIGITS);
    if (rm2 === void 0) rm2 = Ctor.rounding;
    else checkInt32(rm2, 0, 8);
    y = round(new Ctor(x), dp2 + getBase10Exponent(x) + 1, rm2);
    str = toString(y.abs(), false, dp2 + getBase10Exponent(y) + 1);
    return x.isneg() && !x.isZero() ? "-" + str : str;
  };
  P.toInteger = P.toint = function() {
    var x = this, Ctor = x.constructor;
    return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
  };
  P.toNumber = function() {
    return +this;
  };
  P.toPower = P.pow = function(y) {
    var e, k, pr2, r, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn2 = +(y = new Ctor(y));
    if (!y.s) return new Ctor(ONE);
    x = new Ctor(x);
    if (!x.s) {
      if (y.s < 1) throw Error(decimalError + "Infinity");
      return x;
    }
    if (x.eq(ONE)) return x;
    pr2 = Ctor.precision;
    if (y.eq(ONE)) return round(x, pr2);
    e = y.e;
    k = y.d.length - 1;
    yIsInt = e >= k;
    sign = x.s;
    if (!yIsInt) {
      if (sign < 0) throw Error(decimalError + "NaN");
    } else if ((k = yn2 < 0 ? -yn2 : yn2) <= MAX_SAFE_INTEGER) {
      r = new Ctor(ONE);
      e = Math.ceil(pr2 / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (k % 2) {
          r = r.times(x);
          truncate(r.d, e);
        }
        k = mathfloor(k / 2);
        if (k === 0) break;
        x = x.times(x);
        truncate(x.d, e);
      }
      external = true;
      return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr2);
    }
    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
    x.s = 1;
    external = false;
    r = y.times(ln(x, pr2 + guard));
    external = true;
    r = exp(r);
    r.s = sign;
    return r;
  };
  P.toPrecision = function(sd2, rm2) {
    var e, str, x = this, Ctor = x.constructor;
    if (sd2 === void 0) {
      e = getBase10Exponent(x);
      str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    } else {
      checkInt32(sd2, 1, MAX_DIGITS);
      if (rm2 === void 0) rm2 = Ctor.rounding;
      else checkInt32(rm2, 0, 8);
      x = round(new Ctor(x), sd2, rm2);
      e = getBase10Exponent(x);
      str = toString(x, sd2 <= e || e <= Ctor.toExpNeg, sd2);
    }
    return str;
  };
  P.toSignificantDigits = P.tosd = function(sd2, rm2) {
    var x = this, Ctor = x.constructor;
    if (sd2 === void 0) {
      sd2 = Ctor.precision;
      rm2 = Ctor.rounding;
    } else {
      checkInt32(sd2, 1, MAX_DIGITS);
      if (rm2 === void 0) rm2 = Ctor.rounding;
      else checkInt32(rm2, 0, 8);
    }
    return round(new Ctor(x), sd2, rm2);
  };
  P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
    var x = this, e = getBase10Exponent(x), Ctor = x.constructor;
    return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  };
  function add(x, y) {
    var carry, d, e, i, k, len, xd2, yd2, Ctor = x.constructor, pr2 = Ctor.precision;
    if (!x.s || !y.s) {
      if (!y.s) y = new Ctor(x);
      return external ? round(y, pr2) : y;
    }
    xd2 = x.d;
    yd2 = y.d;
    k = x.e;
    e = y.e;
    xd2 = xd2.slice();
    i = k - e;
    if (i) {
      if (i < 0) {
        d = xd2;
        i = -i;
        len = yd2.length;
      } else {
        d = yd2;
        e = k;
        len = xd2.length;
      }
      k = Math.ceil(pr2 / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; ) d.push(0);
      d.reverse();
    }
    len = xd2.length;
    i = yd2.length;
    if (len - i < 0) {
      i = len;
      d = yd2;
      yd2 = xd2;
      xd2 = d;
    }
    for (carry = 0; i; ) {
      carry = (xd2[--i] = xd2[i] + yd2[i] + carry) / BASE | 0;
      xd2[i] %= BASE;
    }
    if (carry) {
      xd2.unshift(carry);
      ++e;
    }
    for (len = xd2.length; xd2[--len] == 0; ) xd2.pop();
    y.d = xd2;
    y.e = e;
    return external ? round(y, pr2) : y;
  }
  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }
  function digitsToString(d) {
    var i, k, ws2, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws2 = d[i] + "";
        k = LOG_BASE - ws2.length;
        if (k) str += getZeroString(k);
        str += ws2;
      }
      w = d[i];
      ws2 = w + "";
      k = LOG_BASE - ws2.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; ) w /= 10;
    return str + w;
  }
  var divide = /* @__PURE__ */ function() {
    function multiplyInteger(x, k) {
      var temp, carry = 0, i = x.length;
      for (x = x.slice(); i--; ) {
        temp = x[i] * k + carry;
        x[i] = temp % BASE | 0;
        carry = temp / BASE | 0;
      }
      if (carry) x.unshift(carry);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract2(a, b, aL) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * BASE + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; ) a.shift();
    }
    return function(x, y, pr2, dp2) {
      var cmp, e, i, k, prod, prodL, q, qd2, rem, remL, rem0, sd2, t, xi2, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd2 = x.d, yd2 = y.d;
      if (!x.s) return new Ctor(x);
      if (!y.s) throw Error(decimalError + "Division by zero");
      e = x.e - y.e;
      yL = yd2.length;
      xL = xd2.length;
      q = new Ctor(sign);
      qd2 = q.d = [];
      for (i = 0; yd2[i] == (xd2[i] || 0); ) ++i;
      if (yd2[i] > (xd2[i] || 0)) --e;
      if (pr2 == null) {
        sd2 = pr2 = Ctor.precision;
      } else if (dp2) {
        sd2 = pr2 + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
      } else {
        sd2 = pr2;
      }
      if (sd2 < 0) return new Ctor(0);
      sd2 = sd2 / LOG_BASE + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd2 = yd2[0];
        sd2++;
        for (; (i < xL || k) && sd2--; i++) {
          t = k * BASE + (xd2[i] || 0);
          qd2[i] = t / yd2 | 0;
          k = t % yd2 | 0;
        }
      } else {
        k = BASE / (yd2[0] + 1) | 0;
        if (k > 1) {
          yd2 = multiplyInteger(yd2, k);
          xd2 = multiplyInteger(xd2, k);
          yL = yd2.length;
          xL = xd2.length;
        }
        xi2 = yL;
        rem = xd2.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd2.slice();
        yz.unshift(0);
        yd0 = yd2[0];
        if (yd2[1] >= BASE / 2) ++yd0;
        do {
          k = 0;
          cmp = compare(yd2, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= BASE) k = BASE - 1;
              prod = multiplyInteger(yd2, k);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract2(prod, yL < prodL ? yz : yd2, prodL);
              }
            } else {
              if (k == 0) cmp = k = 1;
              prod = yd2.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract2(rem, prod, remL);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd2, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract2(rem, yL < remL ? yz : yd2, remL);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd2[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd2[xi2] || 0;
          } else {
            rem = [xd2[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] !== void 0) && sd2--);
      }
      if (!qd2[0]) qd2.shift();
      q.e = e;
      return round(q, dp2 ? pr2 + getBase10Exponent(q) + 1 : pr2);
    };
  }();
  function exp(x, sd2) {
    var denominator, guard, pow, sum, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr2 = Ctor.precision;
    if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));
    if (!x.s) return new Ctor(ONE);
    {
      external = false;
      wpr = pr2;
    }
    t = new Ctor(0.03125);
    while (x.abs().gte(0.1)) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(ONE);
    Ctor.precision = wpr;
    for (; ; ) {
      pow = round(pow.times(x), wpr);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        while (k--) sum = round(sum.times(sum), wpr);
        Ctor.precision = pr2;
        return sd2 == null ? (external = true, round(sum, pr2)) : sum;
      }
      sum = t;
    }
  }
  function getBase10Exponent(x) {
    var e = x.e * LOG_BASE, w = x.d[0];
    for (; w >= 10; w /= 10) e++;
    return e;
  }
  function getLn10(Ctor, sd2, pr2) {
    if (sd2 > Ctor.LN10.sd()) {
      external = true;
      if (pr2) Ctor.precision = pr2;
      throw Error(decimalError + "LN10 precision limit exceeded");
    }
    return round(new Ctor(Ctor.LN10), sd2);
  }
  function getZeroString(k) {
    var zs2 = "";
    for (; k--; ) zs2 += "0";
    return zs2;
  }
  function ln(y, sd2) {
    var c, c0, denominator, e, numerator, sum, t, wpr, x22, n = 1, guard = 10, x = y, xd2 = x.d, Ctor = x.constructor, pr2 = Ctor.precision;
    if (x.s < 1) throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
    if (x.eq(ONE)) return new Ctor(0);
    if (sd2 == null) {
      external = false;
      wpr = pr2;
    } else {
      wpr = sd2;
    }
    if (x.eq(10)) {
      if (sd2 == null) external = true;
      return getLn10(Ctor, wpr);
    }
    wpr += guard;
    Ctor.precision = wpr;
    c = digitsToString(xd2);
    c0 = c.charAt(0);
    e = getBase10Exponent(x);
    if (Math.abs(e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }
      e = getBase10Exponent(x);
      if (c0 > 1) {
        x = new Ctor("0." + c);
        e++;
      } else {
        x = new Ctor(c0 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr2).times(e + "");
      x = ln(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr2;
      return sd2 == null ? (external = true, round(x, pr2)) : x;
    }
    sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
    x22 = round(x.times(x), wpr);
    denominator = 3;
    for (; ; ) {
      numerator = round(numerator.times(x22), wpr);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr2).times(e + ""));
        sum = divide(sum, new Ctor(n), wpr);
        Ctor.precision = pr2;
        return sd2 == null ? (external = true, round(sum, pr2)) : sum;
      }
      sum = t;
      denominator += 2;
    }
  }
  function parseDecimal(x, str) {
    var e, i, len;
    if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; ) ++i;
    for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      e = e - i - 1;
      x.e = mathfloor(e / LOG_BASE);
      x.d = [];
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;
      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; ) str += "0";
      x.d.push(+str);
      if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);
    } else {
      x.s = 0;
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function round(x, sd2, rm2) {
    var i, j, k, n, rd2, doRound, w, xdi, xd2 = x.d;
    for (n = 1, k = xd2[0]; k >= 10; k /= 10) n++;
    i = sd2 - n;
    if (i < 0) {
      i += LOG_BASE;
      j = sd2;
      w = xd2[xdi = 0];
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd2.length;
      if (xdi >= k) return x;
      w = k = xd2[xdi];
      for (n = 1; k >= 10; k /= 10) n++;
      i %= LOG_BASE;
      j = i - LOG_BASE + n;
    }
    if (rm2 !== void 0) {
      k = mathpow(10, n - j - 1);
      rd2 = w / k % 10 | 0;
      doRound = sd2 < 0 || xd2[xdi + 1] !== void 0 || w % k;
      doRound = rm2 < 4 ? (rd2 || doRound) && (rm2 == 0 || rm2 == (x.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm2 == 4 || doRound || rm2 == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd2[xdi - 1]) % 10 & 1 || rm2 == (x.s < 0 ? 8 : 7));
    }
    if (sd2 < 1 || !xd2[0]) {
      if (doRound) {
        k = getBase10Exponent(x);
        xd2.length = 1;
        sd2 = sd2 - k - 1;
        xd2[0] = mathpow(10, (LOG_BASE - sd2 % LOG_BASE) % LOG_BASE);
        x.e = mathfloor(-sd2 / LOG_BASE) || 0;
      } else {
        xd2.length = 1;
        xd2[0] = x.e = x.s = 0;
      }
      return x;
    }
    if (i == 0) {
      xd2.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd2.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);
      xd2[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
    }
    if (doRound) {
      for (; ; ) {
        if (xdi == 0) {
          if ((xd2[0] += k) == BASE) {
            xd2[0] = 1;
            ++x.e;
          }
          break;
        } else {
          xd2[xdi] += k;
          if (xd2[xdi] != BASE) break;
          xd2[xdi--] = 0;
          k = 1;
        }
      }
    }
    for (i = xd2.length; xd2[--i] === 0; ) xd2.pop();
    if (external && (x.e > MAX_E || x.e < -MAX_E)) {
      throw Error(exponentOutOfRange + getBase10Exponent(x));
    }
    return x;
  }
  function subtract(x, y) {
    var d, e, i, j, k, len, xd2, xe2, xLTy, yd2, Ctor = x.constructor, pr2 = Ctor.precision;
    if (!x.s || !y.s) {
      if (y.s) y.s = -y.s;
      else y = new Ctor(x);
      return external ? round(y, pr2) : y;
    }
    xd2 = x.d;
    yd2 = y.d;
    e = y.e;
    xe2 = x.e;
    xd2 = xd2.slice();
    k = xe2 - e;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd2;
        k = -k;
        len = yd2.length;
      } else {
        d = yd2;
        e = xe2;
        len = xd2.length;
      }
      i = Math.max(Math.ceil(pr2 / LOG_BASE), len) + 2;
      if (k > i) {
        k = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k; i--; ) d.push(0);
      d.reverse();
    } else {
      i = xd2.length;
      len = yd2.length;
      xLTy = i < len;
      if (xLTy) len = i;
      for (i = 0; i < len; i++) {
        if (xd2[i] != yd2[i]) {
          xLTy = xd2[i] < yd2[i];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd2;
      xd2 = yd2;
      yd2 = d;
      y.s = -y.s;
    }
    len = xd2.length;
    for (i = yd2.length - len; i > 0; --i) xd2[len++] = 0;
    for (i = yd2.length; i > k; ) {
      if (xd2[--i] < yd2[i]) {
        for (j = i; j && xd2[--j] === 0; ) xd2[j] = BASE - 1;
        --xd2[j];
        xd2[i] += BASE;
      }
      xd2[i] -= yd2[i];
    }
    for (; xd2[--len] === 0; ) xd2.pop();
    for (; xd2[0] === 0; xd2.shift()) --e;
    if (!xd2[0]) return new Ctor(0);
    y.d = xd2;
    y.e = e;
    return external ? round(y, pr2) : y;
  }
  function toString(x, isExp, sd2) {
    var k, e = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd2 && (k = sd2 - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (e < 0 ? "e" : "e+") + e;
    } else if (e < 0) {
      str = "0." + getZeroString(-e - 1) + str;
      if (sd2 && (k = sd2 - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd2 && (k = sd2 - e - 1) > 0) str = str + "." + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
      if (sd2 && (k = sd2 - len) > 0) {
        if (e + 1 === len) str += ".";
        str += getZeroString(k);
      }
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function clone(obj) {
    var i, p, ps2;
    function Decimal2(value) {
      var x = this;
      if (!(x instanceof Decimal2)) return new Decimal2(value);
      x.constructor = Decimal2;
      if (value instanceof Decimal2) {
        x.s = value.s;
        x.e = value.e;
        x.d = (value = value.d) ? value.slice() : value;
        return;
      }
      if (typeof value === "number") {
        if (value * 0 !== 0) {
          throw Error(invalidArgument + value);
        }
        if (value > 0) {
          x.s = 1;
        } else if (value < 0) {
          value = -value;
          x.s = -1;
        } else {
          x.s = 0;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (value === ~~value && value < 1e7) {
          x.e = 0;
          x.d = [value];
          return;
        }
        return parseDecimal(x, value.toString());
      } else if (typeof value !== "string") {
        throw Error(invalidArgument + value);
      }
      if (value.charCodeAt(0) === 45) {
        value = value.slice(1);
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (isDecimal.test(value)) parseDecimal(x, value);
      else throw Error(invalidArgument + value);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.clone = clone;
    Decimal2.config = Decimal2.set = config;
    if (obj === void 0) obj = {};
    if (obj) {
      ps2 = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
      for (i = 0; i < ps2.length; ) if (!obj.hasOwnProperty(p = ps2[i++])) obj[p] = this[p];
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function config(obj) {
    if (!obj || typeof obj !== "object") {
      throw Error(decimalError + "Object expected");
    }
    var i, p, v, ps2 = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -1 / 0,
      0,
      "toExpPos",
      0,
      1 / 0
    ];
    for (i = 0; i < ps2.length; i += 3) {
      if ((v = obj[p = ps2[i]]) !== void 0) {
        if (mathfloor(v) === v && v >= ps2[i + 1] && v <= ps2[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ": " + v);
      }
    }
    if ((v = obj[p = "LN10"]) !== void 0) {
      if (v == Math.LN10) this[p] = new this(v);
      else throw Error(invalidArgument + p + ": " + v);
    }
    return this;
  }
  var Decimal = clone(defaults);
  ONE = new Decimal(1);
  var Decimal$1 = Decimal;
  var CurrencyCodes;
  (function(CurrencyCodes2) {
    CurrencyCodes2["AED"] = "aed";
    CurrencyCodes2["AFN"] = "afn";
    CurrencyCodes2["ALL"] = "all";
    CurrencyCodes2["AMD"] = "amd";
    CurrencyCodes2["ANG"] = "ang";
    CurrencyCodes2["AOA"] = "aoa";
    CurrencyCodes2["ARS"] = "ars";
    CurrencyCodes2["AUD"] = "aud";
    CurrencyCodes2["AWG"] = "awg";
    CurrencyCodes2["AZN"] = "azn";
    CurrencyCodes2["BAM"] = "bam";
    CurrencyCodes2["BBD"] = "bbd";
    CurrencyCodes2["BDT"] = "bdt";
    CurrencyCodes2["BGN"] = "bgn";
    CurrencyCodes2["BHD"] = "bhd";
    CurrencyCodes2["BIF"] = "bif";
    CurrencyCodes2["BMD"] = "bmd";
    CurrencyCodes2["BND"] = "bnd";
    CurrencyCodes2["BOB"] = "bob";
    CurrencyCodes2["BOV"] = "bov";
    CurrencyCodes2["BRL"] = "brl";
    CurrencyCodes2["BSD"] = "bsd";
    CurrencyCodes2["BTN"] = "btn";
    CurrencyCodes2["BWP"] = "bwp";
    CurrencyCodes2["BYN"] = "byn";
    CurrencyCodes2["BYR"] = "byr";
    CurrencyCodes2["BZD"] = "bzd";
    CurrencyCodes2["CAD"] = "cad";
    CurrencyCodes2["CDF"] = "cdf";
    CurrencyCodes2["CHE"] = "che";
    CurrencyCodes2["CHF"] = "chf";
    CurrencyCodes2["CHW"] = "chw";
    CurrencyCodes2["CLF"] = "clf";
    CurrencyCodes2["CLP"] = "clp";
    CurrencyCodes2["CNY"] = "cny";
    CurrencyCodes2["COP"] = "cop";
    CurrencyCodes2["COU"] = "cou";
    CurrencyCodes2["CRC"] = "crc";
    CurrencyCodes2["CUC"] = "cuc";
    CurrencyCodes2["CUP"] = "cup";
    CurrencyCodes2["CVE"] = "cve";
    CurrencyCodes2["CZK"] = "czk";
    CurrencyCodes2["DJF"] = "djf";
    CurrencyCodes2["DKK"] = "dkk";
    CurrencyCodes2["DOP"] = "dop";
    CurrencyCodes2["DZD"] = "dzd";
    CurrencyCodes2["EGP"] = "egp";
    CurrencyCodes2["ERN"] = "ern";
    CurrencyCodes2["ETB"] = "etb";
    CurrencyCodes2["EUR"] = "eur";
    CurrencyCodes2["FJD"] = "fjd";
    CurrencyCodes2["FKP"] = "fkp";
    CurrencyCodes2["GBP"] = "gbp";
    CurrencyCodes2["GEL"] = "gel";
    CurrencyCodes2["GHS"] = "ghs";
    CurrencyCodes2["GIP"] = "gip";
    CurrencyCodes2["GMD"] = "gmd";
    CurrencyCodes2["GNF"] = "gnf";
    CurrencyCodes2["GTQ"] = "gtq";
    CurrencyCodes2["GYD"] = "gyd";
    CurrencyCodes2["HKD"] = "hkd";
    CurrencyCodes2["HNL"] = "hnl";
    CurrencyCodes2["HRK"] = "hrk";
    CurrencyCodes2["HTG"] = "htg";
    CurrencyCodes2["HUF"] = "huf";
    CurrencyCodes2["IDR"] = "idr";
    CurrencyCodes2["ILS"] = "ils";
    CurrencyCodes2["INR"] = "inr";
    CurrencyCodes2["IQD"] = "iqd";
    CurrencyCodes2["IRR"] = "irr";
    CurrencyCodes2["ISK"] = "isk";
    CurrencyCodes2["JMD"] = "jmd";
    CurrencyCodes2["JOD"] = "jod";
    CurrencyCodes2["JPY"] = "jpy";
    CurrencyCodes2["KES"] = "kes";
    CurrencyCodes2["KGS"] = "kgs";
    CurrencyCodes2["KHR"] = "khr";
    CurrencyCodes2["KMF"] = "kmf";
    CurrencyCodes2["KPW"] = "kpw";
    CurrencyCodes2["KRW"] = "krw";
    CurrencyCodes2["KWD"] = "kwd";
    CurrencyCodes2["KYD"] = "kyd";
    CurrencyCodes2["KZT"] = "kzt";
    CurrencyCodes2["LAK"] = "lak";
    CurrencyCodes2["LBP"] = "lbp";
    CurrencyCodes2["LKR"] = "lkr";
    CurrencyCodes2["LRD"] = "lrd";
    CurrencyCodes2["LSL"] = "lsl";
    CurrencyCodes2["LTL"] = "ltl";
    CurrencyCodes2["LVL"] = "lvl";
    CurrencyCodes2["LYD"] = "lyd";
    CurrencyCodes2["MAD"] = "mad";
    CurrencyCodes2["MDL"] = "mdl";
    CurrencyCodes2["MGA"] = "mga";
    CurrencyCodes2["MKD"] = "mkd";
    CurrencyCodes2["MMK"] = "mmk";
    CurrencyCodes2["MNT"] = "mnt";
    CurrencyCodes2["MOP"] = "mop";
    CurrencyCodes2["MRO"] = "mro";
    CurrencyCodes2["MUR"] = "mur";
    CurrencyCodes2["MVR"] = "mvr";
    CurrencyCodes2["MWK"] = "mwk";
    CurrencyCodes2["MXN"] = "mxn";
    CurrencyCodes2["MXV"] = "mxv";
    CurrencyCodes2["MYR"] = "myr";
    CurrencyCodes2["MZN"] = "mzn";
    CurrencyCodes2["NAD"] = "nad";
    CurrencyCodes2["NGN"] = "ngn";
    CurrencyCodes2["NIO"] = "nio";
    CurrencyCodes2["NOK"] = "nok";
    CurrencyCodes2["NPR"] = "npr";
    CurrencyCodes2["NZD"] = "nzd";
    CurrencyCodes2["OMR"] = "omr";
    CurrencyCodes2["PAB"] = "pab";
    CurrencyCodes2["PEN"] = "pen";
    CurrencyCodes2["PGK"] = "pgk";
    CurrencyCodes2["PHP"] = "php";
    CurrencyCodes2["PKR"] = "pkr";
    CurrencyCodes2["PLN"] = "pln";
    CurrencyCodes2["PYG"] = "pyg";
    CurrencyCodes2["QAR"] = "qar";
    CurrencyCodes2["RON"] = "ron";
    CurrencyCodes2["RSD"] = "rsd";
    CurrencyCodes2["RUB"] = "rub";
    CurrencyCodes2["RWF"] = "rwf";
    CurrencyCodes2["SAR"] = "sar";
    CurrencyCodes2["SBD"] = "sbd";
    CurrencyCodes2["SCR"] = "scr";
    CurrencyCodes2["SDG"] = "sdg";
    CurrencyCodes2["SEK"] = "sek";
    CurrencyCodes2["SGD"] = "sgd";
    CurrencyCodes2["SHP"] = "shp";
    CurrencyCodes2["SLL"] = "sll";
    CurrencyCodes2["SOS"] = "sos";
    CurrencyCodes2["SRD"] = "srd";
    CurrencyCodes2["SSP"] = "ssp";
    CurrencyCodes2["STD"] = "std";
    CurrencyCodes2["SVC"] = "svc";
    CurrencyCodes2["SYP"] = "syp";
    CurrencyCodes2["SZL"] = "szl";
    CurrencyCodes2["THB"] = "thb";
    CurrencyCodes2["TJS"] = "tjs";
    CurrencyCodes2["TMT"] = "tmt";
    CurrencyCodes2["TND"] = "tnd";
    CurrencyCodes2["TOP"] = "top";
    CurrencyCodes2["TRY"] = "try";
    CurrencyCodes2["TTD"] = "ttd";
    CurrencyCodes2["TWD"] = "twd";
    CurrencyCodes2["TZS"] = "tzs";
    CurrencyCodes2["UAH"] = "uah";
    CurrencyCodes2["UGX"] = "ugx";
    CurrencyCodes2["USD"] = "usd";
    CurrencyCodes2["USN"] = "usn";
    CurrencyCodes2["USS"] = "uss";
    CurrencyCodes2["UYI"] = "uyi";
    CurrencyCodes2["UYU"] = "uyu";
    CurrencyCodes2["UZS"] = "uzs";
    CurrencyCodes2["VEF"] = "vef";
    CurrencyCodes2["VND"] = "vnd";
    CurrencyCodes2["VUV"] = "vuv";
    CurrencyCodes2["WST"] = "wst";
    CurrencyCodes2["XAF"] = "xaf";
    CurrencyCodes2["XAG"] = "xag";
    CurrencyCodes2["XAU"] = "xau";
    CurrencyCodes2["XBA"] = "xba";
    CurrencyCodes2["XBB"] = "xbb";
    CurrencyCodes2["XBC"] = "xbc";
    CurrencyCodes2["XBD"] = "xbd";
    CurrencyCodes2["XCD"] = "xcd";
    CurrencyCodes2["XDR"] = "xdr";
    CurrencyCodes2["XFU"] = "xfu";
    CurrencyCodes2["XOF"] = "xof";
    CurrencyCodes2["XPD"] = "xpd";
    CurrencyCodes2["XPF"] = "xpf";
    CurrencyCodes2["XPT"] = "xpt";
    CurrencyCodes2["XSU"] = "xsu";
    CurrencyCodes2["XTS"] = "xts";
    CurrencyCodes2["XUA"] = "xua";
    CurrencyCodes2["YER"] = "yer";
    CurrencyCodes2["ZAR"] = "zar";
    CurrencyCodes2["ZMW"] = "zmw";
    CurrencyCodes2["ZWL"] = "zwl";
  })(CurrencyCodes || (CurrencyCodes = {}));
  const CurrencyExponents = {
    [CurrencyCodes.AED]: 2,
    [CurrencyCodes.AFN]: 2,
    [CurrencyCodes.ALL]: 2,
    [CurrencyCodes.AMD]: 2,
    [CurrencyCodes.ANG]: 2,
    [CurrencyCodes.AOA]: 2,
    [CurrencyCodes.ARS]: 2,
    [CurrencyCodes.AUD]: 2,
    [CurrencyCodes.AWG]: 2,
    [CurrencyCodes.AZN]: 2,
    [CurrencyCodes.BAM]: 2,
    [CurrencyCodes.BBD]: 2,
    [CurrencyCodes.BDT]: 2,
    [CurrencyCodes.BGN]: 2,
    [CurrencyCodes.BHD]: 3,
    [CurrencyCodes.BIF]: 0,
    [CurrencyCodes.BMD]: 2,
    [CurrencyCodes.BND]: 2,
    [CurrencyCodes.BOB]: 2,
    [CurrencyCodes.BOV]: 2,
    [CurrencyCodes.BRL]: 2,
    [CurrencyCodes.BSD]: 2,
    [CurrencyCodes.BTN]: 2,
    [CurrencyCodes.BWP]: 2,
    [CurrencyCodes.BYR]: 0,
    [CurrencyCodes.BYN]: 2,
    [CurrencyCodes.BZD]: 2,
    [CurrencyCodes.CAD]: 2,
    [CurrencyCodes.CDF]: 2,
    [CurrencyCodes.CHE]: 2,
    [CurrencyCodes.CHF]: 2,
    [CurrencyCodes.CHW]: 2,
    [CurrencyCodes.CLF]: 0,
    [CurrencyCodes.CLP]: 0,
    [CurrencyCodes.CNY]: 2,
    [CurrencyCodes.COP]: 2,
    [CurrencyCodes.COU]: 2,
    [CurrencyCodes.CRC]: 2,
    [CurrencyCodes.CUC]: 2,
    [CurrencyCodes.CUP]: 2,
    [CurrencyCodes.CVE]: 2,
    [CurrencyCodes.CZK]: 2,
    [CurrencyCodes.DJF]: 0,
    [CurrencyCodes.DKK]: 2,
    [CurrencyCodes.DOP]: 2,
    [CurrencyCodes.DZD]: 2,
    [CurrencyCodes.EGP]: 2,
    [CurrencyCodes.ERN]: 2,
    [CurrencyCodes.ETB]: 2,
    [CurrencyCodes.EUR]: 2,
    [CurrencyCodes.FJD]: 2,
    [CurrencyCodes.FKP]: 2,
    [CurrencyCodes.GBP]: 2,
    [CurrencyCodes.GEL]: 2,
    [CurrencyCodes.GHS]: 2,
    [CurrencyCodes.GIP]: 2,
    [CurrencyCodes.GMD]: 2,
    [CurrencyCodes.GNF]: 0,
    [CurrencyCodes.GTQ]: 2,
    [CurrencyCodes.GYD]: 2,
    [CurrencyCodes.HKD]: 2,
    [CurrencyCodes.HNL]: 2,
    [CurrencyCodes.HRK]: 2,
    [CurrencyCodes.HTG]: 2,
    [CurrencyCodes.HUF]: 2,
    [CurrencyCodes.IDR]: 2,
    [CurrencyCodes.ILS]: 2,
    [CurrencyCodes.INR]: 2,
    [CurrencyCodes.IQD]: 3,
    [CurrencyCodes.IRR]: 2,
    [CurrencyCodes.ISK]: 0,
    [CurrencyCodes.JMD]: 2,
    [CurrencyCodes.JOD]: 3,
    [CurrencyCodes.JPY]: 0,
    [CurrencyCodes.KES]: 2,
    [CurrencyCodes.KGS]: 2,
    [CurrencyCodes.KHR]: 2,
    [CurrencyCodes.KMF]: 0,
    [CurrencyCodes.KPW]: 2,
    [CurrencyCodes.KRW]: 0,
    [CurrencyCodes.KWD]: 3,
    [CurrencyCodes.KYD]: 2,
    [CurrencyCodes.KZT]: 2,
    [CurrencyCodes.LAK]: 2,
    [CurrencyCodes.LBP]: 2,
    [CurrencyCodes.LKR]: 2,
    [CurrencyCodes.LRD]: 2,
    [CurrencyCodes.LSL]: 2,
    [CurrencyCodes.LTL]: 2,
    [CurrencyCodes.LVL]: 2,
    [CurrencyCodes.LYD]: 3,
    [CurrencyCodes.MAD]: 2,
    [CurrencyCodes.MDL]: 2,
    [CurrencyCodes.MGA]: 2,
    [CurrencyCodes.MKD]: 2,
    [CurrencyCodes.MMK]: 2,
    [CurrencyCodes.MNT]: 2,
    [CurrencyCodes.MOP]: 2,
    [CurrencyCodes.MRO]: 2,
    [CurrencyCodes.MUR]: 2,
    [CurrencyCodes.MVR]: 2,
    [CurrencyCodes.MWK]: 2,
    [CurrencyCodes.MXN]: 2,
    [CurrencyCodes.MXV]: 2,
    [CurrencyCodes.MYR]: 2,
    [CurrencyCodes.MZN]: 2,
    [CurrencyCodes.NAD]: 2,
    [CurrencyCodes.NGN]: 2,
    [CurrencyCodes.NIO]: 2,
    [CurrencyCodes.NOK]: 2,
    [CurrencyCodes.NPR]: 2,
    [CurrencyCodes.NZD]: 2,
    [CurrencyCodes.OMR]: 3,
    [CurrencyCodes.PAB]: 2,
    [CurrencyCodes.PEN]: 2,
    [CurrencyCodes.PGK]: 2,
    [CurrencyCodes.PHP]: 2,
    [CurrencyCodes.PKR]: 2,
    [CurrencyCodes.PLN]: 2,
    [CurrencyCodes.PYG]: 0,
    [CurrencyCodes.QAR]: 2,
    [CurrencyCodes.RON]: 2,
    [CurrencyCodes.RSD]: 2,
    [CurrencyCodes.RUB]: 2,
    [CurrencyCodes.RWF]: 0,
    [CurrencyCodes.SAR]: 2,
    [CurrencyCodes.SBD]: 2,
    [CurrencyCodes.SCR]: 2,
    [CurrencyCodes.SDG]: 2,
    [CurrencyCodes.SEK]: 2,
    [CurrencyCodes.SGD]: 2,
    [CurrencyCodes.SHP]: 2,
    [CurrencyCodes.SLL]: 2,
    [CurrencyCodes.SOS]: 2,
    [CurrencyCodes.SRD]: 2,
    [CurrencyCodes.SSP]: 2,
    [CurrencyCodes.STD]: 2,
    [CurrencyCodes.SVC]: 2,
    [CurrencyCodes.SYP]: 2,
    [CurrencyCodes.SZL]: 2,
    [CurrencyCodes.THB]: 2,
    [CurrencyCodes.TJS]: 2,
    [CurrencyCodes.TMT]: 2,
    [CurrencyCodes.TND]: 3,
    [CurrencyCodes.TOP]: 2,
    [CurrencyCodes.TRY]: 2,
    [CurrencyCodes.TTD]: 2,
    [CurrencyCodes.TWD]: 2,
    [CurrencyCodes.TZS]: 2,
    [CurrencyCodes.UAH]: 2,
    [CurrencyCodes.UGX]: 0,
    [CurrencyCodes.USD]: 2,
    [CurrencyCodes.USN]: 2,
    [CurrencyCodes.USS]: 2,
    [CurrencyCodes.UYI]: 0,
    [CurrencyCodes.UYU]: 2,
    [CurrencyCodes.UZS]: 2,
    [CurrencyCodes.VEF]: 2,
    [CurrencyCodes.VND]: 0,
    [CurrencyCodes.VUV]: 0,
    [CurrencyCodes.WST]: 2,
    [CurrencyCodes.XAF]: 0,
    [CurrencyCodes.XAG]: 0,
    [CurrencyCodes.XAU]: 0,
    [CurrencyCodes.XBA]: 0,
    [CurrencyCodes.XBB]: 0,
    [CurrencyCodes.XBC]: 0,
    [CurrencyCodes.XBD]: 0,
    [CurrencyCodes.XCD]: 2,
    [CurrencyCodes.XDR]: 0,
    [CurrencyCodes.XFU]: 0,
    [CurrencyCodes.XOF]: 0,
    [CurrencyCodes.XPD]: 0,
    [CurrencyCodes.XPF]: 0,
    [CurrencyCodes.XPT]: 0,
    [CurrencyCodes.XSU]: 0,
    [CurrencyCodes.XTS]: 0,
    [CurrencyCodes.XUA]: 0,
    [CurrencyCodes.YER]: 2,
    [CurrencyCodes.ZAR]: 2,
    [CurrencyCodes.ZMW]: 2,
    [CurrencyCodes.ZWL]: 2
  };
  function formatPrice(price, locale = "en-US") {
    const { amount, currency } = price;
    const formatter = Intl.NumberFormat(locale, { style: "currency", currency });
    return formatter.format(convertToMajorCurrencyUnits(amount, currency));
  }
  function convertToMajorCurrencyUnits(minorUnitValue, currency) {
    const exponent = CurrencyExponents[currency];
    if (exponent == null) {
      console.warn(`Unexpected currency ${currency}`);
      return minorUnitValue;
    }
    const minorUnit = new Decimal$1(minorUnitValue);
    return minorUnit.dividedBy(10 ** exponent).toNumber();
  }
  var PriceUtils = {
    formatPrice
  };
  var lodash_transform = { exports: {} };
  lodash_transform.exports;
  var hasRequiredLodash_transform;
  function requireLodash_transform() {
    if (hasRequiredLodash_transform) return lodash_transform.exports;
    hasRequiredLodash_transform = 1;
    (function(module, exports$1) {
      var LARGE_ARRAY_SIZE = 200;
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
      var MAX_SAFE_INTEGER2 = 9007199254740991;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports$1 && !exports$1.nodeType && exports$1;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          return freeProcess && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array ? array.length : 0;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array ? array.length : 0;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform3) {
        return function(arg) {
          return func(transform3(arg));
        };
      }
      function setToArray(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
      var nativeKeys = overArg(Object.keys, Object);
      var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index2 = -1, length = values ? values.length : 0;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        this.__data__ = new ListCache(entries);
      }
      function stackClear() {
        this.__data__ = new ListCache();
      }
      function stackDelete(key) {
        return this.__data__["delete"](key);
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var cache = this.__data__;
        if (cache instanceof ListCache) {
          var pairs = cache.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            return this;
          }
          cache = this.__data__ = new MapCache(pairs);
        }
        cache.set(key, value);
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if (hasOwnProperty.call(value, key) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseCreate(proto) {
        return isObject(proto) ? objectCreate(proto) : {};
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : void 0;
      }
      function baseGetTag(value) {
        return objectToString.call(value);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function baseIsEqual(value, other, customizer, bitmask, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
      }
      function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
        if (!objIsArr) {
          objTag = getTag(object);
          objTag = objTag == argsTag ? objectTag : objTag;
        }
        if (!othIsArr) {
          othTag = getTag(other);
          othTag = othTag == argsTag ? objectTag : othTag;
        }
        var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
        }
        if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index2--) {
          var data = matchData[index2];
          if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            var result;
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      function castPath(value) {
        return isArray(value) ? value : stringToPath(value);
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                return seen.add(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= UNORDERED_COMPARE_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function hasPath(object, path, hasFunc) {
        path = isKey(path, object) ? [path] : castPath(path);
        var result, index2 = -1, length = path.length;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result) {
          return result;
        }
        var length = object ? object.length : 0;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      var stringToPath = memoize(function(string) {
        string = toString2(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      function isArguments(value) {
        return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
      }
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function transform2(object, iteratee, accumulator) {
        var isArr = isArray(object) || isTypedArray(object);
        iteratee = baseIteratee(iteratee);
        if (accumulator == null) {
          if (isArr || isObject(object)) {
            var Ctor = object.constructor;
            if (isArr) {
              accumulator = isArray(object) ? new Ctor() : [];
            } else {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
          } else {
            accumulator = {};
          }
        }
        (isArr ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function identity(value) {
        return value;
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = transform2;
    })(lodash_transform, lodash_transform.exports);
    return lodash_transform.exports;
  }
  var lodash_transformExports = requireLodash_transform();
  var transform = /* @__PURE__ */ getDefaultExportFromCjs(lodash_transformExports);
  class DiscordSDKMock {
    constructor(clientId, guildId, channelId, locationId) {
      this.platform = Platform.DESKTOP;
      this.instanceId = "123456789012345678";
      this.configuration = getDefaultSdkConfiguration();
      this.source = null;
      this.sourceOrigin = "";
      this.sdkVersion = "mock";
      this.mobileAppVersion = "unknown";
      this.frameId = "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa";
      this.eventBus = new EventEmitter();
      this.clientId = clientId;
      this.commands = this._updateCommandMocks({});
      this.guildId = guildId;
      this.channelId = channelId;
      this.locationId = locationId;
      this.customId = null;
      this.referrerId = null;
    }
    _updateCommandMocks(newCommands) {
      this.commands = transform(Object.assign({}, commandsMockDefault, newCommands), (mock, func, name) => {
        mock[name] = async (...args) => {
          console.info(`DiscordSDKMock: ${String(name)}(${JSON.stringify(args)})`);
          return await func(...args);
        };
      });
      return this.commands;
    }
    emitReady() {
      this.emitEvent("READY", void 0);
    }
    close(...args) {
      console.info(`DiscordSDKMock: close(${JSON.stringify(args)})`);
    }
    ready() {
      return Promise.resolve();
    }
    async subscribe(event, listener, ..._subscribeArgs) {
      return await this.eventBus.on(event, listener);
    }
    async unsubscribe(event, listener, ..._unsubscribeArgs) {
      return await this.eventBus.off(event, listener);
    }
    emitEvent(event, data) {
      this.eventBus.emit(event, data);
    }
  }
  const commandsMockDefault = {
    authorize: () => Promise.resolve({ code: "mock_code" }),
    setActivity: () => Promise.resolve({
      name: "mock_activity_name",
      type: 0
    }),
    getChannel: () => Promise.resolve({
      id: "mock_channel_id",
      name: "mock_channel_name",
      type: ChannelTypesObject.GUILD_TEXT,
      voice_states: [],
      messages: []
    }),
    getSkus: () => Promise.resolve({ skus: [] }),
    getEntitlements: () => Promise.resolve({ entitlements: [] }),
    startPurchase: () => Promise.resolve([]),
    setConfig: () => Promise.resolve({ use_interactive_pip: false }),
    userSettingsGetLocale: () => Promise.resolve({ locale: "" }),
    openExternalLink: () => Promise.resolve({ opened: false }),
    encourageHardwareAcceleration: () => Promise.resolve({ enabled: true }),
    captureLog: () => Promise.resolve(null),
    setOrientationLockState: () => Promise.resolve(null),
    openInviteDialog: () => Promise.resolve(null),
    getPlatformBehaviors: () => Promise.resolve({
      iosKeyboardResizesView: true
    }),
    getChannelPermissions: () => Promise.resolve({ permissions: bigInt(1234567890) }),
    getInstanceConnectedParticipants: () => Promise.resolve({ participants: [] }),
    // START-GENERATED-SECTION
    openShareMomentDialog: () => Promise.resolve(null),
    authenticate: () => Promise.resolve({
      access_token: "mock_token",
      user: {
        username: "mock_user_username",
        discriminator: "mock_user_discriminator",
        id: "mock_user_id",
        avatar: null,
        public_flags: 1
      },
      scopes: [],
      expires: new Date(2121, 1, 1).toString(),
      application: {
        description: "mock_app_description",
        icon: "mock_app_icon",
        id: "mock_app_id",
        name: "mock_app_name"
      }
    }),
    shareLink: () => Promise.resolve({ success: false, didSendMessage: false, didCopyLink: false }),
    initiateImageUpload: () => Promise.resolve({
      image_url: "https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b52aa9e99b832574a53_full_logo_blurple_RGB.png"
    }),
    getRelationships: () => Promise.resolve({
      relationships: [
        {
          type: 1,
          user: {
            username: "mock_friend_username",
            flags: 0,
            bot: false,
            discriminator: "mock_friend_discriminator",
            id: "mock_friend_id_1",
            avatar: null
          }
        },
        {
          type: 1,
          user: {
            username: "mock_friend_username_with_nickname",
            flags: 0,
            bot: false,
            discriminator: "mock_friend_discriminator_with_nickname",
            id: "mock_friend_id_2",
            avatar: null
          },
          nickname: "mock_friend_nickname_for_user"
        },
        {
          type: 1,
          user: {
            username: "mock_friend_username_with_since",
            flags: 0,
            bot: false,
            discriminator: "mock_friend_discriminator_with_since",
            id: "mock_friend_id_3",
            avatar: null
          },
          since: "2021-06-29T00:32:37.180813+00:00"
        }
      ]
    }),
    inviteUserEmbedded: () => Promise.resolve(null),
    getUser: () => {
      return Promise.resolve({
        username: "mock_friend_username",
        flags: 0,
        bot: false,
        discriminator: "mock_friend_discriminator",
        id: "mock_friend_id_1",
        avatar: null
      });
    },
    getQuestEnrollmentStatus: () => Promise.resolve({
      quest_id: "mock_quest_id",
      is_enrolled: false,
      enrolled_at: null
    }),
    questStartTimer: () => Promise.resolve({ success: true }),
    getActivityInstanceConnectedParticipants: () => Promise.resolve({ participants: [] }),
    shareInteraction: () => Promise.resolve({ success: false })
    // END-GENERATED-SECTION
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  const SUBSTITUTION_REGEX = /\{([a-z]+)\}/g;
  function regexFromTarget(target) {
    const regexString = target.replace(SUBSTITUTION_REGEX, (match, name) => `(?<${name}>[\\w-]+)`);
    return new RegExp(`${regexString}(/|$)`);
  }
  function matchAndRewriteURL({ originalURL, prefix, prefixHost, target }) {
    const targetURL = new URL(`https://${target}`);
    const targetRegEx = regexFromTarget(targetURL.host.replace(/%7B/g, "{").replace(/%7D/g, "}"));
    const match = originalURL.toString().match(targetRegEx);
    if (match == null)
      return originalURL;
    const newURL = new URL(originalURL.toString());
    newURL.host = prefixHost;
    newURL.pathname = prefix.replace(SUBSTITUTION_REGEX, (_, matchName) => {
      var _a2;
      const replaceValue = (_a2 = match.groups) === null || _a2 === void 0 ? void 0 : _a2[matchName];
      if (replaceValue == null)
        throw new Error("Misconfigured route.");
      return replaceValue;
    });
    const pathToAppend = originalURL.pathname.startsWith("/") ? originalURL.pathname.slice(1) : originalURL.pathname;
    newURL.pathname += newURL.pathname.endsWith("/") ? pathToAppend : "/" + pathToAppend;
    newURL.pathname = newURL.pathname.replace(targetURL.pathname, "");
    if (originalURL.pathname.endsWith("/") && !newURL.pathname.endsWith("/")) {
      newURL.pathname += "/";
    }
    return newURL;
  }
  function absoluteURL(url, protocol = window.location.protocol, host = window.location.host) {
    return new URL(url, `${protocol}//${host}`);
  }
  function patchUrlMappings(mappings, { patchFetch = true, patchWebSocket = true, patchXhr = true, patchSrcAttributes = false } = {}) {
    if (typeof window === "undefined")
      return;
    if (patchFetch) {
      const fetchImpl = window.fetch;
      window.fetch = function(input, init) {
        if (input instanceof Request) {
          const newUrl = attemptRemap({ url: absoluteURL(input.url), mappings });
          const _a2 = init !== null && init !== void 0 ? init : {}, newInit = __rest(_a2, ["url"]);
          Object.keys(Request.prototype).forEach((value) => {
            if (value === "url")
              return;
            try {
              newInit[value] = input[value];
            } catch (ex2) {
              console.warn(`Remapping fetch request key "${value}" failed`, ex2);
            }
          });
          return new Promise((resolve, reject) => {
            try {
              input.blob().then((blob) => {
                if (input.method.toUpperCase() !== "HEAD" && input.method.toUpperCase() !== "GET" && blob.size > 0) {
                  newInit.body = blob;
                }
                resolve(fetchImpl(new Request(newUrl, newInit)));
              });
            } catch (ex2) {
              reject(ex2);
            }
          });
        }
        const remapped = attemptRemap({ url: input instanceof URL ? input : absoluteURL(input), mappings });
        return fetchImpl(remapped, init);
      };
    }
    if (patchWebSocket) {
      class WebSocketProxy extends WebSocket {
        constructor(url, protocols) {
          const remapped = attemptRemap({ url: url instanceof URL ? url : absoluteURL(url), mappings });
          super(remapped, protocols);
        }
      }
      window.WebSocket = WebSocketProxy;
    }
    if (patchXhr) {
      const openImpl = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url, async, username, password) {
        const remapped = attemptRemap({ url: absoluteURL(url), mappings });
        openImpl.apply(this, [method, remapped, async, username, password]);
      };
    }
    if (patchSrcAttributes) {
      const callback = function(mutationsList) {
        for (const mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "src") {
            attemptSetNodeSrc(mutation.target, mappings);
          } else if (mutation.type === "childList") {
            mutation.addedNodes.forEach((node) => {
              attemptSetNodeSrc(node, mappings);
              recursivelyRemapChildNodes(node, mappings);
            });
          }
        }
      };
      const observer = new MutationObserver(callback);
      const config2 = {
        attributeFilter: ["src"],
        childList: true,
        subtree: true
      };
      observer.observe(window.document, config2);
      window.document.querySelectorAll("[src]").forEach((node) => {
        attemptSetNodeSrc(node, mappings);
      });
    }
  }
  function recursivelyRemapChildNodes(node, mappings) {
    if (node.hasChildNodes()) {
      node.childNodes.forEach((child) => {
        attemptSetNodeSrc(child, mappings);
        recursivelyRemapChildNodes(child, mappings);
      });
    }
  }
  function attemptSetNodeSrc(node, mappings) {
    if (node instanceof HTMLElement && node.hasAttribute("src")) {
      const rawSrc = node.getAttribute("src");
      const url = absoluteURL(rawSrc !== null && rawSrc !== void 0 ? rawSrc : "");
      if (url.host === window.location.host)
        return;
      if (node.tagName.toLowerCase() === "script") {
        attemptRecreateScriptNode(node, { url, mappings });
      } else {
        const newSrc = attemptRemap({ url, mappings }).toString();
        if (newSrc !== rawSrc) {
          node.setAttribute("src", newSrc);
        }
      }
    }
  }
  function attemptRecreateScriptNode(node, { url, mappings }) {
    const newUrl = attemptRemap({ url, mappings });
    if (url.toString() !== newUrl.toString()) {
      const newNode = document.createElement(node.tagName);
      newNode.innerHTML = node.innerHTML;
      for (const attr of node.attributes) {
        newNode.setAttribute(attr.name, attr.value);
      }
      newNode.setAttribute("src", attemptRemap({ url, mappings }).toString());
      node.after(newNode);
      node.remove();
    }
  }
  function attemptRemap({ url, mappings }) {
    const newURL = new URL(url.toString());
    for (const mapping of mappings) {
      const mapped = matchAndRewriteURL({
        originalURL: newURL,
        prefix: mapping.prefix,
        target: mapping.target,
        prefixHost: window.location.host
      });
      if (mapped != null && (mapped === null || mapped === void 0 ? void 0 : mapped.toString()) !== url.toString()) {
        return mapped;
      }
    }
    return newURL;
  }
  const { Commands } = common;
  const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Commands,
    Common: common,
    DiscordSDK,
    DiscordSDKMock,
    get Events() {
      return Events;
    },
    get Orientation() {
      return Orientation$1;
    },
    PermissionUtils,
    Permissions,
    get Platform() {
      return Platform;
    },
    PriceUtils,
    get RPCCloseCodes() {
      return RPCCloseCodes;
    },
    get RPCErrorCodes() {
      return RPCErrorCodes;
    },
    Responses: responses,
    attemptRemap,
    patchUrlMappings
  }, Symbol.toStringTag, { value: "Module" }));
});
